; ModuleID = 'xxhash.c'
source_filename = "xxhash.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.XXH32_state_s = type { i32, i32, i32, i32, i32, i32, [4 x i32], i32, i32 }
%struct.XXH32_canonical_t = type { [4 x i8] }
%struct.XXH64_state_s = type { i64, i64, i64, i64, i64, [4 x i64], i32, i32, i64 }
%struct.XXH64_canonical_t = type { [8 x i8] }
%struct.XXH3_state_s = type { [8 x i64], [192 x i8], [256 x i8], i32, i32, i64, i64, i64, i64, i64, i64, i8* }
%struct.__loadu_si128 = type { <2 x i64> }
%struct.XXH128_canonical_t = type { [16 x i8] }
%struct.XXH128_hash_t = type { i64, i64 }

@XXH3_kSecret = internal constant [192 x i8] c"\B8\FEl9#\A4K\BE|\01\81,\F7!\AD\1C\DE\D4m\E9\83\90\97\DBr@\A4\A4\B7\B3g\1F\CBy\E6N\CC\C0\E5x\82Z\D0}\CC\FFr!\B8\08Ft\F7C$\8E\E05\90\E6\81:&L<(R\BB\91\C3\00\CB\88\D0e\8B\1BS.\A3qdH\97\A2\0D\F9N8\19\EFF\A9\DE\AC\D8\A8\FAv?\E3\9C4?\F9\DC\BB\C7\C7\0BO\1D\8AQ\E0K\CD\B4Y1\C8\9F~\C9\D9xsd\EA\C5\AC\834\D3\EB\C3\C5\81\A0\FF\FA\13c\EB\17\0D\DDQ\B7\F0\DAI\D3\16U&)\D4h\9E+\16\BEX}G\A1\FC\8F\F8\B8\D1z\D01\CEE\CB:\8F\95\16\04(\AF\D7\FB\CA\BBK@~", align 64
@XXH3_hashLong_64b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16
@XXH3_hashLong_128b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH_versionNumber() #0 {
entry:
  ret i32 704
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32(i8* %input, i64 %len, i32 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i32, i32* %seed.addr, align 4
  %call = call i32 @XXH32_endian_align(i8* %0, i64 %1, i32 %2, i32 1)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_endian_align(i8* %input, i64 %len, i32 %seed, i32 %align) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h32 = alloca i32, align 4
  %limit = alloca i8*, align 8
  %v1 = alloca i32, align 4
  %v2 = alloca i32, align 4
  %v3 = alloca i32, align 4
  %v4 = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  store i32 %align, i32* %align.addr, align 4
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %1
  store i8* %add.ptr, i8** %bEnd, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp uge i64 %2, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %bEnd, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %3, i64 -15
  store i8* %add.ptr1, i8** %limit, align 8
  %4 = load i32, i32* %seed.addr, align 4
  %add = add i32 %4, -1640531535
  %add2 = add i32 %add, -2048144777
  store i32 %add2, i32* %v1, align 4
  %5 = load i32, i32* %seed.addr, align 4
  %add3 = add i32 %5, -2048144777
  store i32 %add3, i32* %v2, align 4
  %6 = load i32, i32* %seed.addr, align 4
  %add4 = add i32 %6, 0
  store i32 %add4, i32* %v3, align 4
  %7 = load i32, i32* %seed.addr, align 4
  %sub = sub i32 %7, -1640531535
  store i32 %sub, i32* %v4, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %8 = load i32, i32* %v1, align 4
  %9 = load i8*, i8** %input.addr, align 8
  %10 = load i32, i32* %align.addr, align 4
  %call = call i32 @XXH_readLE32_align(i8* %9, i32 %10)
  %call5 = call i32 @XXH32_round(i32 %8, i32 %call)
  store i32 %call5, i32* %v1, align 4
  %11 = load i8*, i8** %input.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 4
  store i8* %add.ptr6, i8** %input.addr, align 8
  %12 = load i32, i32* %v2, align 4
  %13 = load i8*, i8** %input.addr, align 8
  %14 = load i32, i32* %align.addr, align 4
  %call7 = call i32 @XXH_readLE32_align(i8* %13, i32 %14)
  %call8 = call i32 @XXH32_round(i32 %12, i32 %call7)
  store i32 %call8, i32* %v2, align 4
  %15 = load i8*, i8** %input.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %15, i64 4
  store i8* %add.ptr9, i8** %input.addr, align 8
  %16 = load i32, i32* %v3, align 4
  %17 = load i8*, i8** %input.addr, align 8
  %18 = load i32, i32* %align.addr, align 4
  %call10 = call i32 @XXH_readLE32_align(i8* %17, i32 %18)
  %call11 = call i32 @XXH32_round(i32 %16, i32 %call10)
  store i32 %call11, i32* %v3, align 4
  %19 = load i8*, i8** %input.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %19, i64 4
  store i8* %add.ptr12, i8** %input.addr, align 8
  %20 = load i32, i32* %v4, align 4
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i32, i32* %align.addr, align 4
  %call13 = call i32 @XXH_readLE32_align(i8* %21, i32 %22)
  %call14 = call i32 @XXH32_round(i32 %20, i32 %call13)
  store i32 %call14, i32* %v4, align 4
  %23 = load i8*, i8** %input.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %23, i64 4
  store i8* %add.ptr15, i8** %input.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %24 = load i8*, i8** %input.addr, align 8
  %25 = load i8*, i8** %limit, align 8
  %cmp16 = icmp ult i8* %24, %25
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %26 = load i32, i32* %v1, align 4
  %shl = shl i32 %26, 1
  %27 = load i32, i32* %v1, align 4
  %shr = lshr i32 %27, 31
  %or = or i32 %shl, %shr
  %28 = load i32, i32* %v2, align 4
  %shl17 = shl i32 %28, 7
  %29 = load i32, i32* %v2, align 4
  %shr18 = lshr i32 %29, 25
  %or19 = or i32 %shl17, %shr18
  %add20 = add i32 %or, %or19
  %30 = load i32, i32* %v3, align 4
  %shl21 = shl i32 %30, 12
  %31 = load i32, i32* %v3, align 4
  %shr22 = lshr i32 %31, 20
  %or23 = or i32 %shl21, %shr22
  %add24 = add i32 %add20, %or23
  %32 = load i32, i32* %v4, align 4
  %shl25 = shl i32 %32, 18
  %33 = load i32, i32* %v4, align 4
  %shr26 = lshr i32 %33, 14
  %or27 = or i32 %shl25, %shr26
  %add28 = add i32 %add24, %or27
  store i32 %add28, i32* %h32, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %34 = load i32, i32* %seed.addr, align 4
  %add29 = add i32 %34, 374761393
  store i32 %add29, i32* %h32, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %35 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %35 to i32
  %36 = load i32, i32* %h32, align 4
  %add30 = add i32 %36, %conv
  store i32 %add30, i32* %h32, align 4
  %37 = load i32, i32* %h32, align 4
  %38 = load i8*, i8** %input.addr, align 8
  %39 = load i64, i64* %len.addr, align 8
  %and = and i64 %39, 15
  %40 = load i32, i32* %align.addr, align 4
  %call31 = call i32 @XXH32_finalize(i32 %37, i8* %38, i64 %and, i32 %40)
  ret i32 %call31
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.XXH32_state_s* @XXH32_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 48)
  %0 = bitcast i8* %call to %struct.XXH32_state_s*
  ret %struct.XXH32_state_s* %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @XXH_malloc(i64 %s) #0 {
entry:
  %s.addr = alloca i64, align 8
  store i64 %s, i64* %s.addr, align 8
  %0 = load i64, i64* %s.addr, align 8
  %call = call i8* @malloc(i64 %0) #9
  ret i8* %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_freeState(%struct.XXH32_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH_free(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  call void @free(i8* %0)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH32_copyState(%struct.XXH32_state_s* %dstState, %struct.XXH32_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH32_state_s*, align 8
  %srcState.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %dstState, %struct.XXH32_state_s** %dstState.addr, align 8
  store %struct.XXH32_state_s* %srcState, %struct.XXH32_state_s** %srcState.addr, align 8
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  %2 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %srcState.addr, align 8
  %3 = bitcast %struct.XXH32_state_s* %2 to i8*
  %4 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8
  %5 = bitcast %struct.XXH32_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 48, i64 %6) #10
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #1

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_reset(%struct.XXH32_state_s* %statePtr, i32 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  %seed.addr = alloca i32, align 4
  %state = alloca %struct.XXH32_state_s, align 4
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  %0 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %0, i8 0, i64 48, i1 false)
  %1 = load i32, i32* %seed.addr, align 4
  %add = add i32 %1, -1640531535
  %add1 = add i32 %add, -2048144777
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 2
  store i32 %add1, i32* %v1, align 4
  %2 = load i32, i32* %seed.addr, align 4
  %add2 = add i32 %2, -2048144777
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 3
  store i32 %add2, i32* %v2, align 4
  %3 = load i32, i32* %seed.addr, align 4
  %add3 = add i32 %3, 0
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 4
  store i32 %add3, i32* %v3, align 4
  %4 = load i32, i32* %seed.addr, align 4
  %sub = sub i32 %4, -1640531535
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 5
  store i32 %sub, i32* %v4, align 4
  %5 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8
  %6 = bitcast %struct.XXH32_state_s* %5 to i8*
  %7 = bitcast %struct.XXH32_state_s* %state to i8*
  %8 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8
  %9 = bitcast %struct.XXH32_state_s* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 44, i64 %10) #10
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #3

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_update(%struct.XXH32_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %p32 = alloca i32*, align 8
  %limit = alloca i8*, align 8
  %v155 = alloca i32, align 4
  %v257 = alloca i32, align 4
  %v359 = alloca i32, align 4
  %v461 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  store i8* %1, i8** %p, align 8
  %2 = load i8*, i8** %p, align 8
  %3 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %3
  store i8* %add.ptr, i8** %bEnd, align 8
  %4 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %5, i32 0, i32 0
  %6 = load i32, i32* %total_len_32, align 4
  %add = add i32 %6, %conv
  store i32 %add, i32* %total_len_32, align 4
  %7 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp uge i64 %7, 16
  %conv2 = zext i1 %cmp1 to i32
  %8 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %total_len_323 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %8, i32 0, i32 0
  %9 = load i32, i32* %total_len_323, align 4
  %cmp4 = icmp uge i32 %9, 16
  %conv5 = zext i1 %cmp4 to i32
  %or = or i32 %conv2, %conv5
  %10 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %10, i32 0, i32 1
  %11 = load i32, i32* %large_len, align 4
  %or6 = or i32 %11, %or
  store i32 %or6, i32* %large_len, align 4
  %12 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %12, i32 0, i32 7
  %13 = load i32, i32* %memsize, align 4
  %conv7 = zext i32 %13 to i64
  %14 = load i64, i64* %len.addr, align 8
  %add8 = add i64 %conv7, %14
  %cmp9 = icmp ult i64 %add8, 16
  br i1 %cmp9, label %if.then11, label %if.end17

if.then11:                                        ; preds = %if.end
  %15 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %15, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %16 = bitcast i32* %arraydecay to i8*
  %17 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize12 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %17, i32 0, i32 7
  %18 = load i32, i32* %memsize12, align 4
  %idx.ext = zext i32 %18 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %16, i64 %idx.ext
  %19 = load i8*, i8** %input.addr, align 8
  %20 = load i64, i64* %len.addr, align 8
  %call = call i8* @XXH_memcpy(i8* %add.ptr13, i8* %19, i64 %20)
  %21 = load i64, i64* %len.addr, align 8
  %conv14 = trunc i64 %21 to i32
  %22 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize15 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %22, i32 0, i32 7
  %23 = load i32, i32* %memsize15, align 4
  %add16 = add i32 %23, %conv14
  store i32 %add16, i32* %memsize15, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end
  %24 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize18 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %24, i32 0, i32 7
  %25 = load i32, i32* %memsize18, align 4
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.then19, label %if.end49

if.then19:                                        ; preds = %if.end17
  %26 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem3220 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %26, i32 0, i32 6
  %arraydecay21 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3220, i32 0, i32 0
  %27 = bitcast i32* %arraydecay21 to i8*
  %28 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize22 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %28, i32 0, i32 7
  %29 = load i32, i32* %memsize22, align 4
  %idx.ext23 = zext i32 %29 to i64
  %add.ptr24 = getelementptr inbounds i8, i8* %27, i64 %idx.ext23
  %30 = load i8*, i8** %input.addr, align 8
  %31 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize25 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %31, i32 0, i32 7
  %32 = load i32, i32* %memsize25, align 4
  %sub = sub i32 16, %32
  %conv26 = zext i32 %sub to i64
  %call27 = call i8* @XXH_memcpy(i8* %add.ptr24, i8* %30, i64 %conv26)
  %33 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem3228 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %33, i32 0, i32 6
  %arraydecay29 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3228, i32 0, i32 0
  store i32* %arraydecay29, i32** %p32, align 8
  %34 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %34, i32 0, i32 2
  %35 = load i32, i32* %v1, align 4
  %36 = load i32*, i32** %p32, align 8
  %37 = bitcast i32* %36 to i8*
  %call30 = call i32 @XXH_readLE32(i8* %37)
  %call31 = call i32 @XXH32_round(i32 %35, i32 %call30)
  %38 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v132 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %38, i32 0, i32 2
  store i32 %call31, i32* %v132, align 4
  %39 = load i32*, i32** %p32, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %39, i32 1
  store i32* %incdec.ptr, i32** %p32, align 8
  %40 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %40, i32 0, i32 3
  %41 = load i32, i32* %v2, align 4
  %42 = load i32*, i32** %p32, align 8
  %43 = bitcast i32* %42 to i8*
  %call33 = call i32 @XXH_readLE32(i8* %43)
  %call34 = call i32 @XXH32_round(i32 %41, i32 %call33)
  %44 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v235 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %44, i32 0, i32 3
  store i32 %call34, i32* %v235, align 4
  %45 = load i32*, i32** %p32, align 8
  %incdec.ptr36 = getelementptr inbounds i32, i32* %45, i32 1
  store i32* %incdec.ptr36, i32** %p32, align 8
  %46 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %46, i32 0, i32 4
  %47 = load i32, i32* %v3, align 4
  %48 = load i32*, i32** %p32, align 8
  %49 = bitcast i32* %48 to i8*
  %call37 = call i32 @XXH_readLE32(i8* %49)
  %call38 = call i32 @XXH32_round(i32 %47, i32 %call37)
  %50 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v339 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %50, i32 0, i32 4
  store i32 %call38, i32* %v339, align 4
  %51 = load i32*, i32** %p32, align 8
  %incdec.ptr40 = getelementptr inbounds i32, i32* %51, i32 1
  store i32* %incdec.ptr40, i32** %p32, align 8
  %52 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %52, i32 0, i32 5
  %53 = load i32, i32* %v4, align 4
  %54 = load i32*, i32** %p32, align 8
  %55 = bitcast i32* %54 to i8*
  %call41 = call i32 @XXH_readLE32(i8* %55)
  %call42 = call i32 @XXH32_round(i32 %53, i32 %call41)
  %56 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v443 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %56, i32 0, i32 5
  store i32 %call42, i32* %v443, align 4
  %57 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize44 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %57, i32 0, i32 7
  %58 = load i32, i32* %memsize44, align 4
  %sub45 = sub i32 16, %58
  %59 = load i8*, i8** %p, align 8
  %idx.ext46 = zext i32 %sub45 to i64
  %add.ptr47 = getelementptr inbounds i8, i8* %59, i64 %idx.ext46
  store i8* %add.ptr47, i8** %p, align 8
  %60 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize48 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %60, i32 0, i32 7
  store i32 0, i32* %memsize48, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then19, %if.end17
  %61 = load i8*, i8** %p, align 8
  %62 = load i8*, i8** %bEnd, align 8
  %add.ptr50 = getelementptr inbounds i8, i8* %62, i64 -16
  %cmp51 = icmp ule i8* %61, %add.ptr50
  br i1 %cmp51, label %if.then53, label %if.end81

if.then53:                                        ; preds = %if.end49
  %63 = load i8*, i8** %bEnd, align 8
  %add.ptr54 = getelementptr inbounds i8, i8* %63, i64 -16
  store i8* %add.ptr54, i8** %limit, align 8
  %64 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v156 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %64, i32 0, i32 2
  %65 = load i32, i32* %v156, align 4
  store i32 %65, i32* %v155, align 4
  %66 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v258 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %66, i32 0, i32 3
  %67 = load i32, i32* %v258, align 4
  store i32 %67, i32* %v257, align 4
  %68 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v360 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %68, i32 0, i32 4
  %69 = load i32, i32* %v360, align 4
  store i32 %69, i32* %v359, align 4
  %70 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v462 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %70, i32 0, i32 5
  %71 = load i32, i32* %v462, align 4
  store i32 %71, i32* %v461, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then53
  %72 = load i32, i32* %v155, align 4
  %73 = load i8*, i8** %p, align 8
  %call63 = call i32 @XXH_readLE32(i8* %73)
  %call64 = call i32 @XXH32_round(i32 %72, i32 %call63)
  store i32 %call64, i32* %v155, align 4
  %74 = load i8*, i8** %p, align 8
  %add.ptr65 = getelementptr inbounds i8, i8* %74, i64 4
  store i8* %add.ptr65, i8** %p, align 8
  %75 = load i32, i32* %v257, align 4
  %76 = load i8*, i8** %p, align 8
  %call66 = call i32 @XXH_readLE32(i8* %76)
  %call67 = call i32 @XXH32_round(i32 %75, i32 %call66)
  store i32 %call67, i32* %v257, align 4
  %77 = load i8*, i8** %p, align 8
  %add.ptr68 = getelementptr inbounds i8, i8* %77, i64 4
  store i8* %add.ptr68, i8** %p, align 8
  %78 = load i32, i32* %v359, align 4
  %79 = load i8*, i8** %p, align 8
  %call69 = call i32 @XXH_readLE32(i8* %79)
  %call70 = call i32 @XXH32_round(i32 %78, i32 %call69)
  store i32 %call70, i32* %v359, align 4
  %80 = load i8*, i8** %p, align 8
  %add.ptr71 = getelementptr inbounds i8, i8* %80, i64 4
  store i8* %add.ptr71, i8** %p, align 8
  %81 = load i32, i32* %v461, align 4
  %82 = load i8*, i8** %p, align 8
  %call72 = call i32 @XXH_readLE32(i8* %82)
  %call73 = call i32 @XXH32_round(i32 %81, i32 %call72)
  store i32 %call73, i32* %v461, align 4
  %83 = load i8*, i8** %p, align 8
  %add.ptr74 = getelementptr inbounds i8, i8* %83, i64 4
  store i8* %add.ptr74, i8** %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %84 = load i8*, i8** %p, align 8
  %85 = load i8*, i8** %limit, align 8
  %cmp75 = icmp ule i8* %84, %85
  br i1 %cmp75, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %86 = load i32, i32* %v155, align 4
  %87 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v177 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %87, i32 0, i32 2
  store i32 %86, i32* %v177, align 4
  %88 = load i32, i32* %v257, align 4
  %89 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v278 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %89, i32 0, i32 3
  store i32 %88, i32* %v278, align 4
  %90 = load i32, i32* %v359, align 4
  %91 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v379 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %91, i32 0, i32 4
  store i32 %90, i32* %v379, align 4
  %92 = load i32, i32* %v461, align 4
  %93 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v480 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %93, i32 0, i32 5
  store i32 %92, i32* %v480, align 4
  br label %if.end81

if.end81:                                         ; preds = %do.end, %if.end49
  %94 = load i8*, i8** %p, align 8
  %95 = load i8*, i8** %bEnd, align 8
  %cmp82 = icmp ult i8* %94, %95
  br i1 %cmp82, label %if.then84, label %if.end93

if.then84:                                        ; preds = %if.end81
  %96 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem3285 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %96, i32 0, i32 6
  %arraydecay86 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3285, i32 0, i32 0
  %97 = bitcast i32* %arraydecay86 to i8*
  %98 = load i8*, i8** %p, align 8
  %99 = load i8*, i8** %bEnd, align 8
  %100 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %99 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %100 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call87 = call i8* @XXH_memcpy(i8* %97, i8* %98, i64 %sub.ptr.sub)
  %101 = load i8*, i8** %bEnd, align 8
  %102 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast88 = ptrtoint i8* %101 to i64
  %sub.ptr.rhs.cast89 = ptrtoint i8* %102 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %conv91 = trunc i64 %sub.ptr.sub90 to i32
  %103 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize92 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %103, i32 0, i32 7
  store i32 %conv91, i32* %memsize92, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then84, %if.end81
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end93, %if.then11, %if.then
  %104 = load i32, i32* %retval, align 4
  ret i32 %104
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @XXH_memcpy(i8* %dest, i8* %src, i64 %size) #0 {
entry:
  %dest.addr = alloca i8*, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  store i8* %dest, i8** %dest.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i8*, i8** %dest.addr, align 8
  %1 = load i8*, i8** %src.addr, align 8
  %2 = load i64, i64* %size.addr, align 8
  %3 = load i8*, i8** %dest.addr, align 8
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 %2, i64 %4) #10
  ret i8* %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_round(i32 %acc, i32 %input) #0 {
entry:
  %acc.addr = alloca i32, align 4
  %input.addr = alloca i32, align 4
  store i32 %acc, i32* %acc.addr, align 4
  store i32 %input, i32* %input.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %mul = mul i32 %0, -2048144777
  %1 = load i32, i32* %acc.addr, align 4
  %add = add i32 %1, %mul
  store i32 %add, i32* %acc.addr, align 4
  %2 = load i32, i32* %acc.addr, align 4
  %shl = shl i32 %2, 13
  %3 = load i32, i32* %acc.addr, align 4
  %shr = lshr i32 %3, 19
  %or = or i32 %shl, %shr
  store i32 %or, i32* %acc.addr, align 4
  %4 = load i32, i32* %acc.addr, align 4
  %mul1 = mul i32 %4, -1640531535
  store i32 %mul1, i32* %acc.addr, align 4
  %5 = load i32, i32* %acc.addr, align 4
  %6 = call i32 asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %5) #8, !srcloc !3
  store i32 %6, i32* %acc.addr, align 4
  %7 = load i32, i32* %acc.addr, align 4
  ret i32 %7
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_readLE32(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i32 @XXH_read32(i8* %0)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_digest(%struct.XXH32_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %h32 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %0, i32 0, i32 1
  %1 = load i32, i32* %large_len, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %2, i32 0, i32 2
  %3 = load i32, i32* %v1, align 4
  %shl = shl i32 %3, 1
  %4 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v11 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %4, i32 0, i32 2
  %5 = load i32, i32* %v11, align 4
  %shr = lshr i32 %5, 31
  %or = or i32 %shl, %shr
  %6 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %6, i32 0, i32 3
  %7 = load i32, i32* %v2, align 4
  %shl2 = shl i32 %7, 7
  %8 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v23 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %8, i32 0, i32 3
  %9 = load i32, i32* %v23, align 4
  %shr4 = lshr i32 %9, 25
  %or5 = or i32 %shl2, %shr4
  %add = add i32 %or, %or5
  %10 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %10, i32 0, i32 4
  %11 = load i32, i32* %v3, align 4
  %shl6 = shl i32 %11, 12
  %12 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v37 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %12, i32 0, i32 4
  %13 = load i32, i32* %v37, align 4
  %shr8 = lshr i32 %13, 20
  %or9 = or i32 %shl6, %shr8
  %add10 = add i32 %add, %or9
  %14 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %14, i32 0, i32 5
  %15 = load i32, i32* %v4, align 4
  %shl11 = shl i32 %15, 18
  %16 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v412 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %16, i32 0, i32 5
  %17 = load i32, i32* %v412, align 4
  %shr13 = lshr i32 %17, 14
  %or14 = or i32 %shl11, %shr13
  %add15 = add i32 %add10, %or14
  store i32 %add15, i32* %h32, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %18 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v316 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %18, i32 0, i32 4
  %19 = load i32, i32* %v316, align 4
  %add17 = add i32 %19, 374761393
  store i32 %add17, i32* %h32, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %20 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %20, i32 0, i32 0
  %21 = load i32, i32* %total_len_32, align 4
  %22 = load i32, i32* %h32, align 4
  %add18 = add i32 %22, %21
  store i32 %add18, i32* %h32, align 4
  %23 = load i32, i32* %h32, align 4
  %24 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %24, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %25 = bitcast i32* %arraydecay to i8*
  %26 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %26, i32 0, i32 7
  %27 = load i32, i32* %memsize, align 4
  %conv = zext i32 %27 to i64
  %call = call i32 @XXH32_finalize(i32 %23, i8* %25, i64 %conv, i32 0)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_finalize(i32 %h32, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i32, align 4
  %h32.addr = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i64, i64* %len.addr, align 8
  %and = and i64 %0, 15
  switch i64 %and, label %sw.epilog [
    i64 12, label %sw.bb
    i64 8, label %sw.bb2
    i64 4, label %sw.bb13
    i64 13, label %sw.bb25
    i64 9, label %sw.bb36
    i64 5, label %sw.bb47
    i64 14, label %sw.bb67
    i64 10, label %sw.bb78
    i64 6, label %sw.bb89
    i64 15, label %sw.bb121
    i64 11, label %sw.bb132
    i64 7, label %sw.bb143
    i64 3, label %sw.bb154
    i64 2, label %sw.bb165
    i64 1, label %sw.bb176
    i64 0, label %sw.bb187
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i8*, i8** %ptr.addr, align 8
  %2 = load i32, i32* %align.addr, align 4
  %call = call i32 @XXH_readLE32_align(i8* %1, i32 %2)
  %mul = mul i32 %call, -1028477379
  %3 = load i32, i32* %h32.addr, align 4
  %add = add i32 %3, %mul
  store i32 %add, i32* %h32.addr, align 4
  %4 = load i8*, i8** %ptr.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 4
  store i8* %add.ptr, i8** %ptr.addr, align 8
  %5 = load i32, i32* %h32.addr, align 4
  %shl = shl i32 %5, 17
  %6 = load i32, i32* %h32.addr, align 4
  %shr = lshr i32 %6, 15
  %or = or i32 %shl, %shr
  %mul1 = mul i32 %or, 668265263
  store i32 %mul1, i32* %h32.addr, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %7 = load i8*, i8** %ptr.addr, align 8
  %8 = load i32, i32* %align.addr, align 4
  %call4 = call i32 @XXH_readLE32_align(i8* %7, i32 %8)
  %mul5 = mul i32 %call4, -1028477379
  %9 = load i32, i32* %h32.addr, align 4
  %add6 = add i32 %9, %mul5
  store i32 %add6, i32* %h32.addr, align 4
  %10 = load i8*, i8** %ptr.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 4
  store i8* %add.ptr7, i8** %ptr.addr, align 8
  %11 = load i32, i32* %h32.addr, align 4
  %shl8 = shl i32 %11, 17
  %12 = load i32, i32* %h32.addr, align 4
  %shr9 = lshr i32 %12, 15
  %or10 = or i32 %shl8, %shr9
  %mul11 = mul i32 %or10, 668265263
  store i32 %mul11, i32* %h32.addr, align 4
  br label %do.end12

do.end12:                                         ; preds = %do.body3
  br label %sw.bb13

sw.bb13:                                          ; preds = %entry, %do.end12
  br label %do.body14

do.body14:                                        ; preds = %sw.bb13
  %13 = load i8*, i8** %ptr.addr, align 8
  %14 = load i32, i32* %align.addr, align 4
  %call15 = call i32 @XXH_readLE32_align(i8* %13, i32 %14)
  %mul16 = mul i32 %call15, -1028477379
  %15 = load i32, i32* %h32.addr, align 4
  %add17 = add i32 %15, %mul16
  store i32 %add17, i32* %h32.addr, align 4
  %16 = load i8*, i8** %ptr.addr, align 8
  %add.ptr18 = getelementptr inbounds i8, i8* %16, i64 4
  store i8* %add.ptr18, i8** %ptr.addr, align 8
  %17 = load i32, i32* %h32.addr, align 4
  %shl19 = shl i32 %17, 17
  %18 = load i32, i32* %h32.addr, align 4
  %shr20 = lshr i32 %18, 15
  %or21 = or i32 %shl19, %shr20
  %mul22 = mul i32 %or21, 668265263
  store i32 %mul22, i32* %h32.addr, align 4
  br label %do.end23

do.end23:                                         ; preds = %do.body14
  %19 = load i32, i32* %h32.addr, align 4
  %call24 = call i32 @XXH32_avalanche(i32 %19)
  store i32 %call24, i32* %retval, align 4
  br label %return

sw.bb25:                                          ; preds = %entry
  br label %do.body26

do.body26:                                        ; preds = %sw.bb25
  %20 = load i8*, i8** %ptr.addr, align 8
  %21 = load i32, i32* %align.addr, align 4
  %call27 = call i32 @XXH_readLE32_align(i8* %20, i32 %21)
  %mul28 = mul i32 %call27, -1028477379
  %22 = load i32, i32* %h32.addr, align 4
  %add29 = add i32 %22, %mul28
  store i32 %add29, i32* %h32.addr, align 4
  %23 = load i8*, i8** %ptr.addr, align 8
  %add.ptr30 = getelementptr inbounds i8, i8* %23, i64 4
  store i8* %add.ptr30, i8** %ptr.addr, align 8
  %24 = load i32, i32* %h32.addr, align 4
  %shl31 = shl i32 %24, 17
  %25 = load i32, i32* %h32.addr, align 4
  %shr32 = lshr i32 %25, 15
  %or33 = or i32 %shl31, %shr32
  %mul34 = mul i32 %or33, 668265263
  store i32 %mul34, i32* %h32.addr, align 4
  br label %do.end35

do.end35:                                         ; preds = %do.body26
  br label %sw.bb36

sw.bb36:                                          ; preds = %entry, %do.end35
  br label %do.body37

do.body37:                                        ; preds = %sw.bb36
  %26 = load i8*, i8** %ptr.addr, align 8
  %27 = load i32, i32* %align.addr, align 4
  %call38 = call i32 @XXH_readLE32_align(i8* %26, i32 %27)
  %mul39 = mul i32 %call38, -1028477379
  %28 = load i32, i32* %h32.addr, align 4
  %add40 = add i32 %28, %mul39
  store i32 %add40, i32* %h32.addr, align 4
  %29 = load i8*, i8** %ptr.addr, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %29, i64 4
  store i8* %add.ptr41, i8** %ptr.addr, align 8
  %30 = load i32, i32* %h32.addr, align 4
  %shl42 = shl i32 %30, 17
  %31 = load i32, i32* %h32.addr, align 4
  %shr43 = lshr i32 %31, 15
  %or44 = or i32 %shl42, %shr43
  %mul45 = mul i32 %or44, 668265263
  store i32 %mul45, i32* %h32.addr, align 4
  br label %do.end46

do.end46:                                         ; preds = %do.body37
  br label %sw.bb47

sw.bb47:                                          ; preds = %entry, %do.end46
  br label %do.body48

do.body48:                                        ; preds = %sw.bb47
  %32 = load i8*, i8** %ptr.addr, align 8
  %33 = load i32, i32* %align.addr, align 4
  %call49 = call i32 @XXH_readLE32_align(i8* %32, i32 %33)
  %mul50 = mul i32 %call49, -1028477379
  %34 = load i32, i32* %h32.addr, align 4
  %add51 = add i32 %34, %mul50
  store i32 %add51, i32* %h32.addr, align 4
  %35 = load i8*, i8** %ptr.addr, align 8
  %add.ptr52 = getelementptr inbounds i8, i8* %35, i64 4
  store i8* %add.ptr52, i8** %ptr.addr, align 8
  %36 = load i32, i32* %h32.addr, align 4
  %shl53 = shl i32 %36, 17
  %37 = load i32, i32* %h32.addr, align 4
  %shr54 = lshr i32 %37, 15
  %or55 = or i32 %shl53, %shr54
  %mul56 = mul i32 %or55, 668265263
  store i32 %mul56, i32* %h32.addr, align 4
  br label %do.end57

do.end57:                                         ; preds = %do.body48
  br label %do.body58

do.body58:                                        ; preds = %do.end57
  %38 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %38, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8
  %39 = load i8, i8* %38, align 1
  %conv = zext i8 %39 to i32
  %mul59 = mul i32 %conv, 374761393
  %40 = load i32, i32* %h32.addr, align 4
  %add60 = add i32 %40, %mul59
  store i32 %add60, i32* %h32.addr, align 4
  %41 = load i32, i32* %h32.addr, align 4
  %shl61 = shl i32 %41, 11
  %42 = load i32, i32* %h32.addr, align 4
  %shr62 = lshr i32 %42, 21
  %or63 = or i32 %shl61, %shr62
  %mul64 = mul i32 %or63, -1640531535
  store i32 %mul64, i32* %h32.addr, align 4
  br label %do.end65

do.end65:                                         ; preds = %do.body58
  %43 = load i32, i32* %h32.addr, align 4
  %call66 = call i32 @XXH32_avalanche(i32 %43)
  store i32 %call66, i32* %retval, align 4
  br label %return

sw.bb67:                                          ; preds = %entry
  br label %do.body68

do.body68:                                        ; preds = %sw.bb67
  %44 = load i8*, i8** %ptr.addr, align 8
  %45 = load i32, i32* %align.addr, align 4
  %call69 = call i32 @XXH_readLE32_align(i8* %44, i32 %45)
  %mul70 = mul i32 %call69, -1028477379
  %46 = load i32, i32* %h32.addr, align 4
  %add71 = add i32 %46, %mul70
  store i32 %add71, i32* %h32.addr, align 4
  %47 = load i8*, i8** %ptr.addr, align 8
  %add.ptr72 = getelementptr inbounds i8, i8* %47, i64 4
  store i8* %add.ptr72, i8** %ptr.addr, align 8
  %48 = load i32, i32* %h32.addr, align 4
  %shl73 = shl i32 %48, 17
  %49 = load i32, i32* %h32.addr, align 4
  %shr74 = lshr i32 %49, 15
  %or75 = or i32 %shl73, %shr74
  %mul76 = mul i32 %or75, 668265263
  store i32 %mul76, i32* %h32.addr, align 4
  br label %do.end77

do.end77:                                         ; preds = %do.body68
  br label %sw.bb78

sw.bb78:                                          ; preds = %entry, %do.end77
  br label %do.body79

do.body79:                                        ; preds = %sw.bb78
  %50 = load i8*, i8** %ptr.addr, align 8
  %51 = load i32, i32* %align.addr, align 4
  %call80 = call i32 @XXH_readLE32_align(i8* %50, i32 %51)
  %mul81 = mul i32 %call80, -1028477379
  %52 = load i32, i32* %h32.addr, align 4
  %add82 = add i32 %52, %mul81
  store i32 %add82, i32* %h32.addr, align 4
  %53 = load i8*, i8** %ptr.addr, align 8
  %add.ptr83 = getelementptr inbounds i8, i8* %53, i64 4
  store i8* %add.ptr83, i8** %ptr.addr, align 8
  %54 = load i32, i32* %h32.addr, align 4
  %shl84 = shl i32 %54, 17
  %55 = load i32, i32* %h32.addr, align 4
  %shr85 = lshr i32 %55, 15
  %or86 = or i32 %shl84, %shr85
  %mul87 = mul i32 %or86, 668265263
  store i32 %mul87, i32* %h32.addr, align 4
  br label %do.end88

do.end88:                                         ; preds = %do.body79
  br label %sw.bb89

sw.bb89:                                          ; preds = %entry, %do.end88
  br label %do.body90

do.body90:                                        ; preds = %sw.bb89
  %56 = load i8*, i8** %ptr.addr, align 8
  %57 = load i32, i32* %align.addr, align 4
  %call91 = call i32 @XXH_readLE32_align(i8* %56, i32 %57)
  %mul92 = mul i32 %call91, -1028477379
  %58 = load i32, i32* %h32.addr, align 4
  %add93 = add i32 %58, %mul92
  store i32 %add93, i32* %h32.addr, align 4
  %59 = load i8*, i8** %ptr.addr, align 8
  %add.ptr94 = getelementptr inbounds i8, i8* %59, i64 4
  store i8* %add.ptr94, i8** %ptr.addr, align 8
  %60 = load i32, i32* %h32.addr, align 4
  %shl95 = shl i32 %60, 17
  %61 = load i32, i32* %h32.addr, align 4
  %shr96 = lshr i32 %61, 15
  %or97 = or i32 %shl95, %shr96
  %mul98 = mul i32 %or97, 668265263
  store i32 %mul98, i32* %h32.addr, align 4
  br label %do.end99

do.end99:                                         ; preds = %do.body90
  br label %do.body100

do.body100:                                       ; preds = %do.end99
  %62 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr101 = getelementptr inbounds i8, i8* %62, i32 1
  store i8* %incdec.ptr101, i8** %ptr.addr, align 8
  %63 = load i8, i8* %62, align 1
  %conv102 = zext i8 %63 to i32
  %mul103 = mul i32 %conv102, 374761393
  %64 = load i32, i32* %h32.addr, align 4
  %add104 = add i32 %64, %mul103
  store i32 %add104, i32* %h32.addr, align 4
  %65 = load i32, i32* %h32.addr, align 4
  %shl105 = shl i32 %65, 11
  %66 = load i32, i32* %h32.addr, align 4
  %shr106 = lshr i32 %66, 21
  %or107 = or i32 %shl105, %shr106
  %mul108 = mul i32 %or107, -1640531535
  store i32 %mul108, i32* %h32.addr, align 4
  br label %do.end109

do.end109:                                        ; preds = %do.body100
  br label %do.body110

do.body110:                                       ; preds = %do.end109
  %67 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr111 = getelementptr inbounds i8, i8* %67, i32 1
  store i8* %incdec.ptr111, i8** %ptr.addr, align 8
  %68 = load i8, i8* %67, align 1
  %conv112 = zext i8 %68 to i32
  %mul113 = mul i32 %conv112, 374761393
  %69 = load i32, i32* %h32.addr, align 4
  %add114 = add i32 %69, %mul113
  store i32 %add114, i32* %h32.addr, align 4
  %70 = load i32, i32* %h32.addr, align 4
  %shl115 = shl i32 %70, 11
  %71 = load i32, i32* %h32.addr, align 4
  %shr116 = lshr i32 %71, 21
  %or117 = or i32 %shl115, %shr116
  %mul118 = mul i32 %or117, -1640531535
  store i32 %mul118, i32* %h32.addr, align 4
  br label %do.end119

do.end119:                                        ; preds = %do.body110
  %72 = load i32, i32* %h32.addr, align 4
  %call120 = call i32 @XXH32_avalanche(i32 %72)
  store i32 %call120, i32* %retval, align 4
  br label %return

sw.bb121:                                         ; preds = %entry
  br label %do.body122

do.body122:                                       ; preds = %sw.bb121
  %73 = load i8*, i8** %ptr.addr, align 8
  %74 = load i32, i32* %align.addr, align 4
  %call123 = call i32 @XXH_readLE32_align(i8* %73, i32 %74)
  %mul124 = mul i32 %call123, -1028477379
  %75 = load i32, i32* %h32.addr, align 4
  %add125 = add i32 %75, %mul124
  store i32 %add125, i32* %h32.addr, align 4
  %76 = load i8*, i8** %ptr.addr, align 8
  %add.ptr126 = getelementptr inbounds i8, i8* %76, i64 4
  store i8* %add.ptr126, i8** %ptr.addr, align 8
  %77 = load i32, i32* %h32.addr, align 4
  %shl127 = shl i32 %77, 17
  %78 = load i32, i32* %h32.addr, align 4
  %shr128 = lshr i32 %78, 15
  %or129 = or i32 %shl127, %shr128
  %mul130 = mul i32 %or129, 668265263
  store i32 %mul130, i32* %h32.addr, align 4
  br label %do.end131

do.end131:                                        ; preds = %do.body122
  br label %sw.bb132

sw.bb132:                                         ; preds = %entry, %do.end131
  br label %do.body133

do.body133:                                       ; preds = %sw.bb132
  %79 = load i8*, i8** %ptr.addr, align 8
  %80 = load i32, i32* %align.addr, align 4
  %call134 = call i32 @XXH_readLE32_align(i8* %79, i32 %80)
  %mul135 = mul i32 %call134, -1028477379
  %81 = load i32, i32* %h32.addr, align 4
  %add136 = add i32 %81, %mul135
  store i32 %add136, i32* %h32.addr, align 4
  %82 = load i8*, i8** %ptr.addr, align 8
  %add.ptr137 = getelementptr inbounds i8, i8* %82, i64 4
  store i8* %add.ptr137, i8** %ptr.addr, align 8
  %83 = load i32, i32* %h32.addr, align 4
  %shl138 = shl i32 %83, 17
  %84 = load i32, i32* %h32.addr, align 4
  %shr139 = lshr i32 %84, 15
  %or140 = or i32 %shl138, %shr139
  %mul141 = mul i32 %or140, 668265263
  store i32 %mul141, i32* %h32.addr, align 4
  br label %do.end142

do.end142:                                        ; preds = %do.body133
  br label %sw.bb143

sw.bb143:                                         ; preds = %entry, %do.end142
  br label %do.body144

do.body144:                                       ; preds = %sw.bb143
  %85 = load i8*, i8** %ptr.addr, align 8
  %86 = load i32, i32* %align.addr, align 4
  %call145 = call i32 @XXH_readLE32_align(i8* %85, i32 %86)
  %mul146 = mul i32 %call145, -1028477379
  %87 = load i32, i32* %h32.addr, align 4
  %add147 = add i32 %87, %mul146
  store i32 %add147, i32* %h32.addr, align 4
  %88 = load i8*, i8** %ptr.addr, align 8
  %add.ptr148 = getelementptr inbounds i8, i8* %88, i64 4
  store i8* %add.ptr148, i8** %ptr.addr, align 8
  %89 = load i32, i32* %h32.addr, align 4
  %shl149 = shl i32 %89, 17
  %90 = load i32, i32* %h32.addr, align 4
  %shr150 = lshr i32 %90, 15
  %or151 = or i32 %shl149, %shr150
  %mul152 = mul i32 %or151, 668265263
  store i32 %mul152, i32* %h32.addr, align 4
  br label %do.end153

do.end153:                                        ; preds = %do.body144
  br label %sw.bb154

sw.bb154:                                         ; preds = %entry, %do.end153
  br label %do.body155

do.body155:                                       ; preds = %sw.bb154
  %91 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr156 = getelementptr inbounds i8, i8* %91, i32 1
  store i8* %incdec.ptr156, i8** %ptr.addr, align 8
  %92 = load i8, i8* %91, align 1
  %conv157 = zext i8 %92 to i32
  %mul158 = mul i32 %conv157, 374761393
  %93 = load i32, i32* %h32.addr, align 4
  %add159 = add i32 %93, %mul158
  store i32 %add159, i32* %h32.addr, align 4
  %94 = load i32, i32* %h32.addr, align 4
  %shl160 = shl i32 %94, 11
  %95 = load i32, i32* %h32.addr, align 4
  %shr161 = lshr i32 %95, 21
  %or162 = or i32 %shl160, %shr161
  %mul163 = mul i32 %or162, -1640531535
  store i32 %mul163, i32* %h32.addr, align 4
  br label %do.end164

do.end164:                                        ; preds = %do.body155
  br label %sw.bb165

sw.bb165:                                         ; preds = %entry, %do.end164
  br label %do.body166

do.body166:                                       ; preds = %sw.bb165
  %96 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr167 = getelementptr inbounds i8, i8* %96, i32 1
  store i8* %incdec.ptr167, i8** %ptr.addr, align 8
  %97 = load i8, i8* %96, align 1
  %conv168 = zext i8 %97 to i32
  %mul169 = mul i32 %conv168, 374761393
  %98 = load i32, i32* %h32.addr, align 4
  %add170 = add i32 %98, %mul169
  store i32 %add170, i32* %h32.addr, align 4
  %99 = load i32, i32* %h32.addr, align 4
  %shl171 = shl i32 %99, 11
  %100 = load i32, i32* %h32.addr, align 4
  %shr172 = lshr i32 %100, 21
  %or173 = or i32 %shl171, %shr172
  %mul174 = mul i32 %or173, -1640531535
  store i32 %mul174, i32* %h32.addr, align 4
  br label %do.end175

do.end175:                                        ; preds = %do.body166
  br label %sw.bb176

sw.bb176:                                         ; preds = %entry, %do.end175
  br label %do.body177

do.body177:                                       ; preds = %sw.bb176
  %101 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr178 = getelementptr inbounds i8, i8* %101, i32 1
  store i8* %incdec.ptr178, i8** %ptr.addr, align 8
  %102 = load i8, i8* %101, align 1
  %conv179 = zext i8 %102 to i32
  %mul180 = mul i32 %conv179, 374761393
  %103 = load i32, i32* %h32.addr, align 4
  %add181 = add i32 %103, %mul180
  store i32 %add181, i32* %h32.addr, align 4
  %104 = load i32, i32* %h32.addr, align 4
  %shl182 = shl i32 %104, 11
  %105 = load i32, i32* %h32.addr, align 4
  %shr183 = lshr i32 %105, 21
  %or184 = or i32 %shl182, %shr183
  %mul185 = mul i32 %or184, -1640531535
  store i32 %mul185, i32* %h32.addr, align 4
  br label %do.end186

do.end186:                                        ; preds = %do.body177
  br label %sw.bb187

sw.bb187:                                         ; preds = %entry, %do.end186
  %106 = load i32, i32* %h32.addr, align 4
  %call188 = call i32 @XXH32_avalanche(i32 %106)
  store i32 %call188, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %entry
  %107 = load i32, i32* %h32.addr, align 4
  store i32 %107, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb187, %do.end119, %do.end65, %do.end23
  %108 = load i32, i32* %retval, align 4
  ret i32 %108
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH32_canonicalFromHash(%struct.XXH32_canonical_t* %dst, i32 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH32_canonical_t*, align 8
  %hash.addr = alloca i32, align 4
  store %struct.XXH32_canonical_t* %dst, %struct.XXH32_canonical_t** %dst.addr, align 8
  store i32 %hash, i32* %hash.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, i32* %hash.addr, align 4
  %call = call i32 @XXH_swap32(i32 %0)
  store i32 %call, i32* %hash.addr, align 4
  %1 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8
  %2 = bitcast %struct.XXH32_canonical_t* %1 to i8*
  %3 = bitcast i32* %hash.addr to i8*
  %4 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8
  %5 = bitcast %struct.XXH32_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 4, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_swap32(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = load i32, i32* %x.addr, align 4
  %shl = shl i32 %0, 24
  %and = and i32 %shl, -16777216
  %1 = load i32, i32* %x.addr, align 4
  %shl1 = shl i32 %1, 8
  %and2 = and i32 %shl1, 16711680
  %or = or i32 %and, %and2
  %2 = load i32, i32* %x.addr, align 4
  %shr = lshr i32 %2, 8
  %and3 = and i32 %shr, 65280
  %or4 = or i32 %or, %and3
  %3 = load i32, i32* %x.addr, align 4
  %shr5 = lshr i32 %3, 24
  %and6 = and i32 %shr5, 255
  %or7 = or i32 %or4, %and6
  ret i32 %or7
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_hashFromCanonical(%struct.XXH32_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH32_canonical_t*, align 8
  store %struct.XXH32_canonical_t* %src, %struct.XXH32_canonical_t** %src.addr, align 8
  %0 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %src.addr, align 8
  %1 = bitcast %struct.XXH32_canonical_t* %0 to i8*
  %call = call i32 @XXH_readBE32(i8* %1)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_readBE32(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i32 @XXH_read32(i8* %0)
  %call1 = call i32 @XXH_swap32(i32 %call)
  ret i32 %call1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH64(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH64_endian_align(i8* %0, i64 %1, i64 %2, i32 1)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_endian_align(i8* %input, i64 %len, i64 %seed, i32 %align) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h64 = alloca i64, align 8
  %limit = alloca i8*, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %1
  store i8* %add.ptr, i8** %bEnd, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp uge i64 %2, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %bEnd, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %3, i64 -32
  store i8* %add.ptr1, i8** %limit, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %add = add i64 %4, -7046029288634856825
  %add2 = add i64 %add, -4417276706812531889
  store i64 %add2, i64* %v1, align 8
  %5 = load i64, i64* %seed.addr, align 8
  %add3 = add i64 %5, -4417276706812531889
  store i64 %add3, i64* %v2, align 8
  %6 = load i64, i64* %seed.addr, align 8
  %add4 = add i64 %6, 0
  store i64 %add4, i64* %v3, align 8
  %7 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %7, -7046029288634856825
  store i64 %sub, i64* %v4, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %8 = load i64, i64* %v1, align 8
  %9 = load i8*, i8** %input.addr, align 8
  %10 = load i32, i32* %align.addr, align 4
  %call = call i64 @XXH_readLE64_align(i8* %9, i32 %10)
  %call5 = call i64 @XXH64_round(i64 %8, i64 %call)
  store i64 %call5, i64* %v1, align 8
  %11 = load i8*, i8** %input.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 8
  store i8* %add.ptr6, i8** %input.addr, align 8
  %12 = load i64, i64* %v2, align 8
  %13 = load i8*, i8** %input.addr, align 8
  %14 = load i32, i32* %align.addr, align 4
  %call7 = call i64 @XXH_readLE64_align(i8* %13, i32 %14)
  %call8 = call i64 @XXH64_round(i64 %12, i64 %call7)
  store i64 %call8, i64* %v2, align 8
  %15 = load i8*, i8** %input.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %15, i64 8
  store i8* %add.ptr9, i8** %input.addr, align 8
  %16 = load i64, i64* %v3, align 8
  %17 = load i8*, i8** %input.addr, align 8
  %18 = load i32, i32* %align.addr, align 4
  %call10 = call i64 @XXH_readLE64_align(i8* %17, i32 %18)
  %call11 = call i64 @XXH64_round(i64 %16, i64 %call10)
  store i64 %call11, i64* %v3, align 8
  %19 = load i8*, i8** %input.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %19, i64 8
  store i8* %add.ptr12, i8** %input.addr, align 8
  %20 = load i64, i64* %v4, align 8
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i32, i32* %align.addr, align 4
  %call13 = call i64 @XXH_readLE64_align(i8* %21, i32 %22)
  %call14 = call i64 @XXH64_round(i64 %20, i64 %call13)
  store i64 %call14, i64* %v4, align 8
  %23 = load i8*, i8** %input.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %23, i64 8
  store i8* %add.ptr15, i8** %input.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %24 = load i8*, i8** %input.addr, align 8
  %25 = load i8*, i8** %limit, align 8
  %cmp16 = icmp ule i8* %24, %25
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %26 = load i64, i64* %v1, align 8
  %shl = shl i64 %26, 1
  %27 = load i64, i64* %v1, align 8
  %shr = lshr i64 %27, 63
  %or = or i64 %shl, %shr
  %28 = load i64, i64* %v2, align 8
  %shl17 = shl i64 %28, 7
  %29 = load i64, i64* %v2, align 8
  %shr18 = lshr i64 %29, 57
  %or19 = or i64 %shl17, %shr18
  %add20 = add i64 %or, %or19
  %30 = load i64, i64* %v3, align 8
  %shl21 = shl i64 %30, 12
  %31 = load i64, i64* %v3, align 8
  %shr22 = lshr i64 %31, 52
  %or23 = or i64 %shl21, %shr22
  %add24 = add i64 %add20, %or23
  %32 = load i64, i64* %v4, align 8
  %shl25 = shl i64 %32, 18
  %33 = load i64, i64* %v4, align 8
  %shr26 = lshr i64 %33, 46
  %or27 = or i64 %shl25, %shr26
  %add28 = add i64 %add24, %or27
  store i64 %add28, i64* %h64, align 8
  %34 = load i64, i64* %h64, align 8
  %35 = load i64, i64* %v1, align 8
  %call29 = call i64 @XXH64_mergeRound(i64 %34, i64 %35)
  store i64 %call29, i64* %h64, align 8
  %36 = load i64, i64* %h64, align 8
  %37 = load i64, i64* %v2, align 8
  %call30 = call i64 @XXH64_mergeRound(i64 %36, i64 %37)
  store i64 %call30, i64* %h64, align 8
  %38 = load i64, i64* %h64, align 8
  %39 = load i64, i64* %v3, align 8
  %call31 = call i64 @XXH64_mergeRound(i64 %38, i64 %39)
  store i64 %call31, i64* %h64, align 8
  %40 = load i64, i64* %h64, align 8
  %41 = load i64, i64* %v4, align 8
  %call32 = call i64 @XXH64_mergeRound(i64 %40, i64 %41)
  store i64 %call32, i64* %h64, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %42 = load i64, i64* %seed.addr, align 8
  %add33 = add i64 %42, 2870177450012600261
  store i64 %add33, i64* %h64, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %43 = load i64, i64* %len.addr, align 8
  %44 = load i64, i64* %h64, align 8
  %add34 = add i64 %44, %43
  store i64 %add34, i64* %h64, align 8
  %45 = load i64, i64* %h64, align 8
  %46 = load i8*, i8** %input.addr, align 8
  %47 = load i64, i64* %len.addr, align 8
  %48 = load i32, i32* %align.addr, align 4
  %call35 = call i64 @XXH64_finalize(i64 %45, i8* %46, i64 %47, i32 %48)
  ret i64 %call35
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.XXH64_state_s* @XXH64_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 88)
  %0 = bitcast i8* %call to %struct.XXH64_state_s*
  ret %struct.XXH64_state_s* %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH64_freeState(%struct.XXH64_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH64_copyState(%struct.XXH64_state_s* %dstState, %struct.XXH64_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH64_state_s*, align 8
  %srcState.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %dstState, %struct.XXH64_state_s** %dstState.addr, align 8
  store %struct.XXH64_state_s* %srcState, %struct.XXH64_state_s** %srcState.addr, align 8
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  %2 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %srcState.addr, align 8
  %3 = bitcast %struct.XXH64_state_s* %2 to i8*
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8
  %5 = bitcast %struct.XXH64_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 88, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH64_reset(%struct.XXH64_state_s* %statePtr, i64 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %state = alloca %struct.XXH64_state_s, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %0, i8 0, i64 88, i1 false)
  %1 = load i64, i64* %seed.addr, align 8
  %add = add i64 %1, -7046029288634856825
  %add1 = add i64 %add, -4417276706812531889
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 1
  store i64 %add1, i64* %v1, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %add2 = add i64 %2, -4417276706812531889
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 2
  store i64 %add2, i64* %v2, align 8
  %3 = load i64, i64* %seed.addr, align 8
  %add3 = add i64 %3, 0
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 3
  store i64 %add3, i64* %v3, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %4, -7046029288634856825
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 4
  store i64 %sub, i64* %v4, align 8
  %5 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8
  %6 = bitcast %struct.XXH64_state_s* %5 to i8*
  %7 = bitcast %struct.XXH64_state_s* %state to i8*
  %8 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8
  %9 = bitcast %struct.XXH64_state_s* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 80, i64 %10) #10
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH64_update(%struct.XXH64_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %limit = alloca i8*, align 8
  %v156 = alloca i64, align 8
  %v258 = alloca i64, align 8
  %v360 = alloca i64, align 8
  %v462 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  store i8* %1, i8** %p, align 8
  %2 = load i8*, i8** %p, align 8
  %3 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %3
  store i8* %add.ptr, i8** %bEnd, align 8
  %4 = load i64, i64* %len.addr, align 8
  %5 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %5, i32 0, i32 0
  %6 = load i64, i64* %total_len, align 8
  %add = add i64 %6, %4
  store i64 %add, i64* %total_len, align 8
  %7 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %7, i32 0, i32 6
  %8 = load i32, i32* %memsize, align 8
  %conv = zext i32 %8 to i64
  %9 = load i64, i64* %len.addr, align 8
  %add1 = add i64 %conv, %9
  %cmp2 = icmp ult i64 %add1, 32
  br i1 %cmp2, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %10 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %10, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %11 = bitcast i64* %arraydecay to i8*
  %12 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize5 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %12, i32 0, i32 6
  %13 = load i32, i32* %memsize5, align 8
  %idx.ext = zext i32 %13 to i64
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 %idx.ext
  %14 = load i8*, i8** %input.addr, align 8
  %15 = load i64, i64* %len.addr, align 8
  %call = call i8* @XXH_memcpy(i8* %add.ptr6, i8* %14, i64 %15)
  %16 = load i64, i64* %len.addr, align 8
  %conv7 = trunc i64 %16 to i32
  %17 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize8 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %17, i32 0, i32 6
  %18 = load i32, i32* %memsize8, align 8
  %add9 = add i32 %18, %conv7
  store i32 %add9, i32* %memsize8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %19 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %19, i32 0, i32 6
  %20 = load i32, i32* %memsize11, align 8
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.then12, label %if.end50

if.then12:                                        ; preds = %if.end10
  %21 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6413 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %21, i32 0, i32 5
  %arraydecay14 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6413, i32 0, i32 0
  %22 = bitcast i64* %arraydecay14 to i8*
  %23 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize15 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %23, i32 0, i32 6
  %24 = load i32, i32* %memsize15, align 8
  %idx.ext16 = zext i32 %24 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %22, i64 %idx.ext16
  %25 = load i8*, i8** %input.addr, align 8
  %26 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize18 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %26, i32 0, i32 6
  %27 = load i32, i32* %memsize18, align 8
  %sub = sub i32 32, %27
  %conv19 = zext i32 %sub to i64
  %call20 = call i8* @XXH_memcpy(i8* %add.ptr17, i8* %25, i64 %conv19)
  %28 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %28, i32 0, i32 1
  %29 = load i64, i64* %v1, align 8
  %30 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6421 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %30, i32 0, i32 5
  %arraydecay22 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6421, i32 0, i32 0
  %add.ptr23 = getelementptr inbounds i64, i64* %arraydecay22, i64 0
  %31 = bitcast i64* %add.ptr23 to i8*
  %call24 = call i64 @XXH_readLE64(i8* %31)
  %call25 = call i64 @XXH64_round(i64 %29, i64 %call24)
  %32 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v126 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %32, i32 0, i32 1
  store i64 %call25, i64* %v126, align 8
  %33 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %33, i32 0, i32 2
  %34 = load i64, i64* %v2, align 8
  %35 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6427 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %35, i32 0, i32 5
  %arraydecay28 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6427, i32 0, i32 0
  %add.ptr29 = getelementptr inbounds i64, i64* %arraydecay28, i64 1
  %36 = bitcast i64* %add.ptr29 to i8*
  %call30 = call i64 @XXH_readLE64(i8* %36)
  %call31 = call i64 @XXH64_round(i64 %34, i64 %call30)
  %37 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v232 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %37, i32 0, i32 2
  store i64 %call31, i64* %v232, align 8
  %38 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %38, i32 0, i32 3
  %39 = load i64, i64* %v3, align 8
  %40 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6433 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %40, i32 0, i32 5
  %arraydecay34 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6433, i32 0, i32 0
  %add.ptr35 = getelementptr inbounds i64, i64* %arraydecay34, i64 2
  %41 = bitcast i64* %add.ptr35 to i8*
  %call36 = call i64 @XXH_readLE64(i8* %41)
  %call37 = call i64 @XXH64_round(i64 %39, i64 %call36)
  %42 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v338 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %42, i32 0, i32 3
  store i64 %call37, i64* %v338, align 8
  %43 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %43, i32 0, i32 4
  %44 = load i64, i64* %v4, align 8
  %45 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6439 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %45, i32 0, i32 5
  %arraydecay40 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6439, i32 0, i32 0
  %add.ptr41 = getelementptr inbounds i64, i64* %arraydecay40, i64 3
  %46 = bitcast i64* %add.ptr41 to i8*
  %call42 = call i64 @XXH_readLE64(i8* %46)
  %call43 = call i64 @XXH64_round(i64 %44, i64 %call42)
  %47 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v444 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %47, i32 0, i32 4
  store i64 %call43, i64* %v444, align 8
  %48 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize45 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %48, i32 0, i32 6
  %49 = load i32, i32* %memsize45, align 8
  %sub46 = sub i32 32, %49
  %50 = load i8*, i8** %p, align 8
  %idx.ext47 = zext i32 %sub46 to i64
  %add.ptr48 = getelementptr inbounds i8, i8* %50, i64 %idx.ext47
  store i8* %add.ptr48, i8** %p, align 8
  %51 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize49 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %51, i32 0, i32 6
  store i32 0, i32* %memsize49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then12, %if.end10
  %52 = load i8*, i8** %p, align 8
  %add.ptr51 = getelementptr inbounds i8, i8* %52, i64 32
  %53 = load i8*, i8** %bEnd, align 8
  %cmp52 = icmp ule i8* %add.ptr51, %53
  br i1 %cmp52, label %if.then54, label %if.end82

if.then54:                                        ; preds = %if.end50
  %54 = load i8*, i8** %bEnd, align 8
  %add.ptr55 = getelementptr inbounds i8, i8* %54, i64 -32
  store i8* %add.ptr55, i8** %limit, align 8
  %55 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v157 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %55, i32 0, i32 1
  %56 = load i64, i64* %v157, align 8
  store i64 %56, i64* %v156, align 8
  %57 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v259 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %57, i32 0, i32 2
  %58 = load i64, i64* %v259, align 8
  store i64 %58, i64* %v258, align 8
  %59 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v361 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %59, i32 0, i32 3
  %60 = load i64, i64* %v361, align 8
  store i64 %60, i64* %v360, align 8
  %61 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v463 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %61, i32 0, i32 4
  %62 = load i64, i64* %v463, align 8
  store i64 %62, i64* %v462, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then54
  %63 = load i64, i64* %v156, align 8
  %64 = load i8*, i8** %p, align 8
  %call64 = call i64 @XXH_readLE64(i8* %64)
  %call65 = call i64 @XXH64_round(i64 %63, i64 %call64)
  store i64 %call65, i64* %v156, align 8
  %65 = load i8*, i8** %p, align 8
  %add.ptr66 = getelementptr inbounds i8, i8* %65, i64 8
  store i8* %add.ptr66, i8** %p, align 8
  %66 = load i64, i64* %v258, align 8
  %67 = load i8*, i8** %p, align 8
  %call67 = call i64 @XXH_readLE64(i8* %67)
  %call68 = call i64 @XXH64_round(i64 %66, i64 %call67)
  store i64 %call68, i64* %v258, align 8
  %68 = load i8*, i8** %p, align 8
  %add.ptr69 = getelementptr inbounds i8, i8* %68, i64 8
  store i8* %add.ptr69, i8** %p, align 8
  %69 = load i64, i64* %v360, align 8
  %70 = load i8*, i8** %p, align 8
  %call70 = call i64 @XXH_readLE64(i8* %70)
  %call71 = call i64 @XXH64_round(i64 %69, i64 %call70)
  store i64 %call71, i64* %v360, align 8
  %71 = load i8*, i8** %p, align 8
  %add.ptr72 = getelementptr inbounds i8, i8* %71, i64 8
  store i8* %add.ptr72, i8** %p, align 8
  %72 = load i64, i64* %v462, align 8
  %73 = load i8*, i8** %p, align 8
  %call73 = call i64 @XXH_readLE64(i8* %73)
  %call74 = call i64 @XXH64_round(i64 %72, i64 %call73)
  store i64 %call74, i64* %v462, align 8
  %74 = load i8*, i8** %p, align 8
  %add.ptr75 = getelementptr inbounds i8, i8* %74, i64 8
  store i8* %add.ptr75, i8** %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %75 = load i8*, i8** %p, align 8
  %76 = load i8*, i8** %limit, align 8
  %cmp76 = icmp ule i8* %75, %76
  br i1 %cmp76, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %77 = load i64, i64* %v156, align 8
  %78 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v178 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %78, i32 0, i32 1
  store i64 %77, i64* %v178, align 8
  %79 = load i64, i64* %v258, align 8
  %80 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v279 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %80, i32 0, i32 2
  store i64 %79, i64* %v279, align 8
  %81 = load i64, i64* %v360, align 8
  %82 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v380 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %82, i32 0, i32 3
  store i64 %81, i64* %v380, align 8
  %83 = load i64, i64* %v462, align 8
  %84 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v481 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %84, i32 0, i32 4
  store i64 %83, i64* %v481, align 8
  br label %if.end82

if.end82:                                         ; preds = %do.end, %if.end50
  %85 = load i8*, i8** %p, align 8
  %86 = load i8*, i8** %bEnd, align 8
  %cmp83 = icmp ult i8* %85, %86
  br i1 %cmp83, label %if.then85, label %if.end94

if.then85:                                        ; preds = %if.end82
  %87 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6486 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %87, i32 0, i32 5
  %arraydecay87 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6486, i32 0, i32 0
  %88 = bitcast i64* %arraydecay87 to i8*
  %89 = load i8*, i8** %p, align 8
  %90 = load i8*, i8** %bEnd, align 8
  %91 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %90 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %91 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call88 = call i8* @XXH_memcpy(i8* %88, i8* %89, i64 %sub.ptr.sub)
  %92 = load i8*, i8** %bEnd, align 8
  %93 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast89 = ptrtoint i8* %92 to i64
  %sub.ptr.rhs.cast90 = ptrtoint i8* %93 to i64
  %sub.ptr.sub91 = sub i64 %sub.ptr.lhs.cast89, %sub.ptr.rhs.cast90
  %conv92 = trunc i64 %sub.ptr.sub91 to i32
  %94 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize93 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %94, i32 0, i32 6
  store i32 %conv92, i32* %memsize93, align 8
  br label %if.end94

if.end94:                                         ; preds = %if.then85, %if.end82
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end94, %if.then4, %if.then
  %95 = load i32, i32* %retval, align 4
  ret i32 %95
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_round(i64 %acc, i64 %input) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %input.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8
  store i64 %input, i64* %input.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %mul = mul i64 %0, -4417276706812531889
  %1 = load i64, i64* %acc.addr, align 8
  %add = add i64 %1, %mul
  store i64 %add, i64* %acc.addr, align 8
  %2 = load i64, i64* %acc.addr, align 8
  %shl = shl i64 %2, 31
  %3 = load i64, i64* %acc.addr, align 8
  %shr = lshr i64 %3, 33
  %or = or i64 %shl, %shr
  store i64 %or, i64* %acc.addr, align 8
  %4 = load i64, i64* %acc.addr, align 8
  %mul1 = mul i64 %4, -7046029288634856825
  store i64 %mul1, i64* %acc.addr, align 8
  %5 = load i64, i64* %acc.addr, align 8
  ret i64 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_readLE64(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i64 @XXH_read64(i8* %0)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH64_digest(%struct.XXH64_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %h64 = alloca i64, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %0, i32 0, i32 0
  %1 = load i64, i64* %total_len, align 8
  %cmp = icmp uge i64 %1, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %2, i32 0, i32 1
  %3 = load i64, i64* %v11, align 8
  store i64 %3, i64* %v1, align 8
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v22 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %4, i32 0, i32 2
  %5 = load i64, i64* %v22, align 8
  store i64 %5, i64* %v2, align 8
  %6 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v33 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %6, i32 0, i32 3
  %7 = load i64, i64* %v33, align 8
  store i64 %7, i64* %v3, align 8
  %8 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v44 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %8, i32 0, i32 4
  %9 = load i64, i64* %v44, align 8
  store i64 %9, i64* %v4, align 8
  %10 = load i64, i64* %v1, align 8
  %shl = shl i64 %10, 1
  %11 = load i64, i64* %v1, align 8
  %shr = lshr i64 %11, 63
  %or = or i64 %shl, %shr
  %12 = load i64, i64* %v2, align 8
  %shl5 = shl i64 %12, 7
  %13 = load i64, i64* %v2, align 8
  %shr6 = lshr i64 %13, 57
  %or7 = or i64 %shl5, %shr6
  %add = add i64 %or, %or7
  %14 = load i64, i64* %v3, align 8
  %shl8 = shl i64 %14, 12
  %15 = load i64, i64* %v3, align 8
  %shr9 = lshr i64 %15, 52
  %or10 = or i64 %shl8, %shr9
  %add11 = add i64 %add, %or10
  %16 = load i64, i64* %v4, align 8
  %shl12 = shl i64 %16, 18
  %17 = load i64, i64* %v4, align 8
  %shr13 = lshr i64 %17, 46
  %or14 = or i64 %shl12, %shr13
  %add15 = add i64 %add11, %or14
  store i64 %add15, i64* %h64, align 8
  %18 = load i64, i64* %h64, align 8
  %19 = load i64, i64* %v1, align 8
  %call = call i64 @XXH64_mergeRound(i64 %18, i64 %19)
  store i64 %call, i64* %h64, align 8
  %20 = load i64, i64* %h64, align 8
  %21 = load i64, i64* %v2, align 8
  %call16 = call i64 @XXH64_mergeRound(i64 %20, i64 %21)
  store i64 %call16, i64* %h64, align 8
  %22 = load i64, i64* %h64, align 8
  %23 = load i64, i64* %v3, align 8
  %call17 = call i64 @XXH64_mergeRound(i64 %22, i64 %23)
  store i64 %call17, i64* %h64, align 8
  %24 = load i64, i64* %h64, align 8
  %25 = load i64, i64* %v4, align 8
  %call18 = call i64 @XXH64_mergeRound(i64 %24, i64 %25)
  store i64 %call18, i64* %h64, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %26 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v319 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %26, i32 0, i32 3
  %27 = load i64, i64* %v319, align 8
  %add20 = add i64 %27, 2870177450012600261
  store i64 %add20, i64* %h64, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %28 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len21 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %28, i32 0, i32 0
  %29 = load i64, i64* %total_len21, align 8
  %30 = load i64, i64* %h64, align 8
  %add22 = add i64 %30, %29
  store i64 %add22, i64* %h64, align 8
  %31 = load i64, i64* %h64, align 8
  %32 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %32, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %33 = bitcast i64* %arraydecay to i8*
  %34 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len23 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %34, i32 0, i32 0
  %35 = load i64, i64* %total_len23, align 8
  %call24 = call i64 @XXH64_finalize(i64 %31, i8* %33, i64 %35, i32 0)
  ret i64 %call24
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_mergeRound(i64 %acc, i64 %val) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %call = call i64 @XXH64_round(i64 0, i64 %0)
  store i64 %call, i64* %val.addr, align 8
  %1 = load i64, i64* %val.addr, align 8
  %2 = load i64, i64* %acc.addr, align 8
  %xor = xor i64 %2, %1
  store i64 %xor, i64* %acc.addr, align 8
  %3 = load i64, i64* %acc.addr, align 8
  %mul = mul i64 %3, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %acc.addr, align 8
  %4 = load i64, i64* %acc.addr, align 8
  ret i64 %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_finalize(i64 %h64, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i64, align 8
  %h64.addr = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %k1 = alloca i64, align 8
  %k14 = alloca i64, align 8
  %k117 = alloca i64, align 8
  %k131 = alloca i64, align 8
  %k144 = alloca i64, align 8
  %k157 = alloca i64, align 8
  %k183 = alloca i64, align 8
  %k196 = alloca i64, align 8
  %k1109 = alloca i64, align 8
  %k1132 = alloca i64, align 8
  %k1145 = alloca i64, align 8
  %k1158 = alloca i64, align 8
  %k1195 = alloca i64, align 8
  %k1208 = alloca i64, align 8
  %k1221 = alloca i64, align 8
  %k1255 = alloca i64, align 8
  %k1268 = alloca i64, align 8
  %k1281 = alloca i64, align 8
  %k1328 = alloca i64, align 8
  %k1341 = alloca i64, align 8
  %k1354 = alloca i64, align 8
  %k1398 = alloca i64, align 8
  %k1411 = alloca i64, align 8
  %k1424 = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i64, i64* %len.addr, align 8
  %and = and i64 %0, 31
  switch i64 %and, label %sw.epilog [
    i64 24, label %sw.bb
    i64 16, label %sw.bb2
    i64 8, label %sw.bb15
    i64 28, label %sw.bb29
    i64 20, label %sw.bb42
    i64 12, label %sw.bb55
    i64 4, label %sw.bb68
    i64 25, label %sw.bb81
    i64 17, label %sw.bb94
    i64 9, label %sw.bb107
    i64 29, label %sw.bb130
    i64 21, label %sw.bb143
    i64 13, label %sw.bb156
    i64 5, label %sw.bb169
    i64 26, label %sw.bb193
    i64 18, label %sw.bb206
    i64 10, label %sw.bb219
    i64 30, label %sw.bb253
    i64 22, label %sw.bb266
    i64 14, label %sw.bb279
    i64 6, label %sw.bb292
    i64 27, label %sw.bb326
    i64 19, label %sw.bb339
    i64 11, label %sw.bb352
    i64 31, label %sw.bb396
    i64 23, label %sw.bb409
    i64 15, label %sw.bb422
    i64 7, label %sw.bb435
    i64 3, label %sw.bb448
    i64 2, label %sw.bb459
    i64 1, label %sw.bb470
    i64 0, label %sw.bb481
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i8*, i8** %ptr.addr, align 8
  %2 = load i32, i32* %align.addr, align 4
  %call = call i64 @XXH_readLE64_align(i8* %1, i32 %2)
  %call1 = call i64 @XXH64_round(i64 0, i64 %call)
  store i64 %call1, i64* %k1, align 8
  %3 = load i8*, i8** %ptr.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 8
  store i8* %add.ptr, i8** %ptr.addr, align 8
  %4 = load i64, i64* %k1, align 8
  %5 = load i64, i64* %h64.addr, align 8
  %xor = xor i64 %5, %4
  store i64 %xor, i64* %h64.addr, align 8
  %6 = load i64, i64* %h64.addr, align 8
  %shl = shl i64 %6, 27
  %7 = load i64, i64* %h64.addr, align 8
  %shr = lshr i64 %7, 37
  %or = or i64 %shl, %shr
  %mul = mul i64 %or, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %h64.addr, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %8 = load i8*, i8** %ptr.addr, align 8
  %9 = load i32, i32* %align.addr, align 4
  %call5 = call i64 @XXH_readLE64_align(i8* %8, i32 %9)
  %call6 = call i64 @XXH64_round(i64 0, i64 %call5)
  store i64 %call6, i64* %k14, align 8
  %10 = load i8*, i8** %ptr.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 8
  store i8* %add.ptr7, i8** %ptr.addr, align 8
  %11 = load i64, i64* %k14, align 8
  %12 = load i64, i64* %h64.addr, align 8
  %xor8 = xor i64 %12, %11
  store i64 %xor8, i64* %h64.addr, align 8
  %13 = load i64, i64* %h64.addr, align 8
  %shl9 = shl i64 %13, 27
  %14 = load i64, i64* %h64.addr, align 8
  %shr10 = lshr i64 %14, 37
  %or11 = or i64 %shl9, %shr10
  %mul12 = mul i64 %or11, -7046029288634856825
  %add13 = add i64 %mul12, -8796714831421723037
  store i64 %add13, i64* %h64.addr, align 8
  br label %do.end14

do.end14:                                         ; preds = %do.body3
  br label %sw.bb15

sw.bb15:                                          ; preds = %entry, %do.end14
  br label %do.body16

do.body16:                                        ; preds = %sw.bb15
  %15 = load i8*, i8** %ptr.addr, align 8
  %16 = load i32, i32* %align.addr, align 4
  %call18 = call i64 @XXH_readLE64_align(i8* %15, i32 %16)
  %call19 = call i64 @XXH64_round(i64 0, i64 %call18)
  store i64 %call19, i64* %k117, align 8
  %17 = load i8*, i8** %ptr.addr, align 8
  %add.ptr20 = getelementptr inbounds i8, i8* %17, i64 8
  store i8* %add.ptr20, i8** %ptr.addr, align 8
  %18 = load i64, i64* %k117, align 8
  %19 = load i64, i64* %h64.addr, align 8
  %xor21 = xor i64 %19, %18
  store i64 %xor21, i64* %h64.addr, align 8
  %20 = load i64, i64* %h64.addr, align 8
  %shl22 = shl i64 %20, 27
  %21 = load i64, i64* %h64.addr, align 8
  %shr23 = lshr i64 %21, 37
  %or24 = or i64 %shl22, %shr23
  %mul25 = mul i64 %or24, -7046029288634856825
  %add26 = add i64 %mul25, -8796714831421723037
  store i64 %add26, i64* %h64.addr, align 8
  br label %do.end27

do.end27:                                         ; preds = %do.body16
  %22 = load i64, i64* %h64.addr, align 8
  %call28 = call i64 @XXH64_avalanche(i64 %22)
  store i64 %call28, i64* %retval, align 8
  br label %return

sw.bb29:                                          ; preds = %entry
  br label %do.body30

do.body30:                                        ; preds = %sw.bb29
  %23 = load i8*, i8** %ptr.addr, align 8
  %24 = load i32, i32* %align.addr, align 4
  %call32 = call i64 @XXH_readLE64_align(i8* %23, i32 %24)
  %call33 = call i64 @XXH64_round(i64 0, i64 %call32)
  store i64 %call33, i64* %k131, align 8
  %25 = load i8*, i8** %ptr.addr, align 8
  %add.ptr34 = getelementptr inbounds i8, i8* %25, i64 8
  store i8* %add.ptr34, i8** %ptr.addr, align 8
  %26 = load i64, i64* %k131, align 8
  %27 = load i64, i64* %h64.addr, align 8
  %xor35 = xor i64 %27, %26
  store i64 %xor35, i64* %h64.addr, align 8
  %28 = load i64, i64* %h64.addr, align 8
  %shl36 = shl i64 %28, 27
  %29 = load i64, i64* %h64.addr, align 8
  %shr37 = lshr i64 %29, 37
  %or38 = or i64 %shl36, %shr37
  %mul39 = mul i64 %or38, -7046029288634856825
  %add40 = add i64 %mul39, -8796714831421723037
  store i64 %add40, i64* %h64.addr, align 8
  br label %do.end41

do.end41:                                         ; preds = %do.body30
  br label %sw.bb42

sw.bb42:                                          ; preds = %entry, %do.end41
  br label %do.body43

do.body43:                                        ; preds = %sw.bb42
  %30 = load i8*, i8** %ptr.addr, align 8
  %31 = load i32, i32* %align.addr, align 4
  %call45 = call i64 @XXH_readLE64_align(i8* %30, i32 %31)
  %call46 = call i64 @XXH64_round(i64 0, i64 %call45)
  store i64 %call46, i64* %k144, align 8
  %32 = load i8*, i8** %ptr.addr, align 8
  %add.ptr47 = getelementptr inbounds i8, i8* %32, i64 8
  store i8* %add.ptr47, i8** %ptr.addr, align 8
  %33 = load i64, i64* %k144, align 8
  %34 = load i64, i64* %h64.addr, align 8
  %xor48 = xor i64 %34, %33
  store i64 %xor48, i64* %h64.addr, align 8
  %35 = load i64, i64* %h64.addr, align 8
  %shl49 = shl i64 %35, 27
  %36 = load i64, i64* %h64.addr, align 8
  %shr50 = lshr i64 %36, 37
  %or51 = or i64 %shl49, %shr50
  %mul52 = mul i64 %or51, -7046029288634856825
  %add53 = add i64 %mul52, -8796714831421723037
  store i64 %add53, i64* %h64.addr, align 8
  br label %do.end54

do.end54:                                         ; preds = %do.body43
  br label %sw.bb55

sw.bb55:                                          ; preds = %entry, %do.end54
  br label %do.body56

do.body56:                                        ; preds = %sw.bb55
  %37 = load i8*, i8** %ptr.addr, align 8
  %38 = load i32, i32* %align.addr, align 4
  %call58 = call i64 @XXH_readLE64_align(i8* %37, i32 %38)
  %call59 = call i64 @XXH64_round(i64 0, i64 %call58)
  store i64 %call59, i64* %k157, align 8
  %39 = load i8*, i8** %ptr.addr, align 8
  %add.ptr60 = getelementptr inbounds i8, i8* %39, i64 8
  store i8* %add.ptr60, i8** %ptr.addr, align 8
  %40 = load i64, i64* %k157, align 8
  %41 = load i64, i64* %h64.addr, align 8
  %xor61 = xor i64 %41, %40
  store i64 %xor61, i64* %h64.addr, align 8
  %42 = load i64, i64* %h64.addr, align 8
  %shl62 = shl i64 %42, 27
  %43 = load i64, i64* %h64.addr, align 8
  %shr63 = lshr i64 %43, 37
  %or64 = or i64 %shl62, %shr63
  %mul65 = mul i64 %or64, -7046029288634856825
  %add66 = add i64 %mul65, -8796714831421723037
  store i64 %add66, i64* %h64.addr, align 8
  br label %do.end67

do.end67:                                         ; preds = %do.body56
  br label %sw.bb68

sw.bb68:                                          ; preds = %entry, %do.end67
  br label %do.body69

do.body69:                                        ; preds = %sw.bb68
  %44 = load i8*, i8** %ptr.addr, align 8
  %45 = load i32, i32* %align.addr, align 4
  %call70 = call i32 @XXH_readLE32_align(i8* %44, i32 %45)
  %conv = zext i32 %call70 to i64
  %mul71 = mul i64 %conv, -7046029288634856825
  %46 = load i64, i64* %h64.addr, align 8
  %xor72 = xor i64 %46, %mul71
  store i64 %xor72, i64* %h64.addr, align 8
  %47 = load i8*, i8** %ptr.addr, align 8
  %add.ptr73 = getelementptr inbounds i8, i8* %47, i64 4
  store i8* %add.ptr73, i8** %ptr.addr, align 8
  %48 = load i64, i64* %h64.addr, align 8
  %shl74 = shl i64 %48, 23
  %49 = load i64, i64* %h64.addr, align 8
  %shr75 = lshr i64 %49, 41
  %or76 = or i64 %shl74, %shr75
  %mul77 = mul i64 %or76, -4417276706812531889
  %add78 = add i64 %mul77, 1609587929392839161
  store i64 %add78, i64* %h64.addr, align 8
  br label %do.end79

do.end79:                                         ; preds = %do.body69
  %50 = load i64, i64* %h64.addr, align 8
  %call80 = call i64 @XXH64_avalanche(i64 %50)
  store i64 %call80, i64* %retval, align 8
  br label %return

sw.bb81:                                          ; preds = %entry
  br label %do.body82

do.body82:                                        ; preds = %sw.bb81
  %51 = load i8*, i8** %ptr.addr, align 8
  %52 = load i32, i32* %align.addr, align 4
  %call84 = call i64 @XXH_readLE64_align(i8* %51, i32 %52)
  %call85 = call i64 @XXH64_round(i64 0, i64 %call84)
  store i64 %call85, i64* %k183, align 8
  %53 = load i8*, i8** %ptr.addr, align 8
  %add.ptr86 = getelementptr inbounds i8, i8* %53, i64 8
  store i8* %add.ptr86, i8** %ptr.addr, align 8
  %54 = load i64, i64* %k183, align 8
  %55 = load i64, i64* %h64.addr, align 8
  %xor87 = xor i64 %55, %54
  store i64 %xor87, i64* %h64.addr, align 8
  %56 = load i64, i64* %h64.addr, align 8
  %shl88 = shl i64 %56, 27
  %57 = load i64, i64* %h64.addr, align 8
  %shr89 = lshr i64 %57, 37
  %or90 = or i64 %shl88, %shr89
  %mul91 = mul i64 %or90, -7046029288634856825
  %add92 = add i64 %mul91, -8796714831421723037
  store i64 %add92, i64* %h64.addr, align 8
  br label %do.end93

do.end93:                                         ; preds = %do.body82
  br label %sw.bb94

sw.bb94:                                          ; preds = %entry, %do.end93
  br label %do.body95

do.body95:                                        ; preds = %sw.bb94
  %58 = load i8*, i8** %ptr.addr, align 8
  %59 = load i32, i32* %align.addr, align 4
  %call97 = call i64 @XXH_readLE64_align(i8* %58, i32 %59)
  %call98 = call i64 @XXH64_round(i64 0, i64 %call97)
  store i64 %call98, i64* %k196, align 8
  %60 = load i8*, i8** %ptr.addr, align 8
  %add.ptr99 = getelementptr inbounds i8, i8* %60, i64 8
  store i8* %add.ptr99, i8** %ptr.addr, align 8
  %61 = load i64, i64* %k196, align 8
  %62 = load i64, i64* %h64.addr, align 8
  %xor100 = xor i64 %62, %61
  store i64 %xor100, i64* %h64.addr, align 8
  %63 = load i64, i64* %h64.addr, align 8
  %shl101 = shl i64 %63, 27
  %64 = load i64, i64* %h64.addr, align 8
  %shr102 = lshr i64 %64, 37
  %or103 = or i64 %shl101, %shr102
  %mul104 = mul i64 %or103, -7046029288634856825
  %add105 = add i64 %mul104, -8796714831421723037
  store i64 %add105, i64* %h64.addr, align 8
  br label %do.end106

do.end106:                                        ; preds = %do.body95
  br label %sw.bb107

sw.bb107:                                         ; preds = %entry, %do.end106
  br label %do.body108

do.body108:                                       ; preds = %sw.bb107
  %65 = load i8*, i8** %ptr.addr, align 8
  %66 = load i32, i32* %align.addr, align 4
  %call110 = call i64 @XXH_readLE64_align(i8* %65, i32 %66)
  %call111 = call i64 @XXH64_round(i64 0, i64 %call110)
  store i64 %call111, i64* %k1109, align 8
  %67 = load i8*, i8** %ptr.addr, align 8
  %add.ptr112 = getelementptr inbounds i8, i8* %67, i64 8
  store i8* %add.ptr112, i8** %ptr.addr, align 8
  %68 = load i64, i64* %k1109, align 8
  %69 = load i64, i64* %h64.addr, align 8
  %xor113 = xor i64 %69, %68
  store i64 %xor113, i64* %h64.addr, align 8
  %70 = load i64, i64* %h64.addr, align 8
  %shl114 = shl i64 %70, 27
  %71 = load i64, i64* %h64.addr, align 8
  %shr115 = lshr i64 %71, 37
  %or116 = or i64 %shl114, %shr115
  %mul117 = mul i64 %or116, -7046029288634856825
  %add118 = add i64 %mul117, -8796714831421723037
  store i64 %add118, i64* %h64.addr, align 8
  br label %do.end119

do.end119:                                        ; preds = %do.body108
  br label %do.body120

do.body120:                                       ; preds = %do.end119
  %72 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %72, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8
  %73 = load i8, i8* %72, align 1
  %conv121 = zext i8 %73 to i64
  %mul122 = mul i64 %conv121, 2870177450012600261
  %74 = load i64, i64* %h64.addr, align 8
  %xor123 = xor i64 %74, %mul122
  store i64 %xor123, i64* %h64.addr, align 8
  %75 = load i64, i64* %h64.addr, align 8
  %shl124 = shl i64 %75, 11
  %76 = load i64, i64* %h64.addr, align 8
  %shr125 = lshr i64 %76, 53
  %or126 = or i64 %shl124, %shr125
  %mul127 = mul i64 %or126, -7046029288634856825
  store i64 %mul127, i64* %h64.addr, align 8
  br label %do.end128

do.end128:                                        ; preds = %do.body120
  %77 = load i64, i64* %h64.addr, align 8
  %call129 = call i64 @XXH64_avalanche(i64 %77)
  store i64 %call129, i64* %retval, align 8
  br label %return

sw.bb130:                                         ; preds = %entry
  br label %do.body131

do.body131:                                       ; preds = %sw.bb130
  %78 = load i8*, i8** %ptr.addr, align 8
  %79 = load i32, i32* %align.addr, align 4
  %call133 = call i64 @XXH_readLE64_align(i8* %78, i32 %79)
  %call134 = call i64 @XXH64_round(i64 0, i64 %call133)
  store i64 %call134, i64* %k1132, align 8
  %80 = load i8*, i8** %ptr.addr, align 8
  %add.ptr135 = getelementptr inbounds i8, i8* %80, i64 8
  store i8* %add.ptr135, i8** %ptr.addr, align 8
  %81 = load i64, i64* %k1132, align 8
  %82 = load i64, i64* %h64.addr, align 8
  %xor136 = xor i64 %82, %81
  store i64 %xor136, i64* %h64.addr, align 8
  %83 = load i64, i64* %h64.addr, align 8
  %shl137 = shl i64 %83, 27
  %84 = load i64, i64* %h64.addr, align 8
  %shr138 = lshr i64 %84, 37
  %or139 = or i64 %shl137, %shr138
  %mul140 = mul i64 %or139, -7046029288634856825
  %add141 = add i64 %mul140, -8796714831421723037
  store i64 %add141, i64* %h64.addr, align 8
  br label %do.end142

do.end142:                                        ; preds = %do.body131
  br label %sw.bb143

sw.bb143:                                         ; preds = %entry, %do.end142
  br label %do.body144

do.body144:                                       ; preds = %sw.bb143
  %85 = load i8*, i8** %ptr.addr, align 8
  %86 = load i32, i32* %align.addr, align 4
  %call146 = call i64 @XXH_readLE64_align(i8* %85, i32 %86)
  %call147 = call i64 @XXH64_round(i64 0, i64 %call146)
  store i64 %call147, i64* %k1145, align 8
  %87 = load i8*, i8** %ptr.addr, align 8
  %add.ptr148 = getelementptr inbounds i8, i8* %87, i64 8
  store i8* %add.ptr148, i8** %ptr.addr, align 8
  %88 = load i64, i64* %k1145, align 8
  %89 = load i64, i64* %h64.addr, align 8
  %xor149 = xor i64 %89, %88
  store i64 %xor149, i64* %h64.addr, align 8
  %90 = load i64, i64* %h64.addr, align 8
  %shl150 = shl i64 %90, 27
  %91 = load i64, i64* %h64.addr, align 8
  %shr151 = lshr i64 %91, 37
  %or152 = or i64 %shl150, %shr151
  %mul153 = mul i64 %or152, -7046029288634856825
  %add154 = add i64 %mul153, -8796714831421723037
  store i64 %add154, i64* %h64.addr, align 8
  br label %do.end155

do.end155:                                        ; preds = %do.body144
  br label %sw.bb156

sw.bb156:                                         ; preds = %entry, %do.end155
  br label %do.body157

do.body157:                                       ; preds = %sw.bb156
  %92 = load i8*, i8** %ptr.addr, align 8
  %93 = load i32, i32* %align.addr, align 4
  %call159 = call i64 @XXH_readLE64_align(i8* %92, i32 %93)
  %call160 = call i64 @XXH64_round(i64 0, i64 %call159)
  store i64 %call160, i64* %k1158, align 8
  %94 = load i8*, i8** %ptr.addr, align 8
  %add.ptr161 = getelementptr inbounds i8, i8* %94, i64 8
  store i8* %add.ptr161, i8** %ptr.addr, align 8
  %95 = load i64, i64* %k1158, align 8
  %96 = load i64, i64* %h64.addr, align 8
  %xor162 = xor i64 %96, %95
  store i64 %xor162, i64* %h64.addr, align 8
  %97 = load i64, i64* %h64.addr, align 8
  %shl163 = shl i64 %97, 27
  %98 = load i64, i64* %h64.addr, align 8
  %shr164 = lshr i64 %98, 37
  %or165 = or i64 %shl163, %shr164
  %mul166 = mul i64 %or165, -7046029288634856825
  %add167 = add i64 %mul166, -8796714831421723037
  store i64 %add167, i64* %h64.addr, align 8
  br label %do.end168

do.end168:                                        ; preds = %do.body157
  br label %sw.bb169

sw.bb169:                                         ; preds = %entry, %do.end168
  br label %do.body170

do.body170:                                       ; preds = %sw.bb169
  %99 = load i8*, i8** %ptr.addr, align 8
  %100 = load i32, i32* %align.addr, align 4
  %call171 = call i32 @XXH_readLE32_align(i8* %99, i32 %100)
  %conv172 = zext i32 %call171 to i64
  %mul173 = mul i64 %conv172, -7046029288634856825
  %101 = load i64, i64* %h64.addr, align 8
  %xor174 = xor i64 %101, %mul173
  store i64 %xor174, i64* %h64.addr, align 8
  %102 = load i8*, i8** %ptr.addr, align 8
  %add.ptr175 = getelementptr inbounds i8, i8* %102, i64 4
  store i8* %add.ptr175, i8** %ptr.addr, align 8
  %103 = load i64, i64* %h64.addr, align 8
  %shl176 = shl i64 %103, 23
  %104 = load i64, i64* %h64.addr, align 8
  %shr177 = lshr i64 %104, 41
  %or178 = or i64 %shl176, %shr177
  %mul179 = mul i64 %or178, -4417276706812531889
  %add180 = add i64 %mul179, 1609587929392839161
  store i64 %add180, i64* %h64.addr, align 8
  br label %do.end181

do.end181:                                        ; preds = %do.body170
  br label %do.body182

do.body182:                                       ; preds = %do.end181
  %105 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr183 = getelementptr inbounds i8, i8* %105, i32 1
  store i8* %incdec.ptr183, i8** %ptr.addr, align 8
  %106 = load i8, i8* %105, align 1
  %conv184 = zext i8 %106 to i64
  %mul185 = mul i64 %conv184, 2870177450012600261
  %107 = load i64, i64* %h64.addr, align 8
  %xor186 = xor i64 %107, %mul185
  store i64 %xor186, i64* %h64.addr, align 8
  %108 = load i64, i64* %h64.addr, align 8
  %shl187 = shl i64 %108, 11
  %109 = load i64, i64* %h64.addr, align 8
  %shr188 = lshr i64 %109, 53
  %or189 = or i64 %shl187, %shr188
  %mul190 = mul i64 %or189, -7046029288634856825
  store i64 %mul190, i64* %h64.addr, align 8
  br label %do.end191

do.end191:                                        ; preds = %do.body182
  %110 = load i64, i64* %h64.addr, align 8
  %call192 = call i64 @XXH64_avalanche(i64 %110)
  store i64 %call192, i64* %retval, align 8
  br label %return

sw.bb193:                                         ; preds = %entry
  br label %do.body194

do.body194:                                       ; preds = %sw.bb193
  %111 = load i8*, i8** %ptr.addr, align 8
  %112 = load i32, i32* %align.addr, align 4
  %call196 = call i64 @XXH_readLE64_align(i8* %111, i32 %112)
  %call197 = call i64 @XXH64_round(i64 0, i64 %call196)
  store i64 %call197, i64* %k1195, align 8
  %113 = load i8*, i8** %ptr.addr, align 8
  %add.ptr198 = getelementptr inbounds i8, i8* %113, i64 8
  store i8* %add.ptr198, i8** %ptr.addr, align 8
  %114 = load i64, i64* %k1195, align 8
  %115 = load i64, i64* %h64.addr, align 8
  %xor199 = xor i64 %115, %114
  store i64 %xor199, i64* %h64.addr, align 8
  %116 = load i64, i64* %h64.addr, align 8
  %shl200 = shl i64 %116, 27
  %117 = load i64, i64* %h64.addr, align 8
  %shr201 = lshr i64 %117, 37
  %or202 = or i64 %shl200, %shr201
  %mul203 = mul i64 %or202, -7046029288634856825
  %add204 = add i64 %mul203, -8796714831421723037
  store i64 %add204, i64* %h64.addr, align 8
  br label %do.end205

do.end205:                                        ; preds = %do.body194
  br label %sw.bb206

sw.bb206:                                         ; preds = %entry, %do.end205
  br label %do.body207

do.body207:                                       ; preds = %sw.bb206
  %118 = load i8*, i8** %ptr.addr, align 8
  %119 = load i32, i32* %align.addr, align 4
  %call209 = call i64 @XXH_readLE64_align(i8* %118, i32 %119)
  %call210 = call i64 @XXH64_round(i64 0, i64 %call209)
  store i64 %call210, i64* %k1208, align 8
  %120 = load i8*, i8** %ptr.addr, align 8
  %add.ptr211 = getelementptr inbounds i8, i8* %120, i64 8
  store i8* %add.ptr211, i8** %ptr.addr, align 8
  %121 = load i64, i64* %k1208, align 8
  %122 = load i64, i64* %h64.addr, align 8
  %xor212 = xor i64 %122, %121
  store i64 %xor212, i64* %h64.addr, align 8
  %123 = load i64, i64* %h64.addr, align 8
  %shl213 = shl i64 %123, 27
  %124 = load i64, i64* %h64.addr, align 8
  %shr214 = lshr i64 %124, 37
  %or215 = or i64 %shl213, %shr214
  %mul216 = mul i64 %or215, -7046029288634856825
  %add217 = add i64 %mul216, -8796714831421723037
  store i64 %add217, i64* %h64.addr, align 8
  br label %do.end218

do.end218:                                        ; preds = %do.body207
  br label %sw.bb219

sw.bb219:                                         ; preds = %entry, %do.end218
  br label %do.body220

do.body220:                                       ; preds = %sw.bb219
  %125 = load i8*, i8** %ptr.addr, align 8
  %126 = load i32, i32* %align.addr, align 4
  %call222 = call i64 @XXH_readLE64_align(i8* %125, i32 %126)
  %call223 = call i64 @XXH64_round(i64 0, i64 %call222)
  store i64 %call223, i64* %k1221, align 8
  %127 = load i8*, i8** %ptr.addr, align 8
  %add.ptr224 = getelementptr inbounds i8, i8* %127, i64 8
  store i8* %add.ptr224, i8** %ptr.addr, align 8
  %128 = load i64, i64* %k1221, align 8
  %129 = load i64, i64* %h64.addr, align 8
  %xor225 = xor i64 %129, %128
  store i64 %xor225, i64* %h64.addr, align 8
  %130 = load i64, i64* %h64.addr, align 8
  %shl226 = shl i64 %130, 27
  %131 = load i64, i64* %h64.addr, align 8
  %shr227 = lshr i64 %131, 37
  %or228 = or i64 %shl226, %shr227
  %mul229 = mul i64 %or228, -7046029288634856825
  %add230 = add i64 %mul229, -8796714831421723037
  store i64 %add230, i64* %h64.addr, align 8
  br label %do.end231

do.end231:                                        ; preds = %do.body220
  br label %do.body232

do.body232:                                       ; preds = %do.end231
  %132 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr233 = getelementptr inbounds i8, i8* %132, i32 1
  store i8* %incdec.ptr233, i8** %ptr.addr, align 8
  %133 = load i8, i8* %132, align 1
  %conv234 = zext i8 %133 to i64
  %mul235 = mul i64 %conv234, 2870177450012600261
  %134 = load i64, i64* %h64.addr, align 8
  %xor236 = xor i64 %134, %mul235
  store i64 %xor236, i64* %h64.addr, align 8
  %135 = load i64, i64* %h64.addr, align 8
  %shl237 = shl i64 %135, 11
  %136 = load i64, i64* %h64.addr, align 8
  %shr238 = lshr i64 %136, 53
  %or239 = or i64 %shl237, %shr238
  %mul240 = mul i64 %or239, -7046029288634856825
  store i64 %mul240, i64* %h64.addr, align 8
  br label %do.end241

do.end241:                                        ; preds = %do.body232
  br label %do.body242

do.body242:                                       ; preds = %do.end241
  %137 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr243 = getelementptr inbounds i8, i8* %137, i32 1
  store i8* %incdec.ptr243, i8** %ptr.addr, align 8
  %138 = load i8, i8* %137, align 1
  %conv244 = zext i8 %138 to i64
  %mul245 = mul i64 %conv244, 2870177450012600261
  %139 = load i64, i64* %h64.addr, align 8
  %xor246 = xor i64 %139, %mul245
  store i64 %xor246, i64* %h64.addr, align 8
  %140 = load i64, i64* %h64.addr, align 8
  %shl247 = shl i64 %140, 11
  %141 = load i64, i64* %h64.addr, align 8
  %shr248 = lshr i64 %141, 53
  %or249 = or i64 %shl247, %shr248
  %mul250 = mul i64 %or249, -7046029288634856825
  store i64 %mul250, i64* %h64.addr, align 8
  br label %do.end251

do.end251:                                        ; preds = %do.body242
  %142 = load i64, i64* %h64.addr, align 8
  %call252 = call i64 @XXH64_avalanche(i64 %142)
  store i64 %call252, i64* %retval, align 8
  br label %return

sw.bb253:                                         ; preds = %entry
  br label %do.body254

do.body254:                                       ; preds = %sw.bb253
  %143 = load i8*, i8** %ptr.addr, align 8
  %144 = load i32, i32* %align.addr, align 4
  %call256 = call i64 @XXH_readLE64_align(i8* %143, i32 %144)
  %call257 = call i64 @XXH64_round(i64 0, i64 %call256)
  store i64 %call257, i64* %k1255, align 8
  %145 = load i8*, i8** %ptr.addr, align 8
  %add.ptr258 = getelementptr inbounds i8, i8* %145, i64 8
  store i8* %add.ptr258, i8** %ptr.addr, align 8
  %146 = load i64, i64* %k1255, align 8
  %147 = load i64, i64* %h64.addr, align 8
  %xor259 = xor i64 %147, %146
  store i64 %xor259, i64* %h64.addr, align 8
  %148 = load i64, i64* %h64.addr, align 8
  %shl260 = shl i64 %148, 27
  %149 = load i64, i64* %h64.addr, align 8
  %shr261 = lshr i64 %149, 37
  %or262 = or i64 %shl260, %shr261
  %mul263 = mul i64 %or262, -7046029288634856825
  %add264 = add i64 %mul263, -8796714831421723037
  store i64 %add264, i64* %h64.addr, align 8
  br label %do.end265

do.end265:                                        ; preds = %do.body254
  br label %sw.bb266

sw.bb266:                                         ; preds = %entry, %do.end265
  br label %do.body267

do.body267:                                       ; preds = %sw.bb266
  %150 = load i8*, i8** %ptr.addr, align 8
  %151 = load i32, i32* %align.addr, align 4
  %call269 = call i64 @XXH_readLE64_align(i8* %150, i32 %151)
  %call270 = call i64 @XXH64_round(i64 0, i64 %call269)
  store i64 %call270, i64* %k1268, align 8
  %152 = load i8*, i8** %ptr.addr, align 8
  %add.ptr271 = getelementptr inbounds i8, i8* %152, i64 8
  store i8* %add.ptr271, i8** %ptr.addr, align 8
  %153 = load i64, i64* %k1268, align 8
  %154 = load i64, i64* %h64.addr, align 8
  %xor272 = xor i64 %154, %153
  store i64 %xor272, i64* %h64.addr, align 8
  %155 = load i64, i64* %h64.addr, align 8
  %shl273 = shl i64 %155, 27
  %156 = load i64, i64* %h64.addr, align 8
  %shr274 = lshr i64 %156, 37
  %or275 = or i64 %shl273, %shr274
  %mul276 = mul i64 %or275, -7046029288634856825
  %add277 = add i64 %mul276, -8796714831421723037
  store i64 %add277, i64* %h64.addr, align 8
  br label %do.end278

do.end278:                                        ; preds = %do.body267
  br label %sw.bb279

sw.bb279:                                         ; preds = %entry, %do.end278
  br label %do.body280

do.body280:                                       ; preds = %sw.bb279
  %157 = load i8*, i8** %ptr.addr, align 8
  %158 = load i32, i32* %align.addr, align 4
  %call282 = call i64 @XXH_readLE64_align(i8* %157, i32 %158)
  %call283 = call i64 @XXH64_round(i64 0, i64 %call282)
  store i64 %call283, i64* %k1281, align 8
  %159 = load i8*, i8** %ptr.addr, align 8
  %add.ptr284 = getelementptr inbounds i8, i8* %159, i64 8
  store i8* %add.ptr284, i8** %ptr.addr, align 8
  %160 = load i64, i64* %k1281, align 8
  %161 = load i64, i64* %h64.addr, align 8
  %xor285 = xor i64 %161, %160
  store i64 %xor285, i64* %h64.addr, align 8
  %162 = load i64, i64* %h64.addr, align 8
  %shl286 = shl i64 %162, 27
  %163 = load i64, i64* %h64.addr, align 8
  %shr287 = lshr i64 %163, 37
  %or288 = or i64 %shl286, %shr287
  %mul289 = mul i64 %or288, -7046029288634856825
  %add290 = add i64 %mul289, -8796714831421723037
  store i64 %add290, i64* %h64.addr, align 8
  br label %do.end291

do.end291:                                        ; preds = %do.body280
  br label %sw.bb292

sw.bb292:                                         ; preds = %entry, %do.end291
  br label %do.body293

do.body293:                                       ; preds = %sw.bb292
  %164 = load i8*, i8** %ptr.addr, align 8
  %165 = load i32, i32* %align.addr, align 4
  %call294 = call i32 @XXH_readLE32_align(i8* %164, i32 %165)
  %conv295 = zext i32 %call294 to i64
  %mul296 = mul i64 %conv295, -7046029288634856825
  %166 = load i64, i64* %h64.addr, align 8
  %xor297 = xor i64 %166, %mul296
  store i64 %xor297, i64* %h64.addr, align 8
  %167 = load i8*, i8** %ptr.addr, align 8
  %add.ptr298 = getelementptr inbounds i8, i8* %167, i64 4
  store i8* %add.ptr298, i8** %ptr.addr, align 8
  %168 = load i64, i64* %h64.addr, align 8
  %shl299 = shl i64 %168, 23
  %169 = load i64, i64* %h64.addr, align 8
  %shr300 = lshr i64 %169, 41
  %or301 = or i64 %shl299, %shr300
  %mul302 = mul i64 %or301, -4417276706812531889
  %add303 = add i64 %mul302, 1609587929392839161
  store i64 %add303, i64* %h64.addr, align 8
  br label %do.end304

do.end304:                                        ; preds = %do.body293
  br label %do.body305

do.body305:                                       ; preds = %do.end304
  %170 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr306 = getelementptr inbounds i8, i8* %170, i32 1
  store i8* %incdec.ptr306, i8** %ptr.addr, align 8
  %171 = load i8, i8* %170, align 1
  %conv307 = zext i8 %171 to i64
  %mul308 = mul i64 %conv307, 2870177450012600261
  %172 = load i64, i64* %h64.addr, align 8
  %xor309 = xor i64 %172, %mul308
  store i64 %xor309, i64* %h64.addr, align 8
  %173 = load i64, i64* %h64.addr, align 8
  %shl310 = shl i64 %173, 11
  %174 = load i64, i64* %h64.addr, align 8
  %shr311 = lshr i64 %174, 53
  %or312 = or i64 %shl310, %shr311
  %mul313 = mul i64 %or312, -7046029288634856825
  store i64 %mul313, i64* %h64.addr, align 8
  br label %do.end314

do.end314:                                        ; preds = %do.body305
  br label %do.body315

do.body315:                                       ; preds = %do.end314
  %175 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr316 = getelementptr inbounds i8, i8* %175, i32 1
  store i8* %incdec.ptr316, i8** %ptr.addr, align 8
  %176 = load i8, i8* %175, align 1
  %conv317 = zext i8 %176 to i64
  %mul318 = mul i64 %conv317, 2870177450012600261
  %177 = load i64, i64* %h64.addr, align 8
  %xor319 = xor i64 %177, %mul318
  store i64 %xor319, i64* %h64.addr, align 8
  %178 = load i64, i64* %h64.addr, align 8
  %shl320 = shl i64 %178, 11
  %179 = load i64, i64* %h64.addr, align 8
  %shr321 = lshr i64 %179, 53
  %or322 = or i64 %shl320, %shr321
  %mul323 = mul i64 %or322, -7046029288634856825
  store i64 %mul323, i64* %h64.addr, align 8
  br label %do.end324

do.end324:                                        ; preds = %do.body315
  %180 = load i64, i64* %h64.addr, align 8
  %call325 = call i64 @XXH64_avalanche(i64 %180)
  store i64 %call325, i64* %retval, align 8
  br label %return

sw.bb326:                                         ; preds = %entry
  br label %do.body327

do.body327:                                       ; preds = %sw.bb326
  %181 = load i8*, i8** %ptr.addr, align 8
  %182 = load i32, i32* %align.addr, align 4
  %call329 = call i64 @XXH_readLE64_align(i8* %181, i32 %182)
  %call330 = call i64 @XXH64_round(i64 0, i64 %call329)
  store i64 %call330, i64* %k1328, align 8
  %183 = load i8*, i8** %ptr.addr, align 8
  %add.ptr331 = getelementptr inbounds i8, i8* %183, i64 8
  store i8* %add.ptr331, i8** %ptr.addr, align 8
  %184 = load i64, i64* %k1328, align 8
  %185 = load i64, i64* %h64.addr, align 8
  %xor332 = xor i64 %185, %184
  store i64 %xor332, i64* %h64.addr, align 8
  %186 = load i64, i64* %h64.addr, align 8
  %shl333 = shl i64 %186, 27
  %187 = load i64, i64* %h64.addr, align 8
  %shr334 = lshr i64 %187, 37
  %or335 = or i64 %shl333, %shr334
  %mul336 = mul i64 %or335, -7046029288634856825
  %add337 = add i64 %mul336, -8796714831421723037
  store i64 %add337, i64* %h64.addr, align 8
  br label %do.end338

do.end338:                                        ; preds = %do.body327
  br label %sw.bb339

sw.bb339:                                         ; preds = %entry, %do.end338
  br label %do.body340

do.body340:                                       ; preds = %sw.bb339
  %188 = load i8*, i8** %ptr.addr, align 8
  %189 = load i32, i32* %align.addr, align 4
  %call342 = call i64 @XXH_readLE64_align(i8* %188, i32 %189)
  %call343 = call i64 @XXH64_round(i64 0, i64 %call342)
  store i64 %call343, i64* %k1341, align 8
  %190 = load i8*, i8** %ptr.addr, align 8
  %add.ptr344 = getelementptr inbounds i8, i8* %190, i64 8
  store i8* %add.ptr344, i8** %ptr.addr, align 8
  %191 = load i64, i64* %k1341, align 8
  %192 = load i64, i64* %h64.addr, align 8
  %xor345 = xor i64 %192, %191
  store i64 %xor345, i64* %h64.addr, align 8
  %193 = load i64, i64* %h64.addr, align 8
  %shl346 = shl i64 %193, 27
  %194 = load i64, i64* %h64.addr, align 8
  %shr347 = lshr i64 %194, 37
  %or348 = or i64 %shl346, %shr347
  %mul349 = mul i64 %or348, -7046029288634856825
  %add350 = add i64 %mul349, -8796714831421723037
  store i64 %add350, i64* %h64.addr, align 8
  br label %do.end351

do.end351:                                        ; preds = %do.body340
  br label %sw.bb352

sw.bb352:                                         ; preds = %entry, %do.end351
  br label %do.body353

do.body353:                                       ; preds = %sw.bb352
  %195 = load i8*, i8** %ptr.addr, align 8
  %196 = load i32, i32* %align.addr, align 4
  %call355 = call i64 @XXH_readLE64_align(i8* %195, i32 %196)
  %call356 = call i64 @XXH64_round(i64 0, i64 %call355)
  store i64 %call356, i64* %k1354, align 8
  %197 = load i8*, i8** %ptr.addr, align 8
  %add.ptr357 = getelementptr inbounds i8, i8* %197, i64 8
  store i8* %add.ptr357, i8** %ptr.addr, align 8
  %198 = load i64, i64* %k1354, align 8
  %199 = load i64, i64* %h64.addr, align 8
  %xor358 = xor i64 %199, %198
  store i64 %xor358, i64* %h64.addr, align 8
  %200 = load i64, i64* %h64.addr, align 8
  %shl359 = shl i64 %200, 27
  %201 = load i64, i64* %h64.addr, align 8
  %shr360 = lshr i64 %201, 37
  %or361 = or i64 %shl359, %shr360
  %mul362 = mul i64 %or361, -7046029288634856825
  %add363 = add i64 %mul362, -8796714831421723037
  store i64 %add363, i64* %h64.addr, align 8
  br label %do.end364

do.end364:                                        ; preds = %do.body353
  br label %do.body365

do.body365:                                       ; preds = %do.end364
  %202 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr366 = getelementptr inbounds i8, i8* %202, i32 1
  store i8* %incdec.ptr366, i8** %ptr.addr, align 8
  %203 = load i8, i8* %202, align 1
  %conv367 = zext i8 %203 to i64
  %mul368 = mul i64 %conv367, 2870177450012600261
  %204 = load i64, i64* %h64.addr, align 8
  %xor369 = xor i64 %204, %mul368
  store i64 %xor369, i64* %h64.addr, align 8
  %205 = load i64, i64* %h64.addr, align 8
  %shl370 = shl i64 %205, 11
  %206 = load i64, i64* %h64.addr, align 8
  %shr371 = lshr i64 %206, 53
  %or372 = or i64 %shl370, %shr371
  %mul373 = mul i64 %or372, -7046029288634856825
  store i64 %mul373, i64* %h64.addr, align 8
  br label %do.end374

do.end374:                                        ; preds = %do.body365
  br label %do.body375

do.body375:                                       ; preds = %do.end374
  %207 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr376 = getelementptr inbounds i8, i8* %207, i32 1
  store i8* %incdec.ptr376, i8** %ptr.addr, align 8
  %208 = load i8, i8* %207, align 1
  %conv377 = zext i8 %208 to i64
  %mul378 = mul i64 %conv377, 2870177450012600261
  %209 = load i64, i64* %h64.addr, align 8
  %xor379 = xor i64 %209, %mul378
  store i64 %xor379, i64* %h64.addr, align 8
  %210 = load i64, i64* %h64.addr, align 8
  %shl380 = shl i64 %210, 11
  %211 = load i64, i64* %h64.addr, align 8
  %shr381 = lshr i64 %211, 53
  %or382 = or i64 %shl380, %shr381
  %mul383 = mul i64 %or382, -7046029288634856825
  store i64 %mul383, i64* %h64.addr, align 8
  br label %do.end384

do.end384:                                        ; preds = %do.body375
  br label %do.body385

do.body385:                                       ; preds = %do.end384
  %212 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr386 = getelementptr inbounds i8, i8* %212, i32 1
  store i8* %incdec.ptr386, i8** %ptr.addr, align 8
  %213 = load i8, i8* %212, align 1
  %conv387 = zext i8 %213 to i64
  %mul388 = mul i64 %conv387, 2870177450012600261
  %214 = load i64, i64* %h64.addr, align 8
  %xor389 = xor i64 %214, %mul388
  store i64 %xor389, i64* %h64.addr, align 8
  %215 = load i64, i64* %h64.addr, align 8
  %shl390 = shl i64 %215, 11
  %216 = load i64, i64* %h64.addr, align 8
  %shr391 = lshr i64 %216, 53
  %or392 = or i64 %shl390, %shr391
  %mul393 = mul i64 %or392, -7046029288634856825
  store i64 %mul393, i64* %h64.addr, align 8
  br label %do.end394

do.end394:                                        ; preds = %do.body385
  %217 = load i64, i64* %h64.addr, align 8
  %call395 = call i64 @XXH64_avalanche(i64 %217)
  store i64 %call395, i64* %retval, align 8
  br label %return

sw.bb396:                                         ; preds = %entry
  br label %do.body397

do.body397:                                       ; preds = %sw.bb396
  %218 = load i8*, i8** %ptr.addr, align 8
  %219 = load i32, i32* %align.addr, align 4
  %call399 = call i64 @XXH_readLE64_align(i8* %218, i32 %219)
  %call400 = call i64 @XXH64_round(i64 0, i64 %call399)
  store i64 %call400, i64* %k1398, align 8
  %220 = load i8*, i8** %ptr.addr, align 8
  %add.ptr401 = getelementptr inbounds i8, i8* %220, i64 8
  store i8* %add.ptr401, i8** %ptr.addr, align 8
  %221 = load i64, i64* %k1398, align 8
  %222 = load i64, i64* %h64.addr, align 8
  %xor402 = xor i64 %222, %221
  store i64 %xor402, i64* %h64.addr, align 8
  %223 = load i64, i64* %h64.addr, align 8
  %shl403 = shl i64 %223, 27
  %224 = load i64, i64* %h64.addr, align 8
  %shr404 = lshr i64 %224, 37
  %or405 = or i64 %shl403, %shr404
  %mul406 = mul i64 %or405, -7046029288634856825
  %add407 = add i64 %mul406, -8796714831421723037
  store i64 %add407, i64* %h64.addr, align 8
  br label %do.end408

do.end408:                                        ; preds = %do.body397
  br label %sw.bb409

sw.bb409:                                         ; preds = %entry, %do.end408
  br label %do.body410

do.body410:                                       ; preds = %sw.bb409
  %225 = load i8*, i8** %ptr.addr, align 8
  %226 = load i32, i32* %align.addr, align 4
  %call412 = call i64 @XXH_readLE64_align(i8* %225, i32 %226)
  %call413 = call i64 @XXH64_round(i64 0, i64 %call412)
  store i64 %call413, i64* %k1411, align 8
  %227 = load i8*, i8** %ptr.addr, align 8
  %add.ptr414 = getelementptr inbounds i8, i8* %227, i64 8
  store i8* %add.ptr414, i8** %ptr.addr, align 8
  %228 = load i64, i64* %k1411, align 8
  %229 = load i64, i64* %h64.addr, align 8
  %xor415 = xor i64 %229, %228
  store i64 %xor415, i64* %h64.addr, align 8
  %230 = load i64, i64* %h64.addr, align 8
  %shl416 = shl i64 %230, 27
  %231 = load i64, i64* %h64.addr, align 8
  %shr417 = lshr i64 %231, 37
  %or418 = or i64 %shl416, %shr417
  %mul419 = mul i64 %or418, -7046029288634856825
  %add420 = add i64 %mul419, -8796714831421723037
  store i64 %add420, i64* %h64.addr, align 8
  br label %do.end421

do.end421:                                        ; preds = %do.body410
  br label %sw.bb422

sw.bb422:                                         ; preds = %entry, %do.end421
  br label %do.body423

do.body423:                                       ; preds = %sw.bb422
  %232 = load i8*, i8** %ptr.addr, align 8
  %233 = load i32, i32* %align.addr, align 4
  %call425 = call i64 @XXH_readLE64_align(i8* %232, i32 %233)
  %call426 = call i64 @XXH64_round(i64 0, i64 %call425)
  store i64 %call426, i64* %k1424, align 8
  %234 = load i8*, i8** %ptr.addr, align 8
  %add.ptr427 = getelementptr inbounds i8, i8* %234, i64 8
  store i8* %add.ptr427, i8** %ptr.addr, align 8
  %235 = load i64, i64* %k1424, align 8
  %236 = load i64, i64* %h64.addr, align 8
  %xor428 = xor i64 %236, %235
  store i64 %xor428, i64* %h64.addr, align 8
  %237 = load i64, i64* %h64.addr, align 8
  %shl429 = shl i64 %237, 27
  %238 = load i64, i64* %h64.addr, align 8
  %shr430 = lshr i64 %238, 37
  %or431 = or i64 %shl429, %shr430
  %mul432 = mul i64 %or431, -7046029288634856825
  %add433 = add i64 %mul432, -8796714831421723037
  store i64 %add433, i64* %h64.addr, align 8
  br label %do.end434

do.end434:                                        ; preds = %do.body423
  br label %sw.bb435

sw.bb435:                                         ; preds = %entry, %do.end434
  br label %do.body436

do.body436:                                       ; preds = %sw.bb435
  %239 = load i8*, i8** %ptr.addr, align 8
  %240 = load i32, i32* %align.addr, align 4
  %call437 = call i32 @XXH_readLE32_align(i8* %239, i32 %240)
  %conv438 = zext i32 %call437 to i64
  %mul439 = mul i64 %conv438, -7046029288634856825
  %241 = load i64, i64* %h64.addr, align 8
  %xor440 = xor i64 %241, %mul439
  store i64 %xor440, i64* %h64.addr, align 8
  %242 = load i8*, i8** %ptr.addr, align 8
  %add.ptr441 = getelementptr inbounds i8, i8* %242, i64 4
  store i8* %add.ptr441, i8** %ptr.addr, align 8
  %243 = load i64, i64* %h64.addr, align 8
  %shl442 = shl i64 %243, 23
  %244 = load i64, i64* %h64.addr, align 8
  %shr443 = lshr i64 %244, 41
  %or444 = or i64 %shl442, %shr443
  %mul445 = mul i64 %or444, -4417276706812531889
  %add446 = add i64 %mul445, 1609587929392839161
  store i64 %add446, i64* %h64.addr, align 8
  br label %do.end447

do.end447:                                        ; preds = %do.body436
  br label %sw.bb448

sw.bb448:                                         ; preds = %entry, %do.end447
  br label %do.body449

do.body449:                                       ; preds = %sw.bb448
  %245 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr450 = getelementptr inbounds i8, i8* %245, i32 1
  store i8* %incdec.ptr450, i8** %ptr.addr, align 8
  %246 = load i8, i8* %245, align 1
  %conv451 = zext i8 %246 to i64
  %mul452 = mul i64 %conv451, 2870177450012600261
  %247 = load i64, i64* %h64.addr, align 8
  %xor453 = xor i64 %247, %mul452
  store i64 %xor453, i64* %h64.addr, align 8
  %248 = load i64, i64* %h64.addr, align 8
  %shl454 = shl i64 %248, 11
  %249 = load i64, i64* %h64.addr, align 8
  %shr455 = lshr i64 %249, 53
  %or456 = or i64 %shl454, %shr455
  %mul457 = mul i64 %or456, -7046029288634856825
  store i64 %mul457, i64* %h64.addr, align 8
  br label %do.end458

do.end458:                                        ; preds = %do.body449
  br label %sw.bb459

sw.bb459:                                         ; preds = %entry, %do.end458
  br label %do.body460

do.body460:                                       ; preds = %sw.bb459
  %250 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr461 = getelementptr inbounds i8, i8* %250, i32 1
  store i8* %incdec.ptr461, i8** %ptr.addr, align 8
  %251 = load i8, i8* %250, align 1
  %conv462 = zext i8 %251 to i64
  %mul463 = mul i64 %conv462, 2870177450012600261
  %252 = load i64, i64* %h64.addr, align 8
  %xor464 = xor i64 %252, %mul463
  store i64 %xor464, i64* %h64.addr, align 8
  %253 = load i64, i64* %h64.addr, align 8
  %shl465 = shl i64 %253, 11
  %254 = load i64, i64* %h64.addr, align 8
  %shr466 = lshr i64 %254, 53
  %or467 = or i64 %shl465, %shr466
  %mul468 = mul i64 %or467, -7046029288634856825
  store i64 %mul468, i64* %h64.addr, align 8
  br label %do.end469

do.end469:                                        ; preds = %do.body460
  br label %sw.bb470

sw.bb470:                                         ; preds = %entry, %do.end469
  br label %do.body471

do.body471:                                       ; preds = %sw.bb470
  %255 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr472 = getelementptr inbounds i8, i8* %255, i32 1
  store i8* %incdec.ptr472, i8** %ptr.addr, align 8
  %256 = load i8, i8* %255, align 1
  %conv473 = zext i8 %256 to i64
  %mul474 = mul i64 %conv473, 2870177450012600261
  %257 = load i64, i64* %h64.addr, align 8
  %xor475 = xor i64 %257, %mul474
  store i64 %xor475, i64* %h64.addr, align 8
  %258 = load i64, i64* %h64.addr, align 8
  %shl476 = shl i64 %258, 11
  %259 = load i64, i64* %h64.addr, align 8
  %shr477 = lshr i64 %259, 53
  %or478 = or i64 %shl476, %shr477
  %mul479 = mul i64 %or478, -7046029288634856825
  store i64 %mul479, i64* %h64.addr, align 8
  br label %do.end480

do.end480:                                        ; preds = %do.body471
  br label %sw.bb481

sw.bb481:                                         ; preds = %entry, %do.end480
  %260 = load i64, i64* %h64.addr, align 8
  %call482 = call i64 @XXH64_avalanche(i64 %260)
  store i64 %call482, i64* %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, i64* %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb481, %do.end394, %do.end324, %do.end251, %do.end191, %do.end128, %do.end79, %do.end27
  %261 = load i64, i64* %retval, align 8
  ret i64 %261
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH64_canonicalFromHash(%struct.XXH64_canonical_t* %dst, i64 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH64_canonical_t*, align 8
  %hash.addr = alloca i64, align 8
  store %struct.XXH64_canonical_t* %dst, %struct.XXH64_canonical_t** %dst.addr, align 8
  store i64 %hash, i64* %hash.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i64, i64* %hash.addr, align 8
  %call = call i64 @XXH_swap64(i64 %0)
  store i64 %call, i64* %hash.addr, align 8
  %1 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8
  %2 = bitcast %struct.XXH64_canonical_t* %1 to i8*
  %3 = bitcast i64* %hash.addr to i8*
  %4 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8
  %5 = bitcast %struct.XXH64_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 8, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_swap64(i64 %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %shl = shl i64 %0, 56
  %and = and i64 %shl, -72057594037927936
  %1 = load i64, i64* %x.addr, align 8
  %shl1 = shl i64 %1, 40
  %and2 = and i64 %shl1, 71776119061217280
  %or = or i64 %and, %and2
  %2 = load i64, i64* %x.addr, align 8
  %shl3 = shl i64 %2, 24
  %and4 = and i64 %shl3, 280375465082880
  %or5 = or i64 %or, %and4
  %3 = load i64, i64* %x.addr, align 8
  %shl6 = shl i64 %3, 8
  %and7 = and i64 %shl6, 1095216660480
  %or8 = or i64 %or5, %and7
  %4 = load i64, i64* %x.addr, align 8
  %shr = lshr i64 %4, 8
  %and9 = and i64 %shr, 4278190080
  %or10 = or i64 %or8, %and9
  %5 = load i64, i64* %x.addr, align 8
  %shr11 = lshr i64 %5, 24
  %and12 = and i64 %shr11, 16711680
  %or13 = or i64 %or10, %and12
  %6 = load i64, i64* %x.addr, align 8
  %shr14 = lshr i64 %6, 40
  %and15 = and i64 %shr14, 65280
  %or16 = or i64 %or13, %and15
  %7 = load i64, i64* %x.addr, align 8
  %shr17 = lshr i64 %7, 56
  %and18 = and i64 %shr17, 255
  %or19 = or i64 %or16, %and18
  ret i64 %or19
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH64_hashFromCanonical(%struct.XXH64_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH64_canonical_t*, align 8
  store %struct.XXH64_canonical_t* %src, %struct.XXH64_canonical_t** %src.addr, align 8
  %0 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %src.addr, align 8
  %1 = bitcast %struct.XXH64_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_readBE64(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i64 @XXH_read64(i8* %0)
  %call1 = call i64 @XXH_swap64(i64 %call)
  ret i64 %call1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits(i8* %input, i64 %len) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_64bits_internal(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, i64 (i8*, i64, i64, i8*, i64)* %f_hashLong) #0 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hashLong.addr = alloca i64 (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  store i64 (i8*, i64, i64, i8*, i64)* %f_hashLong, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed64.addr, align 8
  %call = call i64 @XXH3_len_0to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ule i64 %5, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i64, i64* %len.addr, align 8
  %8 = load i8*, i8** %secret.addr, align 8
  %9 = load i64, i64* %secretLen.addr, align 8
  %10 = load i64, i64* %seed64.addr, align 8
  %call3 = call i64 @XXH3_len_17to128_64b(i8* %6, i64 %7, i8* %8, i64 %9, i64 %10)
  store i64 %call3, i64* %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load i64, i64* %len.addr, align 8
  %cmp5 = icmp ule i64 %11, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %12 = load i8*, i8** %input.addr, align 8
  %13 = load i64, i64* %len.addr, align 8
  %14 = load i8*, i8** %secret.addr, align 8
  %15 = load i64, i64* %secretLen.addr, align 8
  %16 = load i64, i64* %seed64.addr, align 8
  %call7 = call i64 @XXH3_len_129to240_64b(i8* %12, i64 %13, i8* %14, i64 %15, i64 %16)
  store i64 %call7, i64* %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %17 = load i64 (i8*, i64, i64, i8*, i64)*, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8
  %18 = load i8*, i8** %input.addr, align 8
  %19 = load i64, i64* %len.addr, align 8
  %20 = load i64, i64* %seed64.addr, align 8
  %21 = load i8*, i8** %secret.addr, align 8
  %22 = load i64, i64* %secretLen.addr, align 8
  %call9 = call i64 %17(i8* %18, i64 %19, i64 %20, i8* %21, i64 %22)
  store i64 %call9, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %23 = load i64, i64* %retval, align 8
  ret i64 %23
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretLen.addr, align 8
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSeed)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed(i8* %input, i64 %len, i64 %seed, i8* %secret, i64 %secretLen) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %1 = load i64, i64* %secretLen.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_hashLong_64b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.XXH3_state_s* @XXH3_createState() #0 {
entry:
  %call = call i8* @XXH_alignedMalloc(i64 576, i64 64)
  %0 = bitcast i8* %call to %struct.XXH3_state_s*
  ret %struct.XXH3_state_s* %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @XXH_alignedMalloc(i64 %s, i64 %align) #0 {
entry:
  %retval = alloca i8*, align 8
  %s.addr = alloca i64, align 8
  %align.addr = alloca i64, align 8
  %base = alloca i8*, align 8
  %offset = alloca i64, align 8
  %ptr = alloca i8*, align 8
  store i64 %s, i64* %s.addr, align 8
  store i64 %align, i64* %align.addr, align 8
  %0 = load i64, i64* %s.addr, align 8
  %1 = load i64, i64* %align.addr, align 8
  %add = add i64 %0, %1
  %call = call i8* @XXH_malloc(i64 %add)
  store i8* %call, i8** %base, align 8
  %2 = load i8*, i8** %base, align 8
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %align.addr, align 8
  %4 = load i8*, i8** %base, align 8
  %5 = ptrtoint i8* %4 to i64
  %6 = load i64, i64* %align.addr, align 8
  %sub = sub i64 %6, 1
  %and = and i64 %5, %sub
  %sub1 = sub i64 %3, %and
  store i64 %sub1, i64* %offset, align 8
  %7 = load i8*, i8** %base, align 8
  %8 = load i64, i64* %offset, align 8
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %8
  store i8* %add.ptr, i8** %ptr, align 8
  %9 = load i64, i64* %offset, align 8
  %conv = trunc i64 %9 to i8
  %10 = load i8*, i8** %ptr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %10, i64 -1
  store i8 %conv, i8* %arrayidx, align 1
  %11 = load i8*, i8** %ptr, align 8
  store i8* %11, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i8*, i8** %retval, align 8
  ret i8* %12
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_freeState(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  call void @XXH_alignedFree(i8* %1)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH_alignedFree(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %ptr = alloca i8*, align 8
  %offset = alloca i8, align 1
  %base = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  %cmp = icmp ne i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %p.addr, align 8
  store i8* %1, i8** %ptr, align 8
  %2 = load i8*, i8** %ptr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 -1
  %3 = load i8, i8* %arrayidx, align 1
  store i8 %3, i8* %offset, align 1
  %4 = load i8*, i8** %ptr, align 8
  %5 = load i8, i8* %offset, align 1
  %conv = zext i8 %5 to i32
  %idx.ext = sext i32 %conv to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.neg
  store i8* %add.ptr, i8** %base, align 8
  %6 = load i8*, i8** %base, align 8
  call void @XXH_free(i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH3_copyState(%struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s* %src_state) #0 {
entry:
  %dst_state.addr = alloca %struct.XXH3_state_s*, align 8
  %src_state.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s** %dst_state.addr, align 8
  store %struct.XXH3_state_s* %src_state, %struct.XXH3_state_s** %src_state.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %src_state.addr, align 8
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8
  %5 = bitcast %struct.XXH3_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 576, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 576, i64 %4) #10
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 0
  %arrayidx = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i64 0, i64 0
  store i64 3266489917, i64* %arrayidx, align 16
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i64 0, i64 1
  store i64 -7046029288634856825, i64* %arrayidx2, align 8
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc3, i64 0, i64 2
  store i64 -4417276706812531889, i64* %arrayidx4, align 16
  %8 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %8, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc5, i64 0, i64 3
  store i64 1609587929392839161, i64* %arrayidx6, align 8
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [8 x i64], [8 x i64]* %acc7, i64 0, i64 4
  store i64 -8796714831421723037, i64* %arrayidx8, align 16
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [8 x i64], [8 x i64]* %acc9, i64 0, i64 5
  store i64 2246822519, i64* %arrayidx10, align 8
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [8 x i64], [8 x i64]* %acc11, i64 0, i64 6
  store i64 2870177450012600261, i64* %arrayidx12, align 16
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc13 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [8 x i64], [8 x i64]* %acc13, i64 0, i64 7
  store i64 2654435761, i64* %arrayidx14, align 8
  %13 = load i64, i64* %seed.addr, align 8
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %seed15 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 9
  store i64 %13, i64* %seed15, align 8
  %15 = load i8*, i8** %secret.addr, align 8
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 11
  store i8* %15, i8** %extSecret, align 8
  %17 = load i64, i64* %secretSize.addr, align 8
  %sub = sub i64 %17, 64
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 7
  store i64 %sub, i64* %secretLimit, align 8
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %secretLimit16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 7
  %20 = load i64, i64* %secretLimit16, align 8
  %div = udiv i64 %20, 8
  %21 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %21, i32 0, i32 5
  store i64 %div, i64* %nbStripesPerBlock, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_initCustomSecret_sse2(i8* noalias %customSecret, i64 %seed64) #4 {
entry:
  %__p.addr.i = alloca float*, align 8
  %__a.addr.i4 = alloca <4 x float>, align 16
  %__a.addr.i = alloca <2 x i64>, align 16
  %__b.addr.i = alloca <2 x i64>, align 16
  %__q1.addr.i = alloca i64, align 8
  %__q0.addr.i = alloca i64, align 8
  %.compoundliteral.i = alloca <2 x i64>, align 16
  %customSecret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %seed = alloca <2 x i64>, align 16
  %i = alloca i32, align 4
  %src = alloca float*, align 64
  %dest = alloca <2 x i64>*, align 16
  store i8* %customSecret, i8** %customSecret.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 12, i32* %nbRounds, align 4
  %0 = load i64, i64* %seed64.addr, align 8
  %sub = sub nsw i64 0, %0
  %1 = load i64, i64* %seed64.addr, align 8
  store i64 %sub, i64* %__q1.addr.i, align 8
  store i64 %1, i64* %__q0.addr.i, align 8
  %2 = load i64, i64* %__q0.addr.i, align 8
  %vecinit.i = insertelement <2 x i64> undef, i64 %2, i32 0
  %3 = load i64, i64* %__q1.addr.i, align 8
  %vecinit1.i = insertelement <2 x i64> %vecinit.i, i64 %3, i32 1
  store <2 x i64> %vecinit1.i, <2 x i64>* %.compoundliteral.i, align 16
  %4 = load <2 x i64>, <2 x i64>* %.compoundliteral.i, align 16
  store <2 x i64> %4, <2 x i64>* %seed, align 16
  store float* bitcast ([192 x i8]* @XXH3_kSecret to float*), float** %src, align 64
  %5 = load i8*, i8** %customSecret.addr, align 8
  %6 = bitcast i8* %5 to <2 x i64>*
  store <2 x i64>* %6, <2 x i64>** %dest, align 16
  %7 = load <2 x i64>*, <2 x i64>** %dest, align 16
  %8 = call <2 x i64>* asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(<2 x i64>* %7) #8, !srcloc !4
  store <2 x i64>* %8, <2 x i64>** %dest, align 16
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %9 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %9, 12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %i, align 4
  %mul = mul nsw i32 %10, 4
  %idx.ext = sext i32 %mul to i64
  %add.ptr = getelementptr inbounds float, float* bitcast ([192 x i8]* @XXH3_kSecret to float*), i64 %idx.ext
  store float* %add.ptr, float** %__p.addr.i, align 8
  %11 = load float*, float** %__p.addr.i, align 8
  %12 = bitcast float* %11 to <4 x float>*
  %13 = load <4 x float>, <4 x float>* %12, align 16
  store <4 x float> %13, <4 x float>* %__a.addr.i4, align 16
  %14 = load <4 x float>, <4 x float>* %__a.addr.i4, align 16
  %15 = bitcast <4 x float> %14 to <2 x i64>
  %16 = load <2 x i64>, <2 x i64>* %seed, align 16
  store <2 x i64> %15, <2 x i64>* %__a.addr.i, align 16
  store <2 x i64> %16, <2 x i64>* %__b.addr.i, align 16
  %17 = load <2 x i64>, <2 x i64>* %__a.addr.i, align 16
  %18 = load <2 x i64>, <2 x i64>* %__b.addr.i, align 16
  %add.i = add <2 x i64> %17, %18
  %19 = load <2 x i64>*, <2 x i64>** %dest, align 16
  %20 = load i32, i32* %i, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %19, i64 %idxprom
  store <2 x i64> %add.i, <2 x i64>* %arrayidx, align 16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32, i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 0, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH3_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %bEnd = alloca i8*, align 8
  %secret = alloca i8*, align 8
  %loadSize = alloca i64, align 8
  %limit = alloca i8*, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %bEnd, align 8
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 11
  %4 = load i8*, i8** %extSecret, align 8
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 11
  %7 = load i8*, i8** %extSecret2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %7, %cond.false ]
  store i8* %cond, i8** %secret, align 8
  %8 = load i64, i64* %len.addr, align 8
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 8
  %10 = load i64, i64* %totalLen, align 16
  %add = add i64 %10, %8
  store i64 %add, i64* %totalLen, align 16
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 3
  %12 = load i32, i32* %bufferedSize, align 16
  %conv = zext i32 %12 to i64
  %13 = load i64, i64* %len.addr, align 8
  %add3 = add i64 %conv, %13
  %cmp4 = icmp ule i64 %add3, 256
  br i1 %cmp4, label %if.then6, label %if.end13

if.then6:                                         ; preds = %cond.end
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 3
  %16 = load i32, i32* %bufferedSize8, align 16
  %idx.ext = zext i32 %16 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %arraydecay7, i64 %idx.ext
  %17 = load i8*, i8** %input.addr, align 8
  %18 = load i64, i64* %len.addr, align 8
  %call = call i8* @XXH_memcpy(i8* %add.ptr9, i8* %17, i64 %18)
  %19 = load i64, i64* %len.addr, align 8
  %conv10 = trunc i64 %19 to i32
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 3
  %21 = load i32, i32* %bufferedSize11, align 16
  %add12 = add i32 %21, %conv10
  store i32 %add12, i32* %bufferedSize11, align 16
  store i32 0, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.end13
  br label %do.end

do.end:                                           ; preds = %do.body
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 3
  %23 = load i32, i32* %bufferedSize14, align 16
  %tobool = icmp ne i32 %23, 0
  br i1 %tobool, label %if.then15, label %if.end29

if.then15:                                        ; preds = %do.end
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 3
  %25 = load i32, i32* %bufferedSize16, align 16
  %sub = sub i32 256, %25
  %conv17 = zext i32 %sub to i64
  store i64 %conv17, i64* %loadSize, align 8
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer18 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer18, i32 0, i32 0
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 3
  %28 = load i32, i32* %bufferedSize20, align 16
  %idx.ext21 = zext i32 %28 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay19, i64 %idx.ext21
  %29 = load i8*, i8** %input.addr, align 8
  %30 = load i64, i64* %loadSize, align 8
  %call23 = call i8* @XXH_memcpy(i8* %add.ptr22, i8* %29, i64 %30)
  %31 = load i64, i64* %loadSize, align 8
  %32 = load i8*, i8** %input.addr, align 8
  %add.ptr24 = getelementptr inbounds i8, i8* %32, i64 %31
  store i8* %add.ptr24, i8** %input.addr, align 8
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %34 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesSoFar = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %34, i32 0, i32 6
  %35 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %35, i32 0, i32 5
  %36 = load i64, i64* %nbStripesPerBlock, align 8
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer26 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 2
  %arraydecay27 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer26, i32 0, i32 0
  %38 = load i8*, i8** %secret, align 8
  %39 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %39, i32 0, i32 7
  %40 = load i64, i64* %secretLimit, align 8
  %41 = load i32, i32* %accWidth.addr, align 4
  %42 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %43 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_consumeStripes(i64* %arraydecay25, i64* %nbStripesSoFar, i64 %36, i8* %arraydecay27, i64 4, i8* %38, i64 %40, i32 %41, void (i8*, i8*, i8*, i32)* %42, void (i8*, i8*)* %43)
  %44 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize28 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %44, i32 0, i32 3
  store i32 0, i32* %bufferedSize28, align 16
  br label %if.end29

if.end29:                                         ; preds = %if.then15, %do.end
  %45 = load i8*, i8** %input.addr, align 8
  %add.ptr30 = getelementptr inbounds i8, i8* %45, i64 256
  %46 = load i8*, i8** %bEnd, align 8
  %cmp31 = icmp ule i8* %add.ptr30, %46
  br i1 %cmp31, label %if.then33, label %if.end55

if.then33:                                        ; preds = %if.end29
  %47 = load i8*, i8** %bEnd, align 8
  %add.ptr34 = getelementptr inbounds i8, i8* %47, i64 -256
  store i8* %add.ptr34, i8** %limit, align 8
  br label %do.body35

do.body35:                                        ; preds = %do.cond, %if.then33
  %48 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %acc36 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %48, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [8 x i64], [8 x i64]* %acc36, i32 0, i32 0
  %49 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesSoFar38 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %49, i32 0, i32 6
  %50 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesPerBlock39 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %50, i32 0, i32 5
  %51 = load i64, i64* %nbStripesPerBlock39, align 8
  %52 = load i8*, i8** %input.addr, align 8
  %53 = load i8*, i8** %secret, align 8
  %54 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit40 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %54, i32 0, i32 7
  %55 = load i64, i64* %secretLimit40, align 8
  %56 = load i32, i32* %accWidth.addr, align 4
  %57 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %58 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_consumeStripes(i64* %arraydecay37, i64* %nbStripesSoFar38, i64 %51, i8* %52, i64 4, i8* %53, i64 %55, i32 %56, void (i8*, i8*, i8*, i32)* %57, void (i8*, i8*)* %58)
  %59 = load i8*, i8** %input.addr, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %59, i64 256
  store i8* %add.ptr41, i8** %input.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body35
  %60 = load i8*, i8** %input.addr, align 8
  %61 = load i8*, i8** %limit, align 8
  %cmp42 = icmp ule i8* %60, %61
  br i1 %cmp42, label %do.body35, label %do.end44

do.end44:                                         ; preds = %do.cond
  %62 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer45 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %62, i32 0, i32 2
  %arraydecay46 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer45, i32 0, i32 0
  %add.ptr47 = getelementptr inbounds i8, i8* %arraydecay46, i64 256
  %add.ptr48 = getelementptr inbounds i8, i8* %add.ptr47, i64 -64
  %63 = load i8*, i8** %input.addr, align 8
  %add.ptr49 = getelementptr inbounds i8, i8* %63, i64 -64
  %64 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer50 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %64, i32 0, i32 2
  %arraydecay51 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer50, i32 0, i32 0
  %add.ptr52 = getelementptr inbounds i8, i8* %arraydecay51, i64 256
  %add.ptr53 = getelementptr inbounds i8, i8* %add.ptr52, i64 -64
  %65 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr53, i1 false, i1 true)
  %call54 = call i8* @__memcpy_chk(i8* %add.ptr48, i8* %add.ptr49, i64 64, i64 %65) #10
  br label %if.end55

if.end55:                                         ; preds = %do.end44, %if.end29
  %66 = load i8*, i8** %input.addr, align 8
  %67 = load i8*, i8** %bEnd, align 8
  %cmp56 = icmp ult i8* %66, %67
  br i1 %cmp56, label %if.then58, label %if.end67

if.then58:                                        ; preds = %if.end55
  %68 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer59 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %68, i32 0, i32 2
  %arraydecay60 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer59, i32 0, i32 0
  %69 = load i8*, i8** %input.addr, align 8
  %70 = load i8*, i8** %bEnd, align 8
  %71 = load i8*, i8** %input.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %70 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %71 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call61 = call i8* @XXH_memcpy(i8* %arraydecay60, i8* %69, i64 %sub.ptr.sub)
  %72 = load i8*, i8** %bEnd, align 8
  %73 = load i8*, i8** %input.addr, align 8
  %sub.ptr.lhs.cast62 = ptrtoint i8* %72 to i64
  %sub.ptr.rhs.cast63 = ptrtoint i8* %73 to i64
  %sub.ptr.sub64 = sub i64 %sub.ptr.lhs.cast62, %sub.ptr.rhs.cast63
  %conv65 = trunc i64 %sub.ptr.sub64 to i32
  %74 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize66 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %74, i32 0, i32 3
  store i32 %conv65, i32* %bufferedSize66, align 16
  br label %if.end67

if.end67:                                         ; preds = %if.then58, %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end67, %if.then6, %if.then
  %75 = load i32, i32* %retval, align 4
  ret i32 %75
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_accumulate_512_sse2(i8* noalias %acc, i8* noalias %input, i8* noalias %secret, i32 %accWidth) #4 {
entry:
  %__p.addr.i28 = alloca <2 x i64>*, align 8
  %__a.addr.i26 = alloca <2 x i64>, align 16
  %__b.addr.i27 = alloca <2 x i64>, align 16
  %__a.addr.i24 = alloca <2 x i64>, align 16
  %__b.addr.i25 = alloca <2 x i64>, align 16
  %__a.addr.i21 = alloca <2 x i64>, align 16
  %__b.addr.i22 = alloca <2 x i64>, align 16
  %__a.addr.i18 = alloca <2 x i64>, align 16
  %__b.addr.i19 = alloca <2 x i64>, align 16
  %__a.addr.i15 = alloca <2 x i64>, align 16
  %__b.addr.i16 = alloca <2 x i64>, align 16
  %__a.addr.i = alloca <2 x i64>, align 16
  %__b.addr.i = alloca <2 x i64>, align 16
  %__p.addr.i = alloca <2 x i64>*, align 8
  %acc.addr = alloca i8*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %xacc = alloca <2 x i64>*, align 16
  %xinput = alloca <2 x i64>*, align 8
  %xsecret = alloca <2 x i64>*, align 8
  %i = alloca i64, align 8
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_lo = alloca <2 x i64>, align 16
  %product = alloca <2 x i64>, align 16
  %data_swap = alloca <2 x i64>, align 16
  %sum = alloca <2 x i64>, align 16
  %sum10 = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  %0 = load i8*, i8** %acc.addr, align 8
  %1 = bitcast i8* %0 to <2 x i64>*
  store <2 x i64>* %1, <2 x i64>** %xacc, align 16
  %2 = load i8*, i8** %input.addr, align 8
  %3 = bitcast i8* %2 to <2 x i64>*
  store <2 x i64>* %3, <2 x i64>** %xinput, align 8
  %4 = load i8*, i8** %secret.addr, align 8
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64>* %5, <2 x i64>** %xsecret, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i64, i64* %i, align 8
  %cmp = icmp ult i64 %6, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load <2 x i64>*, <2 x i64>** %xinput, align 8
  %8 = load i64, i64* %i, align 8
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %7, i64 %8
  store <2 x i64>* %add.ptr, <2 x i64>** %__p.addr.i, align 8
  %9 = load <2 x i64>*, <2 x i64>** %__p.addr.i, align 8
  %10 = bitcast <2 x i64>* %9 to %struct.__loadu_si128*
  %__v.i = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %10, i32 0, i32 0
  %11 = load <2 x i64>, <2 x i64>* %__v.i, align 1
  store <2 x i64> %11, <2 x i64>* %data_vec, align 16
  %12 = load <2 x i64>*, <2 x i64>** %xsecret, align 8
  %13 = load i64, i64* %i, align 8
  %add.ptr1 = getelementptr inbounds <2 x i64>, <2 x i64>* %12, i64 %13
  store <2 x i64>* %add.ptr1, <2 x i64>** %__p.addr.i28, align 8
  %14 = load <2 x i64>*, <2 x i64>** %__p.addr.i28, align 8
  %15 = bitcast <2 x i64>* %14 to %struct.__loadu_si128*
  %__v.i29 = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %15, i32 0, i32 0
  %16 = load <2 x i64>, <2 x i64>* %__v.i29, align 1
  store <2 x i64> %16, <2 x i64>* %key_vec, align 16
  %17 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  %18 = load <2 x i64>, <2 x i64>* %key_vec, align 16
  store <2 x i64> %17, <2 x i64>* %__a.addr.i26, align 16
  store <2 x i64> %18, <2 x i64>* %__b.addr.i27, align 16
  %19 = load <2 x i64>, <2 x i64>* %__a.addr.i26, align 16
  %20 = load <2 x i64>, <2 x i64>* %__b.addr.i27, align 16
  %xor.i = xor <2 x i64> %19, %20
  store <2 x i64> %xor.i, <2 x i64>* %data_key, align 16
  %21 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %22 = bitcast <2 x i64> %21 to <4 x i32>
  %permil = shufflevector <4 x i32> %22, <4 x i32> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %23 = bitcast <4 x i32> %permil to <2 x i64>
  store <2 x i64> %23, <2 x i64>* %data_key_lo, align 16
  %24 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %25 = load <2 x i64>, <2 x i64>* %data_key_lo, align 16
  store <2 x i64> %24, <2 x i64>* %__a.addr.i24, align 16
  store <2 x i64> %25, <2 x i64>* %__b.addr.i25, align 16
  %26 = load <2 x i64>, <2 x i64>* %__a.addr.i24, align 16
  %27 = bitcast <2 x i64> %26 to <4 x i32>
  %28 = load <2 x i64>, <2 x i64>* %__b.addr.i25, align 16
  %29 = bitcast <2 x i64> %28 to <4 x i32>
  %30 = and <2 x i64> %26, <i64 4294967295, i64 4294967295>
  %31 = and <2 x i64> %28, <i64 4294967295, i64 4294967295>
  %32 = mul <2 x i64> %30, %31
  store <2 x i64> %32, <2 x i64>* %product, align 16
  %33 = load i32, i32* %accWidth.addr, align 4
  %cmp5 = icmp eq i32 %33, 1
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %34 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  %35 = bitcast <2 x i64> %34 to <4 x i32>
  %permil6 = shufflevector <4 x i32> %35, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %36 = bitcast <4 x i32> %permil6 to <2 x i64>
  store <2 x i64> %36, <2 x i64>* %data_swap, align 16
  %37 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %38 = load i64, i64* %i, align 8
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %37, i64 %38
  %39 = load <2 x i64>, <2 x i64>* %arrayidx, align 16
  %40 = load <2 x i64>, <2 x i64>* %data_swap, align 16
  store <2 x i64> %39, <2 x i64>* %__a.addr.i21, align 16
  store <2 x i64> %40, <2 x i64>* %__b.addr.i22, align 16
  %41 = load <2 x i64>, <2 x i64>* %__a.addr.i21, align 16
  %42 = load <2 x i64>, <2 x i64>* %__b.addr.i22, align 16
  %add.i23 = add <2 x i64> %41, %42
  store <2 x i64> %add.i23, <2 x i64>* %sum, align 16
  %43 = load <2 x i64>, <2 x i64>* %product, align 16
  %44 = load <2 x i64>, <2 x i64>* %sum, align 16
  store <2 x i64> %43, <2 x i64>* %__a.addr.i18, align 16
  store <2 x i64> %44, <2 x i64>* %__b.addr.i19, align 16
  %45 = load <2 x i64>, <2 x i64>* %__a.addr.i18, align 16
  %46 = load <2 x i64>, <2 x i64>* %__b.addr.i19, align 16
  %add.i20 = add <2 x i64> %45, %46
  %47 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %48 = load i64, i64* %i, align 8
  %arrayidx9 = getelementptr inbounds <2 x i64>, <2 x i64>* %47, i64 %48
  store <2 x i64> %add.i20, <2 x i64>* %arrayidx9, align 16
  br label %if.end

if.else:                                          ; preds = %for.body
  %49 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %50 = load i64, i64* %i, align 8
  %arrayidx11 = getelementptr inbounds <2 x i64>, <2 x i64>* %49, i64 %50
  %51 = load <2 x i64>, <2 x i64>* %arrayidx11, align 16
  %52 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  store <2 x i64> %51, <2 x i64>* %__a.addr.i15, align 16
  store <2 x i64> %52, <2 x i64>* %__b.addr.i16, align 16
  %53 = load <2 x i64>, <2 x i64>* %__a.addr.i15, align 16
  %54 = load <2 x i64>, <2 x i64>* %__b.addr.i16, align 16
  %add.i17 = add <2 x i64> %53, %54
  store <2 x i64> %add.i17, <2 x i64>* %sum10, align 16
  %55 = load <2 x i64>, <2 x i64>* %product, align 16
  %56 = load <2 x i64>, <2 x i64>* %sum10, align 16
  store <2 x i64> %55, <2 x i64>* %__a.addr.i, align 16
  store <2 x i64> %56, <2 x i64>* %__b.addr.i, align 16
  %57 = load <2 x i64>, <2 x i64>* %__a.addr.i, align 16
  %58 = load <2 x i64>, <2 x i64>* %__b.addr.i, align 16
  %add.i = add <2 x i64> %57, %58
  %59 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %60 = load i64, i64* %i, align 8
  %arrayidx14 = getelementptr inbounds <2 x i64>, <2 x i64>* %59, i64 %60
  store <2 x i64> %add.i, <2 x i64>* %arrayidx14, align 16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %61 = load i64, i64* %i, align 8
  %inc = add i64 %61, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_scrambleAcc_sse2(i8* noalias %acc, i8* noalias %secret) #4 {
entry:
  %__a.addr.i20 = alloca <2 x i64>, align 16
  %__count.addr.i21 = alloca i32, align 4
  %__a.addr.i17 = alloca <2 x i64>, align 16
  %__b.addr.i18 = alloca <2 x i64>, align 16
  %__p.addr.i = alloca <2 x i64>*, align 8
  %__a.addr.i15 = alloca <2 x i64>, align 16
  %__b.addr.i16 = alloca <2 x i64>, align 16
  %__a.addr.i13 = alloca <2 x i64>, align 16
  %__b.addr.i14 = alloca <2 x i64>, align 16
  %__a.addr.i11 = alloca <2 x i64>, align 16
  %__b.addr.i12 = alloca <2 x i64>, align 16
  %__a.addr.i10 = alloca <2 x i64>, align 16
  %__count.addr.i = alloca i32, align 4
  %__a.addr.i = alloca <2 x i64>, align 16
  %__b.addr.i = alloca <2 x i64>, align 16
  %__i3.addr.i.i = alloca i32, align 4
  %__i2.addr.i.i = alloca i32, align 4
  %__i1.addr.i.i = alloca i32, align 4
  %__i0.addr.i.i = alloca i32, align 4
  %.compoundliteral.i.i = alloca <4 x i32>, align 16
  %__i.addr.i = alloca i32, align 4
  %acc.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %xacc = alloca <2 x i64>*, align 16
  %xsecret = alloca <2 x i64>*, align 8
  %prime32 = alloca <2 x i64>, align 16
  %i = alloca i64, align 8
  %acc_vec = alloca <2 x i64>, align 16
  %shifted = alloca <2 x i64>, align 16
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_hi = alloca <2 x i64>, align 16
  %prod_lo = alloca <2 x i64>, align 16
  %prod_hi = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  %0 = load i8*, i8** %acc.addr, align 8
  %1 = bitcast i8* %0 to <2 x i64>*
  store <2 x i64>* %1, <2 x i64>** %xacc, align 16
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = bitcast i8* %2 to <2 x i64>*
  store <2 x i64>* %3, <2 x i64>** %xsecret, align 8
  store i32 -1640531535, i32* %__i.addr.i, align 4
  %4 = load i32, i32* %__i.addr.i, align 4
  %5 = load i32, i32* %__i.addr.i, align 4
  %6 = load i32, i32* %__i.addr.i, align 4
  %7 = load i32, i32* %__i.addr.i, align 4
  store i32 %4, i32* %__i3.addr.i.i, align 4
  store i32 %5, i32* %__i2.addr.i.i, align 4
  store i32 %6, i32* %__i1.addr.i.i, align 4
  store i32 %7, i32* %__i0.addr.i.i, align 4
  %8 = load i32, i32* %__i0.addr.i.i, align 4
  %vecinit.i.i = insertelement <4 x i32> undef, i32 %8, i32 0
  %9 = load i32, i32* %__i1.addr.i.i, align 4
  %vecinit1.i.i = insertelement <4 x i32> %vecinit.i.i, i32 %9, i32 1
  %10 = load i32, i32* %__i2.addr.i.i, align 4
  %vecinit2.i.i = insertelement <4 x i32> %vecinit1.i.i, i32 %10, i32 2
  %11 = load i32, i32* %__i3.addr.i.i, align 4
  %vecinit3.i.i = insertelement <4 x i32> %vecinit2.i.i, i32 %11, i32 3
  store <4 x i32> %vecinit3.i.i, <4 x i32>* %.compoundliteral.i.i, align 16
  %12 = load <4 x i32>, <4 x i32>* %.compoundliteral.i.i, align 16
  %13 = bitcast <4 x i32> %12 to <2 x i64>
  store <2 x i64> %13, <2 x i64>* %prime32, align 16
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %14 = load i64, i64* %i, align 8
  %cmp = icmp ult i64 %14, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %16 = load i64, i64* %i, align 8
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %15, i64 %16
  %17 = load <2 x i64>, <2 x i64>* %arrayidx, align 16
  store <2 x i64> %17, <2 x i64>* %acc_vec, align 16
  %18 = load <2 x i64>, <2 x i64>* %acc_vec, align 16
  store <2 x i64> %18, <2 x i64>* %__a.addr.i20, align 16
  store i32 47, i32* %__count.addr.i21, align 4
  %19 = load <2 x i64>, <2 x i64>* %__a.addr.i20, align 16
  %20 = load i32, i32* %__count.addr.i21, align 4
  %21 = call <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64> %19, i32 %20) #10
  store <2 x i64> %21, <2 x i64>* %shifted, align 16
  %22 = load <2 x i64>, <2 x i64>* %acc_vec, align 16
  %23 = load <2 x i64>, <2 x i64>* %shifted, align 16
  store <2 x i64> %22, <2 x i64>* %__a.addr.i17, align 16
  store <2 x i64> %23, <2 x i64>* %__b.addr.i18, align 16
  %24 = load <2 x i64>, <2 x i64>* %__a.addr.i17, align 16
  %25 = load <2 x i64>, <2 x i64>* %__b.addr.i18, align 16
  %xor.i19 = xor <2 x i64> %24, %25
  store <2 x i64> %xor.i19, <2 x i64>* %data_vec, align 16
  %26 = load <2 x i64>*, <2 x i64>** %xsecret, align 8
  %27 = load i64, i64* %i, align 8
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %26, i64 %27
  store <2 x i64>* %add.ptr, <2 x i64>** %__p.addr.i, align 8
  %28 = load <2 x i64>*, <2 x i64>** %__p.addr.i, align 8
  %29 = bitcast <2 x i64>* %28 to %struct.__loadu_si128*
  %__v.i = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %29, i32 0, i32 0
  %30 = load <2 x i64>, <2 x i64>* %__v.i, align 1
  store <2 x i64> %30, <2 x i64>* %key_vec, align 16
  %31 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  %32 = load <2 x i64>, <2 x i64>* %key_vec, align 16
  store <2 x i64> %31, <2 x i64>* %__a.addr.i15, align 16
  store <2 x i64> %32, <2 x i64>* %__b.addr.i16, align 16
  %33 = load <2 x i64>, <2 x i64>* %__a.addr.i15, align 16
  %34 = load <2 x i64>, <2 x i64>* %__b.addr.i16, align 16
  %xor.i = xor <2 x i64> %33, %34
  store <2 x i64> %xor.i, <2 x i64>* %data_key, align 16
  %35 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %36 = bitcast <2 x i64> %35 to <4 x i32>
  %permil = shufflevector <4 x i32> %36, <4 x i32> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %37 = bitcast <4 x i32> %permil to <2 x i64>
  store <2 x i64> %37, <2 x i64>* %data_key_hi, align 16
  %38 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %39 = load <2 x i64>, <2 x i64>* %prime32, align 16
  store <2 x i64> %38, <2 x i64>* %__a.addr.i13, align 16
  store <2 x i64> %39, <2 x i64>* %__b.addr.i14, align 16
  %40 = load <2 x i64>, <2 x i64>* %__a.addr.i13, align 16
  %41 = bitcast <2 x i64> %40 to <4 x i32>
  %42 = load <2 x i64>, <2 x i64>* %__b.addr.i14, align 16
  %43 = bitcast <2 x i64> %42 to <4 x i32>
  %44 = and <2 x i64> %40, <i64 4294967295, i64 4294967295>
  %45 = and <2 x i64> %42, <i64 4294967295, i64 4294967295>
  %46 = mul <2 x i64> %44, %45
  store <2 x i64> %46, <2 x i64>* %prod_lo, align 16
  %47 = load <2 x i64>, <2 x i64>* %data_key_hi, align 16
  %48 = load <2 x i64>, <2 x i64>* %prime32, align 16
  store <2 x i64> %47, <2 x i64>* %__a.addr.i11, align 16
  store <2 x i64> %48, <2 x i64>* %__b.addr.i12, align 16
  %49 = load <2 x i64>, <2 x i64>* %__a.addr.i11, align 16
  %50 = bitcast <2 x i64> %49 to <4 x i32>
  %51 = load <2 x i64>, <2 x i64>* %__b.addr.i12, align 16
  %52 = bitcast <2 x i64> %51 to <4 x i32>
  %53 = and <2 x i64> %49, <i64 4294967295, i64 4294967295>
  %54 = and <2 x i64> %51, <i64 4294967295, i64 4294967295>
  %55 = mul <2 x i64> %53, %54
  store <2 x i64> %55, <2 x i64>* %prod_hi, align 16
  %56 = load <2 x i64>, <2 x i64>* %prod_lo, align 16
  %57 = load <2 x i64>, <2 x i64>* %prod_hi, align 16
  store <2 x i64> %57, <2 x i64>* %__a.addr.i10, align 16
  store i32 32, i32* %__count.addr.i, align 4
  %58 = load <2 x i64>, <2 x i64>* %__a.addr.i10, align 16
  %59 = load i32, i32* %__count.addr.i, align 4
  %60 = call <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64> %58, i32 %59) #10
  store <2 x i64> %56, <2 x i64>* %__a.addr.i, align 16
  store <2 x i64> %60, <2 x i64>* %__b.addr.i, align 16
  %61 = load <2 x i64>, <2 x i64>* %__a.addr.i, align 16
  %62 = load <2 x i64>, <2 x i64>* %__b.addr.i, align 16
  %add.i = add <2 x i64> %61, %62
  %63 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %64 = load i64, i64* %i, align 8
  %arrayidx9 = getelementptr inbounds <2 x i64>, <2 x i64>* %63, i64 %64
  store <2 x i64> %add.i, <2 x i64>* %arrayidx9, align 16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %65 = load i64, i64* %i, align 8
  %inc = add i64 %65, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca i64, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %0, i32 0, i32 11
  %1 = load i8*, i8** %extSecret, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 11
  %4 = load i8*, i8** %extSecret1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %4, %cond.false ]
  store i8* %cond, i8** %secret, align 8
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 8
  %6 = load i64, i64* %totalLen, align 16
  %cmp2 = icmp ugt i64 %6, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %8 = load i8*, i8** %secret, align 8
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %7, i8* %8, i32 0)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret, align 8
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 11
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 8
  %11 = load i64, i64* %totalLen5, align 16
  %mul = mul i64 %11, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 9
  %13 = load i64, i64* %seed, align 8
  %tobool = icmp ne i64 %13, 0
  br i1 %tobool, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 8
  %16 = load i64, i64* %totalLen8, align 16
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 9
  %18 = load i64, i64* %seed9, align 8
  %call10 = call i64 @XXH3_64bits_withSeed(i8* %arraydecay7, i64 %16, i64 %18)
  store i64 %call10, i64* %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer12 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 2
  %arraydecay13 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer12, i32 0, i32 0
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 8
  %21 = load i64, i64* %totalLen14, align 16
  %22 = load i8*, i8** %secret, align 8
  %23 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %23, i32 0, i32 7
  %24 = load i64, i64* %secretLimit, align 8
  %add = add i64 %24, 64
  %call15 = call i64 @XXH3_64bits_withSecret(i8* %arraydecay13, i64 %21, i8* %22, i64 %add)
  store i64 %call15, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then6, %if.then
  %25 = load i64, i64* %retval, align 8
  ret i64 %25
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_digest_long(i64* %acc, %struct.XXH3_state_s* %state, i8* %secret, i32 %accWidth) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %nbStripes = alloca i64, align 8
  %nbStripesSoFar = alloca i64, align 8
  %lastStripe = alloca [64 x i8], align 16
  %catchupSize = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  %0 = load i64*, i64** %acc.addr, align 8
  %1 = bitcast i64* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i32 0, i32 0
  %3 = bitcast i64* %arraydecay to i8*
  %4 = load i64*, i64** %acc.addr, align 8
  %5 = bitcast i64* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 64, i64 %6) #10
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 3
  %8 = load i32, i32* %bufferedSize, align 16
  %cmp = icmp uge i32 %8, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 3
  %10 = load i32, i32* %bufferedSize2, align 16
  %div = udiv i32 %10, 64
  %conv = zext i32 %div to i64
  store i64 %conv, i64* %nbStripes, align 8
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesSoFar3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 6
  %12 = load i64, i64* %nbStripesSoFar3, align 16
  store i64 %12, i64* %nbStripesSoFar, align 8
  %13 = load i64*, i64** %acc.addr, align 8
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 5
  %15 = load i64, i64* %nbStripesPerBlock, align 8
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %17 = load i64, i64* %nbStripes, align 8
  %18 = load i8*, i8** %secret.addr, align 8
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 7
  %20 = load i64, i64* %secretLimit, align 8
  %21 = load i32, i32* %accWidth.addr, align 4
  call void @XXH3_consumeStripes(i64* %13, i64* %nbStripesSoFar, i64 %15, i8* %arraydecay4, i64 %17, i8* %18, i64 %20, i32 %21, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 3
  %23 = load i32, i32* %bufferedSize5, align 16
  %rem = urem i32 %23, 64
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %24 = load i64*, i64** %acc.addr, align 8
  %25 = bitcast i64* %24 to i8*
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer7, i32 0, i32 0
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 3
  %28 = load i32, i32* %bufferedSize9, align 16
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay8, i64 %idx.ext
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr, i64 -64
  %29 = load i8*, i8** %secret.addr, align 8
  %30 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %30, i32 0, i32 7
  %31 = load i64, i64* %secretLimit11, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %29, i64 %31
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -7
  %32 = load i32, i32* %accWidth.addr, align 4
  call void @XXH3_accumulate_512_sse2(i8* %25, i8* %add.ptr10, i8* %add.ptr13, i32 %32)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  br label %if.end39

if.else:                                          ; preds = %entry
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 3
  %34 = load i32, i32* %bufferedSize14, align 16
  %tobool15 = icmp ne i32 %34, 0
  br i1 %tobool15, label %if.then16, label %if.end38

if.then16:                                        ; preds = %if.else
  %35 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %35, i32 0, i32 3
  %36 = load i32, i32* %bufferedSize17, align 16
  %sub = sub i32 64, %36
  %conv18 = zext i32 %sub to i64
  store i64 %conv18, i64* %catchupSize, align 8
  %arraydecay19 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay21, i64 256
  %38 = load i64, i64* %catchupSize, align 8
  %idx.neg = sub i64 0, %38
  %add.ptr23 = getelementptr inbounds i8, i8* %add.ptr22, i64 %idx.neg
  %39 = load i64, i64* %catchupSize, align 8
  %call24 = call i8* @__memcpy_chk(i8* %arraydecay19, i8* %add.ptr23, i64 %39, i64 64) #10
  %arraydecay25 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %40 = load i64, i64* %catchupSize, align 8
  %add.ptr26 = getelementptr inbounds i8, i8* %arraydecay25, i64 %40
  %41 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer27 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %41, i32 0, i32 2
  %arraydecay28 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer27, i32 0, i32 0
  %42 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize29 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %42, i32 0, i32 3
  %43 = load i32, i32* %bufferedSize29, align 16
  %conv30 = zext i32 %43 to i64
  %arraydecay31 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %44 = load i64, i64* %catchupSize, align 8
  %add.ptr32 = getelementptr inbounds i8, i8* %arraydecay31, i64 %44
  %45 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr32, i1 false, i1 true)
  %call33 = call i8* @__memcpy_chk(i8* %add.ptr26, i8* %arraydecay28, i64 %conv30, i64 %45) #10
  %46 = load i64*, i64** %acc.addr, align 8
  %47 = bitcast i64* %46 to i8*
  %arraydecay34 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %48 = load i8*, i8** %secret.addr, align 8
  %49 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit35 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %49, i32 0, i32 7
  %50 = load i64, i64* %secretLimit35, align 8
  %add.ptr36 = getelementptr inbounds i8, i8* %48, i64 %50
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr36, i64 -7
  %51 = load i32, i32* %accWidth.addr, align 4
  call void @XXH3_accumulate_512_sse2(i8* %47, i8* %arraydecay34, i8* %add.ptr37, i32 %51)
  br label %if.end38

if.end38:                                         ; preds = %if.then16, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mergeAccs(i64* noalias %acc, i8* noalias %secret, i64 %start) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  %start.addr = alloca i64, align 8
  %result64 = alloca i64, align 8
  %i = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  %0 = load i64, i64* %start.addr, align 8
  store i64 %0, i64* %result64, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %i, align 8
  %cmp = icmp ult i64 %1, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64*, i64** %acc.addr, align 8
  %3 = load i64, i64* %i, align 8
  %mul = mul i64 2, %3
  %add.ptr = getelementptr inbounds i64, i64* %2, i64 %mul
  %4 = load i8*, i8** %secret.addr, align 8
  %5 = load i64, i64* %i, align 8
  %mul1 = mul i64 16, %5
  %add.ptr2 = getelementptr inbounds i8, i8* %4, i64 %mul1
  %call = call i64 @XXH3_mix2Accs(i64* %add.ptr, i8* %add.ptr2)
  %6 = load i64, i64* %result64, align 8
  %add = add i64 %6, %call
  store i64 %add, i64* %result64, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, i64* %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i64, i64* %result64, align 8
  %call3 = call i64 @XXH3_avalanche(i64 %8)
  ret i64 %call3
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH3_generateSecret(i8* %secretBuffer, i8* %customSeed, i64 %customSeedSize) #0 {
entry:
  %secretBuffer.addr = alloca i8*, align 8
  %customSeed.addr = alloca i8*, align 8
  %customSeedSize.addr = alloca i64, align 8
  %segmentSize = alloca i64, align 8
  %nbSegments = alloca i64, align 8
  %scrambler = alloca %struct.XXH128_canonical_t, align 1
  %seeds = alloca [12 x i64], align 16
  %segnb = alloca i64, align 8
  %agg.tmp = alloca %struct.XXH128_hash_t, align 8
  %toFill = alloca i64, align 8
  %filled = alloca i64, align 8
  %segmentStart = alloca i64, align 8
  %segment = alloca %struct.XXH128_canonical_t, align 1
  %agg.tmp18 = alloca %struct.XXH128_hash_t, align 8
  store i8* %secretBuffer, i8** %secretBuffer.addr, align 8
  store i8* %customSeed, i8** %customSeed.addr, align 8
  store i64 %customSeedSize, i64* %customSeedSize.addr, align 8
  %0 = load i64, i64* %customSeedSize.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %secretBuffer.addr, align 8
  %2 = load i8*, i8** %secretBuffer.addr, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 %3) #10
  br label %for.end

if.end:                                           ; preds = %entry
  store i64 16, i64* %segmentSize, align 8
  store i64 12, i64* %nbSegments, align 8
  %4 = load i8*, i8** %customSeed.addr, align 8
  %5 = load i64, i64* %customSeedSize.addr, align 8
  %call1 = call { i64, i64 } @XXH128(i8* %4, i64 %5, i64 0)
  %6 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call1, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call1, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %scrambler, i64 %13, i64 %15)
  %16 = load i64, i64* %customSeedSize.addr, align 8
  %cmp2 = icmp ugt i64 %16, 96
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %17 = load i64, i64* %customSeedSize.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 96, %cond.true ], [ %17, %cond.false ]
  store i64 %cond, i64* %toFill, align 8
  %18 = load i64, i64* %toFill, align 8
  store i64 %18, i64* %filled, align 8
  %arraydecay = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %19 = bitcast i64* %arraydecay to i8*
  %20 = load i8*, i8** %customSeed.addr, align 8
  %21 = load i64, i64* %toFill, align 8
  %call3 = call i8* @__memcpy_chk(i8* %19, i8* %20, i64 %21, i64 96) #10
  br label %while.cond

while.cond:                                       ; preds = %cond.end9, %cond.end
  %22 = load i64, i64* %filled, align 8
  %cmp4 = icmp ult i64 %22, 96
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %23 = load i64, i64* %filled, align 8
  %24 = load i64, i64* %filled, align 8
  %sub = sub i64 96, %24
  %cmp5 = icmp ugt i64 %23, %sub
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %while.body
  %25 = load i64, i64* %filled, align 8
  %sub7 = sub i64 96, %25
  br label %cond.end9

cond.false8:                                      ; preds = %while.body
  %26 = load i64, i64* %filled, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true6
  %cond10 = phi i64 [ %sub7, %cond.true6 ], [ %26, %cond.false8 ]
  store i64 %cond10, i64* %toFill, align 8
  %arraydecay11 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %27 = bitcast i64* %arraydecay11 to i8*
  %28 = load i64, i64* %filled, align 8
  %add.ptr = getelementptr inbounds i8, i8* %27, i64 %28
  %arraydecay12 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %29 = bitcast i64* %arraydecay12 to i8*
  %30 = load i64, i64* %toFill, align 8
  %arraydecay13 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %31 = bitcast i64* %arraydecay13 to i8*
  %32 = load i64, i64* %filled, align 8
  %add.ptr14 = getelementptr inbounds i8, i8* %31, i64 %32
  %33 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr14, i1 false, i1 true)
  %call15 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %29, i64 %30, i64 %33) #10
  %34 = load i64, i64* %toFill, align 8
  %35 = load i64, i64* %filled, align 8
  %add = add i64 %35, %34
  store i64 %add, i64* %filled, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i8*, i8** %secretBuffer.addr, align 8
  %37 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %38 = load i8*, i8** %secretBuffer.addr, align 8
  %39 = call i64 @llvm.objectsize.i64.p0i8(i8* %38, i1 false, i1 true)
  %call16 = call i8* @__memcpy_chk(i8* %36, i8* %37, i64 16, i64 %39) #10
  store i64 1, i64* %segnb, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %40 = load i64, i64* %segnb, align 8
  %cmp17 = icmp ult i64 %40, 12
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %41 = load i64, i64* %segnb, align 8
  %mul = mul i64 %41, 16
  store i64 %mul, i64* %segmentStart, align 8
  %42 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %arraydecay19 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %43 = load i64, i64* %segnb, align 8
  %add.ptr20 = getelementptr inbounds i64, i64* %arraydecay19, i64 %43
  %44 = bitcast i64* %add.ptr20 to i8*
  %call21 = call i64 @XXH_readLE64(i8* %44)
  %45 = load i64, i64* %segnb, align 8
  %add22 = add i64 %call21, %45
  %call23 = call { i64, i64 } @XXH128(i8* %42, i64 16, i64 %add22)
  %46 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = extractvalue { i64, i64 } %call23, 0
  store i64 %48, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = extractvalue { i64, i64 } %call23, 1
  store i64 %50, i64* %49, align 8
  %51 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %segment, i64 %53, i64 %55)
  %56 = load i8*, i8** %secretBuffer.addr, align 8
  %57 = load i64, i64* %segmentStart, align 8
  %add.ptr24 = getelementptr inbounds i8, i8* %56, i64 %57
  %58 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  %59 = load i8*, i8** %secretBuffer.addr, align 8
  %60 = load i64, i64* %segmentStart, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %59, i64 %60
  %61 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr25, i1 false, i1 true)
  %call26 = call i8* @__memcpy_chk(i8* %add.ptr24, i8* %58, i64 16, i64 %61) #10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %62 = load i64, i64* %segnb, align 8
  %inc = add i64 %62, 1
  store i64 %inc, i64* %segnb, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %dst, i64 %hash.coerce0, i64 %hash.coerce1) #0 {
entry:
  %hash = alloca %struct.XXH128_hash_t, align 8
  %dst.addr = alloca %struct.XXH128_canonical_t*, align 8
  %0 = bitcast %struct.XXH128_hash_t* %hash to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %hash.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %hash.coerce1, i64* %2, align 8
  store %struct.XXH128_canonical_t* %dst, %struct.XXH128_canonical_t** %dst.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %3 = load i64, i64* %high64, align 8
  %call = call i64 @XXH_swap64(i64 %3)
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  store i64 %call, i64* %high641, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %4 = load i64, i64* %low64, align 8
  %call2 = call i64 @XXH_swap64(i64 %4)
  %low643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  store i64 %call2, i64* %low643, align 8
  %5 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %6 = bitcast %struct.XXH128_canonical_t* %5 to i8*
  %high644 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %7 = bitcast i64* %high644 to i8*
  %8 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %9 = bitcast %struct.XXH128_canonical_t* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call5 = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 8, i64 %10) #10
  %11 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %12 = bitcast %struct.XXH128_canonical_t* %11 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 8
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %13 = bitcast i64* %low646 to i8*
  %14 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %15 = bitcast %struct.XXH128_canonical_t* %14 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %15, i64 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr7, i1 false, i1 true)
  %call8 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %13, i64 8, i64 %16) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH128(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_withSeed(i8* %0, i64 %1, i64 %2)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits(i8* %input, i64 %len) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSecret)
  %2 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_128bits_internal(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hl128.addr = alloca { i64, i64 } (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  store { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed64.addr, align 8
  %call = call { i64, i64 } @XXH3_len_0to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ule i64 %10, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8
  %12 = load i64, i64* %len.addr, align 8
  %13 = load i8*, i8** %secret.addr, align 8
  %14 = load i64, i64* %secretLen.addr, align 8
  %15 = load i64, i64* %seed64.addr, align 8
  %call3 = call { i64, i64 } @XXH3_len_17to128_128b(i8* %11, i64 %12, i8* %13, i64 %14, i64 %15)
  %16 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call3, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call3, 1
  store i64 %20, i64* %19, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %21 = load i64, i64* %len.addr, align 8
  %cmp5 = icmp ule i64 %21, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %22 = load i8*, i8** %input.addr, align 8
  %23 = load i64, i64* %len.addr, align 8
  %24 = load i8*, i8** %secret.addr, align 8
  %25 = load i64, i64* %secretLen.addr, align 8
  %26 = load i64, i64* %seed64.addr, align 8
  %call7 = call { i64, i64 } @XXH3_len_129to240_128b(i8* %22, i64 %23, i8* %24, i64 %25, i64 %26)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call7, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call7, 1
  store i64 %31, i64* %30, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %32 = load { i64, i64 } (i8*, i64, i64, i8*, i64)*, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8
  %33 = load i8*, i8** %input.addr, align 8
  %34 = load i64, i64* %len.addr, align 8
  %35 = load i64, i64* %seed64.addr, align 8
  %36 = load i8*, i8** %secret.addr, align 8
  %37 = load i64, i64* %secretLen.addr, align 8
  %call9 = call { i64, i64 } %32(i8* %33, i64 %34, i64 %35, i8* %36, i64 %37)
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = extractvalue { i64, i64 } %call9, 0
  store i64 %40, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = extractvalue { i64, i64 } %call9, 1
  store i64 %42, i64* %41, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %43 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %44 = load { i64, i64 }, { i64, i64 }* %43, align 8
  ret { i64, i64 } %44
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretLen.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_defaultSecret)
  %4 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = extractvalue { i64, i64 } %call, 0
  store i64 %6, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = extractvalue { i64, i64 } %call, 1
  store i64 %8, i64* %7, align 8
  %9 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_defaultSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %1 = load i8*, i8** %secret.addr, align 8
  %2 = load i64, i64* %secretLen.addr, align 8
  %3 = load i8*, i8** %input.addr, align 8
  %4 = load i64, i64* %len.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %3, i64 %4, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSeed)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %1 = load i64, i64* %secretLen.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %4 = load i64, i64* %seed64.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %1 = load i64, i64* %seed.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %0, i64 %1, i8* %2, i64 %3)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 1, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %0, i32 0, i32 11
  %1 = load i8*, i8** %extSecret, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 11
  %4 = load i8*, i8** %extSecret1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %4, %cond.false ]
  store i8* %cond, i8** %secret, align 8
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 8
  %6 = load i64, i64* %totalLen, align 16
  %cmp2 = icmp ugt i64 %6, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %8 = load i8*, i8** %secret, align 8
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %7, i8* %8, i32 1)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret, align 8
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 11
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 8
  %11 = load i64, i64* %totalLen5, align 16
  %mul = mul i64 %11, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call, i64* %low64, align 8
  %arraydecay6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %12 = load i8*, i8** %secret, align 8
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 7
  %14 = load i64, i64* %secretLimit, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %12, i64 %14
  %add.ptr8 = getelementptr inbounds i8, i8* %add.ptr7, i64 64
  %add.ptr9 = getelementptr inbounds i8, i8* %add.ptr8, i64 -64
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -11
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 8
  %16 = load i64, i64* %totalLen11, align 16
  %mul12 = mul i64 %16, -4417276706812531889
  %neg = xor i64 %mul12, -1
  %call13 = call i64 @XXH3_mergeAccs(i64* %arraydecay6, i8* %add.ptr10, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call13, i64* %high64, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 9
  %18 = load i64, i64* %seed, align 8
  %tobool = icmp ne i64 %18, 0
  br i1 %tobool, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.end
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 2
  %arraydecay15 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 8
  %21 = load i64, i64* %totalLen16, align 16
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 9
  %23 = load i64, i64* %seed17, align 8
  %call18 = call { i64, i64 } @XXH3_128bits_withSeed(i8* %arraydecay15, i64 %21, i64 %23)
  %24 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call18, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call18, 1
  store i64 %28, i64* %27, align 8
  br label %return

if.end19:                                         ; preds = %if.end
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %30 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen22 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %30, i32 0, i32 8
  %31 = load i64, i64* %totalLen22, align 16
  %32 = load i8*, i8** %secret, align 8
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit23 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 7
  %34 = load i64, i64* %secretLimit23, align 8
  %add = add i64 %34, 64
  %call24 = call { i64, i64 } @XXH3_128bits_withSecret(i8* %arraydecay21, i64 %31, i8* %32, i64 %add)
  %35 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = extractvalue { i64, i64 } %call24, 0
  store i64 %37, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = extractvalue { i64, i64 } %call24, 1
  store i64 %39, i64* %38, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %40 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %41 = load { i64, i64 }, { i64, i64 }* %40, align 8
  ret { i64, i64 } %41
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH128_isEqual(i64 %h1.coerce0, i64 %h1.coerce1, i64 %h2.coerce0, i64 %h2.coerce1) #0 {
entry:
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %0 = bitcast %struct.XXH128_hash_t* %h1 to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %h1.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %h1.coerce1, i64* %2, align 8
  %3 = bitcast %struct.XXH128_hash_t* %h2 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %h2.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %h2.coerce1, i64* %5, align 8
  %6 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %7 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %call = call i32 @memcmp(i8* %6, i8* %7, i64 16)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i32 @memcmp(i8*, i8*, i64) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH128_cmp(i8* %h128_1, i8* %h128_2) #0 {
entry:
  %retval = alloca i32, align 4
  %h128_1.addr = alloca i8*, align 8
  %h128_2.addr = alloca i8*, align 8
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %hcmp = alloca i32, align 4
  store i8* %h128_1, i8** %h128_1.addr, align 8
  store i8* %h128_2, i8** %h128_2.addr, align 8
  %0 = load i8*, i8** %h128_1.addr, align 8
  %1 = bitcast i8* %0 to %struct.XXH128_hash_t*
  %2 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %3 = bitcast %struct.XXH128_hash_t* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 %3, i64 16, i1 false)
  %4 = load i8*, i8** %h128_2.addr, align 8
  %5 = bitcast i8* %4 to %struct.XXH128_hash_t*
  %6 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %7 = bitcast %struct.XXH128_hash_t* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 %7, i64 16, i1 false)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %8 = load i64, i64* %high64, align 8
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %9 = load i64, i64* %high641, align 8
  %cmp = icmp ugt i64 %8, %9
  %conv = zext i1 %cmp to i32
  %high642 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %10 = load i64, i64* %high642, align 8
  %high643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %11 = load i64, i64* %high643, align 8
  %cmp4 = icmp ugt i64 %10, %11
  %conv5 = zext i1 %cmp4 to i32
  %sub = sub nsw i32 %conv, %conv5
  store i32 %sub, i32* %hcmp, align 4
  %12 = load i32, i32* %hcmp, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %13 = load i32, i32* %hcmp, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %14 = load i64, i64* %low64, align 8
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %15 = load i64, i64* %low646, align 8
  %cmp7 = icmp ugt i64 %14, %15
  %conv8 = zext i1 %cmp7 to i32
  %low649 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %16 = load i64, i64* %low649, align 8
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %17 = load i64, i64* %low6410, align 8
  %cmp11 = icmp ugt i64 %16, %17
  %conv12 = zext i1 %cmp11 to i32
  %sub13 = sub nsw i32 %conv8, %conv12
  store i32 %sub13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #3

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH128_hashFromCanonical(%struct.XXH128_canonical_t* %src) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %src.addr = alloca %struct.XXH128_canonical_t*, align 8
  store %struct.XXH128_canonical_t* %src, %struct.XXH128_canonical_t** %src.addr, align 8
  %0 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8
  %1 = bitcast %struct.XXH128_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call, i64* %high64, align 8
  %2 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8
  %digest = getelementptr inbounds %struct.XXH128_canonical_t, %struct.XXH128_canonical_t* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %digest, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 8
  %call1 = call i64 @XXH_readBE64(i8* %add.ptr)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call1, i64* %low64, align 8
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = load { i64, i64 }, { i64, i64 }* %3, align 8
  ret { i64, i64 } %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_readLE32_align(i8* %ptr, i32 %align) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i32, i32* %align.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8
  %call = call i32 @XXH_readLE32(i8* %1)
  store i32 %call, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #6

declare void @free(i8*) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_read32(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i32, align 4
  store i8* %memPtr, i8** %memPtr.addr, align 8
  %0 = bitcast i32* %val to i8*
  %1 = load i8*, i8** %memPtr.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 1 %1, i64 4, i1 false)
  %2 = load i32, i32* %val, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_avalanche(i32 %h32) #0 {
entry:
  %h32.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4
  %0 = load i32, i32* %h32.addr, align 4
  %shr = lshr i32 %0, 15
  %1 = load i32, i32* %h32.addr, align 4
  %xor = xor i32 %1, %shr
  store i32 %xor, i32* %h32.addr, align 4
  %2 = load i32, i32* %h32.addr, align 4
  %mul = mul i32 %2, -2048144777
  store i32 %mul, i32* %h32.addr, align 4
  %3 = load i32, i32* %h32.addr, align 4
  %shr1 = lshr i32 %3, 13
  %4 = load i32, i32* %h32.addr, align 4
  %xor2 = xor i32 %4, %shr1
  store i32 %xor2, i32* %h32.addr, align 4
  %5 = load i32, i32* %h32.addr, align 4
  %mul3 = mul i32 %5, -1028477379
  store i32 %mul3, i32* %h32.addr, align 4
  %6 = load i32, i32* %h32.addr, align 4
  %shr4 = lshr i32 %6, 16
  %7 = load i32, i32* %h32.addr, align 4
  %xor5 = xor i32 %7, %shr4
  store i32 %xor5, i32* %h32.addr, align 4
  %8 = load i32, i32* %h32.addr, align 4
  ret i32 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_readLE64_align(i8* %ptr, i32 %align) #0 {
entry:
  %retval = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i32, i32* %align.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8
  %call = call i64 @XXH_readLE64(i8* %1)
  store i64 %call, i64* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8
  %3 = bitcast i8* %2 to i64*
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i64, i64* %retval, align 8
  ret i64 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_read64(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i64, align 8
  store i8* %memPtr, i8** %memPtr.addr, align 8
  %0 = bitcast i64* %val to i8*
  %1 = load i8*, i8** %memPtr.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %0, i8* align 1 %1, i64 8, i1 false)
  %2 = load i64, i64* %val, align 8
  ret i64 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8
  %0 = load i64, i64* %h64.addr, align 8
  %shr = lshr i64 %0, 33
  %1 = load i64, i64* %h64.addr, align 8
  %xor = xor i64 %1, %shr
  store i64 %xor, i64* %h64.addr, align 8
  %2 = load i64, i64* %h64.addr, align 8
  %mul = mul i64 %2, -4417276706812531889
  store i64 %mul, i64* %h64.addr, align 8
  %3 = load i64, i64* %h64.addr, align 8
  %shr1 = lshr i64 %3, 29
  %4 = load i64, i64* %h64.addr, align 8
  %xor2 = xor i64 %4, %shr1
  store i64 %xor2, i64* %h64.addr, align 8
  %5 = load i64, i64* %h64.addr, align 8
  %mul3 = mul i64 %5, 1609587929392839161
  store i64 %mul3, i64* %h64.addr, align 8
  %6 = load i64, i64* %h64.addr, align 8
  %shr4 = lshr i64 %6, 32
  %7 = load i64, i64* %h64.addr, align 8
  %xor5 = xor i64 %7, %shr4
  store i64 %xor5, i64* %h64.addr, align 8
  %8 = load i64, i64* %h64.addr, align 8
  ret i64 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_0to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %0, 8
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %tobool = icmp ne i64 %conv1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_len_9to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8
  %cmp2 = icmp uge i64 %5, 4
  %conv3 = zext i1 %cmp2 to i32
  %conv4 = sext i32 %conv3 to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i64, i64* %len.addr, align 8
  %8 = load i8*, i8** %secret.addr, align 8
  %9 = load i64, i64* %seed.addr, align 8
  %call7 = call i64 @XXH3_len_4to8_64b(i8* %6, i64 %7, i8* %8, i64 %9)
  store i64 %call7, i64* %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %10 = load i64, i64* %len.addr, align 8
  %tobool9 = icmp ne i64 %10, 0
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %11 = load i8*, i8** %input.addr, align 8
  %12 = load i64, i64* %len.addr, align 8
  %13 = load i8*, i8** %secret.addr, align 8
  %14 = load i64, i64* %seed.addr, align 8
  %call11 = call i64 @XXH3_len_1to3_64b(i8* %11, i64 %12, i8* %13, i64 %14)
  store i64 %call11, i64* %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end8
  %15 = load i64, i64* %seed.addr, align 8
  %add = add i64 -7046029288634856825, %15
  %16 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 56
  %call13 = call i64 @XXH_readLE64(i8* %add.ptr)
  %17 = load i8*, i8** %secret.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, i8* %17, i64 64
  %call15 = call i64 @XXH_readLE64(i8* %add.ptr14)
  %xor = xor i64 %call13, %call15
  %xor16 = xor i64 %add, %xor
  %call17 = call i64 @XXH3_avalanche(i64 %xor16)
  store i64 %call17, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then10, %if.then6, %if.then
  %18 = load i64, i64* %retval, align 8
  ret i64 %18
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_17to128_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %1, -7046029288634856825
  store i64 %mul, i64* %acc, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %2, 32
  br i1 %cmp, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ugt i64 %3, 64
  br i1 %cmp1, label %if.then2, label %if.end20

if.then2:                                         ; preds = %if.then
  %4 = load i64, i64* %len.addr, align 8
  %cmp3 = icmp ugt i64 %4, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %5 = load i8*, i8** %input.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 48
  %6 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 96
  %7 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %7)
  %8 = load i64, i64* %acc, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %acc, align 8
  %9 = load i8*, i8** %input.addr, align 8
  %10 = load i64, i64* %len.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %9, i64 %10
  %add.ptr7 = getelementptr inbounds i8, i8* %add.ptr6, i64 -64
  %11 = load i8*, i8** %secret.addr, align 8
  %add.ptr8 = getelementptr inbounds i8, i8* %11, i64 112
  %12 = load i64, i64* %seed.addr, align 8
  %call9 = call i64 @XXH3_mix16B(i8* %add.ptr7, i8* %add.ptr8, i64 %12)
  %13 = load i64, i64* %acc, align 8
  %add10 = add i64 %13, %call9
  store i64 %add10, i64* %acc, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %14 = load i8*, i8** %input.addr, align 8
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i64 32
  %15 = load i8*, i8** %secret.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %15, i64 64
  %16 = load i64, i64* %seed.addr, align 8
  %call13 = call i64 @XXH3_mix16B(i8* %add.ptr11, i8* %add.ptr12, i64 %16)
  %17 = load i64, i64* %acc, align 8
  %add14 = add i64 %17, %call13
  store i64 %add14, i64* %acc, align 8
  %18 = load i8*, i8** %input.addr, align 8
  %19 = load i64, i64* %len.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %18, i64 %19
  %add.ptr16 = getelementptr inbounds i8, i8* %add.ptr15, i64 -48
  %20 = load i8*, i8** %secret.addr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %20, i64 80
  %21 = load i64, i64* %seed.addr, align 8
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr16, i8* %add.ptr17, i64 %21)
  %22 = load i64, i64* %acc, align 8
  %add19 = add i64 %22, %call18
  store i64 %add19, i64* %acc, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.end, %if.then
  %23 = load i8*, i8** %input.addr, align 8
  %add.ptr21 = getelementptr inbounds i8, i8* %23, i64 16
  %24 = load i8*, i8** %secret.addr, align 8
  %add.ptr22 = getelementptr inbounds i8, i8* %24, i64 32
  %25 = load i64, i64* %seed.addr, align 8
  %call23 = call i64 @XXH3_mix16B(i8* %add.ptr21, i8* %add.ptr22, i64 %25)
  %26 = load i64, i64* %acc, align 8
  %add24 = add i64 %26, %call23
  store i64 %add24, i64* %acc, align 8
  %27 = load i8*, i8** %input.addr, align 8
  %28 = load i64, i64* %len.addr, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %27, i64 %28
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -32
  %29 = load i8*, i8** %secret.addr, align 8
  %add.ptr27 = getelementptr inbounds i8, i8* %29, i64 48
  %30 = load i64, i64* %seed.addr, align 8
  %call28 = call i64 @XXH3_mix16B(i8* %add.ptr26, i8* %add.ptr27, i64 %30)
  %31 = load i64, i64* %acc, align 8
  %add29 = add i64 %31, %call28
  store i64 %add29, i64* %acc, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.end20, %entry
  %32 = load i8*, i8** %input.addr, align 8
  %add.ptr31 = getelementptr inbounds i8, i8* %32, i64 0
  %33 = load i8*, i8** %secret.addr, align 8
  %add.ptr32 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i64, i64* %seed.addr, align 8
  %call33 = call i64 @XXH3_mix16B(i8* %add.ptr31, i8* %add.ptr32, i64 %34)
  %35 = load i64, i64* %acc, align 8
  %add34 = add i64 %35, %call33
  store i64 %add34, i64* %acc, align 8
  %36 = load i8*, i8** %input.addr, align 8
  %37 = load i64, i64* %len.addr, align 8
  %add.ptr35 = getelementptr inbounds i8, i8* %36, i64 %37
  %add.ptr36 = getelementptr inbounds i8, i8* %add.ptr35, i64 -16
  %38 = load i8*, i8** %secret.addr, align 8
  %add.ptr37 = getelementptr inbounds i8, i8* %38, i64 16
  %39 = load i64, i64* %seed.addr, align 8
  %call38 = call i64 @XXH3_mix16B(i8* %add.ptr36, i8* %add.ptr37, i64 %39)
  %40 = load i64, i64* %acc, align 8
  %add39 = add i64 %40, %call38
  store i64 %add39, i64* %acc, align 8
  %41 = load i64, i64* %acc, align 8
  %call40 = call i64 @XXH3_avalanche(i64 %41)
  ret i64 %call40
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_129to240_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %1, -7046029288634856825
  store i64 %mul, i64* %acc, align 8
  %2 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %2 to i32
  %div = sdiv i32 %conv, 16
  store i32 %div, i32* %nbRounds, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %3, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %input.addr, align 8
  %5 = load i32, i32* %i, align 4
  %mul2 = mul nsw i32 16, %5
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %6 = load i8*, i8** %secret.addr, align 8
  %7 = load i32, i32* %i, align 4
  %mul3 = mul nsw i32 16, %7
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %idx.ext4
  %8 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %8)
  %9 = load i64, i64* %acc, align 8
  %add = add i64 %9, %call
  store i64 %add, i64* %acc, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i64, i64* %acc, align 8
  %call6 = call i64 @XXH3_avalanche(i64 %11)
  store i64 %call6, i64* %acc, align 8
  store i32 8, i32* %i, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc20, %for.end
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %nbRounds, align 4
  %cmp8 = icmp slt i32 %12, %13
  br i1 %cmp8, label %for.body10, label %for.end22

for.body10:                                       ; preds = %for.cond7
  %14 = load i8*, i8** %input.addr, align 8
  %15 = load i32, i32* %i, align 4
  %mul11 = mul nsw i32 16, %15
  %idx.ext12 = sext i32 %mul11 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %14, i64 %idx.ext12
  %16 = load i8*, i8** %secret.addr, align 8
  %17 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %17, 8
  %mul14 = mul nsw i32 16, %sub
  %idx.ext15 = sext i32 %mul14 to i64
  %add.ptr16 = getelementptr inbounds i8, i8* %16, i64 %idx.ext15
  %add.ptr17 = getelementptr inbounds i8, i8* %add.ptr16, i64 3
  %18 = load i64, i64* %seed.addr, align 8
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr13, i8* %add.ptr17, i64 %18)
  %19 = load i64, i64* %acc, align 8
  %add19 = add i64 %19, %call18
  store i64 %add19, i64* %acc, align 8
  br label %for.inc20

for.inc20:                                        ; preds = %for.body10
  %20 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %20, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond7

for.end22:                                        ; preds = %for.cond7
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i64, i64* %len.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, i8* %21, i64 %22
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %23 = load i8*, i8** %secret.addr, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %23, i64 136
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -17
  %24 = load i64, i64* %seed.addr, align 8
  %call27 = call i64 @XXH3_mix16B(i8* %add.ptr24, i8* %add.ptr26, i64 %24)
  %25 = load i64, i64* %acc, align 8
  %add28 = add i64 %25, %call27
  store i64 %add28, i64* %acc, align 8
  %26 = load i64, i64* %acc, align 8
  %call29 = call i64 @XXH3_avalanche(i64 %26)
  ret i64 %call29
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_9to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflip1 = alloca i64, align 8
  %bitflip2 = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 24
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %1 = load i8*, i8** %secret.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %1, i64 32
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %2 = load i64, i64* %seed.addr, align 8
  %add = add i64 %xor, %2
  store i64 %add, i64* %bitflip1, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 40
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %4 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %4, i64 48
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %5 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %xor7, %5
  store i64 %sub, i64* %bitflip2, align 8
  %6 = load i8*, i8** %input.addr, align 8
  %call8 = call i64 @XXH_readLE64(i8* %6)
  %7 = load i64, i64* %bitflip1, align 8
  %xor9 = xor i64 %call8, %7
  store i64 %xor9, i64* %input_lo, align 8
  %8 = load i8*, i8** %input.addr, align 8
  %9 = load i64, i64* %len.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %8, i64 %9
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -8
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %10 = load i64, i64* %bitflip2, align 8
  %xor13 = xor i64 %call12, %10
  store i64 %xor13, i64* %input_hi, align 8
  %11 = load i64, i64* %len.addr, align 8
  %12 = load i64, i64* %input_lo, align 8
  %call14 = call i64 @XXH_swap64(i64 %12)
  %add15 = add i64 %11, %call14
  %13 = load i64, i64* %input_hi, align 8
  %add16 = add i64 %add15, %13
  %14 = load i64, i64* %input_lo, align 8
  %15 = load i64, i64* %input_hi, align 8
  %call17 = call i64 @XXH3_mul128_fold64(i64 %14, i64 %15)
  %add18 = add i64 %add16, %call17
  store i64 %add18, i64* %acc, align 8
  %16 = load i64, i64* %acc, align 8
  %call19 = call i64 @XXH3_avalanche(i64 %16)
  ret i64 %call19
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_4to8_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input1 = alloca i32, align 4
  %input2 = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %input64 = alloca i64, align 8
  %x = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %seed.addr, align 8
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %call2 = call i32 @XXH_readLE32(i8* %2)
  store i32 %call2, i32* %input1, align 4
  %3 = load i8*, i8** %input.addr, align 8
  %4 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %4
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input2, align 4
  %5 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %5, i64 8
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %6 = load i8*, i8** %secret.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %6, i64 16
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr7)
  %xor9 = xor i64 %call6, %call8
  %7 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %xor9, %7
  store i64 %sub, i64* %bitflip, align 8
  %8 = load i32, i32* %input2, align 4
  %conv10 = zext i32 %8 to i64
  %9 = load i32, i32* %input1, align 4
  %conv11 = zext i32 %9 to i64
  %shl12 = shl i64 %conv11, 32
  %add = add i64 %conv10, %shl12
  store i64 %add, i64* %input64, align 8
  %10 = load i64, i64* %input64, align 8
  %11 = load i64, i64* %bitflip, align 8
  %xor13 = xor i64 %10, %11
  store i64 %xor13, i64* %x, align 8
  %12 = load i64, i64* %x, align 8
  %shl14 = shl i64 %12, 49
  %13 = load i64, i64* %x, align 8
  %shr = lshr i64 %13, 15
  %or = or i64 %shl14, %shr
  %14 = load i64, i64* %x, align 8
  %shl15 = shl i64 %14, 24
  %15 = load i64, i64* %x, align 8
  %shr16 = lshr i64 %15, 40
  %or17 = or i64 %shl15, %shr16
  %xor18 = xor i64 %or, %or17
  %16 = load i64, i64* %x, align 8
  %xor19 = xor i64 %16, %xor18
  store i64 %xor19, i64* %x, align 8
  %17 = load i64, i64* %x, align 8
  %mul = mul i64 %17, -6939452855193903323
  store i64 %mul, i64* %x, align 8
  %18 = load i64, i64* %x, align 8
  %shr20 = lshr i64 %18, 35
  %19 = load i64, i64* %len.addr, align 8
  %add21 = add i64 %shr20, %19
  %20 = load i64, i64* %x, align 8
  %xor22 = xor i64 %20, %add21
  store i64 %xor22, i64* %x, align 8
  %21 = load i64, i64* %x, align 8
  %mul23 = mul i64 %21, -6939452855193903323
  store i64 %mul23, i64* %x, align 8
  %22 = load i64, i64* %x, align 8
  %call24 = call i64 @XXH_xorshift64(i64 %22, i32 28)
  ret i64 %call24
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_1to3_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combined = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  %mixed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1
  store i8 %1, i8* %c1, align 1
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1
  store i8 %4, i8* %c2, align 1
  %5 = load i8*, i8** %input.addr, align 8
  %6 = load i64, i64* %len.addr, align 8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1
  store i8 %7, i8* %c3, align 1
  %8 = load i8, i8* %c1, align 1
  %conv = zext i8 %8 to i32
  %shl = shl i32 %conv, 16
  %9 = load i8, i8* %c2, align 1
  %conv3 = zext i8 %9 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %10 = load i8, i8* %c3, align 1
  %conv5 = zext i8 %10 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %11 = load i64, i64* %len.addr, align 8
  %conv8 = trunc i64 %11 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combined, align 4
  %12 = load i8*, i8** %secret.addr, align 8
  %call = call i32 @XXH_readLE32(i8* %12)
  %13 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 4
  %call11 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call, %call11
  %conv12 = zext i32 %xor to i64
  %14 = load i64, i64* %seed.addr, align 8
  %add = add i64 %conv12, %14
  store i64 %add, i64* %bitflip, align 8
  %15 = load i32, i32* %combined, align 4
  %conv13 = zext i32 %15 to i64
  %16 = load i64, i64* %bitflip, align 8
  %xor14 = xor i64 %conv13, %16
  store i64 %xor14, i64* %keyed, align 8
  %17 = load i64, i64* %keyed, align 8
  %mul = mul i64 %17, -7046029288634856825
  store i64 %mul, i64* %mixed, align 8
  %18 = load i64, i64* %mixed, align 8
  %call15 = call i64 @XXH3_avalanche(i64 %18)
  ret i64 %call15
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8
  %0 = load i64, i64* %h64.addr, align 8
  %call = call i64 @XXH_xorshift64(i64 %0, i32 37)
  store i64 %call, i64* %h64.addr, align 8
  %1 = load i64, i64* %h64.addr, align 8
  %mul = mul i64 %1, 1609587791953885689
  store i64 %mul, i64* %h64.addr, align 8
  %2 = load i64, i64* %h64.addr, align 8
  %call1 = call i64 @XXH_xorshift64(i64 %2, i32 32)
  store i64 %call1, i64* %h64.addr, align 8
  %3 = load i64, i64* %h64.addr, align 8
  ret i64 %3
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mul128_fold64(i64 %lhs, i64 %rhs) #0 {
entry:
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca %struct.XXH128_hash_t, align 8
  store i64 %lhs, i64* %lhs.addr, align 8
  store i64 %rhs, i64* %rhs.addr, align 8
  %0 = load i64, i64* %lhs.addr, align 8
  %1 = load i64, i64* %rhs.addr, align 8
  %call = call { i64, i64 } @XXH_mult64to128(i64 %0, i64 %1)
  %2 = bitcast %struct.XXH128_hash_t* %product to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 0
  %7 = load i64, i64* %low64, align 8
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 1
  %8 = load i64, i64* %high64, align 8
  %xor = xor i64 %7, %8
  ret i64 %xor
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH_mult64to128(i64 %lhs, i64 %rhs) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca i128, align 16
  store i64 %lhs, i64* %lhs.addr, align 8
  store i64 %rhs, i64* %rhs.addr, align 8
  %0 = load i64, i64* %lhs.addr, align 8
  %conv = zext i64 %0 to i128
  %1 = load i64, i64* %rhs.addr, align 8
  %conv1 = zext i64 %1 to i128
  %mul = mul i128 %conv, %conv1
  store i128 %mul, i128* %product, align 16
  %2 = load i128, i128* %product, align 16
  %conv2 = trunc i128 %2 to i64
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %conv2, i64* %low64, align 8
  %3 = load i128, i128* %product, align 16
  %shr = lshr i128 %3, 64
  %conv3 = trunc i128 %shr to i64
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %conv3, i64* %high64, align 8
  %4 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %5 = load { i64, i64 }, { i64, i64 }* %4, align 8
  ret { i64, i64 } %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_xorshift64(i64 %v64, i32 %shift) #0 {
entry:
  %v64.addr = alloca i64, align 8
  %shift.addr = alloca i32, align 4
  store i64 %v64, i64* %v64.addr, align 8
  store i32 %shift, i32* %shift.addr, align 4
  %0 = load i64, i64* %v64.addr, align 8
  %1 = load i64, i64* %v64.addr, align 8
  %2 = load i32, i32* %shift.addr, align 4
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %1, %sh_prom
  %xor = xor i64 %0, %shr
  ret i64 %xor
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mix16B(i8* noalias %input, i8* noalias %secret, i64 %seed64) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %call = call i64 @XXH_readLE64(i8* %0)
  store i64 %call, i64* %input_lo, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 8
  %call1 = call i64 @XXH_readLE64(i8* %add.ptr)
  store i64 %call1, i64* %input_hi, align 8
  %2 = load i64, i64* %input_lo, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %call2 = call i64 @XXH_readLE64(i8* %3)
  %4 = load i64, i64* %seed64.addr, align 8
  %add = add i64 %call2, %4
  %xor = xor i64 %2, %add
  %5 = load i64, i64* %input_hi, align 8
  %6 = load i8*, i8** %secret.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %6, i64 8
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %7 = load i64, i64* %seed64.addr, align 8
  %sub = sub i64 %call4, %7
  %xor5 = xor i64 %5, %sub
  %call6 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor5)
  ret i64 %call6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %0, i8* align 16 bitcast ([8 x i64]* @XXH3_hashLong_64b_internal.acc to i8*), i64 64, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretSize.addr, align 8
  %5 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %6 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %1, i64 %2, i8* %3, i64 %4, i32 0, void (i8*, i8*, i8*, i32)* %5, void (i8*, i8*)* %6)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 11
  %8 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %8, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_hashLong_internal_loop(i64* noalias %acc, i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nb_rounds = alloca i64, align 8
  %block_len = alloca i64, align 8
  %nb_blocks = alloca i64, align 8
  %n = alloca i64, align 8
  %nbStripes = alloca i64, align 8
  %p = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %sub = sub i64 %0, 64
  %div = udiv i64 %sub, 8
  store i64 %div, i64* %nb_rounds, align 8
  %1 = load i64, i64* %nb_rounds, align 8
  %mul = mul i64 64, %1
  store i64 %mul, i64* %block_len, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i64, i64* %block_len, align 8
  %div1 = udiv i64 %2, %3
  store i64 %div1, i64* %nb_blocks, align 8
  store i64 0, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i64, i64* %n, align 8
  %5 = load i64, i64* %nb_blocks, align 8
  %cmp = icmp ult i64 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i64*, i64** %acc.addr, align 8
  %7 = load i8*, i8** %input.addr, align 8
  %8 = load i64, i64* %n, align 8
  %9 = load i64, i64* %block_len, align 8
  %mul2 = mul i64 %8, %9
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %mul2
  %10 = load i8*, i8** %secret.addr, align 8
  %11 = load i64, i64* %nb_rounds, align 8
  %12 = load i32, i32* %accWidth.addr, align 4
  %13 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %6, i8* %add.ptr, i8* %10, i64 %11, i32 %12, void (i8*, i8*, i8*, i32)* %13)
  %14 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %15 = load i64*, i64** %acc.addr, align 8
  %16 = bitcast i64* %15 to i8*
  %17 = load i8*, i8** %secret.addr, align 8
  %18 = load i64, i64* %secretSize.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %17, i64 %18
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  call void %14(i8* %16, i8* %add.ptr4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i64, i64* %n, align 8
  %inc = add i64 %19, 1
  store i64 %inc, i64* %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load i64, i64* %len.addr, align 8
  %21 = load i64, i64* %block_len, align 8
  %22 = load i64, i64* %nb_blocks, align 8
  %mul5 = mul i64 %21, %22
  %sub6 = sub i64 %20, %mul5
  %div7 = udiv i64 %sub6, 64
  store i64 %div7, i64* %nbStripes, align 8
  %23 = load i64*, i64** %acc.addr, align 8
  %24 = load i8*, i8** %input.addr, align 8
  %25 = load i64, i64* %nb_blocks, align 8
  %26 = load i64, i64* %block_len, align 8
  %mul8 = mul i64 %25, %26
  %add.ptr9 = getelementptr inbounds i8, i8* %24, i64 %mul8
  %27 = load i8*, i8** %secret.addr, align 8
  %28 = load i64, i64* %nbStripes, align 8
  %29 = load i32, i32* %accWidth.addr, align 4
  %30 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %23, i8* %add.ptr9, i8* %27, i64 %28, i32 %29, void (i8*, i8*, i8*, i32)* %30)
  %31 = load i64, i64* %len.addr, align 8
  %and = and i64 %31, 63
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %32 = load i8*, i8** %input.addr, align 8
  %33 = load i64, i64* %len.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %32, i64 %33
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -64
  store i8* %add.ptr11, i8** %p, align 8
  %34 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %35 = load i64*, i64** %acc.addr, align 8
  %36 = bitcast i64* %35 to i8*
  %37 = load i8*, i8** %p, align 8
  %38 = load i8*, i8** %secret.addr, align 8
  %39 = load i64, i64* %secretSize.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %38, i64 %39
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -64
  %add.ptr14 = getelementptr inbounds i8, i8* %add.ptr13, i64 -7
  %40 = load i32, i32* %accWidth.addr, align 4
  call void %34(i8* %36, i8* %37, i8* %add.ptr14, i32 %40)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_accumulate(i64* noalias %acc, i8* noalias %input, i8* noalias %secret, i64 %nbStripes, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %n = alloca i64, align 8
  %in = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %nbStripes, i64* %nbStripes.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store i64 0, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %n, align 8
  %1 = load i64, i64* %nbStripes.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %n, align 8
  %mul = mul i64 %3, 64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %mul
  store i8* %add.ptr, i8** %in, align 8
  %4 = load i8*, i8** %in, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %4, i64 320
  call void @llvm.prefetch(i8* %add.ptr1, i32 0, i32 3, i32 1)
  %5 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %6 = load i64*, i64** %acc.addr, align 8
  %7 = bitcast i64* %6 to i8*
  %8 = load i8*, i8** %in, align 8
  %9 = load i8*, i8** %secret.addr, align 8
  %10 = load i64, i64* %n, align 8
  %mul2 = mul i64 %10, 8
  %add.ptr3 = getelementptr inbounds i8, i8* %9, i64 %mul2
  %11 = load i32, i32* %accWidth.addr, align 4
  call void %5(i8* %7, i8* %8, i8* %add.ptr3, i32 %11)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i64, i64* %n, align 8
  %inc = add i64 %12, 1
  store i64 %inc, i64* %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inaccessiblemem_or_argmemonly nounwind
declare void @llvm.prefetch(i8* nocapture readonly, i32, i32, i32) #7

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed_internal(i8* %input, i64 %len, i64 %seed, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #0 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8
  %0 = load i64, i64* %seed.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %6 = load i64, i64* %seed.addr, align 8
  call void %5(i8* %arraydecay, i64 %6)
  %7 = load i8*, i8** %input.addr, align 8
  %8 = load i64, i64* %len.addr, align 8
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %9 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %10 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call2 = call i64 @XXH3_hashLong_64b_internal(i8* %7, i64 %8, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %9, void (i8*, i8*)* %10)
  store i64 %call2, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, i64* %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH_writeLE64(i8* %dst, i64 %v64) #0 {
entry:
  %dst.addr = alloca i8*, align 8
  %v64.addr = alloca i64, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %v64, i64* %v64.addr, align 8
  %0 = load i8*, i8** %dst.addr, align 8
  %1 = bitcast i64* %v64.addr to i8*
  %2 = load i8*, i8** %dst.addr, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 8, i64 %3) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_consumeStripes(i64* noalias %acc, i64* noalias %nbStripesSoFarPtr, i64 %nbStripesPerBlock, i8* noalias %input, i64 %nbStripes, i8* noalias %secret, i64 %secretLimit, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %nbStripesSoFarPtr.addr = alloca i64*, align 8
  %nbStripesPerBlock.addr = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLimit.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nbStripesToEndofBlock = alloca i64, align 8
  %nbStripesAfterBlock = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i64* %nbStripesSoFarPtr, i64** %nbStripesSoFarPtr.addr, align 8
  store i64 %nbStripesPerBlock, i64* %nbStripesPerBlock.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %nbStripes, i64* %nbStripes.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLimit, i64* %secretLimit.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = load i64, i64* %nbStripesPerBlock.addr, align 8
  %1 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %2 = load i64, i64* %1, align 8
  %sub = sub i64 %0, %2
  %3 = load i64, i64* %nbStripes.addr, align 8
  %cmp = icmp ule i64 %sub, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %nbStripesPerBlock.addr, align 8
  %5 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %6 = load i64, i64* %5, align 8
  %sub1 = sub i64 %4, %6
  store i64 %sub1, i64* %nbStripesToEndofBlock, align 8
  %7 = load i64, i64* %nbStripes.addr, align 8
  %8 = load i64, i64* %nbStripesToEndofBlock, align 8
  %sub2 = sub i64 %7, %8
  store i64 %sub2, i64* %nbStripesAfterBlock, align 8
  %9 = load i64*, i64** %acc.addr, align 8
  %10 = load i8*, i8** %input.addr, align 8
  %11 = load i8*, i8** %secret.addr, align 8
  %12 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %12, i64 0
  %13 = load i64, i64* %arrayidx, align 8
  %mul = mul i64 %13, 8
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 %mul
  %14 = load i64, i64* %nbStripesToEndofBlock, align 8
  %15 = load i32, i32* %accWidth.addr, align 4
  %16 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %9, i8* %10, i8* %add.ptr, i64 %14, i32 %15, void (i8*, i8*, i8*, i32)* %16)
  %17 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %18 = load i64*, i64** %acc.addr, align 8
  %19 = bitcast i64* %18 to i8*
  %20 = load i8*, i8** %secret.addr, align 8
  %21 = load i64, i64* %secretLimit.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %20, i64 %21
  call void %17(i8* %19, i8* %add.ptr3)
  %22 = load i64*, i64** %acc.addr, align 8
  %23 = load i8*, i8** %input.addr, align 8
  %24 = load i64, i64* %nbStripesToEndofBlock, align 8
  %mul4 = mul i64 %24, 64
  %add.ptr5 = getelementptr inbounds i8, i8* %23, i64 %mul4
  %25 = load i8*, i8** %secret.addr, align 8
  %26 = load i64, i64* %nbStripesAfterBlock, align 8
  %27 = load i32, i32* %accWidth.addr, align 4
  %28 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %22, i8* %add.ptr5, i8* %25, i64 %26, i32 %27, void (i8*, i8*, i8*, i32)* %28)
  %29 = load i64, i64* %nbStripesAfterBlock, align 8
  %30 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  store i64 %29, i64* %30, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %31 = load i64*, i64** %acc.addr, align 8
  %32 = load i8*, i8** %input.addr, align 8
  %33 = load i8*, i8** %secret.addr, align 8
  %34 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %arrayidx6 = getelementptr inbounds i64, i64* %34, i64 0
  %35 = load i64, i64* %arrayidx6, align 8
  %mul7 = mul i64 %35, 8
  %add.ptr8 = getelementptr inbounds i8, i8* %33, i64 %mul7
  %36 = load i64, i64* %nbStripes.addr, align 8
  %37 = load i32, i32* %accWidth.addr, align 4
  %38 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %31, i8* %32, i8* %add.ptr8, i64 %36, i32 %37, void (i8*, i8*, i8*, i32)* %38)
  %39 = load i64, i64* %nbStripes.addr, align 8
  %40 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %41 = load i64, i64* %40, align 8
  %add = add i64 %41, %39
  store i64 %add, i64* %40, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64>, i32) #8

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64>, i32) #8

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mix2Accs(i64* noalias %acc, i8* noalias %secret) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  %0 = load i64*, i64** %acc.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %call = call i64 @XXH_readLE64(i8* %2)
  %xor = xor i64 %1, %call
  %3 = load i64*, i64** %acc.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %3, i64 1
  %4 = load i64, i64* %arrayidx1, align 8
  %5 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 8
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr)
  %xor3 = xor i64 %4, %call2
  %call4 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor3)
  ret i64 %call4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_0to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %call = call { i64, i64 } @XXH3_len_9to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp uge i64 %10, 4
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8
  %12 = load i64, i64* %len.addr, align 8
  %13 = load i8*, i8** %secret.addr, align 8
  %14 = load i64, i64* %seed.addr, align 8
  %call3 = call { i64, i64 } @XXH3_len_4to8_128b(i8* %11, i64 %12, i8* %13, i64 %14)
  %15 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call3, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call3, 1
  store i64 %19, i64* %18, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %20 = load i64, i64* %len.addr, align 8
  %tobool = icmp ne i64 %20, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end4
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i64, i64* %len.addr, align 8
  %23 = load i8*, i8** %secret.addr, align 8
  %24 = load i64, i64* %seed.addr, align 8
  %call6 = call { i64, i64 } @XXH3_len_1to3_128b(i8* %21, i64 %22, i8* %23, i64 %24)
  %25 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call6, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call6, 1
  store i64 %29, i64* %28, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %30 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %30, i64 64
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr)
  %31 = load i8*, i8** %secret.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %31, i64 72
  %call10 = call i64 @XXH_readLE64(i8* %add.ptr9)
  %xor = xor i64 %call8, %call10
  store i64 %xor, i64* %bitflipl, align 8
  %32 = load i8*, i8** %secret.addr, align 8
  %add.ptr11 = getelementptr inbounds i8, i8* %32, i64 80
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %33 = load i8*, i8** %secret.addr, align 8
  %add.ptr13 = getelementptr inbounds i8, i8* %33, i64 88
  %call14 = call i64 @XXH_readLE64(i8* %add.ptr13)
  %xor15 = xor i64 %call12, %call14
  store i64 %xor15, i64* %bitfliph, align 8
  %34 = load i64, i64* %seed.addr, align 8
  %add = add i64 -7046029288634856825, %34
  %35 = load i64, i64* %bitflipl, align 8
  %xor16 = xor i64 %add, %35
  %call17 = call i64 @XXH3_avalanche(i64 %xor16)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call17, i64* %low64, align 8
  %36 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 -4417276706812531889, %36
  %37 = load i64, i64* %bitfliph, align 8
  %xor18 = xor i64 %sub, %37
  %call19 = call i64 @XXH3_avalanche(i64 %xor18)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call19, i64* %high64, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then2, %if.then
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = load { i64, i64 }, { i64, i64 }* %38, align 8
  ret { i64, i64 } %39
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_17to128_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %tmp = alloca %struct.XXH128_hash_t, align 8
  %tmp8 = alloca %struct.XXH128_hash_t, align 8
  %tmp15 = alloca %struct.XXH128_hash_t, align 8
  %tmp22 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %1, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %2, 32
  br i1 %cmp, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ugt i64 %3, 64
  br i1 %cmp1, label %if.then2, label %if.end14

if.then2:                                         ; preds = %if.then
  %4 = load i64, i64* %len.addr, align 8
  %cmp3 = icmp ugt i64 %4, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %5 = load i8*, i8** %input.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 48
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i64, i64* %len.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %7
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 -64
  %8 = load i8*, i8** %secret.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %8, i64 96
  %9 = load i64, i64* %seed.addr, align 8
  %10 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %12, i64 %14, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr7, i64 %9)
  %15 = bitcast %struct.XXH128_hash_t* %tmp to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call, 1
  store i64 %19, i64* %18, align 8
  %20 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %21 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %21, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %22 = load i8*, i8** %input.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %22, i64 32
  %23 = load i8*, i8** %input.addr, align 8
  %24 = load i64, i64* %len.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %23, i64 %24
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -48
  %25 = load i8*, i8** %secret.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %25, i64 64
  %26 = load i64, i64* %seed.addr, align 8
  %27 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = load i64, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = load i64, i64* %30, align 8
  %call13 = call { i64, i64 } @XXH128_mix32B(i64 %29, i64 %31, i8* %add.ptr9, i8* %add.ptr11, i8* %add.ptr12, i64 %26)
  %32 = bitcast %struct.XXH128_hash_t* %tmp8 to { i64, i64 }*
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 0
  %34 = extractvalue { i64, i64 } %call13, 0
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 1
  %36 = extractvalue { i64, i64 } %call13, 1
  store i64 %36, i64* %35, align 8
  %37 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %38 = bitcast %struct.XXH128_hash_t* %tmp8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 %38, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %39 = load i8*, i8** %input.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, i8* %39, i64 16
  %40 = load i8*, i8** %input.addr, align 8
  %41 = load i64, i64* %len.addr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %40, i64 %41
  %add.ptr18 = getelementptr inbounds i8, i8* %add.ptr17, i64 -32
  %42 = load i8*, i8** %secret.addr, align 8
  %add.ptr19 = getelementptr inbounds i8, i8* %42, i64 32
  %43 = load i64, i64* %seed.addr, align 8
  %44 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call20 = call { i64, i64 } @XXH128_mix32B(i64 %46, i64 %48, i8* %add.ptr16, i8* %add.ptr18, i8* %add.ptr19, i64 %43)
  %49 = bitcast %struct.XXH128_hash_t* %tmp15 to { i64, i64 }*
  %50 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %49, i32 0, i32 0
  %51 = extractvalue { i64, i64 } %call20, 0
  store i64 %51, i64* %50, align 8
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %49, i32 0, i32 1
  %53 = extractvalue { i64, i64 } %call20, 1
  store i64 %53, i64* %52, align 8
  %54 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %55 = bitcast %struct.XXH128_hash_t* %tmp15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %54, i8* align 8 %55, i64 16, i1 false)
  br label %if.end21

if.end21:                                         ; preds = %if.end14, %entry
  %56 = load i8*, i8** %input.addr, align 8
  %57 = load i8*, i8** %input.addr, align 8
  %58 = load i64, i64* %len.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, i8* %57, i64 %58
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %59 = load i8*, i8** %secret.addr, align 8
  %60 = load i64, i64* %seed.addr, align 8
  %61 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %call25 = call { i64, i64 } @XXH128_mix32B(i64 %63, i64 %65, i8* %56, i8* %add.ptr24, i8* %59, i64 %60)
  %66 = bitcast %struct.XXH128_hash_t* %tmp22 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call25, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call25, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %72 = bitcast %struct.XXH128_hash_t* %tmp22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 8 %72, i64 16, i1 false)
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %73 = load i64, i64* %low6426, align 8
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %74 = load i64, i64* %high6427, align 8
  %add = add i64 %73, %74
  %low6428 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %add, i64* %low6428, align 8
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %75 = load i64, i64* %low6429, align 8
  %mul30 = mul i64 %75, -7046029288634856825
  %high6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %76 = load i64, i64* %high6431, align 8
  %mul32 = mul i64 %76, -8796714831421723037
  %add33 = add i64 %mul30, %mul32
  %77 = load i64, i64* %len.addr, align 8
  %78 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %77, %78
  %mul34 = mul i64 %sub, -4417276706812531889
  %add35 = add i64 %add33, %mul34
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %add35, i64* %high6436, align 8
  %low6437 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %79 = load i64, i64* %low6437, align 8
  %call38 = call i64 @XXH3_avalanche(i64 %79)
  %low6439 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call38, i64* %low6439, align 8
  %high6440 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %80 = load i64, i64* %high6440, align 8
  %call41 = call i64 @XXH3_avalanche(i64 %80)
  %sub42 = sub i64 0, %call41
  %high6443 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %sub42, i64* %high6443, align 8
  %81 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %82 = load { i64, i64 }, { i64, i64 }* %81, align 8
  ret { i64, i64 } %82
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_129to240_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  %tmp = alloca %struct.XXH128_hash_t, align 8
  %tmp20 = alloca %struct.XXH128_hash_t, align 8
  %tmp36 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %1 to i32
  %div = sdiv i32 %conv, 32
  store i32 %div, i32* %nbRounds, align 4
  %2 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %2, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %3, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %input.addr, align 8
  %5 = load i32, i32* %i, align 4
  %mul2 = mul nsw i32 32, %5
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i32, i32* %i, align 4
  %mul3 = mul nsw i32 32, %7
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %idx.ext4
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 16
  %8 = load i8*, i8** %secret.addr, align 8
  %9 = load i32, i32* %i, align 4
  %mul7 = mul nsw i32 32, %9
  %idx.ext8 = sext i32 %mul7 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i64 %idx.ext8
  %10 = load i64, i64* %seed.addr, align 8
  %11 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %13, i64 %15, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr9, i64 %10)
  %16 = bitcast %struct.XXH128_hash_t* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %22 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, i32* %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %24 = load i64, i64* %low6410, align 8
  %call11 = call i64 @XXH3_avalanche(i64 %24)
  %low6412 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %call11, i64* %low6412, align 8
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %25 = load i64, i64* %high6413, align 8
  %call14 = call i64 @XXH3_avalanche(i64 %25)
  %high6415 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 %call14, i64* %high6415, align 8
  store i32 4, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc33, %for.end
  %26 = load i32, i32* %i, align 4
  %27 = load i32, i32* %nbRounds, align 4
  %cmp17 = icmp slt i32 %26, %27
  br i1 %cmp17, label %for.body19, label %for.end35

for.body19:                                       ; preds = %for.cond16
  %28 = load i8*, i8** %input.addr, align 8
  %29 = load i32, i32* %i, align 4
  %mul21 = mul nsw i32 32, %29
  %idx.ext22 = sext i32 %mul21 to i64
  %add.ptr23 = getelementptr inbounds i8, i8* %28, i64 %idx.ext22
  %30 = load i8*, i8** %input.addr, align 8
  %31 = load i32, i32* %i, align 4
  %mul24 = mul nsw i32 32, %31
  %idx.ext25 = sext i32 %mul24 to i64
  %add.ptr26 = getelementptr inbounds i8, i8* %30, i64 %idx.ext25
  %add.ptr27 = getelementptr inbounds i8, i8* %add.ptr26, i64 16
  %32 = load i8*, i8** %secret.addr, align 8
  %add.ptr28 = getelementptr inbounds i8, i8* %32, i64 3
  %33 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %33, 4
  %mul29 = mul nsw i32 32, %sub
  %idx.ext30 = sext i32 %mul29 to i64
  %add.ptr31 = getelementptr inbounds i8, i8* %add.ptr28, i64 %idx.ext30
  %34 = load i64, i64* %seed.addr, align 8
  %35 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 8
  %call32 = call { i64, i64 } @XXH128_mix32B(i64 %37, i64 %39, i8* %add.ptr23, i8* %add.ptr27, i8* %add.ptr31, i64 %34)
  %40 = bitcast %struct.XXH128_hash_t* %tmp20 to { i64, i64 }*
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 0
  %42 = extractvalue { i64, i64 } %call32, 0
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 1
  %44 = extractvalue { i64, i64 } %call32, 1
  store i64 %44, i64* %43, align 8
  %45 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %46 = bitcast %struct.XXH128_hash_t* %tmp20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %45, i8* align 8 %46, i64 16, i1 false)
  br label %for.inc33

for.inc33:                                        ; preds = %for.body19
  %47 = load i32, i32* %i, align 4
  %inc34 = add nsw i32 %47, 1
  store i32 %inc34, i32* %i, align 4
  br label %for.cond16

for.end35:                                        ; preds = %for.cond16
  %48 = load i8*, i8** %input.addr, align 8
  %49 = load i64, i64* %len.addr, align 8
  %add.ptr37 = getelementptr inbounds i8, i8* %48, i64 %49
  %add.ptr38 = getelementptr inbounds i8, i8* %add.ptr37, i64 -16
  %50 = load i8*, i8** %input.addr, align 8
  %51 = load i64, i64* %len.addr, align 8
  %add.ptr39 = getelementptr inbounds i8, i8* %50, i64 %51
  %add.ptr40 = getelementptr inbounds i8, i8* %add.ptr39, i64 -32
  %52 = load i8*, i8** %secret.addr, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %52, i64 136
  %add.ptr42 = getelementptr inbounds i8, i8* %add.ptr41, i64 -17
  %add.ptr43 = getelementptr inbounds i8, i8* %add.ptr42, i64 -16
  %53 = load i64, i64* %seed.addr, align 8
  %sub44 = sub i64 0, %53
  %54 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %54, i32 0, i32 0
  %56 = load i64, i64* %55, align 8
  %57 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %54, i32 0, i32 1
  %58 = load i64, i64* %57, align 8
  %call45 = call { i64, i64 } @XXH128_mix32B(i64 %56, i64 %58, i8* %add.ptr38, i8* %add.ptr40, i8* %add.ptr43, i64 %sub44)
  %59 = bitcast %struct.XXH128_hash_t* %tmp36 to { i64, i64 }*
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %59, i32 0, i32 0
  %61 = extractvalue { i64, i64 } %call45, 0
  store i64 %61, i64* %60, align 8
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %59, i32 0, i32 1
  %63 = extractvalue { i64, i64 } %call45, 1
  store i64 %63, i64* %62, align 8
  %64 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %65 = bitcast %struct.XXH128_hash_t* %tmp36 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %64, i8* align 8 %65, i64 16, i1 false)
  %low6446 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %66 = load i64, i64* %low6446, align 8
  %high6447 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %67 = load i64, i64* %high6447, align 8
  %add = add i64 %66, %67
  %low6448 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %add, i64* %low6448, align 8
  %low6449 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %68 = load i64, i64* %low6449, align 8
  %mul50 = mul i64 %68, -7046029288634856825
  %high6451 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %69 = load i64, i64* %high6451, align 8
  %mul52 = mul i64 %69, -8796714831421723037
  %add53 = add i64 %mul50, %mul52
  %70 = load i64, i64* %len.addr, align 8
  %71 = load i64, i64* %seed.addr, align 8
  %sub54 = sub i64 %70, %71
  %mul55 = mul i64 %sub54, -4417276706812531889
  %add56 = add i64 %add53, %mul55
  %high6457 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %add56, i64* %high6457, align 8
  %low6458 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %72 = load i64, i64* %low6458, align 8
  %call59 = call i64 @XXH3_avalanche(i64 %72)
  %low6460 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call59, i64* %low6460, align 8
  %high6461 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %73 = load i64, i64* %high6461, align 8
  %call62 = call i64 @XXH3_avalanche(i64 %73)
  %sub63 = sub i64 0, %call62
  %high6464 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %sub63, i64* %high6464, align 8
  %74 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %75 = load { i64, i64 }, { i64, i64 }* %74, align 8
  ret { i64, i64 } %75
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_9to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %m128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 32
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %1 = load i8*, i8** %secret.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %1, i64 40
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %2 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %xor, %2
  store i64 %sub, i64* %bitflipl, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 48
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %4 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %4, i64 56
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %5 = load i64, i64* %seed.addr, align 8
  %add = add i64 %xor7, %5
  store i64 %add, i64* %bitfliph, align 8
  %6 = load i8*, i8** %input.addr, align 8
  %call8 = call i64 @XXH_readLE64(i8* %6)
  store i64 %call8, i64* %input_lo, align 8
  %7 = load i8*, i8** %input.addr, align 8
  %8 = load i64, i64* %len.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %7, i64 %8
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  store i64 %call11, i64* %input_hi, align 8
  %9 = load i64, i64* %input_lo, align 8
  %10 = load i64, i64* %input_hi, align 8
  %xor12 = xor i64 %9, %10
  %11 = load i64, i64* %bitflipl, align 8
  %xor13 = xor i64 %xor12, %11
  %call14 = call { i64, i64 } @XXH_mult64to128(i64 %xor13, i64 -7046029288634856825)
  %12 = bitcast %struct.XXH128_hash_t* %m128 to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = extractvalue { i64, i64 } %call14, 0
  store i64 %14, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = extractvalue { i64, i64 } %call14, 1
  store i64 %16, i64* %15, align 8
  %17 = load i64, i64* %len.addr, align 8
  %sub15 = sub i64 %17, 1
  %shl = shl i64 %sub15, 54
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %18 = load i64, i64* %low64, align 8
  %add16 = add i64 %18, %shl
  store i64 %add16, i64* %low64, align 8
  %19 = load i64, i64* %bitfliph, align 8
  %20 = load i64, i64* %input_hi, align 8
  %xor17 = xor i64 %20, %19
  store i64 %xor17, i64* %input_hi, align 8
  %21 = load i64, i64* %input_hi, align 8
  %22 = load i64, i64* %input_hi, align 8
  %conv = trunc i64 %22 to i32
  %conv18 = zext i32 %conv to i64
  %mul = mul i64 %conv18, 2246822518
  %add19 = add i64 %21, %mul
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %23 = load i64, i64* %high64, align 8
  %add20 = add i64 %23, %add19
  store i64 %add20, i64* %high64, align 8
  %high6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %24 = load i64, i64* %high6421, align 8
  %call22 = call i64 @XXH_swap64(i64 %24)
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %25 = load i64, i64* %low6423, align 8
  %xor24 = xor i64 %25, %call22
  store i64 %xor24, i64* %low6423, align 8
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %26 = load i64, i64* %low6425, align 8
  %call26 = call { i64, i64 } @XXH_mult64to128(i64 %26, i64 -4417276706812531889)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call26, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call26, 1
  store i64 %31, i64* %30, align 8
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %32 = load i64, i64* %high6427, align 8
  %mul28 = mul i64 %32, -4417276706812531889
  %high6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %33 = load i64, i64* %high6429, align 8
  %add30 = add i64 %33, %mul28
  store i64 %add30, i64* %high6429, align 8
  %low6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %34 = load i64, i64* %low6431, align 8
  %call32 = call i64 @XXH3_avalanche(i64 %34)
  %low6433 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call32, i64* %low6433, align 8
  %high6434 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %35 = load i64, i64* %high6434, align 8
  %call35 = call i64 @XXH3_avalanche(i64 %35)
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call35, i64* %high6436, align 8
  %36 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %37 = load { i64, i64 }, { i64, i64 }* %36, align 8
  ret { i64, i64 } %37
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_4to8_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input_lo = alloca i32, align 4
  %input_hi = alloca i32, align 4
  %input_64 = alloca i64, align 8
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %seed.addr, align 8
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %call2 = call i32 @XXH_readLE32(i8* %2)
  store i32 %call2, i32* %input_lo, align 4
  %3 = load i8*, i8** %input.addr, align 8
  %4 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %4
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input_hi, align 4
  %5 = load i32, i32* %input_lo, align 4
  %conv5 = zext i32 %5 to i64
  %6 = load i32, i32* %input_hi, align 4
  %conv6 = zext i32 %6 to i64
  %shl7 = shl i64 %conv6, 32
  %add = add i64 %conv5, %shl7
  store i64 %add, i64* %input_64, align 8
  %7 = load i8*, i8** %secret.addr, align 8
  %add.ptr8 = getelementptr inbounds i8, i8* %7, i64 16
  %call9 = call i64 @XXH_readLE64(i8* %add.ptr8)
  %8 = load i8*, i8** %secret.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %8, i64 24
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %xor12 = xor i64 %call9, %call11
  %9 = load i64, i64* %seed.addr, align 8
  %add13 = add i64 %xor12, %9
  store i64 %add13, i64* %bitflip, align 8
  %10 = load i64, i64* %input_64, align 8
  %11 = load i64, i64* %bitflip, align 8
  %xor14 = xor i64 %10, %11
  store i64 %xor14, i64* %keyed, align 8
  %12 = load i64, i64* %keyed, align 8
  %13 = load i64, i64* %len.addr, align 8
  %shl15 = shl i64 %13, 2
  %add16 = add i64 -7046029288634856825, %shl15
  %call17 = call { i64, i64 } @XXH_mult64to128(i64 %12, i64 %add16)
  %14 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call17, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call17, 1
  store i64 %18, i64* %17, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %19 = load i64, i64* %low64, align 8
  %shl18 = shl i64 %19, 1
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %20 = load i64, i64* %high64, align 8
  %add19 = add i64 %20, %shl18
  store i64 %add19, i64* %high64, align 8
  %high6420 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %21 = load i64, i64* %high6420, align 8
  %shr = lshr i64 %21, 3
  %low6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %22 = load i64, i64* %low6421, align 8
  %xor22 = xor i64 %22, %shr
  store i64 %xor22, i64* %low6421, align 8
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %23 = load i64, i64* %low6423, align 8
  %call24 = call i64 @XXH_xorshift64(i64 %23, i32 35)
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call24, i64* %low6425, align 8
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %24 = load i64, i64* %low6426, align 8
  %mul = mul i64 %24, -6939452855193903323
  store i64 %mul, i64* %low6426, align 8
  %low6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %25 = load i64, i64* %low6427, align 8
  %call28 = call i64 @XXH_xorshift64(i64 %25, i32 28)
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call28, i64* %low6429, align 8
  %high6430 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %26 = load i64, i64* %high6430, align 8
  %call31 = call i64 @XXH3_avalanche(i64 %26)
  %high6432 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call31, i64* %high6432, align 8
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = load { i64, i64 }, { i64, i64 }* %27, align 8
  ret { i64, i64 } %28
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_1to3_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combinedl = alloca i32, align 4
  %combinedh = alloca i32, align 4
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %keyed_lo = alloca i64, align 8
  %keyed_hi = alloca i64, align 8
  %mixedl = alloca i64, align 8
  %mixedh = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1
  store i8 %1, i8* %c1, align 1
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1
  store i8 %4, i8* %c2, align 1
  %5 = load i8*, i8** %input.addr, align 8
  %6 = load i64, i64* %len.addr, align 8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1
  store i8 %7, i8* %c3, align 1
  %8 = load i8, i8* %c1, align 1
  %conv = zext i8 %8 to i32
  %shl = shl i32 %conv, 16
  %9 = load i8, i8* %c2, align 1
  %conv3 = zext i8 %9 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %10 = load i8, i8* %c3, align 1
  %conv5 = zext i8 %10 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %11 = load i64, i64* %len.addr, align 8
  %conv8 = trunc i64 %11 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combinedl, align 4
  %12 = load i32, i32* %combinedl, align 4
  %call = call i32 @XXH_swap32(i32 %12)
  %shl11 = shl i32 %call, 13
  %13 = load i32, i32* %combinedl, align 4
  %call12 = call i32 @XXH_swap32(i32 %13)
  %shr13 = lshr i32 %call12, 19
  %or14 = or i32 %shl11, %shr13
  store i32 %or14, i32* %combinedh, align 4
  %14 = load i8*, i8** %secret.addr, align 8
  %call15 = call i32 @XXH_readLE32(i8* %14)
  %15 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 4
  %call16 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call15, %call16
  %conv17 = zext i32 %xor to i64
  %16 = load i64, i64* %seed.addr, align 8
  %add = add i64 %conv17, %16
  store i64 %add, i64* %bitflipl, align 8
  %17 = load i8*, i8** %secret.addr, align 8
  %add.ptr18 = getelementptr inbounds i8, i8* %17, i64 8
  %call19 = call i32 @XXH_readLE32(i8* %add.ptr18)
  %18 = load i8*, i8** %secret.addr, align 8
  %add.ptr20 = getelementptr inbounds i8, i8* %18, i64 12
  %call21 = call i32 @XXH_readLE32(i8* %add.ptr20)
  %xor22 = xor i32 %call19, %call21
  %conv23 = zext i32 %xor22 to i64
  %19 = load i64, i64* %seed.addr, align 8
  %sub24 = sub i64 %conv23, %19
  store i64 %sub24, i64* %bitfliph, align 8
  %20 = load i32, i32* %combinedl, align 4
  %conv25 = zext i32 %20 to i64
  %21 = load i64, i64* %bitflipl, align 8
  %xor26 = xor i64 %conv25, %21
  store i64 %xor26, i64* %keyed_lo, align 8
  %22 = load i32, i32* %combinedh, align 4
  %conv27 = zext i32 %22 to i64
  %23 = load i64, i64* %bitfliph, align 8
  %xor28 = xor i64 %conv27, %23
  store i64 %xor28, i64* %keyed_hi, align 8
  %24 = load i64, i64* %keyed_lo, align 8
  %mul = mul i64 %24, -7046029288634856825
  store i64 %mul, i64* %mixedl, align 8
  %25 = load i64, i64* %keyed_hi, align 8
  %mul29 = mul i64 %25, 2870177450012600261
  store i64 %mul29, i64* %mixedh, align 8
  %26 = load i64, i64* %mixedl, align 8
  %call30 = call i64 @XXH3_avalanche(i64 %26)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call30, i64* %low64, align 8
  %27 = load i64, i64* %mixedh, align 8
  %call31 = call i64 @XXH3_avalanche(i64 %27)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call31, i64* %high64, align 8
  %28 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %29 = load { i64, i64 }, { i64, i64 }* %28, align 8
  ret { i64, i64 } %29
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH128_mix32B(i64 %acc.coerce0, i64 %acc.coerce1, i8* %input_1, i8* %input_2, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %input_1.addr = alloca i8*, align 8
  %input_2.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %0 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %acc.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %acc.coerce1, i64* %2, align 8
  store i8* %input_1, i8** %input_1.addr, align 8
  store i8* %input_2, i8** %input_2.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %3 = load i8*, i8** %input_1.addr, align 8
  %4 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_mix16B(i8* %3, i8* %add.ptr, i64 %5)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %6 = load i64, i64* %low64, align 8
  %add = add i64 %6, %call
  store i64 %add, i64* %low64, align 8
  %7 = load i8*, i8** %input_2.addr, align 8
  %call1 = call i64 @XXH_readLE64(i8* %7)
  %8 = load i8*, i8** %input_2.addr, align 8
  %add.ptr2 = getelementptr inbounds i8, i8* %8, i64 8
  %call3 = call i64 @XXH_readLE64(i8* %add.ptr2)
  %add4 = add i64 %call1, %call3
  %low645 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %9 = load i64, i64* %low645, align 8
  %xor = xor i64 %9, %add4
  store i64 %xor, i64* %low645, align 8
  %10 = load i8*, i8** %input_2.addr, align 8
  %11 = load i8*, i8** %secret.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 16
  %12 = load i64, i64* %seed.addr, align 8
  %call7 = call i64 @XXH3_mix16B(i8* %10, i8* %add.ptr6, i64 %12)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %13 = load i64, i64* %high64, align 8
  %add8 = add i64 %13, %call7
  store i64 %add8, i64* %high64, align 8
  %14 = load i8*, i8** %input_1.addr, align 8
  %call9 = call i64 @XXH_readLE64(i8* %14)
  %15 = load i8*, i8** %input_1.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %15, i64 8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %add12 = add i64 %call9, %call11
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %16 = load i64, i64* %high6413, align 8
  %xor14 = xor i64 %16, %add12
  store i64 %xor14, i64* %high6413, align 8
  %17 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %18 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %18, i64 16, i1 false)
  %19 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %20 = load { i64, i64 }, { i64, i64 }* %19, align 8
  ret { i64, i64 } %20
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %0, i8* align 16 bitcast ([8 x i64]* @XXH3_hashLong_128b_internal.acc to i8*), i64 64, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretSize.addr, align 8
  %5 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %6 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %1, i64 %2, i8* %3, i64 %4, i32 1, void (i8*, i8*, i8*, i32)* %5, void (i8*, i8*)* %6)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 11
  %8 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %8, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call, i64* %low64, align 8
  %arraydecay2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret.addr, align 8
  %10 = load i64, i64* %secretSize.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %9, i64 %10
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  %add.ptr5 = getelementptr inbounds i8, i8* %add.ptr4, i64 -11
  %11 = load i64, i64* %len.addr, align 8
  %mul6 = mul i64 %11, -4417276706812531889
  %neg = xor i64 %mul6, -1
  %call7 = call i64 @XXH3_mergeAccs(i64* %arraydecay2, i8* %add.ptr5, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call7, i64* %high64, align 8
  %12 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %13 = load { i64, i64 }, { i64, i64 }* %12, align 8
  ret { i64, i64 } %13
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* noalias %input, i64 %len, i64 %seed64, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %11 = load i64, i64* %seed64.addr, align 8
  call void %10(i8* %arraydecay, i64 %11)
  %12 = load i8*, i8** %input.addr, align 8
  %13 = load i64, i64* %len.addr, align 8
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %14 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %15 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call2 = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %12, i64 %13, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %14, void (i8*, i8*)* %15)
  %16 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call2, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call2, 1
  store i64 %20, i64* %19, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %22 = load { i64, i64 }, { i64, i64 }* %21, align 8
  ret { i64, i64 } %22
}

attributes #0 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone speculatable }
attributes #3 = { argmemonly nounwind }
attributes #4 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="128" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { inaccessiblemem_or_argmemonly nounwind }
attributes #8 = { nounwind readnone }
attributes #9 = { allocsize(0) }
attributes #10 = { nounwind }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 7.1.0 (https://github.com/llvm-mirror/clang.git 4519e2637fcc4bf6e3049a0a80e6a5e7b97667cb) (https://github.com/llvm-mirror/llvm.git dd3329aeb25d87d4ac6429c0af220f92e1ba5f26)"}
!3 = !{i32 61632}
!4 = !{i32 1011914}
