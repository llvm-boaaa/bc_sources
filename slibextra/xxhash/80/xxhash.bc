; ModuleID = 'xxhash.c'
source_filename = "xxhash.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.XXH32_state_s = type { i32, i32, i32, i32, i32, i32, [4 x i32], i32, i32 }
%struct.XXH32_canonical_t = type { [4 x i8] }
%struct.XXH64_state_s = type { i64, i64, i64, i64, i64, [4 x i64], i32, i32, i64 }
%struct.XXH64_canonical_t = type { [8 x i8] }
%struct.XXH3_state_s = type { [8 x i64], [192 x i8], [256 x i8], i32, i32, i64, i64, i64, i64, i64, i64, i8* }
%struct.__loadu_si128 = type { <2 x i64> }
%struct.XXH128_canonical_t = type { [16 x i8] }
%struct.XXH128_hash_t = type { i64, i64 }

@XXH3_kSecret = internal constant [192 x i8] c"\B8\FEl9#\A4K\BE|\01\81,\F7!\AD\1C\DE\D4m\E9\83\90\97\DBr@\A4\A4\B7\B3g\1F\CBy\E6N\CC\C0\E5x\82Z\D0}\CC\FFr!\B8\08Ft\F7C$\8E\E05\90\E6\81:&L<(R\BB\91\C3\00\CB\88\D0e\8B\1BS.\A3qdH\97\A2\0D\F9N8\19\EFF\A9\DE\AC\D8\A8\FAv?\E3\9C4?\F9\DC\BB\C7\C7\0BO\1D\8AQ\E0K\CD\B4Y1\C8\9F~\C9\D9xsd\EA\C5\AC\834\D3\EB\C3\C5\81\A0\FF\FA\13c\EB\17\0D\DDQ\B7\F0\DAI\D3\16U&)\D4h\9E+\16\BEX}G\A1\FC\8F\F8\B8\D1z\D01\CEE\CB:\8F\95\16\04(\AF\D7\FB\CA\BBK@~", align 64
@__const.XXH3_hashLong_64b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16
@__const.XXH3_hashLong_128b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH_versionNumber() #0 {
entry:
  ret i32 704
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32(i8* %input, i64 %len, i32 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i32, i32* %seed.addr, align 4
  %call = call i32 @XXH32_endian_align(i8* %0, i64 %1, i32 %2, i32 1)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_endian_align(i8* %input, i64 %len, i32 %seed, i32 %align) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h32 = alloca i32, align 4
  %limit = alloca i8*, align 8
  %v1 = alloca i32, align 4
  %v2 = alloca i32, align 4
  %v3 = alloca i32, align 4
  %v4 = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  store i32 %align, i32* %align.addr, align 4
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %1
  store i8* %add.ptr, i8** %bEnd, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp uge i64 %2, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %bEnd, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %3, i64 -15
  store i8* %add.ptr1, i8** %limit, align 8
  %4 = load i32, i32* %seed.addr, align 4
  %add = add i32 %4, -1640531535
  %add2 = add i32 %add, -2048144777
  store i32 %add2, i32* %v1, align 4
  %5 = load i32, i32* %seed.addr, align 4
  %add3 = add i32 %5, -2048144777
  store i32 %add3, i32* %v2, align 4
  %6 = load i32, i32* %seed.addr, align 4
  %add4 = add i32 %6, 0
  store i32 %add4, i32* %v3, align 4
  %7 = load i32, i32* %seed.addr, align 4
  %sub = sub i32 %7, -1640531535
  store i32 %sub, i32* %v4, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %8 = load i32, i32* %v1, align 4
  %9 = load i8*, i8** %input.addr, align 8
  %10 = load i32, i32* %align.addr, align 4
  %call = call i32 @XXH_readLE32_align(i8* %9, i32 %10)
  %call5 = call i32 @XXH32_round(i32 %8, i32 %call)
  store i32 %call5, i32* %v1, align 4
  %11 = load i8*, i8** %input.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 4
  store i8* %add.ptr6, i8** %input.addr, align 8
  %12 = load i32, i32* %v2, align 4
  %13 = load i8*, i8** %input.addr, align 8
  %14 = load i32, i32* %align.addr, align 4
  %call7 = call i32 @XXH_readLE32_align(i8* %13, i32 %14)
  %call8 = call i32 @XXH32_round(i32 %12, i32 %call7)
  store i32 %call8, i32* %v2, align 4
  %15 = load i8*, i8** %input.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %15, i64 4
  store i8* %add.ptr9, i8** %input.addr, align 8
  %16 = load i32, i32* %v3, align 4
  %17 = load i8*, i8** %input.addr, align 8
  %18 = load i32, i32* %align.addr, align 4
  %call10 = call i32 @XXH_readLE32_align(i8* %17, i32 %18)
  %call11 = call i32 @XXH32_round(i32 %16, i32 %call10)
  store i32 %call11, i32* %v3, align 4
  %19 = load i8*, i8** %input.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %19, i64 4
  store i8* %add.ptr12, i8** %input.addr, align 8
  %20 = load i32, i32* %v4, align 4
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i32, i32* %align.addr, align 4
  %call13 = call i32 @XXH_readLE32_align(i8* %21, i32 %22)
  %call14 = call i32 @XXH32_round(i32 %20, i32 %call13)
  store i32 %call14, i32* %v4, align 4
  %23 = load i8*, i8** %input.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %23, i64 4
  store i8* %add.ptr15, i8** %input.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %24 = load i8*, i8** %input.addr, align 8
  %25 = load i8*, i8** %limit, align 8
  %cmp16 = icmp ult i8* %24, %25
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %26 = load i32, i32* %v1, align 4
  %27 = call i32 @llvm.fshl.i32(i32 %26, i32 %26, i32 1)
  %28 = load i32, i32* %v2, align 4
  %29 = call i32 @llvm.fshl.i32(i32 %28, i32 %28, i32 7)
  %add17 = add i32 %27, %29
  %30 = load i32, i32* %v3, align 4
  %31 = call i32 @llvm.fshl.i32(i32 %30, i32 %30, i32 12)
  %add18 = add i32 %add17, %31
  %32 = load i32, i32* %v4, align 4
  %33 = call i32 @llvm.fshl.i32(i32 %32, i32 %32, i32 18)
  %add19 = add i32 %add18, %33
  store i32 %add19, i32* %h32, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %34 = load i32, i32* %seed.addr, align 4
  %add20 = add i32 %34, 374761393
  store i32 %add20, i32* %h32, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %35 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %35 to i32
  %36 = load i32, i32* %h32, align 4
  %add21 = add i32 %36, %conv
  store i32 %add21, i32* %h32, align 4
  %37 = load i32, i32* %h32, align 4
  %38 = load i8*, i8** %input.addr, align 8
  %39 = load i64, i64* %len.addr, align 8
  %and = and i64 %39, 15
  %40 = load i32, i32* %align.addr, align 4
  %call22 = call i32 @XXH32_finalize(i32 %37, i8* %38, i64 %and, i32 %40)
  ret i32 %call22
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.XXH32_state_s* @XXH32_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 48)
  %0 = bitcast i8* %call to %struct.XXH32_state_s*
  ret %struct.XXH32_state_s* %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @XXH_malloc(i64 %s) #0 {
entry:
  %s.addr = alloca i64, align 8
  store i64 %s, i64* %s.addr, align 8
  %0 = load i64, i64* %s.addr, align 8
  %call = call i8* @malloc(i64 %0) #9
  ret i8* %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_freeState(%struct.XXH32_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH_free(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  call void @free(i8* %0)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH32_copyState(%struct.XXH32_state_s* %dstState, %struct.XXH32_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH32_state_s*, align 8
  %srcState.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %dstState, %struct.XXH32_state_s** %dstState.addr, align 8
  store %struct.XXH32_state_s* %srcState, %struct.XXH32_state_s** %srcState.addr, align 8
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  %2 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %srcState.addr, align 8
  %3 = bitcast %struct.XXH32_state_s* %2 to i8*
  %4 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8
  %5 = bitcast %struct.XXH32_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 48, i64 %6) #10
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #1

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_reset(%struct.XXH32_state_s* %statePtr, i32 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  %seed.addr = alloca i32, align 4
  %state = alloca %struct.XXH32_state_s, align 4
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  %0 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %0, i8 0, i64 48, i1 false)
  %1 = load i32, i32* %seed.addr, align 4
  %add = add i32 %1, -1640531535
  %add1 = add i32 %add, -2048144777
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 2
  store i32 %add1, i32* %v1, align 4
  %2 = load i32, i32* %seed.addr, align 4
  %add2 = add i32 %2, -2048144777
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 3
  store i32 %add2, i32* %v2, align 4
  %3 = load i32, i32* %seed.addr, align 4
  %add3 = add i32 %3, 0
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 4
  store i32 %add3, i32* %v3, align 4
  %4 = load i32, i32* %seed.addr, align 4
  %sub = sub i32 %4, -1640531535
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 5
  store i32 %sub, i32* %v4, align 4
  %5 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8
  %6 = bitcast %struct.XXH32_state_s* %5 to i8*
  %7 = bitcast %struct.XXH32_state_s* %state to i8*
  %8 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8
  %9 = bitcast %struct.XXH32_state_s* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 44, i64 %10) #10
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #3

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_update(%struct.XXH32_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %p32 = alloca i32*, align 8
  %limit = alloca i8*, align 8
  %v155 = alloca i32, align 4
  %v257 = alloca i32, align 4
  %v359 = alloca i32, align 4
  %v461 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  store i8* %1, i8** %p, align 8
  %2 = load i8*, i8** %p, align 8
  %3 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %3
  store i8* %add.ptr, i8** %bEnd, align 8
  %4 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %5, i32 0, i32 0
  %6 = load i32, i32* %total_len_32, align 4
  %add = add i32 %6, %conv
  store i32 %add, i32* %total_len_32, align 4
  %7 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp uge i64 %7, 16
  %conv2 = zext i1 %cmp1 to i32
  %8 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %total_len_323 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %8, i32 0, i32 0
  %9 = load i32, i32* %total_len_323, align 4
  %cmp4 = icmp uge i32 %9, 16
  %conv5 = zext i1 %cmp4 to i32
  %or = or i32 %conv2, %conv5
  %10 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %10, i32 0, i32 1
  %11 = load i32, i32* %large_len, align 4
  %or6 = or i32 %11, %or
  store i32 %or6, i32* %large_len, align 4
  %12 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %12, i32 0, i32 7
  %13 = load i32, i32* %memsize, align 4
  %conv7 = zext i32 %13 to i64
  %14 = load i64, i64* %len.addr, align 8
  %add8 = add i64 %conv7, %14
  %cmp9 = icmp ult i64 %add8, 16
  br i1 %cmp9, label %if.then11, label %if.end17

if.then11:                                        ; preds = %if.end
  %15 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %15, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %16 = bitcast i32* %arraydecay to i8*
  %17 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize12 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %17, i32 0, i32 7
  %18 = load i32, i32* %memsize12, align 4
  %idx.ext = zext i32 %18 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %16, i64 %idx.ext
  %19 = load i8*, i8** %input.addr, align 8
  %20 = load i64, i64* %len.addr, align 8
  %call = call i8* @XXH_memcpy(i8* %add.ptr13, i8* %19, i64 %20)
  %21 = load i64, i64* %len.addr, align 8
  %conv14 = trunc i64 %21 to i32
  %22 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize15 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %22, i32 0, i32 7
  %23 = load i32, i32* %memsize15, align 4
  %add16 = add i32 %23, %conv14
  store i32 %add16, i32* %memsize15, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end
  %24 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize18 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %24, i32 0, i32 7
  %25 = load i32, i32* %memsize18, align 4
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.then19, label %if.end49

if.then19:                                        ; preds = %if.end17
  %26 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem3220 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %26, i32 0, i32 6
  %arraydecay21 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3220, i32 0, i32 0
  %27 = bitcast i32* %arraydecay21 to i8*
  %28 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize22 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %28, i32 0, i32 7
  %29 = load i32, i32* %memsize22, align 4
  %idx.ext23 = zext i32 %29 to i64
  %add.ptr24 = getelementptr inbounds i8, i8* %27, i64 %idx.ext23
  %30 = load i8*, i8** %input.addr, align 8
  %31 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize25 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %31, i32 0, i32 7
  %32 = load i32, i32* %memsize25, align 4
  %sub = sub i32 16, %32
  %conv26 = zext i32 %sub to i64
  %call27 = call i8* @XXH_memcpy(i8* %add.ptr24, i8* %30, i64 %conv26)
  %33 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem3228 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %33, i32 0, i32 6
  %arraydecay29 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3228, i32 0, i32 0
  store i32* %arraydecay29, i32** %p32, align 8
  %34 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %34, i32 0, i32 2
  %35 = load i32, i32* %v1, align 4
  %36 = load i32*, i32** %p32, align 8
  %37 = bitcast i32* %36 to i8*
  %call30 = call i32 @XXH_readLE32(i8* %37)
  %call31 = call i32 @XXH32_round(i32 %35, i32 %call30)
  %38 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v132 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %38, i32 0, i32 2
  store i32 %call31, i32* %v132, align 4
  %39 = load i32*, i32** %p32, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %39, i32 1
  store i32* %incdec.ptr, i32** %p32, align 8
  %40 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %40, i32 0, i32 3
  %41 = load i32, i32* %v2, align 4
  %42 = load i32*, i32** %p32, align 8
  %43 = bitcast i32* %42 to i8*
  %call33 = call i32 @XXH_readLE32(i8* %43)
  %call34 = call i32 @XXH32_round(i32 %41, i32 %call33)
  %44 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v235 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %44, i32 0, i32 3
  store i32 %call34, i32* %v235, align 4
  %45 = load i32*, i32** %p32, align 8
  %incdec.ptr36 = getelementptr inbounds i32, i32* %45, i32 1
  store i32* %incdec.ptr36, i32** %p32, align 8
  %46 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %46, i32 0, i32 4
  %47 = load i32, i32* %v3, align 4
  %48 = load i32*, i32** %p32, align 8
  %49 = bitcast i32* %48 to i8*
  %call37 = call i32 @XXH_readLE32(i8* %49)
  %call38 = call i32 @XXH32_round(i32 %47, i32 %call37)
  %50 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v339 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %50, i32 0, i32 4
  store i32 %call38, i32* %v339, align 4
  %51 = load i32*, i32** %p32, align 8
  %incdec.ptr40 = getelementptr inbounds i32, i32* %51, i32 1
  store i32* %incdec.ptr40, i32** %p32, align 8
  %52 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %52, i32 0, i32 5
  %53 = load i32, i32* %v4, align 4
  %54 = load i32*, i32** %p32, align 8
  %55 = bitcast i32* %54 to i8*
  %call41 = call i32 @XXH_readLE32(i8* %55)
  %call42 = call i32 @XXH32_round(i32 %53, i32 %call41)
  %56 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v443 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %56, i32 0, i32 5
  store i32 %call42, i32* %v443, align 4
  %57 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize44 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %57, i32 0, i32 7
  %58 = load i32, i32* %memsize44, align 4
  %sub45 = sub i32 16, %58
  %59 = load i8*, i8** %p, align 8
  %idx.ext46 = zext i32 %sub45 to i64
  %add.ptr47 = getelementptr inbounds i8, i8* %59, i64 %idx.ext46
  store i8* %add.ptr47, i8** %p, align 8
  %60 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize48 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %60, i32 0, i32 7
  store i32 0, i32* %memsize48, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then19, %if.end17
  %61 = load i8*, i8** %p, align 8
  %62 = load i8*, i8** %bEnd, align 8
  %add.ptr50 = getelementptr inbounds i8, i8* %62, i64 -16
  %cmp51 = icmp ule i8* %61, %add.ptr50
  br i1 %cmp51, label %if.then53, label %if.end81

if.then53:                                        ; preds = %if.end49
  %63 = load i8*, i8** %bEnd, align 8
  %add.ptr54 = getelementptr inbounds i8, i8* %63, i64 -16
  store i8* %add.ptr54, i8** %limit, align 8
  %64 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v156 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %64, i32 0, i32 2
  %65 = load i32, i32* %v156, align 4
  store i32 %65, i32* %v155, align 4
  %66 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v258 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %66, i32 0, i32 3
  %67 = load i32, i32* %v258, align 4
  store i32 %67, i32* %v257, align 4
  %68 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v360 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %68, i32 0, i32 4
  %69 = load i32, i32* %v360, align 4
  store i32 %69, i32* %v359, align 4
  %70 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v462 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %70, i32 0, i32 5
  %71 = load i32, i32* %v462, align 4
  store i32 %71, i32* %v461, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then53
  %72 = load i32, i32* %v155, align 4
  %73 = load i8*, i8** %p, align 8
  %call63 = call i32 @XXH_readLE32(i8* %73)
  %call64 = call i32 @XXH32_round(i32 %72, i32 %call63)
  store i32 %call64, i32* %v155, align 4
  %74 = load i8*, i8** %p, align 8
  %add.ptr65 = getelementptr inbounds i8, i8* %74, i64 4
  store i8* %add.ptr65, i8** %p, align 8
  %75 = load i32, i32* %v257, align 4
  %76 = load i8*, i8** %p, align 8
  %call66 = call i32 @XXH_readLE32(i8* %76)
  %call67 = call i32 @XXH32_round(i32 %75, i32 %call66)
  store i32 %call67, i32* %v257, align 4
  %77 = load i8*, i8** %p, align 8
  %add.ptr68 = getelementptr inbounds i8, i8* %77, i64 4
  store i8* %add.ptr68, i8** %p, align 8
  %78 = load i32, i32* %v359, align 4
  %79 = load i8*, i8** %p, align 8
  %call69 = call i32 @XXH_readLE32(i8* %79)
  %call70 = call i32 @XXH32_round(i32 %78, i32 %call69)
  store i32 %call70, i32* %v359, align 4
  %80 = load i8*, i8** %p, align 8
  %add.ptr71 = getelementptr inbounds i8, i8* %80, i64 4
  store i8* %add.ptr71, i8** %p, align 8
  %81 = load i32, i32* %v461, align 4
  %82 = load i8*, i8** %p, align 8
  %call72 = call i32 @XXH_readLE32(i8* %82)
  %call73 = call i32 @XXH32_round(i32 %81, i32 %call72)
  store i32 %call73, i32* %v461, align 4
  %83 = load i8*, i8** %p, align 8
  %add.ptr74 = getelementptr inbounds i8, i8* %83, i64 4
  store i8* %add.ptr74, i8** %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %84 = load i8*, i8** %p, align 8
  %85 = load i8*, i8** %limit, align 8
  %cmp75 = icmp ule i8* %84, %85
  br i1 %cmp75, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %86 = load i32, i32* %v155, align 4
  %87 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v177 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %87, i32 0, i32 2
  store i32 %86, i32* %v177, align 4
  %88 = load i32, i32* %v257, align 4
  %89 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v278 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %89, i32 0, i32 3
  store i32 %88, i32* %v278, align 4
  %90 = load i32, i32* %v359, align 4
  %91 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v379 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %91, i32 0, i32 4
  store i32 %90, i32* %v379, align 4
  %92 = load i32, i32* %v461, align 4
  %93 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v480 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %93, i32 0, i32 5
  store i32 %92, i32* %v480, align 4
  br label %if.end81

if.end81:                                         ; preds = %do.end, %if.end49
  %94 = load i8*, i8** %p, align 8
  %95 = load i8*, i8** %bEnd, align 8
  %cmp82 = icmp ult i8* %94, %95
  br i1 %cmp82, label %if.then84, label %if.end93

if.then84:                                        ; preds = %if.end81
  %96 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem3285 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %96, i32 0, i32 6
  %arraydecay86 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3285, i32 0, i32 0
  %97 = bitcast i32* %arraydecay86 to i8*
  %98 = load i8*, i8** %p, align 8
  %99 = load i8*, i8** %bEnd, align 8
  %100 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %99 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %100 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call87 = call i8* @XXH_memcpy(i8* %97, i8* %98, i64 %sub.ptr.sub)
  %101 = load i8*, i8** %bEnd, align 8
  %102 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast88 = ptrtoint i8* %101 to i64
  %sub.ptr.rhs.cast89 = ptrtoint i8* %102 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %conv91 = trunc i64 %sub.ptr.sub90 to i32
  %103 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize92 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %103, i32 0, i32 7
  store i32 %conv91, i32* %memsize92, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then84, %if.end81
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end93, %if.then11, %if.then
  %104 = load i32, i32* %retval, align 4
  ret i32 %104
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @XXH_memcpy(i8* %dest, i8* %src, i64 %size) #0 {
entry:
  %dest.addr = alloca i8*, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  store i8* %dest, i8** %dest.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i8*, i8** %dest.addr, align 8
  %1 = load i8*, i8** %src.addr, align 8
  %2 = load i64, i64* %size.addr, align 8
  %3 = load i8*, i8** %dest.addr, align 8
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 %2, i64 %4) #10
  ret i8* %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_round(i32 %acc, i32 %input) #0 {
entry:
  %acc.addr = alloca i32, align 4
  %input.addr = alloca i32, align 4
  store i32 %acc, i32* %acc.addr, align 4
  store i32 %input, i32* %input.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %mul = mul i32 %0, -2048144777
  %1 = load i32, i32* %acc.addr, align 4
  %add = add i32 %1, %mul
  store i32 %add, i32* %acc.addr, align 4
  %2 = load i32, i32* %acc.addr, align 4
  %3 = call i32 @llvm.fshl.i32(i32 %2, i32 %2, i32 13)
  store i32 %3, i32* %acc.addr, align 4
  %4 = load i32, i32* %acc.addr, align 4
  %mul1 = mul i32 %4, -1640531535
  store i32 %mul1, i32* %acc.addr, align 4
  %5 = load i32, i32* %acc.addr, align 4
  %6 = call i32 asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %5) #8, !srcloc !4
  store i32 %6, i32* %acc.addr, align 4
  %7 = load i32, i32* %acc.addr, align 4
  ret i32 %7
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_readLE32(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i32 @XXH_read32(i8* %0)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_digest(%struct.XXH32_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %h32 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %0, i32 0, i32 1
  %1 = load i32, i32* %large_len, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %2, i32 0, i32 2
  %3 = load i32, i32* %v1, align 4
  %4 = call i32 @llvm.fshl.i32(i32 %3, i32 %3, i32 1)
  %5 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %5, i32 0, i32 3
  %6 = load i32, i32* %v2, align 4
  %7 = call i32 @llvm.fshl.i32(i32 %6, i32 %6, i32 7)
  %add = add i32 %4, %7
  %8 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %8, i32 0, i32 4
  %9 = load i32, i32* %v3, align 4
  %10 = call i32 @llvm.fshl.i32(i32 %9, i32 %9, i32 12)
  %add1 = add i32 %add, %10
  %11 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %11, i32 0, i32 5
  %12 = load i32, i32* %v4, align 4
  %13 = call i32 @llvm.fshl.i32(i32 %12, i32 %12, i32 18)
  %add2 = add i32 %add1, %13
  store i32 %add2, i32* %h32, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %14 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %v33 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %14, i32 0, i32 4
  %15 = load i32, i32* %v33, align 4
  %add4 = add i32 %15, 374761393
  store i32 %add4, i32* %h32, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %16, i32 0, i32 0
  %17 = load i32, i32* %total_len_32, align 4
  %18 = load i32, i32* %h32, align 4
  %add5 = add i32 %18, %17
  store i32 %add5, i32* %h32, align 4
  %19 = load i32, i32* %h32, align 4
  %20 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %20, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %21 = bitcast i32* %arraydecay to i8*
  %22 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %22, i32 0, i32 7
  %23 = load i32, i32* %memsize, align 4
  %conv = zext i32 %23 to i64
  %call = call i32 @XXH32_finalize(i32 %19, i8* %21, i64 %conv, i32 0)
  ret i32 %call
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.fshl.i32(i32, i32, i32) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_finalize(i32 %h32, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i32, align 4
  %h32.addr = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i64, i64* %len.addr, align 8
  %and = and i64 %0, 15
  switch i64 %and, label %sw.epilog [
    i64 12, label %sw.bb
    i64 8, label %sw.bb2
    i64 4, label %sw.bb10
    i64 13, label %sw.bb19
    i64 9, label %sw.bb27
    i64 5, label %sw.bb35
    i64 14, label %sw.bb49
    i64 10, label %sw.bb57
    i64 6, label %sw.bb65
    i64 15, label %sw.bb88
    i64 11, label %sw.bb96
    i64 7, label %sw.bb104
    i64 3, label %sw.bb112
    i64 2, label %sw.bb120
    i64 1, label %sw.bb128
    i64 0, label %sw.bb136
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i8*, i8** %ptr.addr, align 8
  %2 = load i32, i32* %align.addr, align 4
  %call = call i32 @XXH_readLE32_align(i8* %1, i32 %2)
  %mul = mul i32 %call, -1028477379
  %3 = load i32, i32* %h32.addr, align 4
  %add = add i32 %3, %mul
  store i32 %add, i32* %h32.addr, align 4
  %4 = load i8*, i8** %ptr.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 4
  store i8* %add.ptr, i8** %ptr.addr, align 8
  %5 = load i32, i32* %h32.addr, align 4
  %6 = call i32 @llvm.fshl.i32(i32 %5, i32 %5, i32 17)
  %mul1 = mul i32 %6, 668265263
  store i32 %mul1, i32* %h32.addr, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %7 = load i8*, i8** %ptr.addr, align 8
  %8 = load i32, i32* %align.addr, align 4
  %call4 = call i32 @XXH_readLE32_align(i8* %7, i32 %8)
  %mul5 = mul i32 %call4, -1028477379
  %9 = load i32, i32* %h32.addr, align 4
  %add6 = add i32 %9, %mul5
  store i32 %add6, i32* %h32.addr, align 4
  %10 = load i8*, i8** %ptr.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 4
  store i8* %add.ptr7, i8** %ptr.addr, align 8
  %11 = load i32, i32* %h32.addr, align 4
  %12 = call i32 @llvm.fshl.i32(i32 %11, i32 %11, i32 17)
  %mul8 = mul i32 %12, 668265263
  store i32 %mul8, i32* %h32.addr, align 4
  br label %do.end9

do.end9:                                          ; preds = %do.body3
  br label %sw.bb10

sw.bb10:                                          ; preds = %entry, %do.end9
  br label %do.body11

do.body11:                                        ; preds = %sw.bb10
  %13 = load i8*, i8** %ptr.addr, align 8
  %14 = load i32, i32* %align.addr, align 4
  %call12 = call i32 @XXH_readLE32_align(i8* %13, i32 %14)
  %mul13 = mul i32 %call12, -1028477379
  %15 = load i32, i32* %h32.addr, align 4
  %add14 = add i32 %15, %mul13
  store i32 %add14, i32* %h32.addr, align 4
  %16 = load i8*, i8** %ptr.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %16, i64 4
  store i8* %add.ptr15, i8** %ptr.addr, align 8
  %17 = load i32, i32* %h32.addr, align 4
  %18 = call i32 @llvm.fshl.i32(i32 %17, i32 %17, i32 17)
  %mul16 = mul i32 %18, 668265263
  store i32 %mul16, i32* %h32.addr, align 4
  br label %do.end17

do.end17:                                         ; preds = %do.body11
  %19 = load i32, i32* %h32.addr, align 4
  %call18 = call i32 @XXH32_avalanche(i32 %19)
  store i32 %call18, i32* %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  br label %do.body20

do.body20:                                        ; preds = %sw.bb19
  %20 = load i8*, i8** %ptr.addr, align 8
  %21 = load i32, i32* %align.addr, align 4
  %call21 = call i32 @XXH_readLE32_align(i8* %20, i32 %21)
  %mul22 = mul i32 %call21, -1028477379
  %22 = load i32, i32* %h32.addr, align 4
  %add23 = add i32 %22, %mul22
  store i32 %add23, i32* %h32.addr, align 4
  %23 = load i8*, i8** %ptr.addr, align 8
  %add.ptr24 = getelementptr inbounds i8, i8* %23, i64 4
  store i8* %add.ptr24, i8** %ptr.addr, align 8
  %24 = load i32, i32* %h32.addr, align 4
  %25 = call i32 @llvm.fshl.i32(i32 %24, i32 %24, i32 17)
  %mul25 = mul i32 %25, 668265263
  store i32 %mul25, i32* %h32.addr, align 4
  br label %do.end26

do.end26:                                         ; preds = %do.body20
  br label %sw.bb27

sw.bb27:                                          ; preds = %entry, %do.end26
  br label %do.body28

do.body28:                                        ; preds = %sw.bb27
  %26 = load i8*, i8** %ptr.addr, align 8
  %27 = load i32, i32* %align.addr, align 4
  %call29 = call i32 @XXH_readLE32_align(i8* %26, i32 %27)
  %mul30 = mul i32 %call29, -1028477379
  %28 = load i32, i32* %h32.addr, align 4
  %add31 = add i32 %28, %mul30
  store i32 %add31, i32* %h32.addr, align 4
  %29 = load i8*, i8** %ptr.addr, align 8
  %add.ptr32 = getelementptr inbounds i8, i8* %29, i64 4
  store i8* %add.ptr32, i8** %ptr.addr, align 8
  %30 = load i32, i32* %h32.addr, align 4
  %31 = call i32 @llvm.fshl.i32(i32 %30, i32 %30, i32 17)
  %mul33 = mul i32 %31, 668265263
  store i32 %mul33, i32* %h32.addr, align 4
  br label %do.end34

do.end34:                                         ; preds = %do.body28
  br label %sw.bb35

sw.bb35:                                          ; preds = %entry, %do.end34
  br label %do.body36

do.body36:                                        ; preds = %sw.bb35
  %32 = load i8*, i8** %ptr.addr, align 8
  %33 = load i32, i32* %align.addr, align 4
  %call37 = call i32 @XXH_readLE32_align(i8* %32, i32 %33)
  %mul38 = mul i32 %call37, -1028477379
  %34 = load i32, i32* %h32.addr, align 4
  %add39 = add i32 %34, %mul38
  store i32 %add39, i32* %h32.addr, align 4
  %35 = load i8*, i8** %ptr.addr, align 8
  %add.ptr40 = getelementptr inbounds i8, i8* %35, i64 4
  store i8* %add.ptr40, i8** %ptr.addr, align 8
  %36 = load i32, i32* %h32.addr, align 4
  %37 = call i32 @llvm.fshl.i32(i32 %36, i32 %36, i32 17)
  %mul41 = mul i32 %37, 668265263
  store i32 %mul41, i32* %h32.addr, align 4
  br label %do.end42

do.end42:                                         ; preds = %do.body36
  br label %do.body43

do.body43:                                        ; preds = %do.end42
  %38 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %38, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8
  %39 = load i8, i8* %38, align 1
  %conv = zext i8 %39 to i32
  %mul44 = mul i32 %conv, 374761393
  %40 = load i32, i32* %h32.addr, align 4
  %add45 = add i32 %40, %mul44
  store i32 %add45, i32* %h32.addr, align 4
  %41 = load i32, i32* %h32.addr, align 4
  %42 = call i32 @llvm.fshl.i32(i32 %41, i32 %41, i32 11)
  %mul46 = mul i32 %42, -1640531535
  store i32 %mul46, i32* %h32.addr, align 4
  br label %do.end47

do.end47:                                         ; preds = %do.body43
  %43 = load i32, i32* %h32.addr, align 4
  %call48 = call i32 @XXH32_avalanche(i32 %43)
  store i32 %call48, i32* %retval, align 4
  br label %return

sw.bb49:                                          ; preds = %entry
  br label %do.body50

do.body50:                                        ; preds = %sw.bb49
  %44 = load i8*, i8** %ptr.addr, align 8
  %45 = load i32, i32* %align.addr, align 4
  %call51 = call i32 @XXH_readLE32_align(i8* %44, i32 %45)
  %mul52 = mul i32 %call51, -1028477379
  %46 = load i32, i32* %h32.addr, align 4
  %add53 = add i32 %46, %mul52
  store i32 %add53, i32* %h32.addr, align 4
  %47 = load i8*, i8** %ptr.addr, align 8
  %add.ptr54 = getelementptr inbounds i8, i8* %47, i64 4
  store i8* %add.ptr54, i8** %ptr.addr, align 8
  %48 = load i32, i32* %h32.addr, align 4
  %49 = call i32 @llvm.fshl.i32(i32 %48, i32 %48, i32 17)
  %mul55 = mul i32 %49, 668265263
  store i32 %mul55, i32* %h32.addr, align 4
  br label %do.end56

do.end56:                                         ; preds = %do.body50
  br label %sw.bb57

sw.bb57:                                          ; preds = %entry, %do.end56
  br label %do.body58

do.body58:                                        ; preds = %sw.bb57
  %50 = load i8*, i8** %ptr.addr, align 8
  %51 = load i32, i32* %align.addr, align 4
  %call59 = call i32 @XXH_readLE32_align(i8* %50, i32 %51)
  %mul60 = mul i32 %call59, -1028477379
  %52 = load i32, i32* %h32.addr, align 4
  %add61 = add i32 %52, %mul60
  store i32 %add61, i32* %h32.addr, align 4
  %53 = load i8*, i8** %ptr.addr, align 8
  %add.ptr62 = getelementptr inbounds i8, i8* %53, i64 4
  store i8* %add.ptr62, i8** %ptr.addr, align 8
  %54 = load i32, i32* %h32.addr, align 4
  %55 = call i32 @llvm.fshl.i32(i32 %54, i32 %54, i32 17)
  %mul63 = mul i32 %55, 668265263
  store i32 %mul63, i32* %h32.addr, align 4
  br label %do.end64

do.end64:                                         ; preds = %do.body58
  br label %sw.bb65

sw.bb65:                                          ; preds = %entry, %do.end64
  br label %do.body66

do.body66:                                        ; preds = %sw.bb65
  %56 = load i8*, i8** %ptr.addr, align 8
  %57 = load i32, i32* %align.addr, align 4
  %call67 = call i32 @XXH_readLE32_align(i8* %56, i32 %57)
  %mul68 = mul i32 %call67, -1028477379
  %58 = load i32, i32* %h32.addr, align 4
  %add69 = add i32 %58, %mul68
  store i32 %add69, i32* %h32.addr, align 4
  %59 = load i8*, i8** %ptr.addr, align 8
  %add.ptr70 = getelementptr inbounds i8, i8* %59, i64 4
  store i8* %add.ptr70, i8** %ptr.addr, align 8
  %60 = load i32, i32* %h32.addr, align 4
  %61 = call i32 @llvm.fshl.i32(i32 %60, i32 %60, i32 17)
  %mul71 = mul i32 %61, 668265263
  store i32 %mul71, i32* %h32.addr, align 4
  br label %do.end72

do.end72:                                         ; preds = %do.body66
  br label %do.body73

do.body73:                                        ; preds = %do.end72
  %62 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr74 = getelementptr inbounds i8, i8* %62, i32 1
  store i8* %incdec.ptr74, i8** %ptr.addr, align 8
  %63 = load i8, i8* %62, align 1
  %conv75 = zext i8 %63 to i32
  %mul76 = mul i32 %conv75, 374761393
  %64 = load i32, i32* %h32.addr, align 4
  %add77 = add i32 %64, %mul76
  store i32 %add77, i32* %h32.addr, align 4
  %65 = load i32, i32* %h32.addr, align 4
  %66 = call i32 @llvm.fshl.i32(i32 %65, i32 %65, i32 11)
  %mul78 = mul i32 %66, -1640531535
  store i32 %mul78, i32* %h32.addr, align 4
  br label %do.end79

do.end79:                                         ; preds = %do.body73
  br label %do.body80

do.body80:                                        ; preds = %do.end79
  %67 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr81 = getelementptr inbounds i8, i8* %67, i32 1
  store i8* %incdec.ptr81, i8** %ptr.addr, align 8
  %68 = load i8, i8* %67, align 1
  %conv82 = zext i8 %68 to i32
  %mul83 = mul i32 %conv82, 374761393
  %69 = load i32, i32* %h32.addr, align 4
  %add84 = add i32 %69, %mul83
  store i32 %add84, i32* %h32.addr, align 4
  %70 = load i32, i32* %h32.addr, align 4
  %71 = call i32 @llvm.fshl.i32(i32 %70, i32 %70, i32 11)
  %mul85 = mul i32 %71, -1640531535
  store i32 %mul85, i32* %h32.addr, align 4
  br label %do.end86

do.end86:                                         ; preds = %do.body80
  %72 = load i32, i32* %h32.addr, align 4
  %call87 = call i32 @XXH32_avalanche(i32 %72)
  store i32 %call87, i32* %retval, align 4
  br label %return

sw.bb88:                                          ; preds = %entry
  br label %do.body89

do.body89:                                        ; preds = %sw.bb88
  %73 = load i8*, i8** %ptr.addr, align 8
  %74 = load i32, i32* %align.addr, align 4
  %call90 = call i32 @XXH_readLE32_align(i8* %73, i32 %74)
  %mul91 = mul i32 %call90, -1028477379
  %75 = load i32, i32* %h32.addr, align 4
  %add92 = add i32 %75, %mul91
  store i32 %add92, i32* %h32.addr, align 4
  %76 = load i8*, i8** %ptr.addr, align 8
  %add.ptr93 = getelementptr inbounds i8, i8* %76, i64 4
  store i8* %add.ptr93, i8** %ptr.addr, align 8
  %77 = load i32, i32* %h32.addr, align 4
  %78 = call i32 @llvm.fshl.i32(i32 %77, i32 %77, i32 17)
  %mul94 = mul i32 %78, 668265263
  store i32 %mul94, i32* %h32.addr, align 4
  br label %do.end95

do.end95:                                         ; preds = %do.body89
  br label %sw.bb96

sw.bb96:                                          ; preds = %entry, %do.end95
  br label %do.body97

do.body97:                                        ; preds = %sw.bb96
  %79 = load i8*, i8** %ptr.addr, align 8
  %80 = load i32, i32* %align.addr, align 4
  %call98 = call i32 @XXH_readLE32_align(i8* %79, i32 %80)
  %mul99 = mul i32 %call98, -1028477379
  %81 = load i32, i32* %h32.addr, align 4
  %add100 = add i32 %81, %mul99
  store i32 %add100, i32* %h32.addr, align 4
  %82 = load i8*, i8** %ptr.addr, align 8
  %add.ptr101 = getelementptr inbounds i8, i8* %82, i64 4
  store i8* %add.ptr101, i8** %ptr.addr, align 8
  %83 = load i32, i32* %h32.addr, align 4
  %84 = call i32 @llvm.fshl.i32(i32 %83, i32 %83, i32 17)
  %mul102 = mul i32 %84, 668265263
  store i32 %mul102, i32* %h32.addr, align 4
  br label %do.end103

do.end103:                                        ; preds = %do.body97
  br label %sw.bb104

sw.bb104:                                         ; preds = %entry, %do.end103
  br label %do.body105

do.body105:                                       ; preds = %sw.bb104
  %85 = load i8*, i8** %ptr.addr, align 8
  %86 = load i32, i32* %align.addr, align 4
  %call106 = call i32 @XXH_readLE32_align(i8* %85, i32 %86)
  %mul107 = mul i32 %call106, -1028477379
  %87 = load i32, i32* %h32.addr, align 4
  %add108 = add i32 %87, %mul107
  store i32 %add108, i32* %h32.addr, align 4
  %88 = load i8*, i8** %ptr.addr, align 8
  %add.ptr109 = getelementptr inbounds i8, i8* %88, i64 4
  store i8* %add.ptr109, i8** %ptr.addr, align 8
  %89 = load i32, i32* %h32.addr, align 4
  %90 = call i32 @llvm.fshl.i32(i32 %89, i32 %89, i32 17)
  %mul110 = mul i32 %90, 668265263
  store i32 %mul110, i32* %h32.addr, align 4
  br label %do.end111

do.end111:                                        ; preds = %do.body105
  br label %sw.bb112

sw.bb112:                                         ; preds = %entry, %do.end111
  br label %do.body113

do.body113:                                       ; preds = %sw.bb112
  %91 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr114 = getelementptr inbounds i8, i8* %91, i32 1
  store i8* %incdec.ptr114, i8** %ptr.addr, align 8
  %92 = load i8, i8* %91, align 1
  %conv115 = zext i8 %92 to i32
  %mul116 = mul i32 %conv115, 374761393
  %93 = load i32, i32* %h32.addr, align 4
  %add117 = add i32 %93, %mul116
  store i32 %add117, i32* %h32.addr, align 4
  %94 = load i32, i32* %h32.addr, align 4
  %95 = call i32 @llvm.fshl.i32(i32 %94, i32 %94, i32 11)
  %mul118 = mul i32 %95, -1640531535
  store i32 %mul118, i32* %h32.addr, align 4
  br label %do.end119

do.end119:                                        ; preds = %do.body113
  br label %sw.bb120

sw.bb120:                                         ; preds = %entry, %do.end119
  br label %do.body121

do.body121:                                       ; preds = %sw.bb120
  %96 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr122 = getelementptr inbounds i8, i8* %96, i32 1
  store i8* %incdec.ptr122, i8** %ptr.addr, align 8
  %97 = load i8, i8* %96, align 1
  %conv123 = zext i8 %97 to i32
  %mul124 = mul i32 %conv123, 374761393
  %98 = load i32, i32* %h32.addr, align 4
  %add125 = add i32 %98, %mul124
  store i32 %add125, i32* %h32.addr, align 4
  %99 = load i32, i32* %h32.addr, align 4
  %100 = call i32 @llvm.fshl.i32(i32 %99, i32 %99, i32 11)
  %mul126 = mul i32 %100, -1640531535
  store i32 %mul126, i32* %h32.addr, align 4
  br label %do.end127

do.end127:                                        ; preds = %do.body121
  br label %sw.bb128

sw.bb128:                                         ; preds = %entry, %do.end127
  br label %do.body129

do.body129:                                       ; preds = %sw.bb128
  %101 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr130 = getelementptr inbounds i8, i8* %101, i32 1
  store i8* %incdec.ptr130, i8** %ptr.addr, align 8
  %102 = load i8, i8* %101, align 1
  %conv131 = zext i8 %102 to i32
  %mul132 = mul i32 %conv131, 374761393
  %103 = load i32, i32* %h32.addr, align 4
  %add133 = add i32 %103, %mul132
  store i32 %add133, i32* %h32.addr, align 4
  %104 = load i32, i32* %h32.addr, align 4
  %105 = call i32 @llvm.fshl.i32(i32 %104, i32 %104, i32 11)
  %mul134 = mul i32 %105, -1640531535
  store i32 %mul134, i32* %h32.addr, align 4
  br label %do.end135

do.end135:                                        ; preds = %do.body129
  br label %sw.bb136

sw.bb136:                                         ; preds = %entry, %do.end135
  %106 = load i32, i32* %h32.addr, align 4
  %call137 = call i32 @XXH32_avalanche(i32 %106)
  store i32 %call137, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %entry
  %107 = load i32, i32* %h32.addr, align 4
  store i32 %107, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb136, %do.end86, %do.end47, %do.end17
  %108 = load i32, i32* %retval, align 4
  ret i32 %108
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH32_canonicalFromHash(%struct.XXH32_canonical_t* %dst, i32 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH32_canonical_t*, align 8
  %hash.addr = alloca i32, align 4
  store %struct.XXH32_canonical_t* %dst, %struct.XXH32_canonical_t** %dst.addr, align 8
  store i32 %hash, i32* %hash.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, i32* %hash.addr, align 4
  %call = call i32 @XXH_swap32(i32 %0)
  store i32 %call, i32* %hash.addr, align 4
  %1 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8
  %2 = bitcast %struct.XXH32_canonical_t* %1 to i8*
  %3 = bitcast i32* %hash.addr to i8*
  %4 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8
  %5 = bitcast %struct.XXH32_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 4, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_swap32(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = load i32, i32* %x.addr, align 4
  %shl = shl i32 %0, 24
  %and = and i32 %shl, -16777216
  %1 = load i32, i32* %x.addr, align 4
  %shl1 = shl i32 %1, 8
  %and2 = and i32 %shl1, 16711680
  %or = or i32 %and, %and2
  %2 = load i32, i32* %x.addr, align 4
  %shr = lshr i32 %2, 8
  %and3 = and i32 %shr, 65280
  %or4 = or i32 %or, %and3
  %3 = load i32, i32* %x.addr, align 4
  %shr5 = lshr i32 %3, 24
  %and6 = and i32 %shr5, 255
  %or7 = or i32 %or4, %and6
  ret i32 %or7
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH32_hashFromCanonical(%struct.XXH32_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH32_canonical_t*, align 8
  store %struct.XXH32_canonical_t* %src, %struct.XXH32_canonical_t** %src.addr, align 8
  %0 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %src.addr, align 8
  %1 = bitcast %struct.XXH32_canonical_t* %0 to i8*
  %call = call i32 @XXH_readBE32(i8* %1)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_readBE32(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i32 @XXH_read32(i8* %0)
  %call1 = call i32 @XXH_swap32(i32 %call)
  ret i32 %call1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH64(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH64_endian_align(i8* %0, i64 %1, i64 %2, i32 1)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_endian_align(i8* %input, i64 %len, i64 %seed, i32 %align) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h64 = alloca i64, align 8
  %limit = alloca i8*, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %1
  store i8* %add.ptr, i8** %bEnd, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp uge i64 %2, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %bEnd, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %3, i64 -32
  store i8* %add.ptr1, i8** %limit, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %add = add i64 %4, -7046029288634856825
  %add2 = add i64 %add, -4417276706812531889
  store i64 %add2, i64* %v1, align 8
  %5 = load i64, i64* %seed.addr, align 8
  %add3 = add i64 %5, -4417276706812531889
  store i64 %add3, i64* %v2, align 8
  %6 = load i64, i64* %seed.addr, align 8
  %add4 = add i64 %6, 0
  store i64 %add4, i64* %v3, align 8
  %7 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %7, -7046029288634856825
  store i64 %sub, i64* %v4, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %8 = load i64, i64* %v1, align 8
  %9 = load i8*, i8** %input.addr, align 8
  %10 = load i32, i32* %align.addr, align 4
  %call = call i64 @XXH_readLE64_align(i8* %9, i32 %10)
  %call5 = call i64 @XXH64_round(i64 %8, i64 %call)
  store i64 %call5, i64* %v1, align 8
  %11 = load i8*, i8** %input.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 8
  store i8* %add.ptr6, i8** %input.addr, align 8
  %12 = load i64, i64* %v2, align 8
  %13 = load i8*, i8** %input.addr, align 8
  %14 = load i32, i32* %align.addr, align 4
  %call7 = call i64 @XXH_readLE64_align(i8* %13, i32 %14)
  %call8 = call i64 @XXH64_round(i64 %12, i64 %call7)
  store i64 %call8, i64* %v2, align 8
  %15 = load i8*, i8** %input.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %15, i64 8
  store i8* %add.ptr9, i8** %input.addr, align 8
  %16 = load i64, i64* %v3, align 8
  %17 = load i8*, i8** %input.addr, align 8
  %18 = load i32, i32* %align.addr, align 4
  %call10 = call i64 @XXH_readLE64_align(i8* %17, i32 %18)
  %call11 = call i64 @XXH64_round(i64 %16, i64 %call10)
  store i64 %call11, i64* %v3, align 8
  %19 = load i8*, i8** %input.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %19, i64 8
  store i8* %add.ptr12, i8** %input.addr, align 8
  %20 = load i64, i64* %v4, align 8
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i32, i32* %align.addr, align 4
  %call13 = call i64 @XXH_readLE64_align(i8* %21, i32 %22)
  %call14 = call i64 @XXH64_round(i64 %20, i64 %call13)
  store i64 %call14, i64* %v4, align 8
  %23 = load i8*, i8** %input.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %23, i64 8
  store i8* %add.ptr15, i8** %input.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %24 = load i8*, i8** %input.addr, align 8
  %25 = load i8*, i8** %limit, align 8
  %cmp16 = icmp ule i8* %24, %25
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %26 = load i64, i64* %v1, align 8
  %27 = call i64 @llvm.fshl.i64(i64 %26, i64 %26, i64 1)
  %28 = load i64, i64* %v2, align 8
  %29 = call i64 @llvm.fshl.i64(i64 %28, i64 %28, i64 7)
  %add17 = add i64 %27, %29
  %30 = load i64, i64* %v3, align 8
  %31 = call i64 @llvm.fshl.i64(i64 %30, i64 %30, i64 12)
  %add18 = add i64 %add17, %31
  %32 = load i64, i64* %v4, align 8
  %33 = call i64 @llvm.fshl.i64(i64 %32, i64 %32, i64 18)
  %add19 = add i64 %add18, %33
  store i64 %add19, i64* %h64, align 8
  %34 = load i64, i64* %h64, align 8
  %35 = load i64, i64* %v1, align 8
  %call20 = call i64 @XXH64_mergeRound(i64 %34, i64 %35)
  store i64 %call20, i64* %h64, align 8
  %36 = load i64, i64* %h64, align 8
  %37 = load i64, i64* %v2, align 8
  %call21 = call i64 @XXH64_mergeRound(i64 %36, i64 %37)
  store i64 %call21, i64* %h64, align 8
  %38 = load i64, i64* %h64, align 8
  %39 = load i64, i64* %v3, align 8
  %call22 = call i64 @XXH64_mergeRound(i64 %38, i64 %39)
  store i64 %call22, i64* %h64, align 8
  %40 = load i64, i64* %h64, align 8
  %41 = load i64, i64* %v4, align 8
  %call23 = call i64 @XXH64_mergeRound(i64 %40, i64 %41)
  store i64 %call23, i64* %h64, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %42 = load i64, i64* %seed.addr, align 8
  %add24 = add i64 %42, 2870177450012600261
  store i64 %add24, i64* %h64, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %43 = load i64, i64* %len.addr, align 8
  %44 = load i64, i64* %h64, align 8
  %add25 = add i64 %44, %43
  store i64 %add25, i64* %h64, align 8
  %45 = load i64, i64* %h64, align 8
  %46 = load i8*, i8** %input.addr, align 8
  %47 = load i64, i64* %len.addr, align 8
  %48 = load i32, i32* %align.addr, align 4
  %call26 = call i64 @XXH64_finalize(i64 %45, i8* %46, i64 %47, i32 %48)
  ret i64 %call26
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.XXH64_state_s* @XXH64_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 88)
  %0 = bitcast i8* %call to %struct.XXH64_state_s*
  ret %struct.XXH64_state_s* %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH64_freeState(%struct.XXH64_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH64_copyState(%struct.XXH64_state_s* %dstState, %struct.XXH64_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH64_state_s*, align 8
  %srcState.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %dstState, %struct.XXH64_state_s** %dstState.addr, align 8
  store %struct.XXH64_state_s* %srcState, %struct.XXH64_state_s** %srcState.addr, align 8
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  %2 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %srcState.addr, align 8
  %3 = bitcast %struct.XXH64_state_s* %2 to i8*
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8
  %5 = bitcast %struct.XXH64_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 88, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH64_reset(%struct.XXH64_state_s* %statePtr, i64 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %state = alloca %struct.XXH64_state_s, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %0, i8 0, i64 88, i1 false)
  %1 = load i64, i64* %seed.addr, align 8
  %add = add i64 %1, -7046029288634856825
  %add1 = add i64 %add, -4417276706812531889
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 1
  store i64 %add1, i64* %v1, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %add2 = add i64 %2, -4417276706812531889
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 2
  store i64 %add2, i64* %v2, align 8
  %3 = load i64, i64* %seed.addr, align 8
  %add3 = add i64 %3, 0
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 3
  store i64 %add3, i64* %v3, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %4, -7046029288634856825
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 4
  store i64 %sub, i64* %v4, align 8
  %5 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8
  %6 = bitcast %struct.XXH64_state_s* %5 to i8*
  %7 = bitcast %struct.XXH64_state_s* %state to i8*
  %8 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8
  %9 = bitcast %struct.XXH64_state_s* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 80, i64 %10) #10
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH64_update(%struct.XXH64_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %limit = alloca i8*, align 8
  %v156 = alloca i64, align 8
  %v258 = alloca i64, align 8
  %v360 = alloca i64, align 8
  %v462 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  store i8* %1, i8** %p, align 8
  %2 = load i8*, i8** %p, align 8
  %3 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %3
  store i8* %add.ptr, i8** %bEnd, align 8
  %4 = load i64, i64* %len.addr, align 8
  %5 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %5, i32 0, i32 0
  %6 = load i64, i64* %total_len, align 8
  %add = add i64 %6, %4
  store i64 %add, i64* %total_len, align 8
  %7 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %7, i32 0, i32 6
  %8 = load i32, i32* %memsize, align 8
  %conv = zext i32 %8 to i64
  %9 = load i64, i64* %len.addr, align 8
  %add1 = add i64 %conv, %9
  %cmp2 = icmp ult i64 %add1, 32
  br i1 %cmp2, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %10 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %10, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %11 = bitcast i64* %arraydecay to i8*
  %12 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize5 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %12, i32 0, i32 6
  %13 = load i32, i32* %memsize5, align 8
  %idx.ext = zext i32 %13 to i64
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 %idx.ext
  %14 = load i8*, i8** %input.addr, align 8
  %15 = load i64, i64* %len.addr, align 8
  %call = call i8* @XXH_memcpy(i8* %add.ptr6, i8* %14, i64 %15)
  %16 = load i64, i64* %len.addr, align 8
  %conv7 = trunc i64 %16 to i32
  %17 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize8 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %17, i32 0, i32 6
  %18 = load i32, i32* %memsize8, align 8
  %add9 = add i32 %18, %conv7
  store i32 %add9, i32* %memsize8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %19 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %19, i32 0, i32 6
  %20 = load i32, i32* %memsize11, align 8
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.then12, label %if.end50

if.then12:                                        ; preds = %if.end10
  %21 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6413 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %21, i32 0, i32 5
  %arraydecay14 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6413, i32 0, i32 0
  %22 = bitcast i64* %arraydecay14 to i8*
  %23 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize15 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %23, i32 0, i32 6
  %24 = load i32, i32* %memsize15, align 8
  %idx.ext16 = zext i32 %24 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %22, i64 %idx.ext16
  %25 = load i8*, i8** %input.addr, align 8
  %26 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize18 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %26, i32 0, i32 6
  %27 = load i32, i32* %memsize18, align 8
  %sub = sub i32 32, %27
  %conv19 = zext i32 %sub to i64
  %call20 = call i8* @XXH_memcpy(i8* %add.ptr17, i8* %25, i64 %conv19)
  %28 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %28, i32 0, i32 1
  %29 = load i64, i64* %v1, align 8
  %30 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6421 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %30, i32 0, i32 5
  %arraydecay22 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6421, i32 0, i32 0
  %add.ptr23 = getelementptr inbounds i64, i64* %arraydecay22, i64 0
  %31 = bitcast i64* %add.ptr23 to i8*
  %call24 = call i64 @XXH_readLE64(i8* %31)
  %call25 = call i64 @XXH64_round(i64 %29, i64 %call24)
  %32 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v126 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %32, i32 0, i32 1
  store i64 %call25, i64* %v126, align 8
  %33 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %33, i32 0, i32 2
  %34 = load i64, i64* %v2, align 8
  %35 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6427 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %35, i32 0, i32 5
  %arraydecay28 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6427, i32 0, i32 0
  %add.ptr29 = getelementptr inbounds i64, i64* %arraydecay28, i64 1
  %36 = bitcast i64* %add.ptr29 to i8*
  %call30 = call i64 @XXH_readLE64(i8* %36)
  %call31 = call i64 @XXH64_round(i64 %34, i64 %call30)
  %37 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v232 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %37, i32 0, i32 2
  store i64 %call31, i64* %v232, align 8
  %38 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %38, i32 0, i32 3
  %39 = load i64, i64* %v3, align 8
  %40 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6433 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %40, i32 0, i32 5
  %arraydecay34 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6433, i32 0, i32 0
  %add.ptr35 = getelementptr inbounds i64, i64* %arraydecay34, i64 2
  %41 = bitcast i64* %add.ptr35 to i8*
  %call36 = call i64 @XXH_readLE64(i8* %41)
  %call37 = call i64 @XXH64_round(i64 %39, i64 %call36)
  %42 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v338 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %42, i32 0, i32 3
  store i64 %call37, i64* %v338, align 8
  %43 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %43, i32 0, i32 4
  %44 = load i64, i64* %v4, align 8
  %45 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6439 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %45, i32 0, i32 5
  %arraydecay40 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6439, i32 0, i32 0
  %add.ptr41 = getelementptr inbounds i64, i64* %arraydecay40, i64 3
  %46 = bitcast i64* %add.ptr41 to i8*
  %call42 = call i64 @XXH_readLE64(i8* %46)
  %call43 = call i64 @XXH64_round(i64 %44, i64 %call42)
  %47 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v444 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %47, i32 0, i32 4
  store i64 %call43, i64* %v444, align 8
  %48 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize45 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %48, i32 0, i32 6
  %49 = load i32, i32* %memsize45, align 8
  %sub46 = sub i32 32, %49
  %50 = load i8*, i8** %p, align 8
  %idx.ext47 = zext i32 %sub46 to i64
  %add.ptr48 = getelementptr inbounds i8, i8* %50, i64 %idx.ext47
  store i8* %add.ptr48, i8** %p, align 8
  %51 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize49 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %51, i32 0, i32 6
  store i32 0, i32* %memsize49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then12, %if.end10
  %52 = load i8*, i8** %p, align 8
  %add.ptr51 = getelementptr inbounds i8, i8* %52, i64 32
  %53 = load i8*, i8** %bEnd, align 8
  %cmp52 = icmp ule i8* %add.ptr51, %53
  br i1 %cmp52, label %if.then54, label %if.end82

if.then54:                                        ; preds = %if.end50
  %54 = load i8*, i8** %bEnd, align 8
  %add.ptr55 = getelementptr inbounds i8, i8* %54, i64 -32
  store i8* %add.ptr55, i8** %limit, align 8
  %55 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v157 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %55, i32 0, i32 1
  %56 = load i64, i64* %v157, align 8
  store i64 %56, i64* %v156, align 8
  %57 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v259 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %57, i32 0, i32 2
  %58 = load i64, i64* %v259, align 8
  store i64 %58, i64* %v258, align 8
  %59 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v361 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %59, i32 0, i32 3
  %60 = load i64, i64* %v361, align 8
  store i64 %60, i64* %v360, align 8
  %61 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v463 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %61, i32 0, i32 4
  %62 = load i64, i64* %v463, align 8
  store i64 %62, i64* %v462, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then54
  %63 = load i64, i64* %v156, align 8
  %64 = load i8*, i8** %p, align 8
  %call64 = call i64 @XXH_readLE64(i8* %64)
  %call65 = call i64 @XXH64_round(i64 %63, i64 %call64)
  store i64 %call65, i64* %v156, align 8
  %65 = load i8*, i8** %p, align 8
  %add.ptr66 = getelementptr inbounds i8, i8* %65, i64 8
  store i8* %add.ptr66, i8** %p, align 8
  %66 = load i64, i64* %v258, align 8
  %67 = load i8*, i8** %p, align 8
  %call67 = call i64 @XXH_readLE64(i8* %67)
  %call68 = call i64 @XXH64_round(i64 %66, i64 %call67)
  store i64 %call68, i64* %v258, align 8
  %68 = load i8*, i8** %p, align 8
  %add.ptr69 = getelementptr inbounds i8, i8* %68, i64 8
  store i8* %add.ptr69, i8** %p, align 8
  %69 = load i64, i64* %v360, align 8
  %70 = load i8*, i8** %p, align 8
  %call70 = call i64 @XXH_readLE64(i8* %70)
  %call71 = call i64 @XXH64_round(i64 %69, i64 %call70)
  store i64 %call71, i64* %v360, align 8
  %71 = load i8*, i8** %p, align 8
  %add.ptr72 = getelementptr inbounds i8, i8* %71, i64 8
  store i8* %add.ptr72, i8** %p, align 8
  %72 = load i64, i64* %v462, align 8
  %73 = load i8*, i8** %p, align 8
  %call73 = call i64 @XXH_readLE64(i8* %73)
  %call74 = call i64 @XXH64_round(i64 %72, i64 %call73)
  store i64 %call74, i64* %v462, align 8
  %74 = load i8*, i8** %p, align 8
  %add.ptr75 = getelementptr inbounds i8, i8* %74, i64 8
  store i8* %add.ptr75, i8** %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %75 = load i8*, i8** %p, align 8
  %76 = load i8*, i8** %limit, align 8
  %cmp76 = icmp ule i8* %75, %76
  br i1 %cmp76, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %77 = load i64, i64* %v156, align 8
  %78 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v178 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %78, i32 0, i32 1
  store i64 %77, i64* %v178, align 8
  %79 = load i64, i64* %v258, align 8
  %80 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v279 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %80, i32 0, i32 2
  store i64 %79, i64* %v279, align 8
  %81 = load i64, i64* %v360, align 8
  %82 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v380 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %82, i32 0, i32 3
  store i64 %81, i64* %v380, align 8
  %83 = load i64, i64* %v462, align 8
  %84 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v481 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %84, i32 0, i32 4
  store i64 %83, i64* %v481, align 8
  br label %if.end82

if.end82:                                         ; preds = %do.end, %if.end50
  %85 = load i8*, i8** %p, align 8
  %86 = load i8*, i8** %bEnd, align 8
  %cmp83 = icmp ult i8* %85, %86
  br i1 %cmp83, label %if.then85, label %if.end94

if.then85:                                        ; preds = %if.end82
  %87 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem6486 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %87, i32 0, i32 5
  %arraydecay87 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6486, i32 0, i32 0
  %88 = bitcast i64* %arraydecay87 to i8*
  %89 = load i8*, i8** %p, align 8
  %90 = load i8*, i8** %bEnd, align 8
  %91 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %90 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %91 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call88 = call i8* @XXH_memcpy(i8* %88, i8* %89, i64 %sub.ptr.sub)
  %92 = load i8*, i8** %bEnd, align 8
  %93 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast89 = ptrtoint i8* %92 to i64
  %sub.ptr.rhs.cast90 = ptrtoint i8* %93 to i64
  %sub.ptr.sub91 = sub i64 %sub.ptr.lhs.cast89, %sub.ptr.rhs.cast90
  %conv92 = trunc i64 %sub.ptr.sub91 to i32
  %94 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %memsize93 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %94, i32 0, i32 6
  store i32 %conv92, i32* %memsize93, align 8
  br label %if.end94

if.end94:                                         ; preds = %if.then85, %if.end82
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end94, %if.then4, %if.then
  %95 = load i32, i32* %retval, align 4
  ret i32 %95
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_round(i64 %acc, i64 %input) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %input.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8
  store i64 %input, i64* %input.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %mul = mul i64 %0, -4417276706812531889
  %1 = load i64, i64* %acc.addr, align 8
  %add = add i64 %1, %mul
  store i64 %add, i64* %acc.addr, align 8
  %2 = load i64, i64* %acc.addr, align 8
  %3 = call i64 @llvm.fshl.i64(i64 %2, i64 %2, i64 31)
  store i64 %3, i64* %acc.addr, align 8
  %4 = load i64, i64* %acc.addr, align 8
  %mul1 = mul i64 %4, -7046029288634856825
  store i64 %mul1, i64* %acc.addr, align 8
  %5 = load i64, i64* %acc.addr, align 8
  ret i64 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_readLE64(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i64 @XXH_read64(i8* %0)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH64_digest(%struct.XXH64_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %h64 = alloca i64, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %0, i32 0, i32 0
  %1 = load i64, i64* %total_len, align 8
  %cmp = icmp uge i64 %1, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %2, i32 0, i32 1
  %3 = load i64, i64* %v11, align 8
  store i64 %3, i64* %v1, align 8
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v22 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %4, i32 0, i32 2
  %5 = load i64, i64* %v22, align 8
  store i64 %5, i64* %v2, align 8
  %6 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v33 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %6, i32 0, i32 3
  %7 = load i64, i64* %v33, align 8
  store i64 %7, i64* %v3, align 8
  %8 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v44 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %8, i32 0, i32 4
  %9 = load i64, i64* %v44, align 8
  store i64 %9, i64* %v4, align 8
  %10 = load i64, i64* %v1, align 8
  %11 = call i64 @llvm.fshl.i64(i64 %10, i64 %10, i64 1)
  %12 = load i64, i64* %v2, align 8
  %13 = call i64 @llvm.fshl.i64(i64 %12, i64 %12, i64 7)
  %add = add i64 %11, %13
  %14 = load i64, i64* %v3, align 8
  %15 = call i64 @llvm.fshl.i64(i64 %14, i64 %14, i64 12)
  %add5 = add i64 %add, %15
  %16 = load i64, i64* %v4, align 8
  %17 = call i64 @llvm.fshl.i64(i64 %16, i64 %16, i64 18)
  %add6 = add i64 %add5, %17
  store i64 %add6, i64* %h64, align 8
  %18 = load i64, i64* %h64, align 8
  %19 = load i64, i64* %v1, align 8
  %call = call i64 @XXH64_mergeRound(i64 %18, i64 %19)
  store i64 %call, i64* %h64, align 8
  %20 = load i64, i64* %h64, align 8
  %21 = load i64, i64* %v2, align 8
  %call7 = call i64 @XXH64_mergeRound(i64 %20, i64 %21)
  store i64 %call7, i64* %h64, align 8
  %22 = load i64, i64* %h64, align 8
  %23 = load i64, i64* %v3, align 8
  %call8 = call i64 @XXH64_mergeRound(i64 %22, i64 %23)
  store i64 %call8, i64* %h64, align 8
  %24 = load i64, i64* %h64, align 8
  %25 = load i64, i64* %v4, align 8
  %call9 = call i64 @XXH64_mergeRound(i64 %24, i64 %25)
  store i64 %call9, i64* %h64, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %26 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %v310 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %26, i32 0, i32 3
  %27 = load i64, i64* %v310, align 8
  %add11 = add i64 %27, 2870177450012600261
  store i64 %add11, i64* %h64, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %28 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len12 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %28, i32 0, i32 0
  %29 = load i64, i64* %total_len12, align 8
  %30 = load i64, i64* %h64, align 8
  %add13 = add i64 %30, %29
  store i64 %add13, i64* %h64, align 8
  %31 = load i64, i64* %h64, align 8
  %32 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %32, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %33 = bitcast i64* %arraydecay to i8*
  %34 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8
  %total_len14 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %34, i32 0, i32 0
  %35 = load i64, i64* %total_len14, align 8
  %call15 = call i64 @XXH64_finalize(i64 %31, i8* %33, i64 %35, i32 0)
  ret i64 %call15
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.fshl.i64(i64, i64, i64) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_mergeRound(i64 %acc, i64 %val) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %call = call i64 @XXH64_round(i64 0, i64 %0)
  store i64 %call, i64* %val.addr, align 8
  %1 = load i64, i64* %val.addr, align 8
  %2 = load i64, i64* %acc.addr, align 8
  %xor = xor i64 %2, %1
  store i64 %xor, i64* %acc.addr, align 8
  %3 = load i64, i64* %acc.addr, align 8
  %mul = mul i64 %3, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %acc.addr, align 8
  %4 = load i64, i64* %acc.addr, align 8
  ret i64 %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_finalize(i64 %h64, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i64, align 8
  %h64.addr = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %k1 = alloca i64, align 8
  %k14 = alloca i64, align 8
  %k114 = alloca i64, align 8
  %k125 = alloca i64, align 8
  %k135 = alloca i64, align 8
  %k145 = alloca i64, align 8
  %k165 = alloca i64, align 8
  %k175 = alloca i64, align 8
  %k185 = alloca i64, align 8
  %k1102 = alloca i64, align 8
  %k1112 = alloca i64, align 8
  %k1122 = alloca i64, align 8
  %k1150 = alloca i64, align 8
  %k1160 = alloca i64, align 8
  %k1170 = alloca i64, align 8
  %k1195 = alloca i64, align 8
  %k1205 = alloca i64, align 8
  %k1215 = alloca i64, align 8
  %k1250 = alloca i64, align 8
  %k1260 = alloca i64, align 8
  %k1270 = alloca i64, align 8
  %k1302 = alloca i64, align 8
  %k1312 = alloca i64, align 8
  %k1322 = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i64, i64* %len.addr, align 8
  %and = and i64 %0, 31
  switch i64 %and, label %sw.epilog [
    i64 24, label %sw.bb
    i64 16, label %sw.bb2
    i64 8, label %sw.bb12
    i64 28, label %sw.bb23
    i64 20, label %sw.bb33
    i64 12, label %sw.bb43
    i64 4, label %sw.bb53
    i64 25, label %sw.bb63
    i64 17, label %sw.bb73
    i64 9, label %sw.bb83
    i64 29, label %sw.bb100
    i64 21, label %sw.bb110
    i64 13, label %sw.bb120
    i64 5, label %sw.bb130
    i64 26, label %sw.bb148
    i64 18, label %sw.bb158
    i64 10, label %sw.bb168
    i64 30, label %sw.bb193
    i64 22, label %sw.bb203
    i64 14, label %sw.bb213
    i64 6, label %sw.bb223
    i64 27, label %sw.bb248
    i64 19, label %sw.bb258
    i64 11, label %sw.bb268
    i64 31, label %sw.bb300
    i64 23, label %sw.bb310
    i64 15, label %sw.bb320
    i64 7, label %sw.bb330
    i64 3, label %sw.bb340
    i64 2, label %sw.bb348
    i64 1, label %sw.bb356
    i64 0, label %sw.bb364
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i8*, i8** %ptr.addr, align 8
  %2 = load i32, i32* %align.addr, align 4
  %call = call i64 @XXH_readLE64_align(i8* %1, i32 %2)
  %call1 = call i64 @XXH64_round(i64 0, i64 %call)
  store i64 %call1, i64* %k1, align 8
  %3 = load i8*, i8** %ptr.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 8
  store i8* %add.ptr, i8** %ptr.addr, align 8
  %4 = load i64, i64* %k1, align 8
  %5 = load i64, i64* %h64.addr, align 8
  %xor = xor i64 %5, %4
  store i64 %xor, i64* %h64.addr, align 8
  %6 = load i64, i64* %h64.addr, align 8
  %7 = call i64 @llvm.fshl.i64(i64 %6, i64 %6, i64 27)
  %mul = mul i64 %7, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %h64.addr, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %8 = load i8*, i8** %ptr.addr, align 8
  %9 = load i32, i32* %align.addr, align 4
  %call5 = call i64 @XXH_readLE64_align(i8* %8, i32 %9)
  %call6 = call i64 @XXH64_round(i64 0, i64 %call5)
  store i64 %call6, i64* %k14, align 8
  %10 = load i8*, i8** %ptr.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 8
  store i8* %add.ptr7, i8** %ptr.addr, align 8
  %11 = load i64, i64* %k14, align 8
  %12 = load i64, i64* %h64.addr, align 8
  %xor8 = xor i64 %12, %11
  store i64 %xor8, i64* %h64.addr, align 8
  %13 = load i64, i64* %h64.addr, align 8
  %14 = call i64 @llvm.fshl.i64(i64 %13, i64 %13, i64 27)
  %mul9 = mul i64 %14, -7046029288634856825
  %add10 = add i64 %mul9, -8796714831421723037
  store i64 %add10, i64* %h64.addr, align 8
  br label %do.end11

do.end11:                                         ; preds = %do.body3
  br label %sw.bb12

sw.bb12:                                          ; preds = %entry, %do.end11
  br label %do.body13

do.body13:                                        ; preds = %sw.bb12
  %15 = load i8*, i8** %ptr.addr, align 8
  %16 = load i32, i32* %align.addr, align 4
  %call15 = call i64 @XXH_readLE64_align(i8* %15, i32 %16)
  %call16 = call i64 @XXH64_round(i64 0, i64 %call15)
  store i64 %call16, i64* %k114, align 8
  %17 = load i8*, i8** %ptr.addr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %17, i64 8
  store i8* %add.ptr17, i8** %ptr.addr, align 8
  %18 = load i64, i64* %k114, align 8
  %19 = load i64, i64* %h64.addr, align 8
  %xor18 = xor i64 %19, %18
  store i64 %xor18, i64* %h64.addr, align 8
  %20 = load i64, i64* %h64.addr, align 8
  %21 = call i64 @llvm.fshl.i64(i64 %20, i64 %20, i64 27)
  %mul19 = mul i64 %21, -7046029288634856825
  %add20 = add i64 %mul19, -8796714831421723037
  store i64 %add20, i64* %h64.addr, align 8
  br label %do.end21

do.end21:                                         ; preds = %do.body13
  %22 = load i64, i64* %h64.addr, align 8
  %call22 = call i64 @XXH64_avalanche(i64 %22)
  store i64 %call22, i64* %retval, align 8
  br label %return

sw.bb23:                                          ; preds = %entry
  br label %do.body24

do.body24:                                        ; preds = %sw.bb23
  %23 = load i8*, i8** %ptr.addr, align 8
  %24 = load i32, i32* %align.addr, align 4
  %call26 = call i64 @XXH_readLE64_align(i8* %23, i32 %24)
  %call27 = call i64 @XXH64_round(i64 0, i64 %call26)
  store i64 %call27, i64* %k125, align 8
  %25 = load i8*, i8** %ptr.addr, align 8
  %add.ptr28 = getelementptr inbounds i8, i8* %25, i64 8
  store i8* %add.ptr28, i8** %ptr.addr, align 8
  %26 = load i64, i64* %k125, align 8
  %27 = load i64, i64* %h64.addr, align 8
  %xor29 = xor i64 %27, %26
  store i64 %xor29, i64* %h64.addr, align 8
  %28 = load i64, i64* %h64.addr, align 8
  %29 = call i64 @llvm.fshl.i64(i64 %28, i64 %28, i64 27)
  %mul30 = mul i64 %29, -7046029288634856825
  %add31 = add i64 %mul30, -8796714831421723037
  store i64 %add31, i64* %h64.addr, align 8
  br label %do.end32

do.end32:                                         ; preds = %do.body24
  br label %sw.bb33

sw.bb33:                                          ; preds = %entry, %do.end32
  br label %do.body34

do.body34:                                        ; preds = %sw.bb33
  %30 = load i8*, i8** %ptr.addr, align 8
  %31 = load i32, i32* %align.addr, align 4
  %call36 = call i64 @XXH_readLE64_align(i8* %30, i32 %31)
  %call37 = call i64 @XXH64_round(i64 0, i64 %call36)
  store i64 %call37, i64* %k135, align 8
  %32 = load i8*, i8** %ptr.addr, align 8
  %add.ptr38 = getelementptr inbounds i8, i8* %32, i64 8
  store i8* %add.ptr38, i8** %ptr.addr, align 8
  %33 = load i64, i64* %k135, align 8
  %34 = load i64, i64* %h64.addr, align 8
  %xor39 = xor i64 %34, %33
  store i64 %xor39, i64* %h64.addr, align 8
  %35 = load i64, i64* %h64.addr, align 8
  %36 = call i64 @llvm.fshl.i64(i64 %35, i64 %35, i64 27)
  %mul40 = mul i64 %36, -7046029288634856825
  %add41 = add i64 %mul40, -8796714831421723037
  store i64 %add41, i64* %h64.addr, align 8
  br label %do.end42

do.end42:                                         ; preds = %do.body34
  br label %sw.bb43

sw.bb43:                                          ; preds = %entry, %do.end42
  br label %do.body44

do.body44:                                        ; preds = %sw.bb43
  %37 = load i8*, i8** %ptr.addr, align 8
  %38 = load i32, i32* %align.addr, align 4
  %call46 = call i64 @XXH_readLE64_align(i8* %37, i32 %38)
  %call47 = call i64 @XXH64_round(i64 0, i64 %call46)
  store i64 %call47, i64* %k145, align 8
  %39 = load i8*, i8** %ptr.addr, align 8
  %add.ptr48 = getelementptr inbounds i8, i8* %39, i64 8
  store i8* %add.ptr48, i8** %ptr.addr, align 8
  %40 = load i64, i64* %k145, align 8
  %41 = load i64, i64* %h64.addr, align 8
  %xor49 = xor i64 %41, %40
  store i64 %xor49, i64* %h64.addr, align 8
  %42 = load i64, i64* %h64.addr, align 8
  %43 = call i64 @llvm.fshl.i64(i64 %42, i64 %42, i64 27)
  %mul50 = mul i64 %43, -7046029288634856825
  %add51 = add i64 %mul50, -8796714831421723037
  store i64 %add51, i64* %h64.addr, align 8
  br label %do.end52

do.end52:                                         ; preds = %do.body44
  br label %sw.bb53

sw.bb53:                                          ; preds = %entry, %do.end52
  br label %do.body54

do.body54:                                        ; preds = %sw.bb53
  %44 = load i8*, i8** %ptr.addr, align 8
  %45 = load i32, i32* %align.addr, align 4
  %call55 = call i32 @XXH_readLE32_align(i8* %44, i32 %45)
  %conv = zext i32 %call55 to i64
  %mul56 = mul i64 %conv, -7046029288634856825
  %46 = load i64, i64* %h64.addr, align 8
  %xor57 = xor i64 %46, %mul56
  store i64 %xor57, i64* %h64.addr, align 8
  %47 = load i8*, i8** %ptr.addr, align 8
  %add.ptr58 = getelementptr inbounds i8, i8* %47, i64 4
  store i8* %add.ptr58, i8** %ptr.addr, align 8
  %48 = load i64, i64* %h64.addr, align 8
  %49 = call i64 @llvm.fshl.i64(i64 %48, i64 %48, i64 23)
  %mul59 = mul i64 %49, -4417276706812531889
  %add60 = add i64 %mul59, 1609587929392839161
  store i64 %add60, i64* %h64.addr, align 8
  br label %do.end61

do.end61:                                         ; preds = %do.body54
  %50 = load i64, i64* %h64.addr, align 8
  %call62 = call i64 @XXH64_avalanche(i64 %50)
  store i64 %call62, i64* %retval, align 8
  br label %return

sw.bb63:                                          ; preds = %entry
  br label %do.body64

do.body64:                                        ; preds = %sw.bb63
  %51 = load i8*, i8** %ptr.addr, align 8
  %52 = load i32, i32* %align.addr, align 4
  %call66 = call i64 @XXH_readLE64_align(i8* %51, i32 %52)
  %call67 = call i64 @XXH64_round(i64 0, i64 %call66)
  store i64 %call67, i64* %k165, align 8
  %53 = load i8*, i8** %ptr.addr, align 8
  %add.ptr68 = getelementptr inbounds i8, i8* %53, i64 8
  store i8* %add.ptr68, i8** %ptr.addr, align 8
  %54 = load i64, i64* %k165, align 8
  %55 = load i64, i64* %h64.addr, align 8
  %xor69 = xor i64 %55, %54
  store i64 %xor69, i64* %h64.addr, align 8
  %56 = load i64, i64* %h64.addr, align 8
  %57 = call i64 @llvm.fshl.i64(i64 %56, i64 %56, i64 27)
  %mul70 = mul i64 %57, -7046029288634856825
  %add71 = add i64 %mul70, -8796714831421723037
  store i64 %add71, i64* %h64.addr, align 8
  br label %do.end72

do.end72:                                         ; preds = %do.body64
  br label %sw.bb73

sw.bb73:                                          ; preds = %entry, %do.end72
  br label %do.body74

do.body74:                                        ; preds = %sw.bb73
  %58 = load i8*, i8** %ptr.addr, align 8
  %59 = load i32, i32* %align.addr, align 4
  %call76 = call i64 @XXH_readLE64_align(i8* %58, i32 %59)
  %call77 = call i64 @XXH64_round(i64 0, i64 %call76)
  store i64 %call77, i64* %k175, align 8
  %60 = load i8*, i8** %ptr.addr, align 8
  %add.ptr78 = getelementptr inbounds i8, i8* %60, i64 8
  store i8* %add.ptr78, i8** %ptr.addr, align 8
  %61 = load i64, i64* %k175, align 8
  %62 = load i64, i64* %h64.addr, align 8
  %xor79 = xor i64 %62, %61
  store i64 %xor79, i64* %h64.addr, align 8
  %63 = load i64, i64* %h64.addr, align 8
  %64 = call i64 @llvm.fshl.i64(i64 %63, i64 %63, i64 27)
  %mul80 = mul i64 %64, -7046029288634856825
  %add81 = add i64 %mul80, -8796714831421723037
  store i64 %add81, i64* %h64.addr, align 8
  br label %do.end82

do.end82:                                         ; preds = %do.body74
  br label %sw.bb83

sw.bb83:                                          ; preds = %entry, %do.end82
  br label %do.body84

do.body84:                                        ; preds = %sw.bb83
  %65 = load i8*, i8** %ptr.addr, align 8
  %66 = load i32, i32* %align.addr, align 4
  %call86 = call i64 @XXH_readLE64_align(i8* %65, i32 %66)
  %call87 = call i64 @XXH64_round(i64 0, i64 %call86)
  store i64 %call87, i64* %k185, align 8
  %67 = load i8*, i8** %ptr.addr, align 8
  %add.ptr88 = getelementptr inbounds i8, i8* %67, i64 8
  store i8* %add.ptr88, i8** %ptr.addr, align 8
  %68 = load i64, i64* %k185, align 8
  %69 = load i64, i64* %h64.addr, align 8
  %xor89 = xor i64 %69, %68
  store i64 %xor89, i64* %h64.addr, align 8
  %70 = load i64, i64* %h64.addr, align 8
  %71 = call i64 @llvm.fshl.i64(i64 %70, i64 %70, i64 27)
  %mul90 = mul i64 %71, -7046029288634856825
  %add91 = add i64 %mul90, -8796714831421723037
  store i64 %add91, i64* %h64.addr, align 8
  br label %do.end92

do.end92:                                         ; preds = %do.body84
  br label %do.body93

do.body93:                                        ; preds = %do.end92
  %72 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %72, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8
  %73 = load i8, i8* %72, align 1
  %conv94 = zext i8 %73 to i64
  %mul95 = mul i64 %conv94, 2870177450012600261
  %74 = load i64, i64* %h64.addr, align 8
  %xor96 = xor i64 %74, %mul95
  store i64 %xor96, i64* %h64.addr, align 8
  %75 = load i64, i64* %h64.addr, align 8
  %76 = call i64 @llvm.fshl.i64(i64 %75, i64 %75, i64 11)
  %mul97 = mul i64 %76, -7046029288634856825
  store i64 %mul97, i64* %h64.addr, align 8
  br label %do.end98

do.end98:                                         ; preds = %do.body93
  %77 = load i64, i64* %h64.addr, align 8
  %call99 = call i64 @XXH64_avalanche(i64 %77)
  store i64 %call99, i64* %retval, align 8
  br label %return

sw.bb100:                                         ; preds = %entry
  br label %do.body101

do.body101:                                       ; preds = %sw.bb100
  %78 = load i8*, i8** %ptr.addr, align 8
  %79 = load i32, i32* %align.addr, align 4
  %call103 = call i64 @XXH_readLE64_align(i8* %78, i32 %79)
  %call104 = call i64 @XXH64_round(i64 0, i64 %call103)
  store i64 %call104, i64* %k1102, align 8
  %80 = load i8*, i8** %ptr.addr, align 8
  %add.ptr105 = getelementptr inbounds i8, i8* %80, i64 8
  store i8* %add.ptr105, i8** %ptr.addr, align 8
  %81 = load i64, i64* %k1102, align 8
  %82 = load i64, i64* %h64.addr, align 8
  %xor106 = xor i64 %82, %81
  store i64 %xor106, i64* %h64.addr, align 8
  %83 = load i64, i64* %h64.addr, align 8
  %84 = call i64 @llvm.fshl.i64(i64 %83, i64 %83, i64 27)
  %mul107 = mul i64 %84, -7046029288634856825
  %add108 = add i64 %mul107, -8796714831421723037
  store i64 %add108, i64* %h64.addr, align 8
  br label %do.end109

do.end109:                                        ; preds = %do.body101
  br label %sw.bb110

sw.bb110:                                         ; preds = %entry, %do.end109
  br label %do.body111

do.body111:                                       ; preds = %sw.bb110
  %85 = load i8*, i8** %ptr.addr, align 8
  %86 = load i32, i32* %align.addr, align 4
  %call113 = call i64 @XXH_readLE64_align(i8* %85, i32 %86)
  %call114 = call i64 @XXH64_round(i64 0, i64 %call113)
  store i64 %call114, i64* %k1112, align 8
  %87 = load i8*, i8** %ptr.addr, align 8
  %add.ptr115 = getelementptr inbounds i8, i8* %87, i64 8
  store i8* %add.ptr115, i8** %ptr.addr, align 8
  %88 = load i64, i64* %k1112, align 8
  %89 = load i64, i64* %h64.addr, align 8
  %xor116 = xor i64 %89, %88
  store i64 %xor116, i64* %h64.addr, align 8
  %90 = load i64, i64* %h64.addr, align 8
  %91 = call i64 @llvm.fshl.i64(i64 %90, i64 %90, i64 27)
  %mul117 = mul i64 %91, -7046029288634856825
  %add118 = add i64 %mul117, -8796714831421723037
  store i64 %add118, i64* %h64.addr, align 8
  br label %do.end119

do.end119:                                        ; preds = %do.body111
  br label %sw.bb120

sw.bb120:                                         ; preds = %entry, %do.end119
  br label %do.body121

do.body121:                                       ; preds = %sw.bb120
  %92 = load i8*, i8** %ptr.addr, align 8
  %93 = load i32, i32* %align.addr, align 4
  %call123 = call i64 @XXH_readLE64_align(i8* %92, i32 %93)
  %call124 = call i64 @XXH64_round(i64 0, i64 %call123)
  store i64 %call124, i64* %k1122, align 8
  %94 = load i8*, i8** %ptr.addr, align 8
  %add.ptr125 = getelementptr inbounds i8, i8* %94, i64 8
  store i8* %add.ptr125, i8** %ptr.addr, align 8
  %95 = load i64, i64* %k1122, align 8
  %96 = load i64, i64* %h64.addr, align 8
  %xor126 = xor i64 %96, %95
  store i64 %xor126, i64* %h64.addr, align 8
  %97 = load i64, i64* %h64.addr, align 8
  %98 = call i64 @llvm.fshl.i64(i64 %97, i64 %97, i64 27)
  %mul127 = mul i64 %98, -7046029288634856825
  %add128 = add i64 %mul127, -8796714831421723037
  store i64 %add128, i64* %h64.addr, align 8
  br label %do.end129

do.end129:                                        ; preds = %do.body121
  br label %sw.bb130

sw.bb130:                                         ; preds = %entry, %do.end129
  br label %do.body131

do.body131:                                       ; preds = %sw.bb130
  %99 = load i8*, i8** %ptr.addr, align 8
  %100 = load i32, i32* %align.addr, align 4
  %call132 = call i32 @XXH_readLE32_align(i8* %99, i32 %100)
  %conv133 = zext i32 %call132 to i64
  %mul134 = mul i64 %conv133, -7046029288634856825
  %101 = load i64, i64* %h64.addr, align 8
  %xor135 = xor i64 %101, %mul134
  store i64 %xor135, i64* %h64.addr, align 8
  %102 = load i8*, i8** %ptr.addr, align 8
  %add.ptr136 = getelementptr inbounds i8, i8* %102, i64 4
  store i8* %add.ptr136, i8** %ptr.addr, align 8
  %103 = load i64, i64* %h64.addr, align 8
  %104 = call i64 @llvm.fshl.i64(i64 %103, i64 %103, i64 23)
  %mul137 = mul i64 %104, -4417276706812531889
  %add138 = add i64 %mul137, 1609587929392839161
  store i64 %add138, i64* %h64.addr, align 8
  br label %do.end139

do.end139:                                        ; preds = %do.body131
  br label %do.body140

do.body140:                                       ; preds = %do.end139
  %105 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr141 = getelementptr inbounds i8, i8* %105, i32 1
  store i8* %incdec.ptr141, i8** %ptr.addr, align 8
  %106 = load i8, i8* %105, align 1
  %conv142 = zext i8 %106 to i64
  %mul143 = mul i64 %conv142, 2870177450012600261
  %107 = load i64, i64* %h64.addr, align 8
  %xor144 = xor i64 %107, %mul143
  store i64 %xor144, i64* %h64.addr, align 8
  %108 = load i64, i64* %h64.addr, align 8
  %109 = call i64 @llvm.fshl.i64(i64 %108, i64 %108, i64 11)
  %mul145 = mul i64 %109, -7046029288634856825
  store i64 %mul145, i64* %h64.addr, align 8
  br label %do.end146

do.end146:                                        ; preds = %do.body140
  %110 = load i64, i64* %h64.addr, align 8
  %call147 = call i64 @XXH64_avalanche(i64 %110)
  store i64 %call147, i64* %retval, align 8
  br label %return

sw.bb148:                                         ; preds = %entry
  br label %do.body149

do.body149:                                       ; preds = %sw.bb148
  %111 = load i8*, i8** %ptr.addr, align 8
  %112 = load i32, i32* %align.addr, align 4
  %call151 = call i64 @XXH_readLE64_align(i8* %111, i32 %112)
  %call152 = call i64 @XXH64_round(i64 0, i64 %call151)
  store i64 %call152, i64* %k1150, align 8
  %113 = load i8*, i8** %ptr.addr, align 8
  %add.ptr153 = getelementptr inbounds i8, i8* %113, i64 8
  store i8* %add.ptr153, i8** %ptr.addr, align 8
  %114 = load i64, i64* %k1150, align 8
  %115 = load i64, i64* %h64.addr, align 8
  %xor154 = xor i64 %115, %114
  store i64 %xor154, i64* %h64.addr, align 8
  %116 = load i64, i64* %h64.addr, align 8
  %117 = call i64 @llvm.fshl.i64(i64 %116, i64 %116, i64 27)
  %mul155 = mul i64 %117, -7046029288634856825
  %add156 = add i64 %mul155, -8796714831421723037
  store i64 %add156, i64* %h64.addr, align 8
  br label %do.end157

do.end157:                                        ; preds = %do.body149
  br label %sw.bb158

sw.bb158:                                         ; preds = %entry, %do.end157
  br label %do.body159

do.body159:                                       ; preds = %sw.bb158
  %118 = load i8*, i8** %ptr.addr, align 8
  %119 = load i32, i32* %align.addr, align 4
  %call161 = call i64 @XXH_readLE64_align(i8* %118, i32 %119)
  %call162 = call i64 @XXH64_round(i64 0, i64 %call161)
  store i64 %call162, i64* %k1160, align 8
  %120 = load i8*, i8** %ptr.addr, align 8
  %add.ptr163 = getelementptr inbounds i8, i8* %120, i64 8
  store i8* %add.ptr163, i8** %ptr.addr, align 8
  %121 = load i64, i64* %k1160, align 8
  %122 = load i64, i64* %h64.addr, align 8
  %xor164 = xor i64 %122, %121
  store i64 %xor164, i64* %h64.addr, align 8
  %123 = load i64, i64* %h64.addr, align 8
  %124 = call i64 @llvm.fshl.i64(i64 %123, i64 %123, i64 27)
  %mul165 = mul i64 %124, -7046029288634856825
  %add166 = add i64 %mul165, -8796714831421723037
  store i64 %add166, i64* %h64.addr, align 8
  br label %do.end167

do.end167:                                        ; preds = %do.body159
  br label %sw.bb168

sw.bb168:                                         ; preds = %entry, %do.end167
  br label %do.body169

do.body169:                                       ; preds = %sw.bb168
  %125 = load i8*, i8** %ptr.addr, align 8
  %126 = load i32, i32* %align.addr, align 4
  %call171 = call i64 @XXH_readLE64_align(i8* %125, i32 %126)
  %call172 = call i64 @XXH64_round(i64 0, i64 %call171)
  store i64 %call172, i64* %k1170, align 8
  %127 = load i8*, i8** %ptr.addr, align 8
  %add.ptr173 = getelementptr inbounds i8, i8* %127, i64 8
  store i8* %add.ptr173, i8** %ptr.addr, align 8
  %128 = load i64, i64* %k1170, align 8
  %129 = load i64, i64* %h64.addr, align 8
  %xor174 = xor i64 %129, %128
  store i64 %xor174, i64* %h64.addr, align 8
  %130 = load i64, i64* %h64.addr, align 8
  %131 = call i64 @llvm.fshl.i64(i64 %130, i64 %130, i64 27)
  %mul175 = mul i64 %131, -7046029288634856825
  %add176 = add i64 %mul175, -8796714831421723037
  store i64 %add176, i64* %h64.addr, align 8
  br label %do.end177

do.end177:                                        ; preds = %do.body169
  br label %do.body178

do.body178:                                       ; preds = %do.end177
  %132 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr179 = getelementptr inbounds i8, i8* %132, i32 1
  store i8* %incdec.ptr179, i8** %ptr.addr, align 8
  %133 = load i8, i8* %132, align 1
  %conv180 = zext i8 %133 to i64
  %mul181 = mul i64 %conv180, 2870177450012600261
  %134 = load i64, i64* %h64.addr, align 8
  %xor182 = xor i64 %134, %mul181
  store i64 %xor182, i64* %h64.addr, align 8
  %135 = load i64, i64* %h64.addr, align 8
  %136 = call i64 @llvm.fshl.i64(i64 %135, i64 %135, i64 11)
  %mul183 = mul i64 %136, -7046029288634856825
  store i64 %mul183, i64* %h64.addr, align 8
  br label %do.end184

do.end184:                                        ; preds = %do.body178
  br label %do.body185

do.body185:                                       ; preds = %do.end184
  %137 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr186 = getelementptr inbounds i8, i8* %137, i32 1
  store i8* %incdec.ptr186, i8** %ptr.addr, align 8
  %138 = load i8, i8* %137, align 1
  %conv187 = zext i8 %138 to i64
  %mul188 = mul i64 %conv187, 2870177450012600261
  %139 = load i64, i64* %h64.addr, align 8
  %xor189 = xor i64 %139, %mul188
  store i64 %xor189, i64* %h64.addr, align 8
  %140 = load i64, i64* %h64.addr, align 8
  %141 = call i64 @llvm.fshl.i64(i64 %140, i64 %140, i64 11)
  %mul190 = mul i64 %141, -7046029288634856825
  store i64 %mul190, i64* %h64.addr, align 8
  br label %do.end191

do.end191:                                        ; preds = %do.body185
  %142 = load i64, i64* %h64.addr, align 8
  %call192 = call i64 @XXH64_avalanche(i64 %142)
  store i64 %call192, i64* %retval, align 8
  br label %return

sw.bb193:                                         ; preds = %entry
  br label %do.body194

do.body194:                                       ; preds = %sw.bb193
  %143 = load i8*, i8** %ptr.addr, align 8
  %144 = load i32, i32* %align.addr, align 4
  %call196 = call i64 @XXH_readLE64_align(i8* %143, i32 %144)
  %call197 = call i64 @XXH64_round(i64 0, i64 %call196)
  store i64 %call197, i64* %k1195, align 8
  %145 = load i8*, i8** %ptr.addr, align 8
  %add.ptr198 = getelementptr inbounds i8, i8* %145, i64 8
  store i8* %add.ptr198, i8** %ptr.addr, align 8
  %146 = load i64, i64* %k1195, align 8
  %147 = load i64, i64* %h64.addr, align 8
  %xor199 = xor i64 %147, %146
  store i64 %xor199, i64* %h64.addr, align 8
  %148 = load i64, i64* %h64.addr, align 8
  %149 = call i64 @llvm.fshl.i64(i64 %148, i64 %148, i64 27)
  %mul200 = mul i64 %149, -7046029288634856825
  %add201 = add i64 %mul200, -8796714831421723037
  store i64 %add201, i64* %h64.addr, align 8
  br label %do.end202

do.end202:                                        ; preds = %do.body194
  br label %sw.bb203

sw.bb203:                                         ; preds = %entry, %do.end202
  br label %do.body204

do.body204:                                       ; preds = %sw.bb203
  %150 = load i8*, i8** %ptr.addr, align 8
  %151 = load i32, i32* %align.addr, align 4
  %call206 = call i64 @XXH_readLE64_align(i8* %150, i32 %151)
  %call207 = call i64 @XXH64_round(i64 0, i64 %call206)
  store i64 %call207, i64* %k1205, align 8
  %152 = load i8*, i8** %ptr.addr, align 8
  %add.ptr208 = getelementptr inbounds i8, i8* %152, i64 8
  store i8* %add.ptr208, i8** %ptr.addr, align 8
  %153 = load i64, i64* %k1205, align 8
  %154 = load i64, i64* %h64.addr, align 8
  %xor209 = xor i64 %154, %153
  store i64 %xor209, i64* %h64.addr, align 8
  %155 = load i64, i64* %h64.addr, align 8
  %156 = call i64 @llvm.fshl.i64(i64 %155, i64 %155, i64 27)
  %mul210 = mul i64 %156, -7046029288634856825
  %add211 = add i64 %mul210, -8796714831421723037
  store i64 %add211, i64* %h64.addr, align 8
  br label %do.end212

do.end212:                                        ; preds = %do.body204
  br label %sw.bb213

sw.bb213:                                         ; preds = %entry, %do.end212
  br label %do.body214

do.body214:                                       ; preds = %sw.bb213
  %157 = load i8*, i8** %ptr.addr, align 8
  %158 = load i32, i32* %align.addr, align 4
  %call216 = call i64 @XXH_readLE64_align(i8* %157, i32 %158)
  %call217 = call i64 @XXH64_round(i64 0, i64 %call216)
  store i64 %call217, i64* %k1215, align 8
  %159 = load i8*, i8** %ptr.addr, align 8
  %add.ptr218 = getelementptr inbounds i8, i8* %159, i64 8
  store i8* %add.ptr218, i8** %ptr.addr, align 8
  %160 = load i64, i64* %k1215, align 8
  %161 = load i64, i64* %h64.addr, align 8
  %xor219 = xor i64 %161, %160
  store i64 %xor219, i64* %h64.addr, align 8
  %162 = load i64, i64* %h64.addr, align 8
  %163 = call i64 @llvm.fshl.i64(i64 %162, i64 %162, i64 27)
  %mul220 = mul i64 %163, -7046029288634856825
  %add221 = add i64 %mul220, -8796714831421723037
  store i64 %add221, i64* %h64.addr, align 8
  br label %do.end222

do.end222:                                        ; preds = %do.body214
  br label %sw.bb223

sw.bb223:                                         ; preds = %entry, %do.end222
  br label %do.body224

do.body224:                                       ; preds = %sw.bb223
  %164 = load i8*, i8** %ptr.addr, align 8
  %165 = load i32, i32* %align.addr, align 4
  %call225 = call i32 @XXH_readLE32_align(i8* %164, i32 %165)
  %conv226 = zext i32 %call225 to i64
  %mul227 = mul i64 %conv226, -7046029288634856825
  %166 = load i64, i64* %h64.addr, align 8
  %xor228 = xor i64 %166, %mul227
  store i64 %xor228, i64* %h64.addr, align 8
  %167 = load i8*, i8** %ptr.addr, align 8
  %add.ptr229 = getelementptr inbounds i8, i8* %167, i64 4
  store i8* %add.ptr229, i8** %ptr.addr, align 8
  %168 = load i64, i64* %h64.addr, align 8
  %169 = call i64 @llvm.fshl.i64(i64 %168, i64 %168, i64 23)
  %mul230 = mul i64 %169, -4417276706812531889
  %add231 = add i64 %mul230, 1609587929392839161
  store i64 %add231, i64* %h64.addr, align 8
  br label %do.end232

do.end232:                                        ; preds = %do.body224
  br label %do.body233

do.body233:                                       ; preds = %do.end232
  %170 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr234 = getelementptr inbounds i8, i8* %170, i32 1
  store i8* %incdec.ptr234, i8** %ptr.addr, align 8
  %171 = load i8, i8* %170, align 1
  %conv235 = zext i8 %171 to i64
  %mul236 = mul i64 %conv235, 2870177450012600261
  %172 = load i64, i64* %h64.addr, align 8
  %xor237 = xor i64 %172, %mul236
  store i64 %xor237, i64* %h64.addr, align 8
  %173 = load i64, i64* %h64.addr, align 8
  %174 = call i64 @llvm.fshl.i64(i64 %173, i64 %173, i64 11)
  %mul238 = mul i64 %174, -7046029288634856825
  store i64 %mul238, i64* %h64.addr, align 8
  br label %do.end239

do.end239:                                        ; preds = %do.body233
  br label %do.body240

do.body240:                                       ; preds = %do.end239
  %175 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr241 = getelementptr inbounds i8, i8* %175, i32 1
  store i8* %incdec.ptr241, i8** %ptr.addr, align 8
  %176 = load i8, i8* %175, align 1
  %conv242 = zext i8 %176 to i64
  %mul243 = mul i64 %conv242, 2870177450012600261
  %177 = load i64, i64* %h64.addr, align 8
  %xor244 = xor i64 %177, %mul243
  store i64 %xor244, i64* %h64.addr, align 8
  %178 = load i64, i64* %h64.addr, align 8
  %179 = call i64 @llvm.fshl.i64(i64 %178, i64 %178, i64 11)
  %mul245 = mul i64 %179, -7046029288634856825
  store i64 %mul245, i64* %h64.addr, align 8
  br label %do.end246

do.end246:                                        ; preds = %do.body240
  %180 = load i64, i64* %h64.addr, align 8
  %call247 = call i64 @XXH64_avalanche(i64 %180)
  store i64 %call247, i64* %retval, align 8
  br label %return

sw.bb248:                                         ; preds = %entry
  br label %do.body249

do.body249:                                       ; preds = %sw.bb248
  %181 = load i8*, i8** %ptr.addr, align 8
  %182 = load i32, i32* %align.addr, align 4
  %call251 = call i64 @XXH_readLE64_align(i8* %181, i32 %182)
  %call252 = call i64 @XXH64_round(i64 0, i64 %call251)
  store i64 %call252, i64* %k1250, align 8
  %183 = load i8*, i8** %ptr.addr, align 8
  %add.ptr253 = getelementptr inbounds i8, i8* %183, i64 8
  store i8* %add.ptr253, i8** %ptr.addr, align 8
  %184 = load i64, i64* %k1250, align 8
  %185 = load i64, i64* %h64.addr, align 8
  %xor254 = xor i64 %185, %184
  store i64 %xor254, i64* %h64.addr, align 8
  %186 = load i64, i64* %h64.addr, align 8
  %187 = call i64 @llvm.fshl.i64(i64 %186, i64 %186, i64 27)
  %mul255 = mul i64 %187, -7046029288634856825
  %add256 = add i64 %mul255, -8796714831421723037
  store i64 %add256, i64* %h64.addr, align 8
  br label %do.end257

do.end257:                                        ; preds = %do.body249
  br label %sw.bb258

sw.bb258:                                         ; preds = %entry, %do.end257
  br label %do.body259

do.body259:                                       ; preds = %sw.bb258
  %188 = load i8*, i8** %ptr.addr, align 8
  %189 = load i32, i32* %align.addr, align 4
  %call261 = call i64 @XXH_readLE64_align(i8* %188, i32 %189)
  %call262 = call i64 @XXH64_round(i64 0, i64 %call261)
  store i64 %call262, i64* %k1260, align 8
  %190 = load i8*, i8** %ptr.addr, align 8
  %add.ptr263 = getelementptr inbounds i8, i8* %190, i64 8
  store i8* %add.ptr263, i8** %ptr.addr, align 8
  %191 = load i64, i64* %k1260, align 8
  %192 = load i64, i64* %h64.addr, align 8
  %xor264 = xor i64 %192, %191
  store i64 %xor264, i64* %h64.addr, align 8
  %193 = load i64, i64* %h64.addr, align 8
  %194 = call i64 @llvm.fshl.i64(i64 %193, i64 %193, i64 27)
  %mul265 = mul i64 %194, -7046029288634856825
  %add266 = add i64 %mul265, -8796714831421723037
  store i64 %add266, i64* %h64.addr, align 8
  br label %do.end267

do.end267:                                        ; preds = %do.body259
  br label %sw.bb268

sw.bb268:                                         ; preds = %entry, %do.end267
  br label %do.body269

do.body269:                                       ; preds = %sw.bb268
  %195 = load i8*, i8** %ptr.addr, align 8
  %196 = load i32, i32* %align.addr, align 4
  %call271 = call i64 @XXH_readLE64_align(i8* %195, i32 %196)
  %call272 = call i64 @XXH64_round(i64 0, i64 %call271)
  store i64 %call272, i64* %k1270, align 8
  %197 = load i8*, i8** %ptr.addr, align 8
  %add.ptr273 = getelementptr inbounds i8, i8* %197, i64 8
  store i8* %add.ptr273, i8** %ptr.addr, align 8
  %198 = load i64, i64* %k1270, align 8
  %199 = load i64, i64* %h64.addr, align 8
  %xor274 = xor i64 %199, %198
  store i64 %xor274, i64* %h64.addr, align 8
  %200 = load i64, i64* %h64.addr, align 8
  %201 = call i64 @llvm.fshl.i64(i64 %200, i64 %200, i64 27)
  %mul275 = mul i64 %201, -7046029288634856825
  %add276 = add i64 %mul275, -8796714831421723037
  store i64 %add276, i64* %h64.addr, align 8
  br label %do.end277

do.end277:                                        ; preds = %do.body269
  br label %do.body278

do.body278:                                       ; preds = %do.end277
  %202 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr279 = getelementptr inbounds i8, i8* %202, i32 1
  store i8* %incdec.ptr279, i8** %ptr.addr, align 8
  %203 = load i8, i8* %202, align 1
  %conv280 = zext i8 %203 to i64
  %mul281 = mul i64 %conv280, 2870177450012600261
  %204 = load i64, i64* %h64.addr, align 8
  %xor282 = xor i64 %204, %mul281
  store i64 %xor282, i64* %h64.addr, align 8
  %205 = load i64, i64* %h64.addr, align 8
  %206 = call i64 @llvm.fshl.i64(i64 %205, i64 %205, i64 11)
  %mul283 = mul i64 %206, -7046029288634856825
  store i64 %mul283, i64* %h64.addr, align 8
  br label %do.end284

do.end284:                                        ; preds = %do.body278
  br label %do.body285

do.body285:                                       ; preds = %do.end284
  %207 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr286 = getelementptr inbounds i8, i8* %207, i32 1
  store i8* %incdec.ptr286, i8** %ptr.addr, align 8
  %208 = load i8, i8* %207, align 1
  %conv287 = zext i8 %208 to i64
  %mul288 = mul i64 %conv287, 2870177450012600261
  %209 = load i64, i64* %h64.addr, align 8
  %xor289 = xor i64 %209, %mul288
  store i64 %xor289, i64* %h64.addr, align 8
  %210 = load i64, i64* %h64.addr, align 8
  %211 = call i64 @llvm.fshl.i64(i64 %210, i64 %210, i64 11)
  %mul290 = mul i64 %211, -7046029288634856825
  store i64 %mul290, i64* %h64.addr, align 8
  br label %do.end291

do.end291:                                        ; preds = %do.body285
  br label %do.body292

do.body292:                                       ; preds = %do.end291
  %212 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr293 = getelementptr inbounds i8, i8* %212, i32 1
  store i8* %incdec.ptr293, i8** %ptr.addr, align 8
  %213 = load i8, i8* %212, align 1
  %conv294 = zext i8 %213 to i64
  %mul295 = mul i64 %conv294, 2870177450012600261
  %214 = load i64, i64* %h64.addr, align 8
  %xor296 = xor i64 %214, %mul295
  store i64 %xor296, i64* %h64.addr, align 8
  %215 = load i64, i64* %h64.addr, align 8
  %216 = call i64 @llvm.fshl.i64(i64 %215, i64 %215, i64 11)
  %mul297 = mul i64 %216, -7046029288634856825
  store i64 %mul297, i64* %h64.addr, align 8
  br label %do.end298

do.end298:                                        ; preds = %do.body292
  %217 = load i64, i64* %h64.addr, align 8
  %call299 = call i64 @XXH64_avalanche(i64 %217)
  store i64 %call299, i64* %retval, align 8
  br label %return

sw.bb300:                                         ; preds = %entry
  br label %do.body301

do.body301:                                       ; preds = %sw.bb300
  %218 = load i8*, i8** %ptr.addr, align 8
  %219 = load i32, i32* %align.addr, align 4
  %call303 = call i64 @XXH_readLE64_align(i8* %218, i32 %219)
  %call304 = call i64 @XXH64_round(i64 0, i64 %call303)
  store i64 %call304, i64* %k1302, align 8
  %220 = load i8*, i8** %ptr.addr, align 8
  %add.ptr305 = getelementptr inbounds i8, i8* %220, i64 8
  store i8* %add.ptr305, i8** %ptr.addr, align 8
  %221 = load i64, i64* %k1302, align 8
  %222 = load i64, i64* %h64.addr, align 8
  %xor306 = xor i64 %222, %221
  store i64 %xor306, i64* %h64.addr, align 8
  %223 = load i64, i64* %h64.addr, align 8
  %224 = call i64 @llvm.fshl.i64(i64 %223, i64 %223, i64 27)
  %mul307 = mul i64 %224, -7046029288634856825
  %add308 = add i64 %mul307, -8796714831421723037
  store i64 %add308, i64* %h64.addr, align 8
  br label %do.end309

do.end309:                                        ; preds = %do.body301
  br label %sw.bb310

sw.bb310:                                         ; preds = %entry, %do.end309
  br label %do.body311

do.body311:                                       ; preds = %sw.bb310
  %225 = load i8*, i8** %ptr.addr, align 8
  %226 = load i32, i32* %align.addr, align 4
  %call313 = call i64 @XXH_readLE64_align(i8* %225, i32 %226)
  %call314 = call i64 @XXH64_round(i64 0, i64 %call313)
  store i64 %call314, i64* %k1312, align 8
  %227 = load i8*, i8** %ptr.addr, align 8
  %add.ptr315 = getelementptr inbounds i8, i8* %227, i64 8
  store i8* %add.ptr315, i8** %ptr.addr, align 8
  %228 = load i64, i64* %k1312, align 8
  %229 = load i64, i64* %h64.addr, align 8
  %xor316 = xor i64 %229, %228
  store i64 %xor316, i64* %h64.addr, align 8
  %230 = load i64, i64* %h64.addr, align 8
  %231 = call i64 @llvm.fshl.i64(i64 %230, i64 %230, i64 27)
  %mul317 = mul i64 %231, -7046029288634856825
  %add318 = add i64 %mul317, -8796714831421723037
  store i64 %add318, i64* %h64.addr, align 8
  br label %do.end319

do.end319:                                        ; preds = %do.body311
  br label %sw.bb320

sw.bb320:                                         ; preds = %entry, %do.end319
  br label %do.body321

do.body321:                                       ; preds = %sw.bb320
  %232 = load i8*, i8** %ptr.addr, align 8
  %233 = load i32, i32* %align.addr, align 4
  %call323 = call i64 @XXH_readLE64_align(i8* %232, i32 %233)
  %call324 = call i64 @XXH64_round(i64 0, i64 %call323)
  store i64 %call324, i64* %k1322, align 8
  %234 = load i8*, i8** %ptr.addr, align 8
  %add.ptr325 = getelementptr inbounds i8, i8* %234, i64 8
  store i8* %add.ptr325, i8** %ptr.addr, align 8
  %235 = load i64, i64* %k1322, align 8
  %236 = load i64, i64* %h64.addr, align 8
  %xor326 = xor i64 %236, %235
  store i64 %xor326, i64* %h64.addr, align 8
  %237 = load i64, i64* %h64.addr, align 8
  %238 = call i64 @llvm.fshl.i64(i64 %237, i64 %237, i64 27)
  %mul327 = mul i64 %238, -7046029288634856825
  %add328 = add i64 %mul327, -8796714831421723037
  store i64 %add328, i64* %h64.addr, align 8
  br label %do.end329

do.end329:                                        ; preds = %do.body321
  br label %sw.bb330

sw.bb330:                                         ; preds = %entry, %do.end329
  br label %do.body331

do.body331:                                       ; preds = %sw.bb330
  %239 = load i8*, i8** %ptr.addr, align 8
  %240 = load i32, i32* %align.addr, align 4
  %call332 = call i32 @XXH_readLE32_align(i8* %239, i32 %240)
  %conv333 = zext i32 %call332 to i64
  %mul334 = mul i64 %conv333, -7046029288634856825
  %241 = load i64, i64* %h64.addr, align 8
  %xor335 = xor i64 %241, %mul334
  store i64 %xor335, i64* %h64.addr, align 8
  %242 = load i8*, i8** %ptr.addr, align 8
  %add.ptr336 = getelementptr inbounds i8, i8* %242, i64 4
  store i8* %add.ptr336, i8** %ptr.addr, align 8
  %243 = load i64, i64* %h64.addr, align 8
  %244 = call i64 @llvm.fshl.i64(i64 %243, i64 %243, i64 23)
  %mul337 = mul i64 %244, -4417276706812531889
  %add338 = add i64 %mul337, 1609587929392839161
  store i64 %add338, i64* %h64.addr, align 8
  br label %do.end339

do.end339:                                        ; preds = %do.body331
  br label %sw.bb340

sw.bb340:                                         ; preds = %entry, %do.end339
  br label %do.body341

do.body341:                                       ; preds = %sw.bb340
  %245 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr342 = getelementptr inbounds i8, i8* %245, i32 1
  store i8* %incdec.ptr342, i8** %ptr.addr, align 8
  %246 = load i8, i8* %245, align 1
  %conv343 = zext i8 %246 to i64
  %mul344 = mul i64 %conv343, 2870177450012600261
  %247 = load i64, i64* %h64.addr, align 8
  %xor345 = xor i64 %247, %mul344
  store i64 %xor345, i64* %h64.addr, align 8
  %248 = load i64, i64* %h64.addr, align 8
  %249 = call i64 @llvm.fshl.i64(i64 %248, i64 %248, i64 11)
  %mul346 = mul i64 %249, -7046029288634856825
  store i64 %mul346, i64* %h64.addr, align 8
  br label %do.end347

do.end347:                                        ; preds = %do.body341
  br label %sw.bb348

sw.bb348:                                         ; preds = %entry, %do.end347
  br label %do.body349

do.body349:                                       ; preds = %sw.bb348
  %250 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr350 = getelementptr inbounds i8, i8* %250, i32 1
  store i8* %incdec.ptr350, i8** %ptr.addr, align 8
  %251 = load i8, i8* %250, align 1
  %conv351 = zext i8 %251 to i64
  %mul352 = mul i64 %conv351, 2870177450012600261
  %252 = load i64, i64* %h64.addr, align 8
  %xor353 = xor i64 %252, %mul352
  store i64 %xor353, i64* %h64.addr, align 8
  %253 = load i64, i64* %h64.addr, align 8
  %254 = call i64 @llvm.fshl.i64(i64 %253, i64 %253, i64 11)
  %mul354 = mul i64 %254, -7046029288634856825
  store i64 %mul354, i64* %h64.addr, align 8
  br label %do.end355

do.end355:                                        ; preds = %do.body349
  br label %sw.bb356

sw.bb356:                                         ; preds = %entry, %do.end355
  br label %do.body357

do.body357:                                       ; preds = %sw.bb356
  %255 = load i8*, i8** %ptr.addr, align 8
  %incdec.ptr358 = getelementptr inbounds i8, i8* %255, i32 1
  store i8* %incdec.ptr358, i8** %ptr.addr, align 8
  %256 = load i8, i8* %255, align 1
  %conv359 = zext i8 %256 to i64
  %mul360 = mul i64 %conv359, 2870177450012600261
  %257 = load i64, i64* %h64.addr, align 8
  %xor361 = xor i64 %257, %mul360
  store i64 %xor361, i64* %h64.addr, align 8
  %258 = load i64, i64* %h64.addr, align 8
  %259 = call i64 @llvm.fshl.i64(i64 %258, i64 %258, i64 11)
  %mul362 = mul i64 %259, -7046029288634856825
  store i64 %mul362, i64* %h64.addr, align 8
  br label %do.end363

do.end363:                                        ; preds = %do.body357
  br label %sw.bb364

sw.bb364:                                         ; preds = %entry, %do.end363
  %260 = load i64, i64* %h64.addr, align 8
  %call365 = call i64 @XXH64_avalanche(i64 %260)
  store i64 %call365, i64* %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, i64* %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb364, %do.end298, %do.end246, %do.end191, %do.end146, %do.end98, %do.end61, %do.end21
  %261 = load i64, i64* %retval, align 8
  ret i64 %261
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH64_canonicalFromHash(%struct.XXH64_canonical_t* %dst, i64 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH64_canonical_t*, align 8
  %hash.addr = alloca i64, align 8
  store %struct.XXH64_canonical_t* %dst, %struct.XXH64_canonical_t** %dst.addr, align 8
  store i64 %hash, i64* %hash.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i64, i64* %hash.addr, align 8
  %call = call i64 @XXH_swap64(i64 %0)
  store i64 %call, i64* %hash.addr, align 8
  %1 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8
  %2 = bitcast %struct.XXH64_canonical_t* %1 to i8*
  %3 = bitcast i64* %hash.addr to i8*
  %4 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8
  %5 = bitcast %struct.XXH64_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 8, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_swap64(i64 %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %shl = shl i64 %0, 56
  %and = and i64 %shl, -72057594037927936
  %1 = load i64, i64* %x.addr, align 8
  %shl1 = shl i64 %1, 40
  %and2 = and i64 %shl1, 71776119061217280
  %or = or i64 %and, %and2
  %2 = load i64, i64* %x.addr, align 8
  %shl3 = shl i64 %2, 24
  %and4 = and i64 %shl3, 280375465082880
  %or5 = or i64 %or, %and4
  %3 = load i64, i64* %x.addr, align 8
  %shl6 = shl i64 %3, 8
  %and7 = and i64 %shl6, 1095216660480
  %or8 = or i64 %or5, %and7
  %4 = load i64, i64* %x.addr, align 8
  %shr = lshr i64 %4, 8
  %and9 = and i64 %shr, 4278190080
  %or10 = or i64 %or8, %and9
  %5 = load i64, i64* %x.addr, align 8
  %shr11 = lshr i64 %5, 24
  %and12 = and i64 %shr11, 16711680
  %or13 = or i64 %or10, %and12
  %6 = load i64, i64* %x.addr, align 8
  %shr14 = lshr i64 %6, 40
  %and15 = and i64 %shr14, 65280
  %or16 = or i64 %or13, %and15
  %7 = load i64, i64* %x.addr, align 8
  %shr17 = lshr i64 %7, 56
  %and18 = and i64 %shr17, 255
  %or19 = or i64 %or16, %and18
  ret i64 %or19
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH64_hashFromCanonical(%struct.XXH64_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH64_canonical_t*, align 8
  store %struct.XXH64_canonical_t* %src, %struct.XXH64_canonical_t** %src.addr, align 8
  %0 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %src.addr, align 8
  %1 = bitcast %struct.XXH64_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_readBE64(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call i64 @XXH_read64(i8* %0)
  %call1 = call i64 @XXH_swap64(i64 %call)
  ret i64 %call1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits(i8* %input, i64 %len) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_64bits_internal(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, i64 (i8*, i64, i64, i8*, i64)* %f_hashLong) #0 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hashLong.addr = alloca i64 (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  store i64 (i8*, i64, i64, i8*, i64)* %f_hashLong, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed64.addr, align 8
  %call = call i64 @XXH3_len_0to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ule i64 %5, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i64, i64* %len.addr, align 8
  %8 = load i8*, i8** %secret.addr, align 8
  %9 = load i64, i64* %secretLen.addr, align 8
  %10 = load i64, i64* %seed64.addr, align 8
  %call3 = call i64 @XXH3_len_17to128_64b(i8* %6, i64 %7, i8* %8, i64 %9, i64 %10)
  store i64 %call3, i64* %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load i64, i64* %len.addr, align 8
  %cmp5 = icmp ule i64 %11, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %12 = load i8*, i8** %input.addr, align 8
  %13 = load i64, i64* %len.addr, align 8
  %14 = load i8*, i8** %secret.addr, align 8
  %15 = load i64, i64* %secretLen.addr, align 8
  %16 = load i64, i64* %seed64.addr, align 8
  %call7 = call i64 @XXH3_len_129to240_64b(i8* %12, i64 %13, i8* %14, i64 %15, i64 %16)
  store i64 %call7, i64* %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %17 = load i64 (i8*, i64, i64, i8*, i64)*, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8
  %18 = load i8*, i8** %input.addr, align 8
  %19 = load i64, i64* %len.addr, align 8
  %20 = load i64, i64* %seed64.addr, align 8
  %21 = load i8*, i8** %secret.addr, align 8
  %22 = load i64, i64* %secretLen.addr, align 8
  %call9 = call i64 %17(i8* %18, i64 %19, i64 %20, i8* %21, i64 %22)
  store i64 %call9, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %23 = load i64, i64* %retval, align 8
  ret i64 %23
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretLen.addr, align 8
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSeed)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed(i8* %input, i64 %len, i64 %seed, i8* %secret, i64 %secretLen) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %1 = load i64, i64* %secretLen.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_hashLong_64b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.XXH3_state_s* @XXH3_createState() #0 {
entry:
  %call = call i8* @XXH_alignedMalloc(i64 576, i64 64)
  %0 = bitcast i8* %call to %struct.XXH3_state_s*
  ret %struct.XXH3_state_s* %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @XXH_alignedMalloc(i64 %s, i64 %align) #0 {
entry:
  %retval = alloca i8*, align 8
  %s.addr = alloca i64, align 8
  %align.addr = alloca i64, align 8
  %base = alloca i8*, align 8
  %offset = alloca i64, align 8
  %ptr = alloca i8*, align 8
  store i64 %s, i64* %s.addr, align 8
  store i64 %align, i64* %align.addr, align 8
  %0 = load i64, i64* %s.addr, align 8
  %1 = load i64, i64* %align.addr, align 8
  %add = add i64 %0, %1
  %call = call i8* @XXH_malloc(i64 %add)
  store i8* %call, i8** %base, align 8
  %2 = load i8*, i8** %base, align 8
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %align.addr, align 8
  %4 = load i8*, i8** %base, align 8
  %5 = ptrtoint i8* %4 to i64
  %6 = load i64, i64* %align.addr, align 8
  %sub = sub i64 %6, 1
  %and = and i64 %5, %sub
  %sub1 = sub i64 %3, %and
  store i64 %sub1, i64* %offset, align 8
  %7 = load i8*, i8** %base, align 8
  %8 = load i64, i64* %offset, align 8
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %8
  store i8* %add.ptr, i8** %ptr, align 8
  %9 = load i64, i64* %offset, align 8
  %conv = trunc i64 %9 to i8
  %10 = load i8*, i8** %ptr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %10, i64 -1
  store i8 %conv, i8* %arrayidx, align 1
  %11 = load i8*, i8** %ptr, align 8
  store i8* %11, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i8*, i8** %retval, align 8
  ret i8* %12
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_freeState(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  call void @XXH_alignedFree(i8* %1)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH_alignedFree(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %ptr = alloca i8*, align 8
  %offset = alloca i8, align 1
  %base = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  %cmp = icmp ne i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %p.addr, align 8
  store i8* %1, i8** %ptr, align 8
  %2 = load i8*, i8** %ptr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 -1
  %3 = load i8, i8* %arrayidx, align 1
  store i8 %3, i8* %offset, align 1
  %4 = load i8*, i8** %ptr, align 8
  %5 = load i8, i8* %offset, align 1
  %conv = zext i8 %5 to i32
  %idx.ext = sext i32 %conv to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.neg
  store i8* %add.ptr, i8** %base, align 8
  %6 = load i8*, i8** %base, align 8
  call void @XXH_free(i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH3_copyState(%struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s* %src_state) #0 {
entry:
  %dst_state.addr = alloca %struct.XXH3_state_s*, align 8
  %src_state.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s** %dst_state.addr, align 8
  store %struct.XXH3_state_s* %src_state, %struct.XXH3_state_s** %src_state.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %src_state.addr, align 8
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8
  %5 = bitcast %struct.XXH3_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 576, i64 %6) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 576, i64 %4) #10
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 0
  %arrayidx = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i64 0, i64 0
  store i64 3266489917, i64* %arrayidx, align 16
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i64 0, i64 1
  store i64 -7046029288634856825, i64* %arrayidx2, align 8
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc3, i64 0, i64 2
  store i64 -4417276706812531889, i64* %arrayidx4, align 16
  %8 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %8, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc5, i64 0, i64 3
  store i64 1609587929392839161, i64* %arrayidx6, align 8
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [8 x i64], [8 x i64]* %acc7, i64 0, i64 4
  store i64 -8796714831421723037, i64* %arrayidx8, align 16
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [8 x i64], [8 x i64]* %acc9, i64 0, i64 5
  store i64 2246822519, i64* %arrayidx10, align 8
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [8 x i64], [8 x i64]* %acc11, i64 0, i64 6
  store i64 2870177450012600261, i64* %arrayidx12, align 16
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %acc13 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [8 x i64], [8 x i64]* %acc13, i64 0, i64 7
  store i64 2654435761, i64* %arrayidx14, align 8
  %13 = load i64, i64* %seed.addr, align 8
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %seed15 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 9
  store i64 %13, i64* %seed15, align 8
  %15 = load i8*, i8** %secret.addr, align 8
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 11
  store i8* %15, i8** %extSecret, align 8
  %17 = load i64, i64* %secretSize.addr, align 8
  %sub = sub i64 %17, 64
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 7
  store i64 %sub, i64* %secretLimit, align 8
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %secretLimit16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 7
  %20 = load i64, i64* %secretLimit16, align 8
  %div = udiv i64 %20, 8
  %21 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %21, i32 0, i32 5
  store i64 %div, i64* %nbStripesPerBlock, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_initCustomSecret_sse2(i8* noalias %customSecret, i64 %seed64) #4 {
entry:
  %__p.addr.i = alloca float*, align 8
  %__a.addr.i4 = alloca <4 x float>, align 16
  %__a.addr.i = alloca <2 x i64>, align 16
  %__b.addr.i = alloca <2 x i64>, align 16
  %__q1.addr.i = alloca i64, align 8
  %__q0.addr.i = alloca i64, align 8
  %.compoundliteral.i = alloca <2 x i64>, align 16
  %customSecret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %seed = alloca <2 x i64>, align 16
  %i = alloca i32, align 4
  %src = alloca float*, align 64
  %dest = alloca <2 x i64>*, align 16
  store i8* %customSecret, i8** %customSecret.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 12, i32* %nbRounds, align 4
  %0 = load i64, i64* %seed64.addr, align 8
  %sub = sub nsw i64 0, %0
  %1 = load i64, i64* %seed64.addr, align 8
  store i64 %sub, i64* %__q1.addr.i, align 8
  store i64 %1, i64* %__q0.addr.i, align 8
  %2 = load i64, i64* %__q0.addr.i, align 8
  %vecinit.i = insertelement <2 x i64> undef, i64 %2, i32 0
  %3 = load i64, i64* %__q1.addr.i, align 8
  %vecinit1.i = insertelement <2 x i64> %vecinit.i, i64 %3, i32 1
  store <2 x i64> %vecinit1.i, <2 x i64>* %.compoundliteral.i, align 16
  %4 = load <2 x i64>, <2 x i64>* %.compoundliteral.i, align 16
  store <2 x i64> %4, <2 x i64>* %seed, align 16
  store float* bitcast ([192 x i8]* @XXH3_kSecret to float*), float** %src, align 64
  %5 = load i8*, i8** %customSecret.addr, align 8
  %6 = bitcast i8* %5 to <2 x i64>*
  store <2 x i64>* %6, <2 x i64>** %dest, align 16
  %7 = load <2 x i64>*, <2 x i64>** %dest, align 16
  %8 = call <2 x i64>* asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(<2 x i64>* %7) #8, !srcloc !5
  store <2 x i64>* %8, <2 x i64>** %dest, align 16
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %9 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %9, 12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %i, align 4
  %mul = mul nsw i32 %10, 4
  %idx.ext = sext i32 %mul to i64
  %add.ptr = getelementptr inbounds float, float* bitcast ([192 x i8]* @XXH3_kSecret to float*), i64 %idx.ext
  store float* %add.ptr, float** %__p.addr.i, align 8
  %11 = load float*, float** %__p.addr.i, align 8
  %12 = bitcast float* %11 to <4 x float>*
  %13 = load <4 x float>, <4 x float>* %12, align 16
  store <4 x float> %13, <4 x float>* %__a.addr.i4, align 16
  %14 = load <4 x float>, <4 x float>* %__a.addr.i4, align 16
  %15 = bitcast <4 x float> %14 to <2 x i64>
  %16 = load <2 x i64>, <2 x i64>* %seed, align 16
  store <2 x i64> %15, <2 x i64>* %__a.addr.i, align 16
  store <2 x i64> %16, <2 x i64>* %__b.addr.i, align 16
  %17 = load <2 x i64>, <2 x i64>* %__a.addr.i, align 16
  %18 = load <2 x i64>, <2 x i64>* %__b.addr.i, align 16
  %add.i = add <2 x i64> %17, %18
  %19 = load <2 x i64>*, <2 x i64>** %dest, align 16
  %20 = load i32, i32* %i, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %19, i64 %idxprom
  store <2 x i64> %add.i, <2 x i64>* %arrayidx, align 16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32, i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_64bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 0, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH3_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %bEnd = alloca i8*, align 8
  %secret = alloca i8*, align 8
  %loadSize = alloca i64, align 8
  %limit = alloca i8*, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %bEnd, align 8
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 11
  %4 = load i8*, i8** %extSecret, align 8
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 11
  %7 = load i8*, i8** %extSecret2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %7, %cond.false ]
  store i8* %cond, i8** %secret, align 8
  %8 = load i64, i64* %len.addr, align 8
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 8
  %10 = load i64, i64* %totalLen, align 16
  %add = add i64 %10, %8
  store i64 %add, i64* %totalLen, align 16
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 3
  %12 = load i32, i32* %bufferedSize, align 16
  %conv = zext i32 %12 to i64
  %13 = load i64, i64* %len.addr, align 8
  %add3 = add i64 %conv, %13
  %cmp4 = icmp ule i64 %add3, 256
  br i1 %cmp4, label %if.then6, label %if.end13

if.then6:                                         ; preds = %cond.end
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 3
  %16 = load i32, i32* %bufferedSize8, align 16
  %idx.ext = zext i32 %16 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %arraydecay7, i64 %idx.ext
  %17 = load i8*, i8** %input.addr, align 8
  %18 = load i64, i64* %len.addr, align 8
  %call = call i8* @XXH_memcpy(i8* %add.ptr9, i8* %17, i64 %18)
  %19 = load i64, i64* %len.addr, align 8
  %conv10 = trunc i64 %19 to i32
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 3
  %21 = load i32, i32* %bufferedSize11, align 16
  %add12 = add i32 %21, %conv10
  store i32 %add12, i32* %bufferedSize11, align 16
  store i32 0, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.end13
  br label %do.end

do.end:                                           ; preds = %do.body
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 3
  %23 = load i32, i32* %bufferedSize14, align 16
  %tobool = icmp ne i32 %23, 0
  br i1 %tobool, label %if.then15, label %if.end29

if.then15:                                        ; preds = %do.end
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 3
  %25 = load i32, i32* %bufferedSize16, align 16
  %sub = sub i32 256, %25
  %conv17 = zext i32 %sub to i64
  store i64 %conv17, i64* %loadSize, align 8
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer18 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer18, i32 0, i32 0
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 3
  %28 = load i32, i32* %bufferedSize20, align 16
  %idx.ext21 = zext i32 %28 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay19, i64 %idx.ext21
  %29 = load i8*, i8** %input.addr, align 8
  %30 = load i64, i64* %loadSize, align 8
  %call23 = call i8* @XXH_memcpy(i8* %add.ptr22, i8* %29, i64 %30)
  %31 = load i64, i64* %loadSize, align 8
  %32 = load i8*, i8** %input.addr, align 8
  %add.ptr24 = getelementptr inbounds i8, i8* %32, i64 %31
  store i8* %add.ptr24, i8** %input.addr, align 8
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %34 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesSoFar = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %34, i32 0, i32 6
  %35 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %35, i32 0, i32 5
  %36 = load i64, i64* %nbStripesPerBlock, align 8
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer26 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 2
  %arraydecay27 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer26, i32 0, i32 0
  %38 = load i8*, i8** %secret, align 8
  %39 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %39, i32 0, i32 7
  %40 = load i64, i64* %secretLimit, align 8
  %41 = load i32, i32* %accWidth.addr, align 4
  %42 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %43 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_consumeStripes(i64* %arraydecay25, i64* %nbStripesSoFar, i64 %36, i8* %arraydecay27, i64 4, i8* %38, i64 %40, i32 %41, void (i8*, i8*, i8*, i32)* %42, void (i8*, i8*)* %43)
  %44 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize28 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %44, i32 0, i32 3
  store i32 0, i32* %bufferedSize28, align 16
  br label %if.end29

if.end29:                                         ; preds = %if.then15, %do.end
  %45 = load i8*, i8** %input.addr, align 8
  %add.ptr30 = getelementptr inbounds i8, i8* %45, i64 256
  %46 = load i8*, i8** %bEnd, align 8
  %cmp31 = icmp ule i8* %add.ptr30, %46
  br i1 %cmp31, label %if.then33, label %if.end55

if.then33:                                        ; preds = %if.end29
  %47 = load i8*, i8** %bEnd, align 8
  %add.ptr34 = getelementptr inbounds i8, i8* %47, i64 -256
  store i8* %add.ptr34, i8** %limit, align 8
  br label %do.body35

do.body35:                                        ; preds = %do.cond, %if.then33
  %48 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %acc36 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %48, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [8 x i64], [8 x i64]* %acc36, i32 0, i32 0
  %49 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesSoFar38 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %49, i32 0, i32 6
  %50 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesPerBlock39 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %50, i32 0, i32 5
  %51 = load i64, i64* %nbStripesPerBlock39, align 8
  %52 = load i8*, i8** %input.addr, align 8
  %53 = load i8*, i8** %secret, align 8
  %54 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit40 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %54, i32 0, i32 7
  %55 = load i64, i64* %secretLimit40, align 8
  %56 = load i32, i32* %accWidth.addr, align 4
  %57 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %58 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_consumeStripes(i64* %arraydecay37, i64* %nbStripesSoFar38, i64 %51, i8* %52, i64 4, i8* %53, i64 %55, i32 %56, void (i8*, i8*, i8*, i32)* %57, void (i8*, i8*)* %58)
  %59 = load i8*, i8** %input.addr, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %59, i64 256
  store i8* %add.ptr41, i8** %input.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body35
  %60 = load i8*, i8** %input.addr, align 8
  %61 = load i8*, i8** %limit, align 8
  %cmp42 = icmp ule i8* %60, %61
  br i1 %cmp42, label %do.body35, label %do.end44

do.end44:                                         ; preds = %do.cond
  %62 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer45 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %62, i32 0, i32 2
  %arraydecay46 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer45, i32 0, i32 0
  %add.ptr47 = getelementptr inbounds i8, i8* %arraydecay46, i64 256
  %add.ptr48 = getelementptr inbounds i8, i8* %add.ptr47, i64 -64
  %63 = load i8*, i8** %input.addr, align 8
  %add.ptr49 = getelementptr inbounds i8, i8* %63, i64 -64
  %64 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer50 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %64, i32 0, i32 2
  %arraydecay51 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer50, i32 0, i32 0
  %add.ptr52 = getelementptr inbounds i8, i8* %arraydecay51, i64 256
  %add.ptr53 = getelementptr inbounds i8, i8* %add.ptr52, i64 -64
  %65 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr53, i1 false, i1 true)
  %call54 = call i8* @__memcpy_chk(i8* %add.ptr48, i8* %add.ptr49, i64 64, i64 %65) #10
  br label %if.end55

if.end55:                                         ; preds = %do.end44, %if.end29
  %66 = load i8*, i8** %input.addr, align 8
  %67 = load i8*, i8** %bEnd, align 8
  %cmp56 = icmp ult i8* %66, %67
  br i1 %cmp56, label %if.then58, label %if.end67

if.then58:                                        ; preds = %if.end55
  %68 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer59 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %68, i32 0, i32 2
  %arraydecay60 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer59, i32 0, i32 0
  %69 = load i8*, i8** %input.addr, align 8
  %70 = load i8*, i8** %bEnd, align 8
  %71 = load i8*, i8** %input.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %70 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %71 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call61 = call i8* @XXH_memcpy(i8* %arraydecay60, i8* %69, i64 %sub.ptr.sub)
  %72 = load i8*, i8** %bEnd, align 8
  %73 = load i8*, i8** %input.addr, align 8
  %sub.ptr.lhs.cast62 = ptrtoint i8* %72 to i64
  %sub.ptr.rhs.cast63 = ptrtoint i8* %73 to i64
  %sub.ptr.sub64 = sub i64 %sub.ptr.lhs.cast62, %sub.ptr.rhs.cast63
  %conv65 = trunc i64 %sub.ptr.sub64 to i32
  %74 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize66 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %74, i32 0, i32 3
  store i32 %conv65, i32* %bufferedSize66, align 16
  br label %if.end67

if.end67:                                         ; preds = %if.then58, %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end67, %if.then6, %if.then
  %75 = load i32, i32* %retval, align 4
  ret i32 %75
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_accumulate_512_sse2(i8* noalias %acc, i8* noalias %input, i8* noalias %secret, i32 %accWidth) #4 {
entry:
  %__p.addr.i28 = alloca <2 x i64>*, align 8
  %__a.addr.i26 = alloca <2 x i64>, align 16
  %__b.addr.i27 = alloca <2 x i64>, align 16
  %__a.addr.i24 = alloca <2 x i64>, align 16
  %__b.addr.i25 = alloca <2 x i64>, align 16
  %__a.addr.i21 = alloca <2 x i64>, align 16
  %__b.addr.i22 = alloca <2 x i64>, align 16
  %__a.addr.i18 = alloca <2 x i64>, align 16
  %__b.addr.i19 = alloca <2 x i64>, align 16
  %__a.addr.i15 = alloca <2 x i64>, align 16
  %__b.addr.i16 = alloca <2 x i64>, align 16
  %__a.addr.i = alloca <2 x i64>, align 16
  %__b.addr.i = alloca <2 x i64>, align 16
  %__p.addr.i = alloca <2 x i64>*, align 8
  %acc.addr = alloca i8*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %xacc = alloca <2 x i64>*, align 16
  %xinput = alloca <2 x i64>*, align 8
  %xsecret = alloca <2 x i64>*, align 8
  %i = alloca i64, align 8
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_lo = alloca <2 x i64>, align 16
  %product = alloca <2 x i64>, align 16
  %data_swap = alloca <2 x i64>, align 16
  %sum = alloca <2 x i64>, align 16
  %sum10 = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  %0 = load i8*, i8** %acc.addr, align 8
  %1 = bitcast i8* %0 to <2 x i64>*
  store <2 x i64>* %1, <2 x i64>** %xacc, align 16
  %2 = load i8*, i8** %input.addr, align 8
  %3 = bitcast i8* %2 to <2 x i64>*
  store <2 x i64>* %3, <2 x i64>** %xinput, align 8
  %4 = load i8*, i8** %secret.addr, align 8
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64>* %5, <2 x i64>** %xsecret, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i64, i64* %i, align 8
  %cmp = icmp ult i64 %6, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load <2 x i64>*, <2 x i64>** %xinput, align 8
  %8 = load i64, i64* %i, align 8
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %7, i64 %8
  store <2 x i64>* %add.ptr, <2 x i64>** %__p.addr.i, align 8
  %9 = load <2 x i64>*, <2 x i64>** %__p.addr.i, align 8
  %10 = bitcast <2 x i64>* %9 to %struct.__loadu_si128*
  %__v.i = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %10, i32 0, i32 0
  %11 = load <2 x i64>, <2 x i64>* %__v.i, align 1
  store <2 x i64> %11, <2 x i64>* %data_vec, align 16
  %12 = load <2 x i64>*, <2 x i64>** %xsecret, align 8
  %13 = load i64, i64* %i, align 8
  %add.ptr1 = getelementptr inbounds <2 x i64>, <2 x i64>* %12, i64 %13
  store <2 x i64>* %add.ptr1, <2 x i64>** %__p.addr.i28, align 8
  %14 = load <2 x i64>*, <2 x i64>** %__p.addr.i28, align 8
  %15 = bitcast <2 x i64>* %14 to %struct.__loadu_si128*
  %__v.i29 = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %15, i32 0, i32 0
  %16 = load <2 x i64>, <2 x i64>* %__v.i29, align 1
  store <2 x i64> %16, <2 x i64>* %key_vec, align 16
  %17 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  %18 = load <2 x i64>, <2 x i64>* %key_vec, align 16
  store <2 x i64> %17, <2 x i64>* %__a.addr.i26, align 16
  store <2 x i64> %18, <2 x i64>* %__b.addr.i27, align 16
  %19 = load <2 x i64>, <2 x i64>* %__a.addr.i26, align 16
  %20 = load <2 x i64>, <2 x i64>* %__b.addr.i27, align 16
  %xor.i = xor <2 x i64> %19, %20
  store <2 x i64> %xor.i, <2 x i64>* %data_key, align 16
  %21 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %22 = bitcast <2 x i64> %21 to <4 x i32>
  %permil = shufflevector <4 x i32> %22, <4 x i32> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %23 = bitcast <4 x i32> %permil to <2 x i64>
  store <2 x i64> %23, <2 x i64>* %data_key_lo, align 16
  %24 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %25 = load <2 x i64>, <2 x i64>* %data_key_lo, align 16
  store <2 x i64> %24, <2 x i64>* %__a.addr.i24, align 16
  store <2 x i64> %25, <2 x i64>* %__b.addr.i25, align 16
  %26 = load <2 x i64>, <2 x i64>* %__a.addr.i24, align 16
  %27 = bitcast <2 x i64> %26 to <4 x i32>
  %28 = load <2 x i64>, <2 x i64>* %__b.addr.i25, align 16
  %29 = bitcast <2 x i64> %28 to <4 x i32>
  %30 = and <2 x i64> %26, <i64 4294967295, i64 4294967295>
  %31 = and <2 x i64> %28, <i64 4294967295, i64 4294967295>
  %32 = mul <2 x i64> %30, %31
  store <2 x i64> %32, <2 x i64>* %product, align 16
  %33 = load i32, i32* %accWidth.addr, align 4
  %cmp5 = icmp eq i32 %33, 1
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %34 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  %35 = bitcast <2 x i64> %34 to <4 x i32>
  %permil6 = shufflevector <4 x i32> %35, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %36 = bitcast <4 x i32> %permil6 to <2 x i64>
  store <2 x i64> %36, <2 x i64>* %data_swap, align 16
  %37 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %38 = load i64, i64* %i, align 8
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %37, i64 %38
  %39 = load <2 x i64>, <2 x i64>* %arrayidx, align 16
  %40 = load <2 x i64>, <2 x i64>* %data_swap, align 16
  store <2 x i64> %39, <2 x i64>* %__a.addr.i21, align 16
  store <2 x i64> %40, <2 x i64>* %__b.addr.i22, align 16
  %41 = load <2 x i64>, <2 x i64>* %__a.addr.i21, align 16
  %42 = load <2 x i64>, <2 x i64>* %__b.addr.i22, align 16
  %add.i23 = add <2 x i64> %41, %42
  store <2 x i64> %add.i23, <2 x i64>* %sum, align 16
  %43 = load <2 x i64>, <2 x i64>* %product, align 16
  %44 = load <2 x i64>, <2 x i64>* %sum, align 16
  store <2 x i64> %43, <2 x i64>* %__a.addr.i18, align 16
  store <2 x i64> %44, <2 x i64>* %__b.addr.i19, align 16
  %45 = load <2 x i64>, <2 x i64>* %__a.addr.i18, align 16
  %46 = load <2 x i64>, <2 x i64>* %__b.addr.i19, align 16
  %add.i20 = add <2 x i64> %45, %46
  %47 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %48 = load i64, i64* %i, align 8
  %arrayidx9 = getelementptr inbounds <2 x i64>, <2 x i64>* %47, i64 %48
  store <2 x i64> %add.i20, <2 x i64>* %arrayidx9, align 16
  br label %if.end

if.else:                                          ; preds = %for.body
  %49 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %50 = load i64, i64* %i, align 8
  %arrayidx11 = getelementptr inbounds <2 x i64>, <2 x i64>* %49, i64 %50
  %51 = load <2 x i64>, <2 x i64>* %arrayidx11, align 16
  %52 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  store <2 x i64> %51, <2 x i64>* %__a.addr.i15, align 16
  store <2 x i64> %52, <2 x i64>* %__b.addr.i16, align 16
  %53 = load <2 x i64>, <2 x i64>* %__a.addr.i15, align 16
  %54 = load <2 x i64>, <2 x i64>* %__b.addr.i16, align 16
  %add.i17 = add <2 x i64> %53, %54
  store <2 x i64> %add.i17, <2 x i64>* %sum10, align 16
  %55 = load <2 x i64>, <2 x i64>* %product, align 16
  %56 = load <2 x i64>, <2 x i64>* %sum10, align 16
  store <2 x i64> %55, <2 x i64>* %__a.addr.i, align 16
  store <2 x i64> %56, <2 x i64>* %__b.addr.i, align 16
  %57 = load <2 x i64>, <2 x i64>* %__a.addr.i, align 16
  %58 = load <2 x i64>, <2 x i64>* %__b.addr.i, align 16
  %add.i = add <2 x i64> %57, %58
  %59 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %60 = load i64, i64* %i, align 8
  %arrayidx14 = getelementptr inbounds <2 x i64>, <2 x i64>* %59, i64 %60
  store <2 x i64> %add.i, <2 x i64>* %arrayidx14, align 16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %61 = load i64, i64* %i, align 8
  %inc = add i64 %61, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_scrambleAcc_sse2(i8* noalias %acc, i8* noalias %secret) #4 {
entry:
  %__a.addr.i20 = alloca <2 x i64>, align 16
  %__count.addr.i21 = alloca i32, align 4
  %__a.addr.i17 = alloca <2 x i64>, align 16
  %__b.addr.i18 = alloca <2 x i64>, align 16
  %__p.addr.i = alloca <2 x i64>*, align 8
  %__a.addr.i15 = alloca <2 x i64>, align 16
  %__b.addr.i16 = alloca <2 x i64>, align 16
  %__a.addr.i13 = alloca <2 x i64>, align 16
  %__b.addr.i14 = alloca <2 x i64>, align 16
  %__a.addr.i11 = alloca <2 x i64>, align 16
  %__b.addr.i12 = alloca <2 x i64>, align 16
  %__a.addr.i10 = alloca <2 x i64>, align 16
  %__count.addr.i = alloca i32, align 4
  %__a.addr.i = alloca <2 x i64>, align 16
  %__b.addr.i = alloca <2 x i64>, align 16
  %__i3.addr.i.i = alloca i32, align 4
  %__i2.addr.i.i = alloca i32, align 4
  %__i1.addr.i.i = alloca i32, align 4
  %__i0.addr.i.i = alloca i32, align 4
  %.compoundliteral.i.i = alloca <4 x i32>, align 16
  %__i.addr.i = alloca i32, align 4
  %acc.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %xacc = alloca <2 x i64>*, align 16
  %xsecret = alloca <2 x i64>*, align 8
  %prime32 = alloca <2 x i64>, align 16
  %i = alloca i64, align 8
  %acc_vec = alloca <2 x i64>, align 16
  %shifted = alloca <2 x i64>, align 16
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_hi = alloca <2 x i64>, align 16
  %prod_lo = alloca <2 x i64>, align 16
  %prod_hi = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  %0 = load i8*, i8** %acc.addr, align 8
  %1 = bitcast i8* %0 to <2 x i64>*
  store <2 x i64>* %1, <2 x i64>** %xacc, align 16
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = bitcast i8* %2 to <2 x i64>*
  store <2 x i64>* %3, <2 x i64>** %xsecret, align 8
  store i32 -1640531535, i32* %__i.addr.i, align 4
  %4 = load i32, i32* %__i.addr.i, align 4
  %5 = load i32, i32* %__i.addr.i, align 4
  %6 = load i32, i32* %__i.addr.i, align 4
  %7 = load i32, i32* %__i.addr.i, align 4
  store i32 %4, i32* %__i3.addr.i.i, align 4
  store i32 %5, i32* %__i2.addr.i.i, align 4
  store i32 %6, i32* %__i1.addr.i.i, align 4
  store i32 %7, i32* %__i0.addr.i.i, align 4
  %8 = load i32, i32* %__i0.addr.i.i, align 4
  %vecinit.i.i = insertelement <4 x i32> undef, i32 %8, i32 0
  %9 = load i32, i32* %__i1.addr.i.i, align 4
  %vecinit1.i.i = insertelement <4 x i32> %vecinit.i.i, i32 %9, i32 1
  %10 = load i32, i32* %__i2.addr.i.i, align 4
  %vecinit2.i.i = insertelement <4 x i32> %vecinit1.i.i, i32 %10, i32 2
  %11 = load i32, i32* %__i3.addr.i.i, align 4
  %vecinit3.i.i = insertelement <4 x i32> %vecinit2.i.i, i32 %11, i32 3
  store <4 x i32> %vecinit3.i.i, <4 x i32>* %.compoundliteral.i.i, align 16
  %12 = load <4 x i32>, <4 x i32>* %.compoundliteral.i.i, align 16
  %13 = bitcast <4 x i32> %12 to <2 x i64>
  store <2 x i64> %13, <2 x i64>* %prime32, align 16
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %14 = load i64, i64* %i, align 8
  %cmp = icmp ult i64 %14, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %16 = load i64, i64* %i, align 8
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %15, i64 %16
  %17 = load <2 x i64>, <2 x i64>* %arrayidx, align 16
  store <2 x i64> %17, <2 x i64>* %acc_vec, align 16
  %18 = load <2 x i64>, <2 x i64>* %acc_vec, align 16
  store <2 x i64> %18, <2 x i64>* %__a.addr.i20, align 16
  store i32 47, i32* %__count.addr.i21, align 4
  %19 = load <2 x i64>, <2 x i64>* %__a.addr.i20, align 16
  %20 = load i32, i32* %__count.addr.i21, align 4
  %21 = call <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64> %19, i32 %20) #10
  store <2 x i64> %21, <2 x i64>* %shifted, align 16
  %22 = load <2 x i64>, <2 x i64>* %acc_vec, align 16
  %23 = load <2 x i64>, <2 x i64>* %shifted, align 16
  store <2 x i64> %22, <2 x i64>* %__a.addr.i17, align 16
  store <2 x i64> %23, <2 x i64>* %__b.addr.i18, align 16
  %24 = load <2 x i64>, <2 x i64>* %__a.addr.i17, align 16
  %25 = load <2 x i64>, <2 x i64>* %__b.addr.i18, align 16
  %xor.i19 = xor <2 x i64> %24, %25
  store <2 x i64> %xor.i19, <2 x i64>* %data_vec, align 16
  %26 = load <2 x i64>*, <2 x i64>** %xsecret, align 8
  %27 = load i64, i64* %i, align 8
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %26, i64 %27
  store <2 x i64>* %add.ptr, <2 x i64>** %__p.addr.i, align 8
  %28 = load <2 x i64>*, <2 x i64>** %__p.addr.i, align 8
  %29 = bitcast <2 x i64>* %28 to %struct.__loadu_si128*
  %__v.i = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %29, i32 0, i32 0
  %30 = load <2 x i64>, <2 x i64>* %__v.i, align 1
  store <2 x i64> %30, <2 x i64>* %key_vec, align 16
  %31 = load <2 x i64>, <2 x i64>* %data_vec, align 16
  %32 = load <2 x i64>, <2 x i64>* %key_vec, align 16
  store <2 x i64> %31, <2 x i64>* %__a.addr.i15, align 16
  store <2 x i64> %32, <2 x i64>* %__b.addr.i16, align 16
  %33 = load <2 x i64>, <2 x i64>* %__a.addr.i15, align 16
  %34 = load <2 x i64>, <2 x i64>* %__b.addr.i16, align 16
  %xor.i = xor <2 x i64> %33, %34
  store <2 x i64> %xor.i, <2 x i64>* %data_key, align 16
  %35 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %36 = bitcast <2 x i64> %35 to <4 x i32>
  %permil = shufflevector <4 x i32> %36, <4 x i32> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %37 = bitcast <4 x i32> %permil to <2 x i64>
  store <2 x i64> %37, <2 x i64>* %data_key_hi, align 16
  %38 = load <2 x i64>, <2 x i64>* %data_key, align 16
  %39 = load <2 x i64>, <2 x i64>* %prime32, align 16
  store <2 x i64> %38, <2 x i64>* %__a.addr.i13, align 16
  store <2 x i64> %39, <2 x i64>* %__b.addr.i14, align 16
  %40 = load <2 x i64>, <2 x i64>* %__a.addr.i13, align 16
  %41 = bitcast <2 x i64> %40 to <4 x i32>
  %42 = load <2 x i64>, <2 x i64>* %__b.addr.i14, align 16
  %43 = bitcast <2 x i64> %42 to <4 x i32>
  %44 = and <2 x i64> %40, <i64 4294967295, i64 4294967295>
  %45 = and <2 x i64> %42, <i64 4294967295, i64 4294967295>
  %46 = mul <2 x i64> %44, %45
  store <2 x i64> %46, <2 x i64>* %prod_lo, align 16
  %47 = load <2 x i64>, <2 x i64>* %data_key_hi, align 16
  %48 = load <2 x i64>, <2 x i64>* %prime32, align 16
  store <2 x i64> %47, <2 x i64>* %__a.addr.i11, align 16
  store <2 x i64> %48, <2 x i64>* %__b.addr.i12, align 16
  %49 = load <2 x i64>, <2 x i64>* %__a.addr.i11, align 16
  %50 = bitcast <2 x i64> %49 to <4 x i32>
  %51 = load <2 x i64>, <2 x i64>* %__b.addr.i12, align 16
  %52 = bitcast <2 x i64> %51 to <4 x i32>
  %53 = and <2 x i64> %49, <i64 4294967295, i64 4294967295>
  %54 = and <2 x i64> %51, <i64 4294967295, i64 4294967295>
  %55 = mul <2 x i64> %53, %54
  store <2 x i64> %55, <2 x i64>* %prod_hi, align 16
  %56 = load <2 x i64>, <2 x i64>* %prod_lo, align 16
  %57 = load <2 x i64>, <2 x i64>* %prod_hi, align 16
  store <2 x i64> %57, <2 x i64>* %__a.addr.i10, align 16
  store i32 32, i32* %__count.addr.i, align 4
  %58 = load <2 x i64>, <2 x i64>* %__a.addr.i10, align 16
  %59 = load i32, i32* %__count.addr.i, align 4
  %60 = call <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64> %58, i32 %59) #10
  store <2 x i64> %56, <2 x i64>* %__a.addr.i, align 16
  store <2 x i64> %60, <2 x i64>* %__b.addr.i, align 16
  %61 = load <2 x i64>, <2 x i64>* %__a.addr.i, align 16
  %62 = load <2 x i64>, <2 x i64>* %__b.addr.i, align 16
  %add.i = add <2 x i64> %61, %62
  %63 = load <2 x i64>*, <2 x i64>** %xacc, align 16
  %64 = load i64, i64* %i, align 8
  %arrayidx9 = getelementptr inbounds <2 x i64>, <2 x i64>* %63, i64 %64
  store <2 x i64> %add.i, <2 x i64>* %arrayidx9, align 16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %65 = load i64, i64* %i, align 8
  %inc = add i64 %65, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @XXH3_64bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca i64, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %0, i32 0, i32 11
  %1 = load i8*, i8** %extSecret, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 11
  %4 = load i8*, i8** %extSecret1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %4, %cond.false ]
  store i8* %cond, i8** %secret, align 8
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 8
  %6 = load i64, i64* %totalLen, align 16
  %cmp2 = icmp ugt i64 %6, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %8 = load i8*, i8** %secret, align 8
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %7, i8* %8, i32 0)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret, align 8
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 11
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 8
  %11 = load i64, i64* %totalLen5, align 16
  %mul = mul i64 %11, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 9
  %13 = load i64, i64* %seed, align 8
  %tobool = icmp ne i64 %13, 0
  br i1 %tobool, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 8
  %16 = load i64, i64* %totalLen8, align 16
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 9
  %18 = load i64, i64* %seed9, align 8
  %call10 = call i64 @XXH3_64bits_withSeed(i8* %arraydecay7, i64 %16, i64 %18)
  store i64 %call10, i64* %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer12 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 2
  %arraydecay13 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer12, i32 0, i32 0
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 8
  %21 = load i64, i64* %totalLen14, align 16
  %22 = load i8*, i8** %secret, align 8
  %23 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %23, i32 0, i32 7
  %24 = load i64, i64* %secretLimit, align 8
  %add = add i64 %24, 64
  %call15 = call i64 @XXH3_64bits_withSecret(i8* %arraydecay13, i64 %21, i8* %22, i64 %add)
  store i64 %call15, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then6, %if.then
  %25 = load i64, i64* %retval, align 8
  ret i64 %25
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_digest_long(i64* %acc, %struct.XXH3_state_s* %state, i8* %secret, i32 %accWidth) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %nbStripes = alloca i64, align 8
  %nbStripesSoFar = alloca i64, align 8
  %lastStripe = alloca [64 x i8], align 16
  %catchupSize = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  %0 = load i64*, i64** %acc.addr, align 8
  %1 = bitcast i64* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i32 0, i32 0
  %3 = bitcast i64* %arraydecay to i8*
  %4 = load i64*, i64** %acc.addr, align 8
  %5 = bitcast i64* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 64, i64 %6) #10
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 3
  %8 = load i32, i32* %bufferedSize, align 16
  %cmp = icmp uge i32 %8, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 3
  %10 = load i32, i32* %bufferedSize2, align 16
  %div = udiv i32 %10, 64
  %conv = zext i32 %div to i64
  store i64 %conv, i64* %nbStripes, align 8
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesSoFar3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 6
  %12 = load i64, i64* %nbStripesSoFar3, align 16
  store i64 %12, i64* %nbStripesSoFar, align 8
  %13 = load i64*, i64** %acc.addr, align 8
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 5
  %15 = load i64, i64* %nbStripesPerBlock, align 8
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %17 = load i64, i64* %nbStripes, align 8
  %18 = load i8*, i8** %secret.addr, align 8
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 7
  %20 = load i64, i64* %secretLimit, align 8
  %21 = load i32, i32* %accWidth.addr, align 4
  call void @XXH3_consumeStripes(i64* %13, i64* %nbStripesSoFar, i64 %15, i8* %arraydecay4, i64 %17, i8* %18, i64 %20, i32 %21, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 3
  %23 = load i32, i32* %bufferedSize5, align 16
  %rem = urem i32 %23, 64
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %24 = load i64*, i64** %acc.addr, align 8
  %25 = bitcast i64* %24 to i8*
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer7, i32 0, i32 0
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 3
  %28 = load i32, i32* %bufferedSize9, align 16
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay8, i64 %idx.ext
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr, i64 -64
  %29 = load i8*, i8** %secret.addr, align 8
  %30 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %30, i32 0, i32 7
  %31 = load i64, i64* %secretLimit11, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %29, i64 %31
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -7
  %32 = load i32, i32* %accWidth.addr, align 4
  call void @XXH3_accumulate_512_sse2(i8* %25, i8* %add.ptr10, i8* %add.ptr13, i32 %32)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  br label %if.end39

if.else:                                          ; preds = %entry
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 3
  %34 = load i32, i32* %bufferedSize14, align 16
  %tobool15 = icmp ne i32 %34, 0
  br i1 %tobool15, label %if.then16, label %if.end38

if.then16:                                        ; preds = %if.else
  %35 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %35, i32 0, i32 3
  %36 = load i32, i32* %bufferedSize17, align 16
  %sub = sub i32 64, %36
  %conv18 = zext i32 %sub to i64
  store i64 %conv18, i64* %catchupSize, align 8
  %arraydecay19 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay21, i64 256
  %38 = load i64, i64* %catchupSize, align 8
  %idx.neg = sub i64 0, %38
  %add.ptr23 = getelementptr inbounds i8, i8* %add.ptr22, i64 %idx.neg
  %39 = load i64, i64* %catchupSize, align 8
  %call24 = call i8* @__memcpy_chk(i8* %arraydecay19, i8* %add.ptr23, i64 %39, i64 64) #10
  %arraydecay25 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %40 = load i64, i64* %catchupSize, align 8
  %add.ptr26 = getelementptr inbounds i8, i8* %arraydecay25, i64 %40
  %41 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer27 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %41, i32 0, i32 2
  %arraydecay28 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer27, i32 0, i32 0
  %42 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %bufferedSize29 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %42, i32 0, i32 3
  %43 = load i32, i32* %bufferedSize29, align 16
  %conv30 = zext i32 %43 to i64
  %arraydecay31 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %44 = load i64, i64* %catchupSize, align 8
  %add.ptr32 = getelementptr inbounds i8, i8* %arraydecay31, i64 %44
  %45 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr32, i1 false, i1 true)
  %call33 = call i8* @__memcpy_chk(i8* %add.ptr26, i8* %arraydecay28, i64 %conv30, i64 %45) #10
  %46 = load i64*, i64** %acc.addr, align 8
  %47 = bitcast i64* %46 to i8*
  %arraydecay34 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %48 = load i8*, i8** %secret.addr, align 8
  %49 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit35 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %49, i32 0, i32 7
  %50 = load i64, i64* %secretLimit35, align 8
  %add.ptr36 = getelementptr inbounds i8, i8* %48, i64 %50
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr36, i64 -7
  %51 = load i32, i32* %accWidth.addr, align 4
  call void @XXH3_accumulate_512_sse2(i8* %47, i8* %arraydecay34, i8* %add.ptr37, i32 %51)
  br label %if.end38

if.end38:                                         ; preds = %if.then16, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mergeAccs(i64* noalias %acc, i8* noalias %secret, i64 %start) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  %start.addr = alloca i64, align 8
  %result64 = alloca i64, align 8
  %i = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  %0 = load i64, i64* %start.addr, align 8
  store i64 %0, i64* %result64, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %i, align 8
  %cmp = icmp ult i64 %1, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64*, i64** %acc.addr, align 8
  %3 = load i64, i64* %i, align 8
  %mul = mul i64 2, %3
  %add.ptr = getelementptr inbounds i64, i64* %2, i64 %mul
  %4 = load i8*, i8** %secret.addr, align 8
  %5 = load i64, i64* %i, align 8
  %mul1 = mul i64 16, %5
  %add.ptr2 = getelementptr inbounds i8, i8* %4, i64 %mul1
  %call = call i64 @XXH3_mix2Accs(i64* %add.ptr, i8* %add.ptr2)
  %6 = load i64, i64* %result64, align 8
  %add = add i64 %6, %call
  store i64 %add, i64* %result64, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, i64* %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i64, i64* %result64, align 8
  %call3 = call i64 @XXH3_avalanche(i64 %8)
  ret i64 %call3
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH3_generateSecret(i8* %secretBuffer, i8* %customSeed, i64 %customSeedSize) #0 {
entry:
  %secretBuffer.addr = alloca i8*, align 8
  %customSeed.addr = alloca i8*, align 8
  %customSeedSize.addr = alloca i64, align 8
  %segmentSize = alloca i64, align 8
  %nbSegments = alloca i64, align 8
  %scrambler = alloca %struct.XXH128_canonical_t, align 1
  %seeds = alloca [12 x i64], align 16
  %segnb = alloca i64, align 8
  %agg.tmp = alloca %struct.XXH128_hash_t, align 8
  %toFill = alloca i64, align 8
  %filled = alloca i64, align 8
  %segmentStart = alloca i64, align 8
  %segment = alloca %struct.XXH128_canonical_t, align 1
  %agg.tmp18 = alloca %struct.XXH128_hash_t, align 8
  store i8* %secretBuffer, i8** %secretBuffer.addr, align 8
  store i8* %customSeed, i8** %customSeed.addr, align 8
  store i64 %customSeedSize, i64* %customSeedSize.addr, align 8
  %0 = load i64, i64* %customSeedSize.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %secretBuffer.addr, align 8
  %2 = load i8*, i8** %secretBuffer.addr, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 %3) #10
  br label %for.end

if.end:                                           ; preds = %entry
  store i64 16, i64* %segmentSize, align 8
  store i64 12, i64* %nbSegments, align 8
  %4 = load i8*, i8** %customSeed.addr, align 8
  %5 = load i64, i64* %customSeedSize.addr, align 8
  %call1 = call { i64, i64 } @XXH128(i8* %4, i64 %5, i64 0)
  %6 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call1, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call1, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %scrambler, i64 %13, i64 %15)
  %16 = load i64, i64* %customSeedSize.addr, align 8
  %cmp2 = icmp ugt i64 %16, 96
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %17 = load i64, i64* %customSeedSize.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 96, %cond.true ], [ %17, %cond.false ]
  store i64 %cond, i64* %toFill, align 8
  %18 = load i64, i64* %toFill, align 8
  store i64 %18, i64* %filled, align 8
  %arraydecay = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %19 = bitcast i64* %arraydecay to i8*
  %20 = load i8*, i8** %customSeed.addr, align 8
  %21 = load i64, i64* %toFill, align 8
  %call3 = call i8* @__memcpy_chk(i8* %19, i8* %20, i64 %21, i64 96) #10
  br label %while.cond

while.cond:                                       ; preds = %cond.end9, %cond.end
  %22 = load i64, i64* %filled, align 8
  %cmp4 = icmp ult i64 %22, 96
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %23 = load i64, i64* %filled, align 8
  %24 = load i64, i64* %filled, align 8
  %sub = sub i64 96, %24
  %cmp5 = icmp ugt i64 %23, %sub
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %while.body
  %25 = load i64, i64* %filled, align 8
  %sub7 = sub i64 96, %25
  br label %cond.end9

cond.false8:                                      ; preds = %while.body
  %26 = load i64, i64* %filled, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true6
  %cond10 = phi i64 [ %sub7, %cond.true6 ], [ %26, %cond.false8 ]
  store i64 %cond10, i64* %toFill, align 8
  %arraydecay11 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %27 = bitcast i64* %arraydecay11 to i8*
  %28 = load i64, i64* %filled, align 8
  %add.ptr = getelementptr inbounds i8, i8* %27, i64 %28
  %arraydecay12 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %29 = bitcast i64* %arraydecay12 to i8*
  %30 = load i64, i64* %toFill, align 8
  %arraydecay13 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %31 = bitcast i64* %arraydecay13 to i8*
  %32 = load i64, i64* %filled, align 8
  %add.ptr14 = getelementptr inbounds i8, i8* %31, i64 %32
  %33 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr14, i1 false, i1 true)
  %call15 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %29, i64 %30, i64 %33) #10
  %34 = load i64, i64* %toFill, align 8
  %35 = load i64, i64* %filled, align 8
  %add = add i64 %35, %34
  store i64 %add, i64* %filled, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i8*, i8** %secretBuffer.addr, align 8
  %37 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %38 = load i8*, i8** %secretBuffer.addr, align 8
  %39 = call i64 @llvm.objectsize.i64.p0i8(i8* %38, i1 false, i1 true)
  %call16 = call i8* @__memcpy_chk(i8* %36, i8* %37, i64 16, i64 %39) #10
  store i64 1, i64* %segnb, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %40 = load i64, i64* %segnb, align 8
  %cmp17 = icmp ult i64 %40, 12
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %41 = load i64, i64* %segnb, align 8
  %mul = mul i64 %41, 16
  store i64 %mul, i64* %segmentStart, align 8
  %42 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %arraydecay19 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %43 = load i64, i64* %segnb, align 8
  %add.ptr20 = getelementptr inbounds i64, i64* %arraydecay19, i64 %43
  %44 = bitcast i64* %add.ptr20 to i8*
  %call21 = call i64 @XXH_readLE64(i8* %44)
  %45 = load i64, i64* %segnb, align 8
  %add22 = add i64 %call21, %45
  %call23 = call { i64, i64 } @XXH128(i8* %42, i64 16, i64 %add22)
  %46 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = extractvalue { i64, i64 } %call23, 0
  store i64 %48, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = extractvalue { i64, i64 } %call23, 1
  store i64 %50, i64* %49, align 8
  %51 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %segment, i64 %53, i64 %55)
  %56 = load i8*, i8** %secretBuffer.addr, align 8
  %57 = load i64, i64* %segmentStart, align 8
  %add.ptr24 = getelementptr inbounds i8, i8* %56, i64 %57
  %58 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  %59 = load i8*, i8** %secretBuffer.addr, align 8
  %60 = load i64, i64* %segmentStart, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %59, i64 %60
  %61 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr25, i1 false, i1 true)
  %call26 = call i8* @__memcpy_chk(i8* %add.ptr24, i8* %58, i64 16, i64 %61) #10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %62 = load i64, i64* %segnb, align 8
  %inc = add i64 %62, 1
  store i64 %inc, i64* %segnb, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %dst, i64 %hash.coerce0, i64 %hash.coerce1) #0 {
entry:
  %hash = alloca %struct.XXH128_hash_t, align 8
  %dst.addr = alloca %struct.XXH128_canonical_t*, align 8
  %0 = bitcast %struct.XXH128_hash_t* %hash to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %hash.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %hash.coerce1, i64* %2, align 8
  store %struct.XXH128_canonical_t* %dst, %struct.XXH128_canonical_t** %dst.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %3 = load i64, i64* %high64, align 8
  %call = call i64 @XXH_swap64(i64 %3)
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  store i64 %call, i64* %high641, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %4 = load i64, i64* %low64, align 8
  %call2 = call i64 @XXH_swap64(i64 %4)
  %low643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  store i64 %call2, i64* %low643, align 8
  %5 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %6 = bitcast %struct.XXH128_canonical_t* %5 to i8*
  %high644 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %7 = bitcast i64* %high644 to i8*
  %8 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %9 = bitcast %struct.XXH128_canonical_t* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call5 = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 8, i64 %10) #10
  %11 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %12 = bitcast %struct.XXH128_canonical_t* %11 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 8
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %13 = bitcast i64* %low646 to i8*
  %14 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8
  %15 = bitcast %struct.XXH128_canonical_t* %14 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %15, i64 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr7, i1 false, i1 true)
  %call8 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %13, i64 8, i64 %16) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH128(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_withSeed(i8* %0, i64 %1, i64 %2)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits(i8* %input, i64 %len) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSecret)
  %2 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_128bits_internal(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hl128.addr = alloca { i64, i64 } (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  store { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed64.addr, align 8
  %call = call { i64, i64 } @XXH3_len_0to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ule i64 %10, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8
  %12 = load i64, i64* %len.addr, align 8
  %13 = load i8*, i8** %secret.addr, align 8
  %14 = load i64, i64* %secretLen.addr, align 8
  %15 = load i64, i64* %seed64.addr, align 8
  %call3 = call { i64, i64 } @XXH3_len_17to128_128b(i8* %11, i64 %12, i8* %13, i64 %14, i64 %15)
  %16 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call3, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call3, 1
  store i64 %20, i64* %19, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %21 = load i64, i64* %len.addr, align 8
  %cmp5 = icmp ule i64 %21, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %22 = load i8*, i8** %input.addr, align 8
  %23 = load i64, i64* %len.addr, align 8
  %24 = load i8*, i8** %secret.addr, align 8
  %25 = load i64, i64* %secretLen.addr, align 8
  %26 = load i64, i64* %seed64.addr, align 8
  %call7 = call { i64, i64 } @XXH3_len_129to240_128b(i8* %22, i64 %23, i8* %24, i64 %25, i64 %26)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call7, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call7, 1
  store i64 %31, i64* %30, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %32 = load { i64, i64 } (i8*, i64, i64, i8*, i64)*, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8
  %33 = load i8*, i8** %input.addr, align 8
  %34 = load i64, i64* %len.addr, align 8
  %35 = load i64, i64* %seed64.addr, align 8
  %36 = load i8*, i8** %secret.addr, align 8
  %37 = load i64, i64* %secretLen.addr, align 8
  %call9 = call { i64, i64 } %32(i8* %33, i64 %34, i64 %35, i8* %36, i64 %37)
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = extractvalue { i64, i64 } %call9, 0
  store i64 %40, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = extractvalue { i64, i64 } %call9, 1
  store i64 %42, i64* %41, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %43 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %44 = load { i64, i64 }, { i64, i64 }* %43, align 8
  ret { i64, i64 } %44
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretLen.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_defaultSecret)
  %4 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = extractvalue { i64, i64 } %call, 0
  store i64 %6, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = extractvalue { i64, i64 } %call, 1
  store i64 %8, i64* %7, align 8
  %9 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_defaultSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %1 = load i8*, i8** %secret.addr, align 8
  %2 = load i64, i64* %secretLen.addr, align 8
  %3 = load i8*, i8** %input.addr, align 8
  %4 = load i64, i64* %len.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %3, i64 %4, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSeed)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLen, i64* %secretLen.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %1 = load i64, i64* %secretLen.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %4 = load i64, i64* %seed64.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %1 = load i64, i64* %seed.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %0, i64 %1, i8* %2, i64 %3)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %3 = load i64, i64* %secretSize.addr, align 8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %2 = load i64, i64* %seed.addr, align 8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH3_128bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 1, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH3_128bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %0, i32 0, i32 11
  %1 = load i8*, i8** %extSecret, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 11
  %4 = load i8*, i8** %extSecret1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %4, %cond.false ]
  store i8* %cond, i8** %secret, align 8
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 8
  %6 = load i64, i64* %totalLen, align 16
  %cmp2 = icmp ugt i64 %6, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %8 = load i8*, i8** %secret, align 8
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %7, i8* %8, i32 1)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret, align 8
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 11
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 8
  %11 = load i64, i64* %totalLen5, align 16
  %mul = mul i64 %11, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call, i64* %low64, align 8
  %arraydecay6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %12 = load i8*, i8** %secret, align 8
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 7
  %14 = load i64, i64* %secretLimit, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %12, i64 %14
  %add.ptr8 = getelementptr inbounds i8, i8* %add.ptr7, i64 64
  %add.ptr9 = getelementptr inbounds i8, i8* %add.ptr8, i64 -64
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -11
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 8
  %16 = load i64, i64* %totalLen11, align 16
  %mul12 = mul i64 %16, -4417276706812531889
  %neg = xor i64 %mul12, -1
  %call13 = call i64 @XXH3_mergeAccs(i64* %arraydecay6, i8* %add.ptr10, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call13, i64* %high64, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 9
  %18 = load i64, i64* %seed, align 8
  %tobool = icmp ne i64 %18, 0
  br i1 %tobool, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.end
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 2
  %arraydecay15 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 8
  %21 = load i64, i64* %totalLen16, align 16
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %seed17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 9
  %23 = load i64, i64* %seed17, align 8
  %call18 = call { i64, i64 } @XXH3_128bits_withSeed(i8* %arraydecay15, i64 %21, i64 %23)
  %24 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call18, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call18, 1
  store i64 %28, i64* %27, align 8
  br label %return

if.end19:                                         ; preds = %if.end
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %30 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %totalLen22 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %30, i32 0, i32 8
  %31 = load i64, i64* %totalLen22, align 16
  %32 = load i8*, i8** %secret, align 8
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8
  %secretLimit23 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 7
  %34 = load i64, i64* %secretLimit23, align 8
  %add = add i64 %34, 64
  %call24 = call { i64, i64 } @XXH3_128bits_withSecret(i8* %arraydecay21, i64 %31, i8* %32, i64 %add)
  %35 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = extractvalue { i64, i64 } %call24, 0
  store i64 %37, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = extractvalue { i64, i64 } %call24, 1
  store i64 %39, i64* %38, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %40 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %41 = load { i64, i64 }, { i64, i64 }* %40, align 8
  ret { i64, i64 } %41
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH128_isEqual(i64 %h1.coerce0, i64 %h1.coerce1, i64 %h2.coerce0, i64 %h2.coerce1) #0 {
entry:
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %0 = bitcast %struct.XXH128_hash_t* %h1 to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %h1.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %h1.coerce1, i64* %2, align 8
  %3 = bitcast %struct.XXH128_hash_t* %h2 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %h2.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %h2.coerce1, i64* %5, align 8
  %6 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %7 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %call = call i32 @memcmp(i8* %6, i8* %7, i64 16)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i32 @memcmp(i8*, i8*, i64) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @XXH128_cmp(i8* %h128_1, i8* %h128_2) #0 {
entry:
  %retval = alloca i32, align 4
  %h128_1.addr = alloca i8*, align 8
  %h128_2.addr = alloca i8*, align 8
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %hcmp = alloca i32, align 4
  store i8* %h128_1, i8** %h128_1.addr, align 8
  store i8* %h128_2, i8** %h128_2.addr, align 8
  %0 = load i8*, i8** %h128_1.addr, align 8
  %1 = bitcast i8* %0 to %struct.XXH128_hash_t*
  %2 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %3 = bitcast %struct.XXH128_hash_t* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 %3, i64 16, i1 false)
  %4 = load i8*, i8** %h128_2.addr, align 8
  %5 = bitcast i8* %4 to %struct.XXH128_hash_t*
  %6 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %7 = bitcast %struct.XXH128_hash_t* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 %7, i64 16, i1 false)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %8 = load i64, i64* %high64, align 8
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %9 = load i64, i64* %high641, align 8
  %cmp = icmp ugt i64 %8, %9
  %conv = zext i1 %cmp to i32
  %high642 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %10 = load i64, i64* %high642, align 8
  %high643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %11 = load i64, i64* %high643, align 8
  %cmp4 = icmp ugt i64 %10, %11
  %conv5 = zext i1 %cmp4 to i32
  %sub = sub nsw i32 %conv, %conv5
  store i32 %sub, i32* %hcmp, align 4
  %12 = load i32, i32* %hcmp, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %13 = load i32, i32* %hcmp, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %14 = load i64, i64* %low64, align 8
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %15 = load i64, i64* %low646, align 8
  %cmp7 = icmp ugt i64 %14, %15
  %conv8 = zext i1 %cmp7 to i32
  %low649 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %16 = load i64, i64* %low649, align 8
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %17 = load i64, i64* %low6410, align 8
  %cmp11 = icmp ugt i64 %16, %17
  %conv12 = zext i1 %cmp11 to i32
  %sub13 = sub nsw i32 %conv8, %conv12
  store i32 %sub13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #3

; Function Attrs: noinline nounwind optnone ssp uwtable
define { i64, i64 } @XXH128_hashFromCanonical(%struct.XXH128_canonical_t* %src) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %src.addr = alloca %struct.XXH128_canonical_t*, align 8
  store %struct.XXH128_canonical_t* %src, %struct.XXH128_canonical_t** %src.addr, align 8
  %0 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8
  %1 = bitcast %struct.XXH128_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call, i64* %high64, align 8
  %2 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8
  %digest = getelementptr inbounds %struct.XXH128_canonical_t, %struct.XXH128_canonical_t* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %digest, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 8
  %call1 = call i64 @XXH_readBE64(i8* %add.ptr)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call1, i64* %low64, align 8
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = load { i64, i64 }, { i64, i64 }* %3, align 8
  ret { i64, i64 } %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_readLE32_align(i8* %ptr, i32 %align) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i32, i32* %align.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8
  %call = call i32 @XXH_readLE32(i8* %1)
  store i32 %call, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #6

declare void @free(i8*) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH_read32(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i32, align 4
  store i8* %memPtr, i8** %memPtr.addr, align 8
  %0 = bitcast i32* %val to i8*
  %1 = load i8*, i8** %memPtr.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 1 %1, i64 4, i1 false)
  %2 = load i32, i32* %val, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @XXH32_avalanche(i32 %h32) #0 {
entry:
  %h32.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4
  %0 = load i32, i32* %h32.addr, align 4
  %shr = lshr i32 %0, 15
  %1 = load i32, i32* %h32.addr, align 4
  %xor = xor i32 %1, %shr
  store i32 %xor, i32* %h32.addr, align 4
  %2 = load i32, i32* %h32.addr, align 4
  %mul = mul i32 %2, -2048144777
  store i32 %mul, i32* %h32.addr, align 4
  %3 = load i32, i32* %h32.addr, align 4
  %shr1 = lshr i32 %3, 13
  %4 = load i32, i32* %h32.addr, align 4
  %xor2 = xor i32 %4, %shr1
  store i32 %xor2, i32* %h32.addr, align 4
  %5 = load i32, i32* %h32.addr, align 4
  %mul3 = mul i32 %5, -1028477379
  store i32 %mul3, i32* %h32.addr, align 4
  %6 = load i32, i32* %h32.addr, align 4
  %shr4 = lshr i32 %6, 16
  %7 = load i32, i32* %h32.addr, align 4
  %xor5 = xor i32 %7, %shr4
  store i32 %xor5, i32* %h32.addr, align 4
  %8 = load i32, i32* %h32.addr, align 4
  ret i32 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_readLE64_align(i8* %ptr, i32 %align) #0 {
entry:
  %retval = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i32 %align, i32* %align.addr, align 4
  %0 = load i32, i32* %align.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8
  %call = call i64 @XXH_readLE64(i8* %1)
  store i64 %call, i64* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8
  %3 = bitcast i8* %2 to i64*
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i64, i64* %retval, align 8
  ret i64 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_read64(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i64, align 8
  store i8* %memPtr, i8** %memPtr.addr, align 8
  %0 = bitcast i64* %val to i8*
  %1 = load i8*, i8** %memPtr.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %0, i8* align 1 %1, i64 8, i1 false)
  %2 = load i64, i64* %val, align 8
  ret i64 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH64_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8
  %0 = load i64, i64* %h64.addr, align 8
  %shr = lshr i64 %0, 33
  %1 = load i64, i64* %h64.addr, align 8
  %xor = xor i64 %1, %shr
  store i64 %xor, i64* %h64.addr, align 8
  %2 = load i64, i64* %h64.addr, align 8
  %mul = mul i64 %2, -4417276706812531889
  store i64 %mul, i64* %h64.addr, align 8
  %3 = load i64, i64* %h64.addr, align 8
  %shr1 = lshr i64 %3, 29
  %4 = load i64, i64* %h64.addr, align 8
  %xor2 = xor i64 %4, %shr1
  store i64 %xor2, i64* %h64.addr, align 8
  %5 = load i64, i64* %h64.addr, align 8
  %mul3 = mul i64 %5, 1609587929392839161
  store i64 %mul3, i64* %h64.addr, align 8
  %6 = load i64, i64* %h64.addr, align 8
  %shr4 = lshr i64 %6, 32
  %7 = load i64, i64* %h64.addr, align 8
  %xor5 = xor i64 %7, %shr4
  store i64 %xor5, i64* %h64.addr, align 8
  %8 = load i64, i64* %h64.addr, align 8
  ret i64 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_0to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %0, 8
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %tobool = icmp ne i64 %conv1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_len_9to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8
  %cmp2 = icmp uge i64 %5, 4
  %conv3 = zext i1 %cmp2 to i32
  %conv4 = sext i32 %conv3 to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i64, i64* %len.addr, align 8
  %8 = load i8*, i8** %secret.addr, align 8
  %9 = load i64, i64* %seed.addr, align 8
  %call7 = call i64 @XXH3_len_4to8_64b(i8* %6, i64 %7, i8* %8, i64 %9)
  store i64 %call7, i64* %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %10 = load i64, i64* %len.addr, align 8
  %tobool9 = icmp ne i64 %10, 0
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %11 = load i8*, i8** %input.addr, align 8
  %12 = load i64, i64* %len.addr, align 8
  %13 = load i8*, i8** %secret.addr, align 8
  %14 = load i64, i64* %seed.addr, align 8
  %call11 = call i64 @XXH3_len_1to3_64b(i8* %11, i64 %12, i8* %13, i64 %14)
  store i64 %call11, i64* %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end8
  %15 = load i64, i64* %seed.addr, align 8
  %add = add i64 -7046029288634856825, %15
  %16 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 56
  %call13 = call i64 @XXH_readLE64(i8* %add.ptr)
  %17 = load i8*, i8** %secret.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, i8* %17, i64 64
  %call15 = call i64 @XXH_readLE64(i8* %add.ptr14)
  %xor = xor i64 %call13, %call15
  %xor16 = xor i64 %add, %xor
  %call17 = call i64 @XXH3_avalanche(i64 %xor16)
  store i64 %call17, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then10, %if.then6, %if.then
  %18 = load i64, i64* %retval, align 8
  ret i64 %18
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_17to128_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %1, -7046029288634856825
  store i64 %mul, i64* %acc, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %2, 32
  br i1 %cmp, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ugt i64 %3, 64
  br i1 %cmp1, label %if.then2, label %if.end20

if.then2:                                         ; preds = %if.then
  %4 = load i64, i64* %len.addr, align 8
  %cmp3 = icmp ugt i64 %4, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %5 = load i8*, i8** %input.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 48
  %6 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 96
  %7 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %7)
  %8 = load i64, i64* %acc, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %acc, align 8
  %9 = load i8*, i8** %input.addr, align 8
  %10 = load i64, i64* %len.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %9, i64 %10
  %add.ptr7 = getelementptr inbounds i8, i8* %add.ptr6, i64 -64
  %11 = load i8*, i8** %secret.addr, align 8
  %add.ptr8 = getelementptr inbounds i8, i8* %11, i64 112
  %12 = load i64, i64* %seed.addr, align 8
  %call9 = call i64 @XXH3_mix16B(i8* %add.ptr7, i8* %add.ptr8, i64 %12)
  %13 = load i64, i64* %acc, align 8
  %add10 = add i64 %13, %call9
  store i64 %add10, i64* %acc, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %14 = load i8*, i8** %input.addr, align 8
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i64 32
  %15 = load i8*, i8** %secret.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %15, i64 64
  %16 = load i64, i64* %seed.addr, align 8
  %call13 = call i64 @XXH3_mix16B(i8* %add.ptr11, i8* %add.ptr12, i64 %16)
  %17 = load i64, i64* %acc, align 8
  %add14 = add i64 %17, %call13
  store i64 %add14, i64* %acc, align 8
  %18 = load i8*, i8** %input.addr, align 8
  %19 = load i64, i64* %len.addr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %18, i64 %19
  %add.ptr16 = getelementptr inbounds i8, i8* %add.ptr15, i64 -48
  %20 = load i8*, i8** %secret.addr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %20, i64 80
  %21 = load i64, i64* %seed.addr, align 8
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr16, i8* %add.ptr17, i64 %21)
  %22 = load i64, i64* %acc, align 8
  %add19 = add i64 %22, %call18
  store i64 %add19, i64* %acc, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.end, %if.then
  %23 = load i8*, i8** %input.addr, align 8
  %add.ptr21 = getelementptr inbounds i8, i8* %23, i64 16
  %24 = load i8*, i8** %secret.addr, align 8
  %add.ptr22 = getelementptr inbounds i8, i8* %24, i64 32
  %25 = load i64, i64* %seed.addr, align 8
  %call23 = call i64 @XXH3_mix16B(i8* %add.ptr21, i8* %add.ptr22, i64 %25)
  %26 = load i64, i64* %acc, align 8
  %add24 = add i64 %26, %call23
  store i64 %add24, i64* %acc, align 8
  %27 = load i8*, i8** %input.addr, align 8
  %28 = load i64, i64* %len.addr, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %27, i64 %28
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -32
  %29 = load i8*, i8** %secret.addr, align 8
  %add.ptr27 = getelementptr inbounds i8, i8* %29, i64 48
  %30 = load i64, i64* %seed.addr, align 8
  %call28 = call i64 @XXH3_mix16B(i8* %add.ptr26, i8* %add.ptr27, i64 %30)
  %31 = load i64, i64* %acc, align 8
  %add29 = add i64 %31, %call28
  store i64 %add29, i64* %acc, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.end20, %entry
  %32 = load i8*, i8** %input.addr, align 8
  %add.ptr31 = getelementptr inbounds i8, i8* %32, i64 0
  %33 = load i8*, i8** %secret.addr, align 8
  %add.ptr32 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i64, i64* %seed.addr, align 8
  %call33 = call i64 @XXH3_mix16B(i8* %add.ptr31, i8* %add.ptr32, i64 %34)
  %35 = load i64, i64* %acc, align 8
  %add34 = add i64 %35, %call33
  store i64 %add34, i64* %acc, align 8
  %36 = load i8*, i8** %input.addr, align 8
  %37 = load i64, i64* %len.addr, align 8
  %add.ptr35 = getelementptr inbounds i8, i8* %36, i64 %37
  %add.ptr36 = getelementptr inbounds i8, i8* %add.ptr35, i64 -16
  %38 = load i8*, i8** %secret.addr, align 8
  %add.ptr37 = getelementptr inbounds i8, i8* %38, i64 16
  %39 = load i64, i64* %seed.addr, align 8
  %call38 = call i64 @XXH3_mix16B(i8* %add.ptr36, i8* %add.ptr37, i64 %39)
  %40 = load i64, i64* %acc, align 8
  %add39 = add i64 %40, %call38
  store i64 %add39, i64* %acc, align 8
  %41 = load i64, i64* %acc, align 8
  %call40 = call i64 @XXH3_avalanche(i64 %41)
  ret i64 %call40
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_129to240_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %1, -7046029288634856825
  store i64 %mul, i64* %acc, align 8
  %2 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %2 to i32
  %div = sdiv i32 %conv, 16
  store i32 %div, i32* %nbRounds, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %3, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %input.addr, align 8
  %5 = load i32, i32* %i, align 4
  %mul2 = mul nsw i32 16, %5
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %6 = load i8*, i8** %secret.addr, align 8
  %7 = load i32, i32* %i, align 4
  %mul3 = mul nsw i32 16, %7
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %idx.ext4
  %8 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %8)
  %9 = load i64, i64* %acc, align 8
  %add = add i64 %9, %call
  store i64 %add, i64* %acc, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i64, i64* %acc, align 8
  %call6 = call i64 @XXH3_avalanche(i64 %11)
  store i64 %call6, i64* %acc, align 8
  store i32 8, i32* %i, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc20, %for.end
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %nbRounds, align 4
  %cmp8 = icmp slt i32 %12, %13
  br i1 %cmp8, label %for.body10, label %for.end22

for.body10:                                       ; preds = %for.cond7
  %14 = load i8*, i8** %input.addr, align 8
  %15 = load i32, i32* %i, align 4
  %mul11 = mul nsw i32 16, %15
  %idx.ext12 = sext i32 %mul11 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %14, i64 %idx.ext12
  %16 = load i8*, i8** %secret.addr, align 8
  %17 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %17, 8
  %mul14 = mul nsw i32 16, %sub
  %idx.ext15 = sext i32 %mul14 to i64
  %add.ptr16 = getelementptr inbounds i8, i8* %16, i64 %idx.ext15
  %add.ptr17 = getelementptr inbounds i8, i8* %add.ptr16, i64 3
  %18 = load i64, i64* %seed.addr, align 8
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr13, i8* %add.ptr17, i64 %18)
  %19 = load i64, i64* %acc, align 8
  %add19 = add i64 %19, %call18
  store i64 %add19, i64* %acc, align 8
  br label %for.inc20

for.inc20:                                        ; preds = %for.body10
  %20 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %20, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond7

for.end22:                                        ; preds = %for.cond7
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i64, i64* %len.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, i8* %21, i64 %22
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %23 = load i8*, i8** %secret.addr, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %23, i64 136
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -17
  %24 = load i64, i64* %seed.addr, align 8
  %call27 = call i64 @XXH3_mix16B(i8* %add.ptr24, i8* %add.ptr26, i64 %24)
  %25 = load i64, i64* %acc, align 8
  %add28 = add i64 %25, %call27
  store i64 %add28, i64* %acc, align 8
  %26 = load i64, i64* %acc, align 8
  %call29 = call i64 @XXH3_avalanche(i64 %26)
  ret i64 %call29
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_9to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflip1 = alloca i64, align 8
  %bitflip2 = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 24
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %1 = load i8*, i8** %secret.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %1, i64 32
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %2 = load i64, i64* %seed.addr, align 8
  %add = add i64 %xor, %2
  store i64 %add, i64* %bitflip1, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 40
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %4 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %4, i64 48
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %5 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %xor7, %5
  store i64 %sub, i64* %bitflip2, align 8
  %6 = load i8*, i8** %input.addr, align 8
  %call8 = call i64 @XXH_readLE64(i8* %6)
  %7 = load i64, i64* %bitflip1, align 8
  %xor9 = xor i64 %call8, %7
  store i64 %xor9, i64* %input_lo, align 8
  %8 = load i8*, i8** %input.addr, align 8
  %9 = load i64, i64* %len.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %8, i64 %9
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -8
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %10 = load i64, i64* %bitflip2, align 8
  %xor13 = xor i64 %call12, %10
  store i64 %xor13, i64* %input_hi, align 8
  %11 = load i64, i64* %len.addr, align 8
  %12 = load i64, i64* %input_lo, align 8
  %call14 = call i64 @XXH_swap64(i64 %12)
  %add15 = add i64 %11, %call14
  %13 = load i64, i64* %input_hi, align 8
  %add16 = add i64 %add15, %13
  %14 = load i64, i64* %input_lo, align 8
  %15 = load i64, i64* %input_hi, align 8
  %call17 = call i64 @XXH3_mul128_fold64(i64 %14, i64 %15)
  %add18 = add i64 %add16, %call17
  store i64 %add18, i64* %acc, align 8
  %16 = load i64, i64* %acc, align 8
  %call19 = call i64 @XXH3_avalanche(i64 %16)
  ret i64 %call19
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_4to8_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input1 = alloca i32, align 4
  %input2 = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %input64 = alloca i64, align 8
  %x = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %seed.addr, align 8
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %call2 = call i32 @XXH_readLE32(i8* %2)
  store i32 %call2, i32* %input1, align 4
  %3 = load i8*, i8** %input.addr, align 8
  %4 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %4
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input2, align 4
  %5 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %5, i64 8
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %6 = load i8*, i8** %secret.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %6, i64 16
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr7)
  %xor9 = xor i64 %call6, %call8
  %7 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %xor9, %7
  store i64 %sub, i64* %bitflip, align 8
  %8 = load i32, i32* %input2, align 4
  %conv10 = zext i32 %8 to i64
  %9 = load i32, i32* %input1, align 4
  %conv11 = zext i32 %9 to i64
  %shl12 = shl i64 %conv11, 32
  %add = add i64 %conv10, %shl12
  store i64 %add, i64* %input64, align 8
  %10 = load i64, i64* %input64, align 8
  %11 = load i64, i64* %bitflip, align 8
  %xor13 = xor i64 %10, %11
  store i64 %xor13, i64* %x, align 8
  %12 = load i64, i64* %x, align 8
  %13 = call i64 @llvm.fshl.i64(i64 %12, i64 %12, i64 49)
  %14 = load i64, i64* %x, align 8
  %15 = call i64 @llvm.fshl.i64(i64 %14, i64 %14, i64 24)
  %xor14 = xor i64 %13, %15
  %16 = load i64, i64* %x, align 8
  %xor15 = xor i64 %16, %xor14
  store i64 %xor15, i64* %x, align 8
  %17 = load i64, i64* %x, align 8
  %mul = mul i64 %17, -6939452855193903323
  store i64 %mul, i64* %x, align 8
  %18 = load i64, i64* %x, align 8
  %shr = lshr i64 %18, 35
  %19 = load i64, i64* %len.addr, align 8
  %add16 = add i64 %shr, %19
  %20 = load i64, i64* %x, align 8
  %xor17 = xor i64 %20, %add16
  store i64 %xor17, i64* %x, align 8
  %21 = load i64, i64* %x, align 8
  %mul18 = mul i64 %21, -6939452855193903323
  store i64 %mul18, i64* %x, align 8
  %22 = load i64, i64* %x, align 8
  %call19 = call i64 @XXH_xorshift64(i64 %22, i32 28)
  ret i64 %call19
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_len_1to3_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combined = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  %mixed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1
  store i8 %1, i8* %c1, align 1
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1
  store i8 %4, i8* %c2, align 1
  %5 = load i8*, i8** %input.addr, align 8
  %6 = load i64, i64* %len.addr, align 8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1
  store i8 %7, i8* %c3, align 1
  %8 = load i8, i8* %c1, align 1
  %conv = zext i8 %8 to i32
  %shl = shl i32 %conv, 16
  %9 = load i8, i8* %c2, align 1
  %conv3 = zext i8 %9 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %10 = load i8, i8* %c3, align 1
  %conv5 = zext i8 %10 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %11 = load i64, i64* %len.addr, align 8
  %conv8 = trunc i64 %11 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combined, align 4
  %12 = load i8*, i8** %secret.addr, align 8
  %call = call i32 @XXH_readLE32(i8* %12)
  %13 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 4
  %call11 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call, %call11
  %conv12 = zext i32 %xor to i64
  %14 = load i64, i64* %seed.addr, align 8
  %add = add i64 %conv12, %14
  store i64 %add, i64* %bitflip, align 8
  %15 = load i32, i32* %combined, align 4
  %conv13 = zext i32 %15 to i64
  %16 = load i64, i64* %bitflip, align 8
  %xor14 = xor i64 %conv13, %16
  store i64 %xor14, i64* %keyed, align 8
  %17 = load i64, i64* %keyed, align 8
  %mul = mul i64 %17, -7046029288634856825
  store i64 %mul, i64* %mixed, align 8
  %18 = load i64, i64* %mixed, align 8
  %call15 = call i64 @XXH3_avalanche(i64 %18)
  ret i64 %call15
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8
  %0 = load i64, i64* %h64.addr, align 8
  %call = call i64 @XXH_xorshift64(i64 %0, i32 37)
  store i64 %call, i64* %h64.addr, align 8
  %1 = load i64, i64* %h64.addr, align 8
  %mul = mul i64 %1, 1609587791953885689
  store i64 %mul, i64* %h64.addr, align 8
  %2 = load i64, i64* %h64.addr, align 8
  %call1 = call i64 @XXH_xorshift64(i64 %2, i32 32)
  store i64 %call1, i64* %h64.addr, align 8
  %3 = load i64, i64* %h64.addr, align 8
  ret i64 %3
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mul128_fold64(i64 %lhs, i64 %rhs) #0 {
entry:
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca %struct.XXH128_hash_t, align 8
  store i64 %lhs, i64* %lhs.addr, align 8
  store i64 %rhs, i64* %rhs.addr, align 8
  %0 = load i64, i64* %lhs.addr, align 8
  %1 = load i64, i64* %rhs.addr, align 8
  %call = call { i64, i64 } @XXH_mult64to128(i64 %0, i64 %1)
  %2 = bitcast %struct.XXH128_hash_t* %product to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 0
  %7 = load i64, i64* %low64, align 8
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 1
  %8 = load i64, i64* %high64, align 8
  %xor = xor i64 %7, %8
  ret i64 %xor
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH_mult64to128(i64 %lhs, i64 %rhs) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca i128, align 16
  store i64 %lhs, i64* %lhs.addr, align 8
  store i64 %rhs, i64* %rhs.addr, align 8
  %0 = load i64, i64* %lhs.addr, align 8
  %conv = zext i64 %0 to i128
  %1 = load i64, i64* %rhs.addr, align 8
  %conv1 = zext i64 %1 to i128
  %mul = mul i128 %conv, %conv1
  store i128 %mul, i128* %product, align 16
  %2 = load i128, i128* %product, align 16
  %conv2 = trunc i128 %2 to i64
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %conv2, i64* %low64, align 8
  %3 = load i128, i128* %product, align 16
  %shr = lshr i128 %3, 64
  %conv3 = trunc i128 %shr to i64
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %conv3, i64* %high64, align 8
  %4 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %5 = load { i64, i64 }, { i64, i64 }* %4, align 8
  ret { i64, i64 } %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH_xorshift64(i64 %v64, i32 %shift) #0 {
entry:
  %v64.addr = alloca i64, align 8
  %shift.addr = alloca i32, align 4
  store i64 %v64, i64* %v64.addr, align 8
  store i32 %shift, i32* %shift.addr, align 4
  %0 = load i64, i64* %v64.addr, align 8
  %1 = load i64, i64* %v64.addr, align 8
  %2 = load i32, i32* %shift.addr, align 4
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %1, %sh_prom
  %xor = xor i64 %0, %shr
  ret i64 %xor
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mix16B(i8* noalias %input, i8* noalias %secret, i64 %seed64) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %call = call i64 @XXH_readLE64(i8* %0)
  store i64 %call, i64* %input_lo, align 8
  %1 = load i8*, i8** %input.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 8
  %call1 = call i64 @XXH_readLE64(i8* %add.ptr)
  store i64 %call1, i64* %input_hi, align 8
  %2 = load i64, i64* %input_lo, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %call2 = call i64 @XXH_readLE64(i8* %3)
  %4 = load i64, i64* %seed64.addr, align 8
  %add = add i64 %call2, %4
  %xor = xor i64 %2, %add
  %5 = load i64, i64* %input_hi, align 8
  %6 = load i8*, i8** %secret.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %6, i64 8
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %7 = load i64, i64* %seed64.addr, align 8
  %sub = sub i64 %call4, %7
  %xor5 = xor i64 %5, %sub
  %call6 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor5)
  ret i64 %call6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %0, i8* align 16 bitcast ([8 x i64]* @__const.XXH3_hashLong_64b_internal.acc to i8*), i64 64, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretSize.addr, align 8
  %5 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %6 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %1, i64 %2, i8* %3, i64 %4, i32 0, void (i8*, i8*, i8*, i32)* %5, void (i8*, i8*)* %6)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 11
  %8 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %8, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_hashLong_internal_loop(i64* noalias %acc, i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nb_rounds = alloca i64, align 8
  %block_len = alloca i64, align 8
  %nb_blocks = alloca i64, align 8
  %n = alloca i64, align 8
  %nbStripes = alloca i64, align 8
  %p = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %sub = sub i64 %0, 64
  %div = udiv i64 %sub, 8
  store i64 %div, i64* %nb_rounds, align 8
  %1 = load i64, i64* %nb_rounds, align 8
  %mul = mul i64 64, %1
  store i64 %mul, i64* %block_len, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i64, i64* %block_len, align 8
  %div1 = udiv i64 %2, %3
  store i64 %div1, i64* %nb_blocks, align 8
  store i64 0, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i64, i64* %n, align 8
  %5 = load i64, i64* %nb_blocks, align 8
  %cmp = icmp ult i64 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i64*, i64** %acc.addr, align 8
  %7 = load i8*, i8** %input.addr, align 8
  %8 = load i64, i64* %n, align 8
  %9 = load i64, i64* %block_len, align 8
  %mul2 = mul i64 %8, %9
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %mul2
  %10 = load i8*, i8** %secret.addr, align 8
  %11 = load i64, i64* %nb_rounds, align 8
  %12 = load i32, i32* %accWidth.addr, align 4
  %13 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %6, i8* %add.ptr, i8* %10, i64 %11, i32 %12, void (i8*, i8*, i8*, i32)* %13)
  %14 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %15 = load i64*, i64** %acc.addr, align 8
  %16 = bitcast i64* %15 to i8*
  %17 = load i8*, i8** %secret.addr, align 8
  %18 = load i64, i64* %secretSize.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %17, i64 %18
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  call void %14(i8* %16, i8* %add.ptr4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i64, i64* %n, align 8
  %inc = add i64 %19, 1
  store i64 %inc, i64* %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load i64, i64* %len.addr, align 8
  %21 = load i64, i64* %block_len, align 8
  %22 = load i64, i64* %nb_blocks, align 8
  %mul5 = mul i64 %21, %22
  %sub6 = sub i64 %20, %mul5
  %div7 = udiv i64 %sub6, 64
  store i64 %div7, i64* %nbStripes, align 8
  %23 = load i64*, i64** %acc.addr, align 8
  %24 = load i8*, i8** %input.addr, align 8
  %25 = load i64, i64* %nb_blocks, align 8
  %26 = load i64, i64* %block_len, align 8
  %mul8 = mul i64 %25, %26
  %add.ptr9 = getelementptr inbounds i8, i8* %24, i64 %mul8
  %27 = load i8*, i8** %secret.addr, align 8
  %28 = load i64, i64* %nbStripes, align 8
  %29 = load i32, i32* %accWidth.addr, align 4
  %30 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %23, i8* %add.ptr9, i8* %27, i64 %28, i32 %29, void (i8*, i8*, i8*, i32)* %30)
  %31 = load i64, i64* %len.addr, align 8
  %and = and i64 %31, 63
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %32 = load i8*, i8** %input.addr, align 8
  %33 = load i64, i64* %len.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %32, i64 %33
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -64
  store i8* %add.ptr11, i8** %p, align 8
  %34 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %35 = load i64*, i64** %acc.addr, align 8
  %36 = bitcast i64* %35 to i8*
  %37 = load i8*, i8** %p, align 8
  %38 = load i8*, i8** %secret.addr, align 8
  %39 = load i64, i64* %secretSize.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %38, i64 %39
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -64
  %add.ptr14 = getelementptr inbounds i8, i8* %add.ptr13, i64 -7
  %40 = load i32, i32* %accWidth.addr, align 4
  call void %34(i8* %36, i8* %37, i8* %add.ptr14, i32 %40)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_accumulate(i64* noalias %acc, i8* noalias %input, i8* noalias %secret, i64 %nbStripes, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %n = alloca i64, align 8
  %in = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %nbStripes, i64* %nbStripes.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store i64 0, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %n, align 8
  %1 = load i64, i64* %nbStripes.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %n, align 8
  %mul = mul i64 %3, 64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %mul
  store i8* %add.ptr, i8** %in, align 8
  %4 = load i8*, i8** %in, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %4, i64 320
  call void @llvm.prefetch(i8* %add.ptr1, i32 0, i32 3, i32 1)
  %5 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %6 = load i64*, i64** %acc.addr, align 8
  %7 = bitcast i64* %6 to i8*
  %8 = load i8*, i8** %in, align 8
  %9 = load i8*, i8** %secret.addr, align 8
  %10 = load i64, i64* %n, align 8
  %mul2 = mul i64 %10, 8
  %add.ptr3 = getelementptr inbounds i8, i8* %9, i64 %mul2
  %11 = load i32, i32* %accWidth.addr, align 4
  call void %5(i8* %7, i8* %8, i8* %add.ptr3, i32 %11)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i64, i64* %n, align 8
  %inc = add i64 %12, 1
  store i64 %inc, i64* %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inaccessiblemem_or_argmemonly nounwind
declare void @llvm.prefetch(i8* nocapture readonly, i32, i32, i32) #7

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed_internal(i8* %input, i64 %len, i64 %seed, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #0 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8
  %0 = load i64, i64* %seed.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %6 = load i64, i64* %seed.addr, align 8
  call void %5(i8* %arraydecay, i64 %6)
  %7 = load i8*, i8** %input.addr, align 8
  %8 = load i64, i64* %len.addr, align 8
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %9 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %10 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call2 = call i64 @XXH3_hashLong_64b_internal(i8* %7, i64 %8, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %9, void (i8*, i8*)* %10)
  store i64 %call2, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, i64* %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH_writeLE64(i8* %dst, i64 %v64) #0 {
entry:
  %dst.addr = alloca i8*, align 8
  %v64.addr = alloca i64, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %v64, i64* %v64.addr, align 8
  %0 = load i8*, i8** %dst.addr, align 8
  %1 = bitcast i64* %v64.addr to i8*
  %2 = load i8*, i8** %dst.addr, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 8, i64 %3) #10
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @XXH3_consumeStripes(i64* noalias %acc, i64* noalias %nbStripesSoFarPtr, i64 %nbStripesPerBlock, i8* noalias %input, i64 %nbStripes, i8* noalias %secret, i64 %secretLimit, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %nbStripesSoFarPtr.addr = alloca i64*, align 8
  %nbStripesPerBlock.addr = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLimit.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nbStripesToEndofBlock = alloca i64, align 8
  %nbStripesAfterBlock = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i64* %nbStripesSoFarPtr, i64** %nbStripesSoFarPtr.addr, align 8
  store i64 %nbStripesPerBlock, i64* %nbStripesPerBlock.addr, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %nbStripes, i64* %nbStripes.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretLimit, i64* %secretLimit.addr, align 8
  store i32 %accWidth, i32* %accWidth.addr, align 4
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = load i64, i64* %nbStripesPerBlock.addr, align 8
  %1 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %2 = load i64, i64* %1, align 8
  %sub = sub i64 %0, %2
  %3 = load i64, i64* %nbStripes.addr, align 8
  %cmp = icmp ule i64 %sub, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %nbStripesPerBlock.addr, align 8
  %5 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %6 = load i64, i64* %5, align 8
  %sub1 = sub i64 %4, %6
  store i64 %sub1, i64* %nbStripesToEndofBlock, align 8
  %7 = load i64, i64* %nbStripes.addr, align 8
  %8 = load i64, i64* %nbStripesToEndofBlock, align 8
  %sub2 = sub i64 %7, %8
  store i64 %sub2, i64* %nbStripesAfterBlock, align 8
  %9 = load i64*, i64** %acc.addr, align 8
  %10 = load i8*, i8** %input.addr, align 8
  %11 = load i8*, i8** %secret.addr, align 8
  %12 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %12, i64 0
  %13 = load i64, i64* %arrayidx, align 8
  %mul = mul i64 %13, 8
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 %mul
  %14 = load i64, i64* %nbStripesToEndofBlock, align 8
  %15 = load i32, i32* %accWidth.addr, align 4
  %16 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %9, i8* %10, i8* %add.ptr, i64 %14, i32 %15, void (i8*, i8*, i8*, i32)* %16)
  %17 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %18 = load i64*, i64** %acc.addr, align 8
  %19 = bitcast i64* %18 to i8*
  %20 = load i8*, i8** %secret.addr, align 8
  %21 = load i64, i64* %secretLimit.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %20, i64 %21
  call void %17(i8* %19, i8* %add.ptr3)
  %22 = load i64*, i64** %acc.addr, align 8
  %23 = load i8*, i8** %input.addr, align 8
  %24 = load i64, i64* %nbStripesToEndofBlock, align 8
  %mul4 = mul i64 %24, 64
  %add.ptr5 = getelementptr inbounds i8, i8* %23, i64 %mul4
  %25 = load i8*, i8** %secret.addr, align 8
  %26 = load i64, i64* %nbStripesAfterBlock, align 8
  %27 = load i32, i32* %accWidth.addr, align 4
  %28 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %22, i8* %add.ptr5, i8* %25, i64 %26, i32 %27, void (i8*, i8*, i8*, i32)* %28)
  %29 = load i64, i64* %nbStripesAfterBlock, align 8
  %30 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  store i64 %29, i64* %30, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %31 = load i64*, i64** %acc.addr, align 8
  %32 = load i8*, i8** %input.addr, align 8
  %33 = load i8*, i8** %secret.addr, align 8
  %34 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %arrayidx6 = getelementptr inbounds i64, i64* %34, i64 0
  %35 = load i64, i64* %arrayidx6, align 8
  %mul7 = mul i64 %35, 8
  %add.ptr8 = getelementptr inbounds i8, i8* %33, i64 %mul7
  %36 = load i64, i64* %nbStripes.addr, align 8
  %37 = load i32, i32* %accWidth.addr, align 4
  %38 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  call void @XXH3_accumulate(i64* %31, i8* %32, i8* %add.ptr8, i64 %36, i32 %37, void (i8*, i8*, i8*, i32)* %38)
  %39 = load i64, i64* %nbStripes.addr, align 8
  %40 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8
  %41 = load i64, i64* %40, align 8
  %add = add i64 %41, %39
  store i64 %add, i64* %40, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64>, i32) #8

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64>, i32) #8

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @XXH3_mix2Accs(i64* noalias %acc, i8* noalias %secret) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  %0 = load i64*, i64** %acc.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  %2 = load i8*, i8** %secret.addr, align 8
  %call = call i64 @XXH_readLE64(i8* %2)
  %xor = xor i64 %1, %call
  %3 = load i64*, i64** %acc.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %3, i64 1
  %4 = load i64, i64* %arrayidx1, align 8
  %5 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 8
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr)
  %xor3 = xor i64 %4, %call2
  %call4 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor3)
  ret i64 %call4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_0to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %seed.addr, align 8
  %call = call { i64, i64 } @XXH3_len_9to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp uge i64 %10, 4
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8
  %12 = load i64, i64* %len.addr, align 8
  %13 = load i8*, i8** %secret.addr, align 8
  %14 = load i64, i64* %seed.addr, align 8
  %call3 = call { i64, i64 } @XXH3_len_4to8_128b(i8* %11, i64 %12, i8* %13, i64 %14)
  %15 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call3, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call3, 1
  store i64 %19, i64* %18, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %20 = load i64, i64* %len.addr, align 8
  %tobool = icmp ne i64 %20, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end4
  %21 = load i8*, i8** %input.addr, align 8
  %22 = load i64, i64* %len.addr, align 8
  %23 = load i8*, i8** %secret.addr, align 8
  %24 = load i64, i64* %seed.addr, align 8
  %call6 = call { i64, i64 } @XXH3_len_1to3_128b(i8* %21, i64 %22, i8* %23, i64 %24)
  %25 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call6, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call6, 1
  store i64 %29, i64* %28, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %30 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %30, i64 64
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr)
  %31 = load i8*, i8** %secret.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %31, i64 72
  %call10 = call i64 @XXH_readLE64(i8* %add.ptr9)
  %xor = xor i64 %call8, %call10
  store i64 %xor, i64* %bitflipl, align 8
  %32 = load i8*, i8** %secret.addr, align 8
  %add.ptr11 = getelementptr inbounds i8, i8* %32, i64 80
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %33 = load i8*, i8** %secret.addr, align 8
  %add.ptr13 = getelementptr inbounds i8, i8* %33, i64 88
  %call14 = call i64 @XXH_readLE64(i8* %add.ptr13)
  %xor15 = xor i64 %call12, %call14
  store i64 %xor15, i64* %bitfliph, align 8
  %34 = load i64, i64* %seed.addr, align 8
  %add = add i64 -7046029288634856825, %34
  %35 = load i64, i64* %bitflipl, align 8
  %xor16 = xor i64 %add, %35
  %call17 = call i64 @XXH3_avalanche(i64 %xor16)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call17, i64* %low64, align 8
  %36 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 -4417276706812531889, %36
  %37 = load i64, i64* %bitfliph, align 8
  %xor18 = xor i64 %sub, %37
  %call19 = call i64 @XXH3_avalanche(i64 %xor18)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call19, i64* %high64, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then2, %if.then
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = load { i64, i64 }, { i64, i64 }* %38, align 8
  ret { i64, i64 } %39
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_17to128_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %tmp = alloca %struct.XXH128_hash_t, align 8
  %tmp8 = alloca %struct.XXH128_hash_t, align 8
  %tmp15 = alloca %struct.XXH128_hash_t, align 8
  %tmp22 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %1, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp ugt i64 %2, 32
  br i1 %cmp, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %len.addr, align 8
  %cmp1 = icmp ugt i64 %3, 64
  br i1 %cmp1, label %if.then2, label %if.end14

if.then2:                                         ; preds = %if.then
  %4 = load i64, i64* %len.addr, align 8
  %cmp3 = icmp ugt i64 %4, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %5 = load i8*, i8** %input.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 48
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i64, i64* %len.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %7
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 -64
  %8 = load i8*, i8** %secret.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, i8* %8, i64 96
  %9 = load i64, i64* %seed.addr, align 8
  %10 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %12, i64 %14, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr7, i64 %9)
  %15 = bitcast %struct.XXH128_hash_t* %tmp to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call, 1
  store i64 %19, i64* %18, align 8
  %20 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %21 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %21, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %22 = load i8*, i8** %input.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %22, i64 32
  %23 = load i8*, i8** %input.addr, align 8
  %24 = load i64, i64* %len.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %23, i64 %24
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -48
  %25 = load i8*, i8** %secret.addr, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %25, i64 64
  %26 = load i64, i64* %seed.addr, align 8
  %27 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = load i64, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = load i64, i64* %30, align 8
  %call13 = call { i64, i64 } @XXH128_mix32B(i64 %29, i64 %31, i8* %add.ptr9, i8* %add.ptr11, i8* %add.ptr12, i64 %26)
  %32 = bitcast %struct.XXH128_hash_t* %tmp8 to { i64, i64 }*
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 0
  %34 = extractvalue { i64, i64 } %call13, 0
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 1
  %36 = extractvalue { i64, i64 } %call13, 1
  store i64 %36, i64* %35, align 8
  %37 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %38 = bitcast %struct.XXH128_hash_t* %tmp8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 %38, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %39 = load i8*, i8** %input.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, i8* %39, i64 16
  %40 = load i8*, i8** %input.addr, align 8
  %41 = load i64, i64* %len.addr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %40, i64 %41
  %add.ptr18 = getelementptr inbounds i8, i8* %add.ptr17, i64 -32
  %42 = load i8*, i8** %secret.addr, align 8
  %add.ptr19 = getelementptr inbounds i8, i8* %42, i64 32
  %43 = load i64, i64* %seed.addr, align 8
  %44 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call20 = call { i64, i64 } @XXH128_mix32B(i64 %46, i64 %48, i8* %add.ptr16, i8* %add.ptr18, i8* %add.ptr19, i64 %43)
  %49 = bitcast %struct.XXH128_hash_t* %tmp15 to { i64, i64 }*
  %50 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %49, i32 0, i32 0
  %51 = extractvalue { i64, i64 } %call20, 0
  store i64 %51, i64* %50, align 8
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %49, i32 0, i32 1
  %53 = extractvalue { i64, i64 } %call20, 1
  store i64 %53, i64* %52, align 8
  %54 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %55 = bitcast %struct.XXH128_hash_t* %tmp15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %54, i8* align 8 %55, i64 16, i1 false)
  br label %if.end21

if.end21:                                         ; preds = %if.end14, %entry
  %56 = load i8*, i8** %input.addr, align 8
  %57 = load i8*, i8** %input.addr, align 8
  %58 = load i64, i64* %len.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, i8* %57, i64 %58
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %59 = load i8*, i8** %secret.addr, align 8
  %60 = load i64, i64* %seed.addr, align 8
  %61 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %call25 = call { i64, i64 } @XXH128_mix32B(i64 %63, i64 %65, i8* %56, i8* %add.ptr24, i8* %59, i64 %60)
  %66 = bitcast %struct.XXH128_hash_t* %tmp22 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call25, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call25, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %72 = bitcast %struct.XXH128_hash_t* %tmp22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 8 %72, i64 16, i1 false)
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %73 = load i64, i64* %low6426, align 8
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %74 = load i64, i64* %high6427, align 8
  %add = add i64 %73, %74
  %low6428 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %add, i64* %low6428, align 8
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %75 = load i64, i64* %low6429, align 8
  %mul30 = mul i64 %75, -7046029288634856825
  %high6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %76 = load i64, i64* %high6431, align 8
  %mul32 = mul i64 %76, -8796714831421723037
  %add33 = add i64 %mul30, %mul32
  %77 = load i64, i64* %len.addr, align 8
  %78 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %77, %78
  %mul34 = mul i64 %sub, -4417276706812531889
  %add35 = add i64 %add33, %mul34
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %add35, i64* %high6436, align 8
  %low6437 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %79 = load i64, i64* %low6437, align 8
  %call38 = call i64 @XXH3_avalanche(i64 %79)
  %low6439 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call38, i64* %low6439, align 8
  %high6440 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %80 = load i64, i64* %high6440, align 8
  %call41 = call i64 @XXH3_avalanche(i64 %80)
  %sub42 = sub i64 0, %call41
  %high6443 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %sub42, i64* %high6443, align 8
  %81 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %82 = load { i64, i64 }, { i64, i64 }* %81, align 8
  ret { i64, i64 } %82
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_129to240_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  %tmp = alloca %struct.XXH128_hash_t, align 8
  %tmp20 = alloca %struct.XXH128_hash_t, align 8
  %tmp36 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %secretSize.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %conv = trunc i64 %1 to i32
  %div = sdiv i32 %conv, 32
  store i32 %div, i32* %nbRounds, align 4
  %2 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %2, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %3, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %input.addr, align 8
  %5 = load i32, i32* %i, align 4
  %mul2 = mul nsw i32 32, %5
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %6 = load i8*, i8** %input.addr, align 8
  %7 = load i32, i32* %i, align 4
  %mul3 = mul nsw i32 32, %7
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %idx.ext4
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 16
  %8 = load i8*, i8** %secret.addr, align 8
  %9 = load i32, i32* %i, align 4
  %mul7 = mul nsw i32 32, %9
  %idx.ext8 = sext i32 %mul7 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i64 %idx.ext8
  %10 = load i64, i64* %seed.addr, align 8
  %11 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %13, i64 %15, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr9, i64 %10)
  %16 = bitcast %struct.XXH128_hash_t* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %22 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, i32* %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %24 = load i64, i64* %low6410, align 8
  %call11 = call i64 @XXH3_avalanche(i64 %24)
  %low6412 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %call11, i64* %low6412, align 8
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %25 = load i64, i64* %high6413, align 8
  %call14 = call i64 @XXH3_avalanche(i64 %25)
  %high6415 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 %call14, i64* %high6415, align 8
  store i32 4, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc33, %for.end
  %26 = load i32, i32* %i, align 4
  %27 = load i32, i32* %nbRounds, align 4
  %cmp17 = icmp slt i32 %26, %27
  br i1 %cmp17, label %for.body19, label %for.end35

for.body19:                                       ; preds = %for.cond16
  %28 = load i8*, i8** %input.addr, align 8
  %29 = load i32, i32* %i, align 4
  %mul21 = mul nsw i32 32, %29
  %idx.ext22 = sext i32 %mul21 to i64
  %add.ptr23 = getelementptr inbounds i8, i8* %28, i64 %idx.ext22
  %30 = load i8*, i8** %input.addr, align 8
  %31 = load i32, i32* %i, align 4
  %mul24 = mul nsw i32 32, %31
  %idx.ext25 = sext i32 %mul24 to i64
  %add.ptr26 = getelementptr inbounds i8, i8* %30, i64 %idx.ext25
  %add.ptr27 = getelementptr inbounds i8, i8* %add.ptr26, i64 16
  %32 = load i8*, i8** %secret.addr, align 8
  %add.ptr28 = getelementptr inbounds i8, i8* %32, i64 3
  %33 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %33, 4
  %mul29 = mul nsw i32 32, %sub
  %idx.ext30 = sext i32 %mul29 to i64
  %add.ptr31 = getelementptr inbounds i8, i8* %add.ptr28, i64 %idx.ext30
  %34 = load i64, i64* %seed.addr, align 8
  %35 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 8
  %call32 = call { i64, i64 } @XXH128_mix32B(i64 %37, i64 %39, i8* %add.ptr23, i8* %add.ptr27, i8* %add.ptr31, i64 %34)
  %40 = bitcast %struct.XXH128_hash_t* %tmp20 to { i64, i64 }*
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 0
  %42 = extractvalue { i64, i64 } %call32, 0
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 1
  %44 = extractvalue { i64, i64 } %call32, 1
  store i64 %44, i64* %43, align 8
  %45 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %46 = bitcast %struct.XXH128_hash_t* %tmp20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %45, i8* align 8 %46, i64 16, i1 false)
  br label %for.inc33

for.inc33:                                        ; preds = %for.body19
  %47 = load i32, i32* %i, align 4
  %inc34 = add nsw i32 %47, 1
  store i32 %inc34, i32* %i, align 4
  br label %for.cond16

for.end35:                                        ; preds = %for.cond16
  %48 = load i8*, i8** %input.addr, align 8
  %49 = load i64, i64* %len.addr, align 8
  %add.ptr37 = getelementptr inbounds i8, i8* %48, i64 %49
  %add.ptr38 = getelementptr inbounds i8, i8* %add.ptr37, i64 -16
  %50 = load i8*, i8** %input.addr, align 8
  %51 = load i64, i64* %len.addr, align 8
  %add.ptr39 = getelementptr inbounds i8, i8* %50, i64 %51
  %add.ptr40 = getelementptr inbounds i8, i8* %add.ptr39, i64 -32
  %52 = load i8*, i8** %secret.addr, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %52, i64 136
  %add.ptr42 = getelementptr inbounds i8, i8* %add.ptr41, i64 -17
  %add.ptr43 = getelementptr inbounds i8, i8* %add.ptr42, i64 -16
  %53 = load i64, i64* %seed.addr, align 8
  %sub44 = sub i64 0, %53
  %54 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %54, i32 0, i32 0
  %56 = load i64, i64* %55, align 8
  %57 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %54, i32 0, i32 1
  %58 = load i64, i64* %57, align 8
  %call45 = call { i64, i64 } @XXH128_mix32B(i64 %56, i64 %58, i8* %add.ptr38, i8* %add.ptr40, i8* %add.ptr43, i64 %sub44)
  %59 = bitcast %struct.XXH128_hash_t* %tmp36 to { i64, i64 }*
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %59, i32 0, i32 0
  %61 = extractvalue { i64, i64 } %call45, 0
  store i64 %61, i64* %60, align 8
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %59, i32 0, i32 1
  %63 = extractvalue { i64, i64 } %call45, 1
  store i64 %63, i64* %62, align 8
  %64 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %65 = bitcast %struct.XXH128_hash_t* %tmp36 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %64, i8* align 8 %65, i64 16, i1 false)
  %low6446 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %66 = load i64, i64* %low6446, align 8
  %high6447 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %67 = load i64, i64* %high6447, align 8
  %add = add i64 %66, %67
  %low6448 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %add, i64* %low6448, align 8
  %low6449 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %68 = load i64, i64* %low6449, align 8
  %mul50 = mul i64 %68, -7046029288634856825
  %high6451 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %69 = load i64, i64* %high6451, align 8
  %mul52 = mul i64 %69, -8796714831421723037
  %add53 = add i64 %mul50, %mul52
  %70 = load i64, i64* %len.addr, align 8
  %71 = load i64, i64* %seed.addr, align 8
  %sub54 = sub i64 %70, %71
  %mul55 = mul i64 %sub54, -4417276706812531889
  %add56 = add i64 %add53, %mul55
  %high6457 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %add56, i64* %high6457, align 8
  %low6458 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %72 = load i64, i64* %low6458, align 8
  %call59 = call i64 @XXH3_avalanche(i64 %72)
  %low6460 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call59, i64* %low6460, align 8
  %high6461 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %73 = load i64, i64* %high6461, align 8
  %call62 = call i64 @XXH3_avalanche(i64 %73)
  %sub63 = sub i64 0, %call62
  %high6464 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %sub63, i64* %high6464, align 8
  %74 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %75 = load { i64, i64 }, { i64, i64 }* %74, align 8
  ret { i64, i64 } %75
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_9to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %m128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 32
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %1 = load i8*, i8** %secret.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, i8* %1, i64 40
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %2 = load i64, i64* %seed.addr, align 8
  %sub = sub i64 %xor, %2
  store i64 %sub, i64* %bitflipl, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 48
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %4 = load i8*, i8** %secret.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %4, i64 56
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %5 = load i64, i64* %seed.addr, align 8
  %add = add i64 %xor7, %5
  store i64 %add, i64* %bitfliph, align 8
  %6 = load i8*, i8** %input.addr, align 8
  %call8 = call i64 @XXH_readLE64(i8* %6)
  store i64 %call8, i64* %input_lo, align 8
  %7 = load i8*, i8** %input.addr, align 8
  %8 = load i64, i64* %len.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, i8* %7, i64 %8
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  store i64 %call11, i64* %input_hi, align 8
  %9 = load i64, i64* %input_lo, align 8
  %10 = load i64, i64* %input_hi, align 8
  %xor12 = xor i64 %9, %10
  %11 = load i64, i64* %bitflipl, align 8
  %xor13 = xor i64 %xor12, %11
  %call14 = call { i64, i64 } @XXH_mult64to128(i64 %xor13, i64 -7046029288634856825)
  %12 = bitcast %struct.XXH128_hash_t* %m128 to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = extractvalue { i64, i64 } %call14, 0
  store i64 %14, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = extractvalue { i64, i64 } %call14, 1
  store i64 %16, i64* %15, align 8
  %17 = load i64, i64* %len.addr, align 8
  %sub15 = sub i64 %17, 1
  %shl = shl i64 %sub15, 54
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %18 = load i64, i64* %low64, align 8
  %add16 = add i64 %18, %shl
  store i64 %add16, i64* %low64, align 8
  %19 = load i64, i64* %bitfliph, align 8
  %20 = load i64, i64* %input_hi, align 8
  %xor17 = xor i64 %20, %19
  store i64 %xor17, i64* %input_hi, align 8
  %21 = load i64, i64* %input_hi, align 8
  %22 = load i64, i64* %input_hi, align 8
  %conv = trunc i64 %22 to i32
  %conv18 = zext i32 %conv to i64
  %mul = mul i64 %conv18, 2246822518
  %add19 = add i64 %21, %mul
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %23 = load i64, i64* %high64, align 8
  %add20 = add i64 %23, %add19
  store i64 %add20, i64* %high64, align 8
  %high6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %24 = load i64, i64* %high6421, align 8
  %call22 = call i64 @XXH_swap64(i64 %24)
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %25 = load i64, i64* %low6423, align 8
  %xor24 = xor i64 %25, %call22
  store i64 %xor24, i64* %low6423, align 8
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %26 = load i64, i64* %low6425, align 8
  %call26 = call { i64, i64 } @XXH_mult64to128(i64 %26, i64 -4417276706812531889)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call26, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call26, 1
  store i64 %31, i64* %30, align 8
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %32 = load i64, i64* %high6427, align 8
  %mul28 = mul i64 %32, -4417276706812531889
  %high6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %33 = load i64, i64* %high6429, align 8
  %add30 = add i64 %33, %mul28
  store i64 %add30, i64* %high6429, align 8
  %low6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %34 = load i64, i64* %low6431, align 8
  %call32 = call i64 @XXH3_avalanche(i64 %34)
  %low6433 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call32, i64* %low6433, align 8
  %high6434 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %35 = load i64, i64* %high6434, align 8
  %call35 = call i64 @XXH3_avalanche(i64 %35)
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call35, i64* %high6436, align 8
  %36 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %37 = load { i64, i64 }, { i64, i64 }* %36, align 8
  ret { i64, i64 } %37
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_4to8_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input_lo = alloca i32, align 4
  %input_hi = alloca i32, align 4
  %input_64 = alloca i64, align 8
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i64, i64* %seed.addr, align 8
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8
  %2 = load i8*, i8** %input.addr, align 8
  %call2 = call i32 @XXH_readLE32(i8* %2)
  store i32 %call2, i32* %input_lo, align 4
  %3 = load i8*, i8** %input.addr, align 8
  %4 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %4
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input_hi, align 4
  %5 = load i32, i32* %input_lo, align 4
  %conv5 = zext i32 %5 to i64
  %6 = load i32, i32* %input_hi, align 4
  %conv6 = zext i32 %6 to i64
  %shl7 = shl i64 %conv6, 32
  %add = add i64 %conv5, %shl7
  store i64 %add, i64* %input_64, align 8
  %7 = load i8*, i8** %secret.addr, align 8
  %add.ptr8 = getelementptr inbounds i8, i8* %7, i64 16
  %call9 = call i64 @XXH_readLE64(i8* %add.ptr8)
  %8 = load i8*, i8** %secret.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %8, i64 24
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %xor12 = xor i64 %call9, %call11
  %9 = load i64, i64* %seed.addr, align 8
  %add13 = add i64 %xor12, %9
  store i64 %add13, i64* %bitflip, align 8
  %10 = load i64, i64* %input_64, align 8
  %11 = load i64, i64* %bitflip, align 8
  %xor14 = xor i64 %10, %11
  store i64 %xor14, i64* %keyed, align 8
  %12 = load i64, i64* %keyed, align 8
  %13 = load i64, i64* %len.addr, align 8
  %shl15 = shl i64 %13, 2
  %add16 = add i64 -7046029288634856825, %shl15
  %call17 = call { i64, i64 } @XXH_mult64to128(i64 %12, i64 %add16)
  %14 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call17, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call17, 1
  store i64 %18, i64* %17, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %19 = load i64, i64* %low64, align 8
  %shl18 = shl i64 %19, 1
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %20 = load i64, i64* %high64, align 8
  %add19 = add i64 %20, %shl18
  store i64 %add19, i64* %high64, align 8
  %high6420 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %21 = load i64, i64* %high6420, align 8
  %shr = lshr i64 %21, 3
  %low6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %22 = load i64, i64* %low6421, align 8
  %xor22 = xor i64 %22, %shr
  store i64 %xor22, i64* %low6421, align 8
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %23 = load i64, i64* %low6423, align 8
  %call24 = call i64 @XXH_xorshift64(i64 %23, i32 35)
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call24, i64* %low6425, align 8
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %24 = load i64, i64* %low6426, align 8
  %mul = mul i64 %24, -6939452855193903323
  store i64 %mul, i64* %low6426, align 8
  %low6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %25 = load i64, i64* %low6427, align 8
  %call28 = call i64 @XXH_xorshift64(i64 %25, i32 28)
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call28, i64* %low6429, align 8
  %high6430 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %26 = load i64, i64* %high6430, align 8
  %call31 = call i64 @XXH3_avalanche(i64 %26)
  %high6432 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call31, i64* %high6432, align 8
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = load { i64, i64 }, { i64, i64 }* %27, align 8
  ret { i64, i64 } %28
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_len_1to3_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combinedl = alloca i32, align 4
  %combinedh = alloca i32, align 4
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %keyed_lo = alloca i64, align 8
  %keyed_hi = alloca i64, align 8
  %mixedl = alloca i64, align 8
  %mixedh = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %0 = load i8*, i8** %input.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1
  store i8 %1, i8* %c1, align 1
  %2 = load i8*, i8** %input.addr, align 8
  %3 = load i64, i64* %len.addr, align 8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1
  store i8 %4, i8* %c2, align 1
  %5 = load i8*, i8** %input.addr, align 8
  %6 = load i64, i64* %len.addr, align 8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1
  store i8 %7, i8* %c3, align 1
  %8 = load i8, i8* %c1, align 1
  %conv = zext i8 %8 to i32
  %shl = shl i32 %conv, 16
  %9 = load i8, i8* %c2, align 1
  %conv3 = zext i8 %9 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %10 = load i8, i8* %c3, align 1
  %conv5 = zext i8 %10 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %11 = load i64, i64* %len.addr, align 8
  %conv8 = trunc i64 %11 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combinedl, align 4
  %12 = load i32, i32* %combinedl, align 4
  %call = call i32 @XXH_swap32(i32 %12)
  %13 = call i32 @llvm.fshl.i32(i32 %call, i32 %call, i32 13)
  store i32 %13, i32* %combinedh, align 4
  %14 = load i8*, i8** %secret.addr, align 8
  %call11 = call i32 @XXH_readLE32(i8* %14)
  %15 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 4
  %call12 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call11, %call12
  %conv13 = zext i32 %xor to i64
  %16 = load i64, i64* %seed.addr, align 8
  %add = add i64 %conv13, %16
  store i64 %add, i64* %bitflipl, align 8
  %17 = load i8*, i8** %secret.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, i8* %17, i64 8
  %call15 = call i32 @XXH_readLE32(i8* %add.ptr14)
  %18 = load i8*, i8** %secret.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, i8* %18, i64 12
  %call17 = call i32 @XXH_readLE32(i8* %add.ptr16)
  %xor18 = xor i32 %call15, %call17
  %conv19 = zext i32 %xor18 to i64
  %19 = load i64, i64* %seed.addr, align 8
  %sub20 = sub i64 %conv19, %19
  store i64 %sub20, i64* %bitfliph, align 8
  %20 = load i32, i32* %combinedl, align 4
  %conv21 = zext i32 %20 to i64
  %21 = load i64, i64* %bitflipl, align 8
  %xor22 = xor i64 %conv21, %21
  store i64 %xor22, i64* %keyed_lo, align 8
  %22 = load i32, i32* %combinedh, align 4
  %conv23 = zext i32 %22 to i64
  %23 = load i64, i64* %bitfliph, align 8
  %xor24 = xor i64 %conv23, %23
  store i64 %xor24, i64* %keyed_hi, align 8
  %24 = load i64, i64* %keyed_lo, align 8
  %mul = mul i64 %24, -7046029288634856825
  store i64 %mul, i64* %mixedl, align 8
  %25 = load i64, i64* %keyed_hi, align 8
  %mul25 = mul i64 %25, 2870177450012600261
  store i64 %mul25, i64* %mixedh, align 8
  %26 = load i64, i64* %mixedl, align 8
  %call26 = call i64 @XXH3_avalanche(i64 %26)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call26, i64* %low64, align 8
  %27 = load i64, i64* %mixedh, align 8
  %call27 = call i64 @XXH3_avalanche(i64 %27)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call27, i64* %high64, align 8
  %28 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %29 = load { i64, i64 }, { i64, i64 }* %28, align 8
  ret { i64, i64 } %29
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH128_mix32B(i64 %acc.coerce0, i64 %acc.coerce1, i8* %input_1, i8* %input_2, i8* %secret, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %input_1.addr = alloca i8*, align 8
  %input_2.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %0 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %acc.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %acc.coerce1, i64* %2, align 8
  store i8* %input_1, i8** %input_1.addr, align 8
  store i8* %input_2, i8** %input_2.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %seed, i64* %seed.addr, align 8
  %3 = load i8*, i8** %input_1.addr, align 8
  %4 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i64, i64* %seed.addr, align 8
  %call = call i64 @XXH3_mix16B(i8* %3, i8* %add.ptr, i64 %5)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %6 = load i64, i64* %low64, align 8
  %add = add i64 %6, %call
  store i64 %add, i64* %low64, align 8
  %7 = load i8*, i8** %input_2.addr, align 8
  %call1 = call i64 @XXH_readLE64(i8* %7)
  %8 = load i8*, i8** %input_2.addr, align 8
  %add.ptr2 = getelementptr inbounds i8, i8* %8, i64 8
  %call3 = call i64 @XXH_readLE64(i8* %add.ptr2)
  %add4 = add i64 %call1, %call3
  %low645 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %9 = load i64, i64* %low645, align 8
  %xor = xor i64 %9, %add4
  store i64 %xor, i64* %low645, align 8
  %10 = load i8*, i8** %input_2.addr, align 8
  %11 = load i8*, i8** %secret.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 16
  %12 = load i64, i64* %seed.addr, align 8
  %call7 = call i64 @XXH3_mix16B(i8* %10, i8* %add.ptr6, i64 %12)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %13 = load i64, i64* %high64, align 8
  %add8 = add i64 %13, %call7
  store i64 %add8, i64* %high64, align 8
  %14 = load i8*, i8** %input_1.addr, align 8
  %call9 = call i64 @XXH_readLE64(i8* %14)
  %15 = load i8*, i8** %input_1.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, i8* %15, i64 8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %add12 = add i64 %call9, %call11
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %16 = load i64, i64* %high6413, align 8
  %xor14 = xor i64 %16, %add12
  store i64 %xor14, i64* %high6413, align 8
  %17 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %18 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %18, i64 16, i1 false)
  %19 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %20 = load { i64, i64 }, { i64, i64 }* %19, align 8
  ret { i64, i64 } %20
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i8* %secret, i8** %secret.addr, align 8
  store i64 %secretSize, i64* %secretSize.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %0, i8* align 16 bitcast ([8 x i64]* @__const.XXH3_hashLong_128b_internal.acc to i8*), i64 64, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load i8*, i8** %secret.addr, align 8
  %4 = load i64, i64* %secretSize.addr, align 8
  %5 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %6 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %1, i64 %2, i8* %3, i64 %4, i32 1, void (i8*, i8*, i8*, i32)* %5, void (i8*, i8*)* %6)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %7 = load i8*, i8** %secret.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 11
  %8 = load i64, i64* %len.addr, align 8
  %mul = mul i64 %8, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call, i64* %low64, align 8
  %arraydecay2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret.addr, align 8
  %10 = load i64, i64* %secretSize.addr, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %9, i64 %10
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  %add.ptr5 = getelementptr inbounds i8, i8* %add.ptr4, i64 -11
  %11 = load i64, i64* %len.addr, align 8
  %mul6 = mul i64 %11, -4417276706812531889
  %neg = xor i64 %mul6, -1
  %call7 = call i64 @XXH3_mergeAccs(i64* %arraydecay2, i8* %add.ptr5, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call7, i64* %high64, align 8
  %12 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %13 = load { i64, i64 }, { i64, i64 }* %12, align 8
  ret { i64, i64 } %13
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* noalias %input, i64 %len, i64 %seed64, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %seed64, i64* %seed64.addr, align 8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8
  %0 = load i64, i64* %seed64.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %11 = load i64, i64* %seed64.addr, align 8
  call void %10(i8* %arraydecay, i64 %11)
  %12 = load i8*, i8** %input.addr, align 8
  %13 = load i64, i64* %len.addr, align 8
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %14 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8
  %15 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8
  %call2 = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %12, i64 %13, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %14, void (i8*, i8*)* %15)
  %16 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call2, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call2, 1
  store i64 %20, i64* %19, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %22 = load { i64, i64 }, { i64, i64 }* %21, align 8
  ret { i64, i64 } %22
}

attributes #0 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone speculatable }
attributes #3 = { argmemonly nounwind }
attributes #4 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="128" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { inaccessiblemem_or_argmemonly nounwind }
attributes #8 = { nounwind readnone }
attributes #9 = { allocsize(0) }
attributes #10 = { nounwind }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 2, !"SDK Version", [3 x i32] [i32 10, i32 15, i32 4]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"PIC Level", i32 2}
!3 = !{!"clang version 8.0.1 (https://github.com/llvm-mirror/clang.git 2e4c9c5fc864c2c432e4c262a67c42d824b265c6) (https://github.com/llvm-mirror/llvm.git ea28a67e47fd87c6b78597d90eba543bad4d7468)"}
!4 = !{i32 61698}
!5 = !{i32 1010566}
