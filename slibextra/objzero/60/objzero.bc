; ModuleID = 'objzero.c'
source_filename = "objzero.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.VertexFormat = type { i64, i64, i64, i64 }
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.MaterialProperty = type { i8*, i32, i64, i32 }
%struct.MaterialMapArg = type { i8*, i32 }
%struct.File = type { i8*, i64, i64 }
%struct.objzModel = type { i32, i8*, i32, %struct.objzMaterial*, i32, %struct.objzMesh*, i32, %struct.objzObject*, i32, i8*, i32 }
%struct.objzMaterial = type { [64 x i8], [3 x float], [3 x float], [3 x float], [3 x float], float, float, [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8] }
%struct.objzMesh = type { i32, i32, i32 }
%struct.objzObject = type { [64 x i8], i32, i32, i32, i32, i32, i32 }
%struct.Array = type { i8*, i32, i32, i32, i32 }
%struct.ChunkedArray = type { %struct.Array, i32, i64, i32 }
%struct.Lexer = type { i8*, i32, i32 }
%struct.Token = type { [256 x i8], i32, i32 }
%struct.TempObject = type { [64 x i8], i32, i32 }
%struct.IndexTriplet = type { i32, i32, i32 }
%struct.Face = type { i16, i16, [3 x %struct.IndexTriplet] }
%struct.vec3 = type { float, float, float }
%struct.VertexHashMap = type { i32*, i32, %struct.Array }
%struct.NormalHashMap = type { i32*, i32, %struct.Array, %struct.ChunkedArray* }
%struct.HashedVertex = type { i32, i32, i32, i32, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.HashedNormal = type { i32, i32 }

@.str = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.1 = private unnamed_addr constant [10 x i8] c"objzero.c\00", align 1
@s_realloc = internal global i8* (i8*, i64)* null, align 8
@s_indexFormat = internal global i32 0, align 4
@s_vertexDecl = internal global %struct.VertexFormat { i64 32, i64 0, i64 12, i64 20 }, align 8
@s_error = internal global [1024 x i8] zeroinitializer, align 16
@.str.2 = private unnamed_addr constant [25 x i8] c"Failed to read file '%s'\00", align 1
@.str.3 = private unnamed_addr constant [43 x i8] c"UTF-32 encoding not supported in file '%s'\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"UTF-16 encoding not supported in file '%s'\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.6 = private unnamed_addr constant [29 x i8] c"(%u:%u) Failed to parse face\00", align 1
@.str.7 = private unnamed_addr constant [39 x i8] c"(%u:%u) Face needs at least 3 vertices\00", align 1
@.str.8 = private unnamed_addr constant [2 x i8] c"g\00", align 1
@.str.9 = private unnamed_addr constant [2 x i8] c"o\00", align 1
@.str.10 = private unnamed_addr constant [32 x i8] c"(%u:%u) Expected name after 'o'\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"mtllib\00", align 1
@.str.13 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'mtllib'\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@.str.15 = private unnamed_addr constant [33 x i8] c"(%u:%u) Expected value after 's'\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.17 = private unnamed_addr constant [7 x i8] c"usemtl\00", align 1
@.str.18 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'usemtl'\00", align 1
@.str.19 = private unnamed_addr constant [2 x i8] c"v\00", align 1
@.str.20 = private unnamed_addr constant [3 x i8] c"vn\00", align 1
@.str.21 = private unnamed_addr constant [3 x i8] c"vt\00", align 1
@__stderrp = external global %struct.__sFILE*, align 8
@.str.22 = private unnamed_addr constant [32 x i8] c"Memory allocation failed %s %d\0A\00", align 1
@.str.23 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.24 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@triangulate.axes = private unnamed_addr constant [2 x i32] [i32 1, i32 2], align 4
@.str.25 = private unnamed_addr constant [34 x i8] c"Failed to read material file '%s'\00", align 1
@.str.26 = private unnamed_addr constant [7 x i8] c"newmtl\00", align 1
@.str.27 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'newmtl'\00", align 1
@s_materialProperties = internal global [14 x %struct.MaterialProperty] [%struct.MaterialProperty { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.29, i32 0, i32 0), i32 1, i64 116, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.30, i32 0, i32 0), i32 1, i64 64, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.31, i32 0, i32 0), i32 1, i64 76, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i32 1, i64 88, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.33, i32 0, i32 0), i32 1, i64 100, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0), i32 1, i64 112, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i32 0, i64 184, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.36, i32 0, i32 0), i32 0, i64 184, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.37, i32 0, i32 0), i32 0, i64 120, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.38, i32 0, i32 0), i32 0, i64 248, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.39, i32 0, i32 0), i32 0, i64 312, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i32 0, i64 376, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i32 0, i64 440, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.42, i32 0, i32 0), i32 0, i64 504, i32 1 }], align 16
@.str.28 = private unnamed_addr constant [34 x i8] c"(%u:%u) Expected token after '%s'\00", align 1
@s_materialMapArgs = internal global [12 x %struct.MaterialMapArg] [%struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.45, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.46, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.49, i32 0, i32 0), i32 2 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.50, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.51, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.53, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54, i32 0, i32 0), i32 1 }], align 16
@.str.29 = private unnamed_addr constant [2 x i8] c"d\00", align 1
@.str.30 = private unnamed_addr constant [3 x i8] c"Ka\00", align 1
@.str.31 = private unnamed_addr constant [3 x i8] c"Kd\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"Ke\00", align 1
@.str.33 = private unnamed_addr constant [3 x i8] c"Ks\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"Ns\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"bump\00", align 1
@.str.36 = private unnamed_addr constant [9 x i8] c"map_Bump\00", align 1
@.str.37 = private unnamed_addr constant [7 x i8] c"map_Ka\00", align 1
@.str.38 = private unnamed_addr constant [7 x i8] c"map_Kd\00", align 1
@.str.39 = private unnamed_addr constant [7 x i8] c"map_Ke\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"map_Ks\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"map_Ns\00", align 1
@.str.42 = private unnamed_addr constant [6 x i8] c"map_d\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"-blendu\00", align 1
@.str.44 = private unnamed_addr constant [8 x i8] c"-blendv\00", align 1
@.str.45 = private unnamed_addr constant [4 x i8] c"-bm\00", align 1
@.str.46 = private unnamed_addr constant [7 x i8] c"-boost\00", align 1
@.str.47 = private unnamed_addr constant [7 x i8] c"-clamp\00", align 1
@.str.48 = private unnamed_addr constant [9 x i8] c"-imfchan\00", align 1
@.str.49 = private unnamed_addr constant [4 x i8] c"-mm\00", align 1
@.str.50 = private unnamed_addr constant [3 x i8] c"-o\00", align 1
@.str.51 = private unnamed_addr constant [3 x i8] c"-s\00", align 1
@.str.52 = private unnamed_addr constant [3 x i8] c"-t\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"-texres\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c"-type\00", align 1
@.str.55 = private unnamed_addr constant [30 x i8] c"(%u:%u) Error skipping tokens\00", align 1
@.str.56 = private unnamed_addr constant [28 x i8] c"(%u:%u) Error parsing float\00", align 1

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @fileOpen(%struct.File* %_file, i8* %_filename) #0 {
entry:
  %retval = alloca i1, align 1
  %_file.addr = alloca %struct.File*, align 8
  %_filename.addr = alloca i8*, align 8
  %handle = alloca %struct.__sFILE*, align 8
  %bytesRead = alloca i64, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8
  store i8* %_filename, i8** %_filename.addr, align 8
  %0 = load i8*, i8** %_filename.addr, align 8
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %handle, align 8
  %1 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %tobool = icmp ne %struct.__sFILE* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call1 = call i32 @fseek(%struct.__sFILE* %2, i64 0, i32 2)
  %3 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call2 = call i64 @ftell(%struct.__sFILE* %3)
  %4 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length = getelementptr inbounds %struct.File, %struct.File* %4, i32 0, i32 1
  store i64 %call2, i64* %length, align 8
  %5 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call3 = call i32 @fseek(%struct.__sFILE* %5, i64 0, i32 0)
  %6 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length4 = getelementptr inbounds %struct.File, %struct.File* %6, i32 0, i32 1
  %7 = load i64, i64* %length4, align 8
  %cmp = icmp eq i64 %7, 0
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %8 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call6 = call i32 @fclose(%struct.__sFILE* %8)
  store i1 false, i1* %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  %9 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos = getelementptr inbounds %struct.File, %struct.File* %9, i32 0, i32 2
  store i64 0, i64* %pos, align 8
  %10 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length8 = getelementptr inbounds %struct.File, %struct.File* %10, i32 0, i32 1
  %11 = load i64, i64* %length8, align 8
  %add = add i64 %11, 1
  %call9 = call i8* @objz_realloc(i8* null, i64 %add, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 338)
  %12 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer = getelementptr inbounds %struct.File, %struct.File* %12, i32 0, i32 0
  store i8* %call9, i8** %buffer, align 8
  %13 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer10 = getelementptr inbounds %struct.File, %struct.File* %13, i32 0, i32 0
  %14 = load i8*, i8** %buffer10, align 8
  %15 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length11 = getelementptr inbounds %struct.File, %struct.File* %15, i32 0, i32 1
  %16 = load i64, i64* %length11, align 8
  %17 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call12 = call i64 @fread(i8* %14, i64 1, i64 %16, %struct.__sFILE* %17)
  store i64 %call12, i64* %bytesRead, align 8
  %18 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call13 = call i32 @fclose(%struct.__sFILE* %18)
  %19 = load i64, i64* %bytesRead, align 8
  %20 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length14 = getelementptr inbounds %struct.File, %struct.File* %20, i32 0, i32 1
  %21 = load i64, i64* %length14, align 8
  %cmp15 = icmp ult i64 %19, %21
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end7
  %22 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer17 = getelementptr inbounds %struct.File, %struct.File* %22, i32 0, i32 0
  %23 = load i8*, i8** %buffer17, align 8
  %call18 = call i8* @objz_realloc(i8* %23, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 342)
  store i1 false, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end7
  %24 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer20 = getelementptr inbounds %struct.File, %struct.File* %24, i32 0, i32 0
  %25 = load i8*, i8** %buffer20, align 8
  %26 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length21 = getelementptr inbounds %struct.File, %struct.File* %26, i32 0, i32 1
  %27 = load i64, i64* %length21, align 8
  %arrayidx = getelementptr inbounds i8, i8* %25, i64 %27
  store i8 0, i8* %arrayidx, align 1
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end19, %if.then16, %if.then5, %if.then
  %28 = load i1, i1* %retval, align 1
  ret i1 %28
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #1

declare i32 @fseek(%struct.__sFILE*, i64, i32) #1

declare i64 @ftell(%struct.__sFILE*) #1

declare i32 @fclose(%struct.__sFILE*) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @objz_realloc(i8* %_ptr, i64 %_size, i8* %_file, i32 %_line) #0 {
entry:
  %retval = alloca i8*, align 8
  %_ptr.addr = alloca i8*, align 8
  %_size.addr = alloca i64, align 8
  %_file.addr = alloca i8*, align 8
  %_line.addr = alloca i32, align 4
  %result = alloca i8*, align 8
  store i8* %_ptr, i8** %_ptr.addr, align 8
  store i64 %_size, i64* %_size.addr, align 8
  store i8* %_file, i8** %_file.addr, align 8
  store i32 %_line, i32* %_line.addr, align 4
  %0 = load i8*, i8** %_ptr.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %_size.addr, align 8
  %tobool1 = icmp ne i64 %1, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i8* (i8*, i64)*, i8* (i8*, i64)** @s_realloc, align 8
  %tobool2 = icmp ne i8* (i8*, i64)* %2, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load i8* (i8*, i64)*, i8* (i8*, i64)** @s_realloc, align 8
  %4 = load i8*, i8** %_ptr.addr, align 8
  %5 = load i64, i64* %_size.addr, align 8
  %call = call i8* %3(i8* %4, i64 %5)
  store i8* %call, i8** %result, align 8
  br label %if.end5

if.else:                                          ; preds = %if.end
  %6 = load i8*, i8** %_ptr.addr, align 8
  %7 = load i64, i64* %_size.addr, align 8
  %call4 = call i8* @realloc(i8* %6, i64 %7) #8
  store i8* %call4, i8** %result, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then3
  %8 = load i64, i64* %_size.addr, align 8
  %cmp = icmp ugt i64 %8, 0
  br i1 %cmp, label %land.lhs.true6, label %if.end10

land.lhs.true6:                                   ; preds = %if.end5
  %9 = load i8*, i8** %result, align 8
  %tobool7 = icmp ne i8* %9, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true6
  %10 = load %struct.__sFILE*, %struct.__sFILE** @__stderrp, align 8
  %11 = load i8*, i8** %_file.addr, align 8
  %12 = load i32, i32* %_line.addr, align 4
  %call9 = call i32 (%struct.__sFILE*, i8*, ...) @fprintf(%struct.__sFILE* %10, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.22, i32 0, i32 0), i8* %11, i32 %12)
  call void @abort() #9
  unreachable

if.end10:                                         ; preds = %land.lhs.true6, %if.end5
  %13 = load i8*, i8** %result, align 8
  store i8* %13, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then
  %14 = load i8*, i8** %retval, align 8
  ret i8* %14
}

declare i64 @fread(i8*, i64, i64, %struct.__sFILE*) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @fileClose(%struct.File* %_file) #0 {
entry:
  %_file.addr = alloca %struct.File*, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8
  %0 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer = getelementptr inbounds %struct.File, %struct.File* %0, i32 0, i32 0
  %1 = load i8*, i8** %buffer, align 8
  %call = call i8* @objz_realloc(i8* %1, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 350)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i8* @fileReadLine(%struct.File* %_file) #0 {
entry:
  %retval = alloca i8*, align 8
  %_file.addr = alloca %struct.File*, align 8
  %start = alloca i8*, align 8
  %c = alloca i8*, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8
  %0 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer = getelementptr inbounds %struct.File, %struct.File* %0, i32 0, i32 0
  %1 = load i8*, i8** %buffer, align 8
  %2 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos = getelementptr inbounds %struct.File, %struct.File* %2, i32 0, i32 2
  %3 = load i64, i64* %pos, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %3
  %4 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer2 = getelementptr inbounds %struct.File, %struct.File* %5, i32 0, i32 0
  %6 = load i8*, i8** %buffer2, align 8
  %7 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos3 = getelementptr inbounds %struct.File, %struct.File* %7, i32 0, i32 2
  %8 = load i64, i64* %pos3, align 8
  %arrayidx4 = getelementptr inbounds i8, i8* %6, i64 %8
  store i8* %arrayidx4, i8** %start, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end23, %if.end
  %9 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer5 = getelementptr inbounds %struct.File, %struct.File* %9, i32 0, i32 0
  %10 = load i8*, i8** %buffer5, align 8
  %11 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos6 = getelementptr inbounds %struct.File, %struct.File* %11, i32 0, i32 2
  %12 = load i64, i64* %pos6, align 8
  %arrayidx7 = getelementptr inbounds i8, i8* %10, i64 %12
  store i8* %arrayidx7, i8** %c, align 8
  %13 = load i8*, i8** %c, align 8
  %14 = load i8, i8* %13, align 1
  %conv8 = sext i8 %14 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.cond
  br label %for.end

if.end12:                                         ; preds = %for.cond
  %15 = load i8*, i8** %c, align 8
  %16 = load i8, i8* %15, align 1
  %conv13 = sext i8 %16 to i32
  %cmp14 = icmp eq i32 %conv13, 13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end12
  %17 = load i8*, i8** %c, align 8
  store i8 0, i8* %17, align 1
  br label %if.end23

if.else:                                          ; preds = %if.end12
  %18 = load i8*, i8** %c, align 8
  %19 = load i8, i8* %18, align 1
  %conv17 = sext i8 %19 to i32
  %cmp18 = icmp eq i32 %conv17, 10
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.else
  %20 = load i8*, i8** %c, align 8
  store i8 0, i8* %20, align 1
  %21 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos21 = getelementptr inbounds %struct.File, %struct.File* %21, i32 0, i32 2
  %22 = load i64, i64* %pos21, align 8
  %inc = add i64 %22, 1
  store i64 %inc, i64* %pos21, align 8
  br label %for.end

if.end22:                                         ; preds = %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then16
  %23 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos24 = getelementptr inbounds %struct.File, %struct.File* %23, i32 0, i32 2
  %24 = load i64, i64* %pos24, align 8
  %inc25 = add i64 %24, 1
  store i64 %inc25, i64* %pos24, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then20, %if.then11
  %25 = load i8*, i8** %start, align 8
  store i8* %25, i8** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %26 = load i8*, i8** %retval, align 8
  ret i8* %26
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @objz_setRealloc(i8* (i8*, i64)* %_realloc) #0 {
entry:
  %_realloc.addr = alloca i8* (i8*, i64)*, align 8
  store i8* (i8*, i64)* %_realloc, i8* (i8*, i64)** %_realloc.addr, align 8
  %0 = load i8* (i8*, i64)*, i8* (i8*, i64)** %_realloc.addr, align 8
  store i8* (i8*, i64)* %0, i8* (i8*, i64)** @s_realloc, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @objz_setIndexFormat(i32 %_format) #0 {
entry:
  %_format.addr = alloca i32, align 4
  store i32 %_format, i32* %_format.addr, align 4
  %0 = load i32, i32* %_format.addr, align 4
  store i32 %0, i32* @s_indexFormat, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @objz_setVertexFormat(i64 %_stride, i64 %_positionOffset, i64 %_texcoordOffset, i64 %_normalOffset) #0 {
entry:
  %_stride.addr = alloca i64, align 8
  %_positionOffset.addr = alloca i64, align 8
  %_texcoordOffset.addr = alloca i64, align 8
  %_normalOffset.addr = alloca i64, align 8
  store i64 %_stride, i64* %_stride.addr, align 8
  store i64 %_positionOffset, i64* %_positionOffset.addr, align 8
  store i64 %_texcoordOffset, i64* %_texcoordOffset.addr, align 8
  store i64 %_normalOffset, i64* %_normalOffset.addr, align 8
  %0 = load i64, i64* %_stride.addr, align 8
  store i64 %0, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8
  %1 = load i64, i64* %_positionOffset.addr, align 8
  store i64 %1, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %2 = load i64, i64* %_texcoordOffset.addr, align 8
  store i64 %2, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %3 = load i64, i64* %_normalOffset.addr, align 8
  store i64 %3, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.objzModel* @objz_load(i8* %_filename) #0 {
entry:
  %retval = alloca %struct.objzModel*, align 8
  %_filename.addr = alloca i8*, align 8
  %file = alloca %struct.File, align 8
  %bom32 = alloca i32*, align 8
  %bom16 = alloca i16*, align 8
  %materialLibs = alloca %struct.Array, align 8
  %materials = alloca %struct.Array, align 8
  %tempObjects = alloca %struct.Array, align 8
  %positions = alloca %struct.ChunkedArray, align 8
  %texcoords = alloca %struct.ChunkedArray, align 8
  %normals = alloca %struct.ChunkedArray, align 8
  %faces = alloca %struct.ChunkedArray, align 8
  %faceIndices = alloca %struct.Array, align 8
  %tempFaceIndices = alloca %struct.Array, align 8
  %generateNormals = alloca i8, align 1
  %currentGroupName = alloca [64 x i8], align 16
  %currentObjectName = alloca [64 x i8], align 16
  %currentMaterialIndex = alloca i32, align 4
  %currentSmoothingGroup = alloca i16, align 2
  %flags = alloca i32, align 4
  %lexer = alloca %struct.Lexer, align 8
  %token = alloca %struct.Token, align 4
  %line = alloca i8*, align 8
  %o = alloca %struct.TempObject, align 4
  %object = alloca %struct.TempObject*, align 8
  %tripletToken = alloca %struct.Token, align 4
  %rawTriplet = alloca [3 x i32], align 4
  %triplet = alloca %struct.IndexTriplet, align 4
  %face = alloca %struct.Face, align 4
  %i = alloca i32, align 4
  %prevFacesLength = alloca i32, align 4
  %isGroup = alloca i8, align 1
  %o141 = alloca %struct.TempObject, align 4
  %alreadyLoaded = alloca i8, align 1
  %i194 = alloca i32, align 4
  %i269 = alloca i32, align 4
  %mat = alloca %struct.objzMaterial*, align 8
  %pos = alloca [3 x float], align 4
  %normal = alloca [3 x float], align 4
  %texcoord = alloca [2 x float], align 4
  %faceNormals = alloca %struct.Array, align 8
  %i346 = alloca i32, align 4
  %tempObject = alloca %struct.TempObject*, align 8
  %j = alloca i32, align 4
  %face362 = alloca %struct.Face*, align 8
  %edge0 = alloca %struct.vec3, align 4
  %edge1 = alloca %struct.vec3, align 4
  %normal366 = alloca %struct.vec3, align 4
  %p0 = alloca %struct.vec3*, align 8
  %p1 = alloca %struct.vec3*, align 8
  %p2 = alloca %struct.vec3*, align 8
  %meshes = alloca %struct.Array, align 8
  %objects = alloca %struct.Array, align 8
  %indices431 = alloca %struct.Array, align 8
  %vertexHashMap = alloca %struct.VertexHashMap, align 8
  %normalHashMap = alloca %struct.NormalHashMap, align 8
  %maxObjectFaces = alloca i32, align 4
  %i441 = alloca i32, align 4
  %tempObject447 = alloca %struct.TempObject*, align 8
  %i467 = alloca i32, align 4
  %tempObject473 = alloca %struct.TempObject*, align 8
  %object483 = alloca %struct.objzObject, align 4
  %material = alloca i32, align 4
  %mesh = alloca %struct.objzMesh, align 4
  %j502 = alloca i32, align 4
  %face508 = alloca %struct.Face*, align 8
  %faceNormalIndex = alloca i32, align 4
  %k = alloca i32, align 4
  %k553 = alloca i32, align 4
  %triplet558 = alloca %struct.IndexTriplet*, align 8
  %vn562 = alloca i32, align 4
  %normal571 = alloca %struct.vec3, align 4
  %tmp = alloca { <2 x float>, float }, align 8
  %index = alloca i32, align 4
  %prev = alloca %struct.objzObject*, align 8
  %model = alloca %struct.objzModel*, align 8
  %i660 = alloca i32, align 4
  %index666 = alloca i32*, align 8
  %i698 = alloca i32, align 4
  %vOut = alloca i8*, align 8
  %vIn = alloca %struct.HashedVertex*, align 8
  store i8* %_filename, i8** %_filename.addr, align 8
  store i8 0, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16
  %0 = load i8*, i8** %_filename.addr, align 8
  %call = call zeroext i1 @fileOpen(%struct.File* %file, i8* %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %_filename.addr, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.2, i32 0, i32 0), i8* %1)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %buffer = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %2 = load i8*, i8** %buffer, align 8
  %3 = bitcast i8* %2 to i32*
  store i32* %3, i32** %bom32, align 8
  %4 = load i32*, i32** %bom32, align 8
  %5 = load i32, i32* %4, align 4
  %cmp = icmp eq i32 %5, 65279
  br i1 %cmp, label %if.then2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load i32*, i32** %bom32, align 8
  %7 = load i32, i32* %6, align 4
  %cmp1 = icmp eq i32 %7, -131072
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %8 = load i8*, i8** %_filename.addr, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i8* %8)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %buffer4 = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %9 = load i8*, i8** %buffer4, align 8
  %10 = bitcast i8* %9 to i16*
  store i16* %10, i16** %bom16, align 8
  %11 = load i16*, i16** %bom16, align 8
  %12 = load i16, i16* %11, align 2
  %conv = zext i16 %12 to i32
  %cmp5 = icmp eq i32 %conv, 65534
  br i1 %cmp5, label %if.then11, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end3
  %13 = load i16*, i16** %bom16, align 8
  %14 = load i16, i16* %13, align 2
  %conv8 = zext i16 %14 to i32
  %cmp9 = icmp eq i32 %conv8, 65279
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false7, %if.end3
  %15 = load i8*, i8** %_filename.addr, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i8* %15)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

if.end12:                                         ; preds = %lor.lhs.false7
  call void @arrayInit(%struct.Array* %materialLibs, i64 256, i32 1)
  call void @arrayInit(%struct.Array* %materials, i64 568, i32 16)
  call void @arrayInit(%struct.Array* %tempObjects, i64 72, i32 64)
  call void @chunkedArrayInit(%struct.ChunkedArray* %positions, i64 12, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %texcoords, i64 8, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %normals, i64 12, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %faces, i64 40, i32 100000)
  call void @arrayInit(%struct.Array* %faceIndices, i64 12, i32 8)
  call void @arrayInit(%struct.Array* %tempFaceIndices, i64 12, i32 8)
  store i8 0, i8* %generateNormals, align 1
  %16 = bitcast [64 x i8]* %currentGroupName to i8*
  call void @llvm.memset.p0i8.i64(i8* %16, i8 0, i64 64, i32 16, i1 false)
  %17 = bitcast [64 x i8]* %currentObjectName to i8*
  call void @llvm.memset.p0i8.i64(i8* %17, i8 0, i64 64, i32 16, i1 false)
  store i32 -1, i32* %currentMaterialIndex, align 4
  store i16 0, i16* %currentSmoothingGroup, align 2
  store i32 0, i32* %flags, align 4
  call void @initLexer(%struct.Lexer* %lexer)
  br label %for.cond

for.cond:                                         ; preds = %if.end336, %if.end12
  %call13 = call i8* @fileReadLine(%struct.File* %file)
  store i8* %call13, i8** %line, align 8
  %18 = load i8*, i8** %line, align 8
  %tobool = icmp ne i8* %18, null
  br i1 %tobool, label %if.end15, label %if.then14

if.then14:                                        ; preds = %for.cond
  br label %for.end337

if.end15:                                         ; preds = %for.cond
  %19 = load i8*, i8** %line, align 8
  call void @lexerSetLine(%struct.Lexer* %lexer, i8* %19)
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call16 = call i32 @strcasecmp(i8* %arraydecay, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.else91

if.then19:                                        ; preds = %if.end15
  %length = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %20 = load i32, i32* %length, align 8
  %cmp20 = icmp eq i32 %20, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then19
  %name = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 0
  %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* %name, i64 0, i64 0
  store i8 0, i8* %arrayidx, align 4
  %numFaces = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 2
  store i32 0, i32* %numFaces, align 4
  %firstFace = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 1
  store i32 0, i32* %firstFace, align 4
  %21 = bitcast %struct.TempObject* %o to i8*
  call void @arrayAppend(%struct.Array* %tempObjects, i8* %21)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then19
  %data = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %22 = load i8*, i8** %data, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %23 = load i32, i32* %elementSize, align 8
  %length24 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %24 = load i32, i32* %length24, align 8
  %sub = sub i32 %24, 1
  %mul = mul i32 %23, %sub
  %idxprom = zext i32 %mul to i64
  %arrayidx25 = getelementptr inbounds i8, i8* %22, i64 %idxprom
  %25 = bitcast i8* %arrayidx25 to %struct.TempObject*
  store %struct.TempObject* %25, %struct.TempObject** %object, align 8
  %length26 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  store i32 0, i32* %length26, align 8
  br label %for.cond27

for.cond27:                                       ; preds = %if.end60, %if.end23
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %tripletToken, i1 zeroext false)
  %text28 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 0
  %arrayidx29 = getelementptr inbounds [256 x i8], [256 x i8]* %text28, i64 0, i64 0
  %26 = load i8, i8* %arrayidx29, align 4
  %conv30 = sext i8 %26 to i32
  %cmp31 = icmp eq i32 %conv30, 0
  br i1 %cmp31, label %if.then33, label %if.end38

if.then33:                                        ; preds = %for.cond27
  %call34 = call zeroext i1 @isEol(%struct.Lexer* %lexer)
  br i1 %call34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then33
  br label %for.end

if.end36:                                         ; preds = %if.then33
  %line37 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 1
  %27 = load i32, i32* %line37, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 2
  %28 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6, i32 0, i32 0), i32 %27, i32 %28)
  br label %error

if.end38:                                         ; preds = %for.cond27
  %arraydecay39 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i32 0, i32 0
  %call40 = call zeroext i1 @parseVertexAttribIndices(%struct.Token* %tripletToken, i32* %arraydecay39)
  br i1 %call40, label %if.end44, label %if.then41

if.then41:                                        ; preds = %if.end38
  %line42 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 1
  %29 = load i32, i32* %line42, align 4
  %column43 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 2
  %30 = load i32, i32* %column43, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6, i32 0, i32 0), i32 %29, i32 %30)
  br label %error

if.end44:                                         ; preds = %if.end38
  %arrayidx45 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 0
  %31 = load i32, i32* %arrayidx45, align 4
  %length46 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %positions, i32 0, i32 3
  %32 = load i32, i32* %length46, align 8
  %call47 = call i32 @fixVertexAttribIndex(i32 %31, i32 %32)
  %v = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 0
  store i32 %call47, i32* %v, align 4
  %arrayidx48 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 1
  %33 = load i32, i32* %arrayidx48, align 4
  %length49 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %texcoords, i32 0, i32 3
  %34 = load i32, i32* %length49, align 8
  %call50 = call i32 @fixVertexAttribIndex(i32 %33, i32 %34)
  %vt = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 1
  store i32 %call50, i32* %vt, align 4
  %arrayidx51 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 2
  %35 = load i32, i32* %arrayidx51, align 4
  %length52 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %36 = load i32, i32* %length52, align 8
  %call53 = call i32 @fixVertexAttribIndex(i32 %35, i32 %36)
  %vn = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 2
  store i32 %call53, i32* %vn, align 4
  %37 = bitcast %struct.IndexTriplet* %triplet to i8*
  call void @arrayAppend(%struct.Array* %faceIndices, i8* %37)
  %vn54 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 2
  %38 = load i32, i32* %vn54, align 4
  %cmp55 = icmp eq i32 %38, -1
  br i1 %cmp55, label %land.lhs.true, label %if.end60

land.lhs.true:                                    ; preds = %if.end44
  %39 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %cmp57 = icmp ne i64 %39, -1
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %land.lhs.true
  store i8 1, i8* %generateNormals, align 1
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %land.lhs.true, %if.end44
  br label %for.cond27

for.end:                                          ; preds = %if.then35
  %length61 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  %40 = load i32, i32* %length61, align 8
  %cmp62 = icmp ult i32 %40, 3
  br i1 %cmp62, label %if.then64, label %if.end67

if.then64:                                        ; preds = %for.end
  %line65 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %41 = load i32, i32* %line65, align 4
  %column66 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %42 = load i32, i32* %column66, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.7, i32 0, i32 0), i32 %41, i32 %42)
  br label %error

if.end67:                                         ; preds = %for.end
  %length68 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  %43 = load i32, i32* %length68, align 8
  %cmp69 = icmp eq i32 %43, 3
  br i1 %cmp69, label %if.then71, label %if.else

if.then71:                                        ; preds = %if.end67
  %44 = load i32, i32* %currentMaterialIndex, align 4
  %conv72 = trunc i32 %44 to i16
  %materialIndex = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 0
  store i16 %conv72, i16* %materialIndex, align 4
  %45 = load i16, i16* %currentSmoothingGroup, align 2
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 1
  store i16 %45, i16* %smoothingGroup, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond73

for.cond73:                                       ; preds = %for.inc, %if.then71
  %46 = load i32, i32* %i, align 4
  %cmp74 = icmp slt i32 %46, 3
  br i1 %cmp74, label %for.body, label %for.end83

for.body:                                         ; preds = %for.cond73
  %indices = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 2
  %47 = load i32, i32* %i, align 4
  %idxprom76 = sext i32 %47 to i64
  %arrayidx77 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices, i64 0, i64 %idxprom76
  %data78 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 0
  %48 = load i8*, i8** %data78, align 8
  %elementSize79 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 3
  %49 = load i32, i32* %elementSize79, align 8
  %50 = load i32, i32* %i, align 4
  %mul80 = mul i32 %49, %50
  %idxprom81 = zext i32 %mul80 to i64
  %arrayidx82 = getelementptr inbounds i8, i8* %48, i64 %idxprom81
  %51 = bitcast i8* %arrayidx82 to %struct.IndexTriplet*
  %52 = bitcast %struct.IndexTriplet* %arrayidx77 to i8*
  %53 = bitcast %struct.IndexTriplet* %51 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* %53, i64 12, i32 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %54 = load i32, i32* %i, align 4
  %inc = add nsw i32 %54, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond73

for.end83:                                        ; preds = %for.cond73
  %55 = bitcast %struct.Face* %face to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %faces, i8* %55)
  %56 = load %struct.TempObject*, %struct.TempObject** %object, align 8
  %numFaces84 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %56, i32 0, i32 2
  %57 = load i32, i32* %numFaces84, align 4
  %inc85 = add i32 %57, 1
  store i32 %inc85, i32* %numFaces84, align 4
  br label %if.end90

if.else:                                          ; preds = %if.end67
  %length86 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %58 = load i32, i32* %length86, align 8
  store i32 %58, i32* %prevFacesLength, align 4
  %59 = load i32, i32* %currentMaterialIndex, align 4
  %60 = load i16, i16* %currentSmoothingGroup, align 2
  call void @triangulate(%struct.Array* %faceIndices, %struct.ChunkedArray* %positions, %struct.Array* %tempFaceIndices, %struct.ChunkedArray* %faces, i32 %59, i16 zeroext %60)
  %length87 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %61 = load i32, i32* %length87, align 8
  %62 = load i32, i32* %prevFacesLength, align 4
  %sub88 = sub i32 %61, %62
  %63 = load %struct.TempObject*, %struct.TempObject** %object, align 8
  %numFaces89 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %63, i32 0, i32 2
  %64 = load i32, i32* %numFaces89, align 4
  %add = add i32 %64, %sub88
  store i32 %add, i32* %numFaces89, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.else, %for.end83
  br label %if.end336

if.else91:                                        ; preds = %if.end15
  %text92 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay93 = getelementptr inbounds [256 x i8], [256 x i8]* %text92, i32 0, i32 0
  %call94 = call i32 @strcasecmp(i8* %arraydecay93, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  %cmp95 = icmp eq i32 %call94, 0
  br i1 %cmp95, label %if.then103, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.else91
  %text98 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay99 = getelementptr inbounds [256 x i8], [256 x i8]* %text98, i32 0, i32 0
  %call100 = call i32 @strcasecmp(i8* %arraydecay99, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0))
  %cmp101 = icmp eq i32 %call100, 0
  br i1 %cmp101, label %if.then103, label %if.else178

if.then103:                                       ; preds = %lor.lhs.false97, %if.else91
  %text104 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay105 = getelementptr inbounds [256 x i8], [256 x i8]* %text104, i32 0, i32 0
  %call106 = call i32 @strcasecmp(i8* %arraydecay105, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  %cmp107 = icmp eq i32 %call106, 0
  %frombool = zext i1 %cmp107 to i8
  store i8 %frombool, i8* %isGroup, align 1
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext true)
  %65 = load i8, i8* %isGroup, align 1
  %tobool109 = trunc i8 %65 to i1
  br i1 %tobool109, label %if.then110, label %if.else124

if.then110:                                       ; preds = %if.then103
  %text111 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx112 = getelementptr inbounds [256 x i8], [256 x i8]* %text111, i64 0, i64 0
  %66 = load i8, i8* %arrayidx112, align 4
  %conv113 = sext i8 %66 to i32
  %cmp114 = icmp ne i32 %conv113, 0
  br i1 %cmp114, label %if.then116, label %if.end123

if.then116:                                       ; preds = %if.then110
  %arraydecay117 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %text118 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay119 = getelementptr inbounds [256 x i8], [256 x i8]* %text118, i32 0, i32 0
  %text120 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay121 = getelementptr inbounds [256 x i8], [256 x i8]* %text120, i32 0, i32 0
  %call122 = call i64 @strLength(i8* %arraydecay121, i64 256)
  call void @strCopy(i8* %arraydecay117, i64 64, i8* %arraydecay119, i64 %call122)
  br label %if.end123

if.end123:                                        ; preds = %if.then116, %if.then110
  br label %if.end140

if.else124:                                       ; preds = %if.then103
  %text125 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx126 = getelementptr inbounds [256 x i8], [256 x i8]* %text125, i64 0, i64 0
  %67 = load i8, i8* %arrayidx126, align 4
  %conv127 = sext i8 %67 to i32
  %cmp128 = icmp eq i32 %conv127, 0
  br i1 %cmp128, label %if.then130, label %if.end133

if.then130:                                       ; preds = %if.else124
  %line131 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %68 = load i32, i32* %line131, align 4
  %column132 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %69 = load i32, i32* %column132, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.10, i32 0, i32 0), i32 %68, i32 %69)
  br label %error

if.end133:                                        ; preds = %if.else124
  %arraydecay134 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %text135 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay136 = getelementptr inbounds [256 x i8], [256 x i8]* %text135, i32 0, i32 0
  %text137 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay138 = getelementptr inbounds [256 x i8], [256 x i8]* %text137, i32 0, i32 0
  %call139 = call i64 @strLength(i8* %arraydecay138, i64 256)
  call void @strCopy(i8* %arraydecay134, i64 64, i8* %arraydecay136, i64 %call139)
  br label %if.end140

if.end140:                                        ; preds = %if.end133, %if.end123
  %name142 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arrayidx143 = getelementptr inbounds [64 x i8], [64 x i8]* %name142, i64 0, i64 0
  store i8 0, i8* %arrayidx143, align 4
  %arrayidx144 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i64 0, i64 0
  %70 = load i8, i8* %arrayidx144, align 16
  %conv145 = sext i8 %70 to i32
  %cmp146 = icmp ne i32 %conv145, 0
  br i1 %cmp146, label %if.then148, label %if.end154

if.then148:                                       ; preds = %if.end140
  %name149 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay150 = getelementptr inbounds [64 x i8], [64 x i8]* %name149, i32 0, i32 0
  %arraydecay151 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %arraydecay152 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %call153 = call i64 @strLength(i8* %arraydecay152, i64 64)
  call void @strCopy(i8* %arraydecay150, i64 64, i8* %arraydecay151, i64 %call153)
  br label %if.end154

if.end154:                                        ; preds = %if.then148, %if.end140
  %arrayidx155 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i64 0, i64 0
  %71 = load i8, i8* %arrayidx155, align 16
  %conv156 = sext i8 %71 to i32
  %cmp157 = icmp ne i32 %conv156, 0
  br i1 %cmp157, label %if.then159, label %if.end174

if.then159:                                       ; preds = %if.end154
  %name160 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay161 = getelementptr inbounds [64 x i8], [64 x i8]* %name160, i32 0, i32 0
  %call162 = call i64 @strLength(i8* %arraydecay161, i64 64)
  %cmp163 = icmp ugt i64 %call162, 0
  br i1 %cmp163, label %if.then165, label %if.end168

if.then165:                                       ; preds = %if.then159
  %name166 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay167 = getelementptr inbounds [64 x i8], [64 x i8]* %name166, i32 0, i32 0
  call void @strConcat(i8* %arraydecay167, i64 64, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0), i64 1)
  br label %if.end168

if.end168:                                        ; preds = %if.then165, %if.then159
  %name169 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay170 = getelementptr inbounds [64 x i8], [64 x i8]* %name169, i32 0, i32 0
  %arraydecay171 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %arraydecay172 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %call173 = call i64 @strLength(i8* %arraydecay172, i64 64)
  call void @strConcat(i8* %arraydecay170, i64 64, i8* %arraydecay171, i64 %call173)
  br label %if.end174

if.end174:                                        ; preds = %if.end168, %if.end154
  %length175 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %72 = load i32, i32* %length175, align 8
  %firstFace176 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 1
  store i32 %72, i32* %firstFace176, align 4
  %numFaces177 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 2
  store i32 0, i32* %numFaces177, align 4
  %73 = bitcast %struct.TempObject* %o141 to i8*
  call void @arrayAppend(%struct.Array* %tempObjects, i8* %73)
  br label %if.end335

if.else178:                                       ; preds = %lor.lhs.false97
  %text179 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay180 = getelementptr inbounds [256 x i8], [256 x i8]* %text179, i32 0, i32 0
  %call181 = call i32 @strcasecmp(i8* %arraydecay180, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0))
  %cmp182 = icmp eq i32 %call181, 0
  br i1 %cmp182, label %if.then184, label %if.else225

if.then184:                                       ; preds = %if.else178
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext true)
  %text185 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx186 = getelementptr inbounds [256 x i8], [256 x i8]* %text185, i64 0, i64 0
  %74 = load i8, i8* %arrayidx186, align 4
  %conv187 = sext i8 %74 to i32
  %cmp188 = icmp eq i32 %conv187, 0
  br i1 %cmp188, label %if.then190, label %if.end193

if.then190:                                       ; preds = %if.then184
  %line191 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %75 = load i32, i32* %line191, align 4
  %column192 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %76 = load i32, i32* %column192, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.13, i32 0, i32 0), i32 %75, i32 %76)
  br label %error

if.end193:                                        ; preds = %if.then184
  store i8 0, i8* %alreadyLoaded, align 1
  store i32 0, i32* %i194, align 4
  br label %for.cond195

for.cond195:                                      ; preds = %for.inc212, %if.end193
  %77 = load i32, i32* %i194, align 4
  %length196 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 1
  %78 = load i32, i32* %length196, align 8
  %cmp197 = icmp ult i32 %77, %78
  br i1 %cmp197, label %for.body199, label %for.end214

for.body199:                                      ; preds = %for.cond195
  %text200 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay201 = getelementptr inbounds [256 x i8], [256 x i8]* %text200, i32 0, i32 0
  %data202 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 0
  %79 = load i8*, i8** %data202, align 8
  %elementSize203 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 3
  %80 = load i32, i32* %elementSize203, align 8
  %81 = load i32, i32* %i194, align 4
  %mul204 = mul i32 %80, %81
  %idxprom205 = zext i32 %mul204 to i64
  %arrayidx206 = getelementptr inbounds i8, i8* %79, i64 %idxprom205
  %call207 = call i32 @strcasecmp(i8* %arraydecay201, i8* %arrayidx206)
  %cmp208 = icmp eq i32 %call207, 0
  br i1 %cmp208, label %if.then210, label %if.end211

if.then210:                                       ; preds = %for.body199
  store i8 1, i8* %alreadyLoaded, align 1
  br label %for.end214

if.end211:                                        ; preds = %for.body199
  br label %for.inc212

for.inc212:                                       ; preds = %if.end211
  %82 = load i32, i32* %i194, align 4
  %inc213 = add i32 %82, 1
  store i32 %inc213, i32* %i194, align 4
  br label %for.cond195

for.end214:                                       ; preds = %if.then210, %for.cond195
  %83 = load i8, i8* %alreadyLoaded, align 1
  %tobool215 = trunc i8 %83 to i1
  br i1 %tobool215, label %if.end224, label %if.then216

if.then216:                                       ; preds = %for.end214
  %84 = load i8*, i8** %_filename.addr, align 8
  %text217 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay218 = getelementptr inbounds [256 x i8], [256 x i8]* %text217, i32 0, i32 0
  %call219 = call zeroext i1 @loadMaterialFile(i8* %84, i8* %arraydecay218, %struct.Array* %materials)
  br i1 %call219, label %if.end221, label %if.then220

if.then220:                                       ; preds = %if.then216
  br label %error

if.end221:                                        ; preds = %if.then216
  %text222 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay223 = getelementptr inbounds [256 x i8], [256 x i8]* %text222, i32 0, i32 0
  call void @arrayAppend(%struct.Array* %materialLibs, i8* %arraydecay223)
  br label %if.end224

if.end224:                                        ; preds = %if.end221, %for.end214
  br label %if.end334

if.else225:                                       ; preds = %if.else178
  %text226 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay227 = getelementptr inbounds [256 x i8], [256 x i8]* %text226, i32 0, i32 0
  %call228 = call i32 @strcasecmp(i8* %arraydecay227, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  %cmp229 = icmp eq i32 %call228, 0
  br i1 %cmp229, label %if.then231, label %if.else253

if.then231:                                       ; preds = %if.else225
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text232 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx233 = getelementptr inbounds [256 x i8], [256 x i8]* %text232, i64 0, i64 0
  %85 = load i8, i8* %arrayidx233, align 4
  %conv234 = sext i8 %85 to i32
  %cmp235 = icmp eq i32 %conv234, 0
  br i1 %cmp235, label %if.then237, label %if.end240

if.then237:                                       ; preds = %if.then231
  %line238 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %86 = load i32, i32* %line238, align 4
  %column239 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %87 = load i32, i32* %column239, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.15, i32 0, i32 0), i32 %86, i32 %87)
  br label %error

if.end240:                                        ; preds = %if.then231
  %text241 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay242 = getelementptr inbounds [256 x i8], [256 x i8]* %text241, i32 0, i32 0
  %call243 = call i32 @strcasecmp(i8* %arraydecay242, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0))
  %cmp244 = icmp eq i32 %call243, 0
  br i1 %cmp244, label %if.then246, label %if.else247

if.then246:                                       ; preds = %if.end240
  store i16 0, i16* %currentSmoothingGroup, align 2
  br label %if.end252

if.else247:                                       ; preds = %if.end240
  %text248 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay249 = getelementptr inbounds [256 x i8], [256 x i8]* %text248, i32 0, i32 0
  %call250 = call i32 @atoi(i8* %arraydecay249)
  %conv251 = trunc i32 %call250 to i16
  store i16 %conv251, i16* %currentSmoothingGroup, align 2
  br label %if.end252

if.end252:                                        ; preds = %if.else247, %if.then246
  br label %if.end333

if.else253:                                       ; preds = %if.else225
  %text254 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay255 = getelementptr inbounds [256 x i8], [256 x i8]* %text254, i32 0, i32 0
  %call256 = call i32 @strcasecmp(i8* %arraydecay255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i32 0, i32 0))
  %cmp257 = icmp eq i32 %call256, 0
  br i1 %cmp257, label %if.then259, label %if.else292

if.then259:                                       ; preds = %if.else253
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text260 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx261 = getelementptr inbounds [256 x i8], [256 x i8]* %text260, i64 0, i64 0
  %88 = load i8, i8* %arrayidx261, align 4
  %conv262 = sext i8 %88 to i32
  %cmp263 = icmp eq i32 %conv262, 0
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %if.then259
  %line266 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %89 = load i32, i32* %line266, align 4
  %column267 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %90 = load i32, i32* %column267, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.18, i32 0, i32 0), i32 %89, i32 %90)
  br label %error

if.end268:                                        ; preds = %if.then259
  store i32 -1, i32* %currentMaterialIndex, align 4
  store i32 0, i32* %i269, align 4
  br label %for.cond270

for.cond270:                                      ; preds = %for.inc289, %if.end268
  %91 = load i32, i32* %i269, align 4
  %length271 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %92 = load i32, i32* %length271, align 8
  %cmp272 = icmp ult i32 %91, %92
  br i1 %cmp272, label %for.body274, label %for.end291

for.body274:                                      ; preds = %for.cond270
  %data275 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 0
  %93 = load i8*, i8** %data275, align 8
  %elementSize276 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 3
  %94 = load i32, i32* %elementSize276, align 8
  %95 = load i32, i32* %i269, align 4
  %mul277 = mul i32 %94, %95
  %idxprom278 = zext i32 %mul277 to i64
  %arrayidx279 = getelementptr inbounds i8, i8* %93, i64 %idxprom278
  %96 = bitcast i8* %arrayidx279 to %struct.objzMaterial*
  store %struct.objzMaterial* %96, %struct.objzMaterial** %mat, align 8
  %97 = load %struct.objzMaterial*, %struct.objzMaterial** %mat, align 8
  %name280 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %97, i32 0, i32 0
  %arraydecay281 = getelementptr inbounds [64 x i8], [64 x i8]* %name280, i32 0, i32 0
  %text282 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay283 = getelementptr inbounds [256 x i8], [256 x i8]* %text282, i32 0, i32 0
  %call284 = call i32 @strcasecmp(i8* %arraydecay281, i8* %arraydecay283)
  %cmp285 = icmp eq i32 %call284, 0
  br i1 %cmp285, label %if.then287, label %if.end288

if.then287:                                       ; preds = %for.body274
  %98 = load i32, i32* %i269, align 4
  store i32 %98, i32* %currentMaterialIndex, align 4
  br label %for.end291

if.end288:                                        ; preds = %for.body274
  br label %for.inc289

for.inc289:                                       ; preds = %if.end288
  %99 = load i32, i32* %i269, align 4
  %inc290 = add i32 %99, 1
  store i32 %inc290, i32* %i269, align 4
  br label %for.cond270

for.end291:                                       ; preds = %if.then287, %for.cond270
  br label %if.end332

if.else292:                                       ; preds = %if.else253
  %text293 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay294 = getelementptr inbounds [256 x i8], [256 x i8]* %text293, i32 0, i32 0
  %call295 = call i32 @strcasecmp(i8* %arraydecay294, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.19, i32 0, i32 0))
  %cmp296 = icmp eq i32 %call295, 0
  br i1 %cmp296, label %if.then298, label %if.else304

if.then298:                                       ; preds = %if.else292
  %arraydecay299 = getelementptr inbounds [3 x float], [3 x float]* %pos, i32 0, i32 0
  %call300 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay299, i32 3)
  br i1 %call300, label %if.end302, label %if.then301

if.then301:                                       ; preds = %if.then298
  br label %error

if.end302:                                        ; preds = %if.then298
  %arraydecay303 = getelementptr inbounds [3 x float], [3 x float]* %pos, i32 0, i32 0
  %100 = bitcast float* %arraydecay303 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %positions, i8* %100)
  br label %if.end331

if.else304:                                       ; preds = %if.else292
  %text305 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay306 = getelementptr inbounds [256 x i8], [256 x i8]* %text305, i32 0, i32 0
  %call307 = call i32 @strcasecmp(i8* %arraydecay306, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0))
  %cmp308 = icmp eq i32 %call307, 0
  br i1 %cmp308, label %if.then310, label %if.else316

if.then310:                                       ; preds = %if.else304
  %arraydecay311 = getelementptr inbounds [3 x float], [3 x float]* %normal, i32 0, i32 0
  %call312 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay311, i32 3)
  br i1 %call312, label %if.end314, label %if.then313

if.then313:                                       ; preds = %if.then310
  br label %error

if.end314:                                        ; preds = %if.then310
  %arraydecay315 = getelementptr inbounds [3 x float], [3 x float]* %normal, i32 0, i32 0
  %101 = bitcast float* %arraydecay315 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %normals, i8* %101)
  %102 = load i32, i32* %flags, align 4
  %or = or i32 %102, 2
  store i32 %or, i32* %flags, align 4
  br label %if.end330

if.else316:                                       ; preds = %if.else304
  %text317 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay318 = getelementptr inbounds [256 x i8], [256 x i8]* %text317, i32 0, i32 0
  %call319 = call i32 @strcasecmp(i8* %arraydecay318, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0))
  %cmp320 = icmp eq i32 %call319, 0
  br i1 %cmp320, label %if.then322, label %if.end329

if.then322:                                       ; preds = %if.else316
  %arraydecay323 = getelementptr inbounds [2 x float], [2 x float]* %texcoord, i32 0, i32 0
  %call324 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay323, i32 2)
  br i1 %call324, label %if.end326, label %if.then325

if.then325:                                       ; preds = %if.then322
  br label %error

if.end326:                                        ; preds = %if.then322
  %arraydecay327 = getelementptr inbounds [2 x float], [2 x float]* %texcoord, i32 0, i32 0
  %103 = bitcast float* %arraydecay327 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %texcoords, i8* %103)
  %104 = load i32, i32* %flags, align 4
  %or328 = or i32 %104, 1
  store i32 %or328, i32* %flags, align 4
  br label %if.end329

if.end329:                                        ; preds = %if.end326, %if.else316
  br label %if.end330

if.end330:                                        ; preds = %if.end329, %if.end314
  br label %if.end331

if.end331:                                        ; preds = %if.end330, %if.end302
  br label %if.end332

if.end332:                                        ; preds = %if.end331, %for.end291
  br label %if.end333

if.end333:                                        ; preds = %if.end332, %if.end252
  br label %if.end334

if.end334:                                        ; preds = %if.end333, %if.end224
  br label %if.end335

if.end335:                                        ; preds = %if.end334, %if.end174
  br label %if.end336

if.end336:                                        ; preds = %if.end335, %if.end90
  br label %for.cond

for.end337:                                       ; preds = %if.then14
  %length338 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %105 = load i32, i32* %length338, align 8
  %cmp339 = icmp eq i32 %105, 0
  br i1 %cmp339, label %if.then341, label %if.end342

if.then341:                                       ; preds = %for.end337
  store i8 1, i8* %generateNormals, align 1
  br label %if.end342

if.end342:                                        ; preds = %if.then341, %for.end337
  call void @arrayDestroy(%struct.Array* %materialLibs)
  call void @arrayDestroy(%struct.Array* %faceIndices)
  call void @arrayDestroy(%struct.Array* %tempFaceIndices)
  call void @fileClose(%struct.File* %file)
  %length343 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %106 = load i32, i32* %length343, align 8
  call void @arrayInit(%struct.Array* %faceNormals, i64 12, i32 %106)
  %107 = load i8, i8* %generateNormals, align 1
  %tobool344 = trunc i8 %107 to i1
  br i1 %tobool344, label %if.then345, label %if.end430

if.then345:                                       ; preds = %if.end342
  store i32 0, i32* %i346, align 4
  br label %for.cond347

for.cond347:                                      ; preds = %for.inc427, %if.then345
  %108 = load i32, i32* %i346, align 4
  %length348 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %109 = load i32, i32* %length348, align 8
  %cmp349 = icmp ult i32 %108, %109
  br i1 %cmp349, label %for.body351, label %for.end429

for.body351:                                      ; preds = %for.cond347
  %data352 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %110 = load i8*, i8** %data352, align 8
  %elementSize353 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %111 = load i32, i32* %elementSize353, align 8
  %112 = load i32, i32* %i346, align 4
  %mul354 = mul i32 %111, %112
  %idxprom355 = zext i32 %mul354 to i64
  %arrayidx356 = getelementptr inbounds i8, i8* %110, i64 %idxprom355
  %113 = bitcast i8* %arrayidx356 to %struct.TempObject*
  store %struct.TempObject* %113, %struct.TempObject** %tempObject, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond357

for.cond357:                                      ; preds = %for.inc424, %for.body351
  %114 = load i32, i32* %j, align 4
  %115 = load %struct.TempObject*, %struct.TempObject** %tempObject, align 8
  %numFaces358 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %115, i32 0, i32 2
  %116 = load i32, i32* %numFaces358, align 4
  %cmp359 = icmp ult i32 %114, %116
  br i1 %cmp359, label %for.body361, label %for.end426

for.body361:                                      ; preds = %for.cond357
  %117 = load %struct.TempObject*, %struct.TempObject** %tempObject, align 8
  %firstFace363 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %117, i32 0, i32 1
  %118 = load i32, i32* %firstFace363, align 4
  %119 = load i32, i32* %j, align 4
  %add364 = add i32 %118, %119
  %call365 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %faces, i32 %add364)
  %120 = bitcast i8* %call365 to %struct.Face*
  store %struct.Face* %120, %struct.Face** %face362, align 8
  %121 = load %struct.Face*, %struct.Face** %face362, align 8
  %indices367 = getelementptr inbounds %struct.Face, %struct.Face* %121, i32 0, i32 2
  %arrayidx368 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices367, i64 0, i64 0
  %v369 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx368, i32 0, i32 0
  %122 = load i32, i32* %v369, align 4
  %call370 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %122)
  %123 = bitcast i8* %call370 to %struct.vec3*
  store %struct.vec3* %123, %struct.vec3** %p0, align 8
  %124 = load %struct.Face*, %struct.Face** %face362, align 8
  %indices371 = getelementptr inbounds %struct.Face, %struct.Face* %124, i32 0, i32 2
  %arrayidx372 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices371, i64 0, i64 1
  %v373 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx372, i32 0, i32 0
  %125 = load i32, i32* %v373, align 4
  %call374 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %125)
  %126 = bitcast i8* %call374 to %struct.vec3*
  store %struct.vec3* %126, %struct.vec3** %p1, align 8
  %127 = load %struct.Face*, %struct.Face** %face362, align 8
  %indices375 = getelementptr inbounds %struct.Face, %struct.Face* %127, i32 0, i32 2
  %arrayidx376 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices375, i64 0, i64 2
  %v377 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx376, i32 0, i32 0
  %128 = load i32, i32* %v377, align 4
  %call378 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %128)
  %129 = bitcast i8* %call378 to %struct.vec3*
  store %struct.vec3* %129, %struct.vec3** %p2, align 8
  %130 = load %struct.vec3*, %struct.vec3** %p1, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %130, i32 0, i32 0
  %131 = load float, float* %x, align 4
  %132 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %x379 = getelementptr inbounds %struct.vec3, %struct.vec3* %132, i32 0, i32 0
  %133 = load float, float* %x379, align 4
  %sub380 = fsub float %131, %133
  %x381 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  store float %sub380, float* %x381, align 4
  %134 = load %struct.vec3*, %struct.vec3** %p1, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %134, i32 0, i32 1
  %135 = load float, float* %y, align 4
  %136 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %y382 = getelementptr inbounds %struct.vec3, %struct.vec3* %136, i32 0, i32 1
  %137 = load float, float* %y382, align 4
  %sub383 = fsub float %135, %137
  %y384 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  store float %sub383, float* %y384, align 4
  %138 = load %struct.vec3*, %struct.vec3** %p1, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %138, i32 0, i32 2
  %139 = load float, float* %z, align 4
  %140 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %z385 = getelementptr inbounds %struct.vec3, %struct.vec3* %140, i32 0, i32 2
  %141 = load float, float* %z385, align 4
  %sub386 = fsub float %139, %141
  %z387 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  store float %sub386, float* %z387, align 4
  %142 = load %struct.vec3*, %struct.vec3** %p2, align 8
  %x388 = getelementptr inbounds %struct.vec3, %struct.vec3* %142, i32 0, i32 0
  %143 = load float, float* %x388, align 4
  %144 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %x389 = getelementptr inbounds %struct.vec3, %struct.vec3* %144, i32 0, i32 0
  %145 = load float, float* %x389, align 4
  %sub390 = fsub float %143, %145
  %x391 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  store float %sub390, float* %x391, align 4
  %146 = load %struct.vec3*, %struct.vec3** %p2, align 8
  %y392 = getelementptr inbounds %struct.vec3, %struct.vec3* %146, i32 0, i32 1
  %147 = load float, float* %y392, align 4
  %148 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %y393 = getelementptr inbounds %struct.vec3, %struct.vec3* %148, i32 0, i32 1
  %149 = load float, float* %y393, align 4
  %sub394 = fsub float %147, %149
  %y395 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  store float %sub394, float* %y395, align 4
  %150 = load %struct.vec3*, %struct.vec3** %p2, align 8
  %z396 = getelementptr inbounds %struct.vec3, %struct.vec3* %150, i32 0, i32 2
  %151 = load float, float* %z396, align 4
  %152 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %z397 = getelementptr inbounds %struct.vec3, %struct.vec3* %152, i32 0, i32 2
  %153 = load float, float* %z397, align 4
  %sub398 = fsub float %151, %153
  %z399 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  store float %sub398, float* %z399, align 4
  %y400 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  %154 = load float, float* %y400, align 4
  %z401 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  %155 = load float, float* %z401, align 4
  %mul402 = fmul float %154, %155
  %z403 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  %156 = load float, float* %z403, align 4
  %y404 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  %157 = load float, float* %y404, align 4
  %mul405 = fmul float %156, %157
  %sub406 = fsub float %mul402, %mul405
  %x407 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal366, i32 0, i32 0
  store float %sub406, float* %x407, align 4
  %z408 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  %158 = load float, float* %z408, align 4
  %x409 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  %159 = load float, float* %x409, align 4
  %mul410 = fmul float %158, %159
  %x411 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  %160 = load float, float* %x411, align 4
  %z412 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  %161 = load float, float* %z412, align 4
  %mul413 = fmul float %160, %161
  %sub414 = fsub float %mul410, %mul413
  %y415 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal366, i32 0, i32 1
  store float %sub414, float* %y415, align 4
  %x416 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  %162 = load float, float* %x416, align 4
  %y417 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  %163 = load float, float* %y417, align 4
  %mul418 = fmul float %162, %163
  %y419 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  %164 = load float, float* %y419, align 4
  %x420 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  %165 = load float, float* %x420, align 4
  %mul421 = fmul float %164, %165
  %sub422 = fsub float %mul418, %mul421
  %z423 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal366, i32 0, i32 2
  store float %sub422, float* %z423, align 4
  call void @vec3Normalize(%struct.vec3* %normal366, %struct.vec3* %normal366)
  %166 = bitcast %struct.vec3* %normal366 to i8*
  call void @arrayAppend(%struct.Array* %faceNormals, i8* %166)
  br label %for.inc424

for.inc424:                                       ; preds = %for.body361
  %167 = load i32, i32* %j, align 4
  %inc425 = add i32 %167, 1
  store i32 %inc425, i32* %j, align 4
  br label %for.cond357

for.end426:                                       ; preds = %for.cond357
  br label %for.inc427

for.inc427:                                       ; preds = %for.end426
  %168 = load i32, i32* %i346, align 4
  %inc428 = add i32 %168, 1
  store i32 %inc428, i32* %i346, align 4
  br label %for.cond347

for.end429:                                       ; preds = %for.cond347
  br label %if.end430

if.end430:                                        ; preds = %for.end429, %if.end342
  %length432 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %169 = load i32, i32* %length432, align 8
  %mul433 = mul i32 %169, 4
  call void @arrayInit(%struct.Array* %meshes, i64 12, i32 %mul433)
  %length434 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %170 = load i32, i32* %length434, align 8
  call void @arrayInit(%struct.Array* %objects, i64 88, i32 %170)
  %length435 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %171 = load i32, i32* %length435, align 8
  %mul436 = mul i32 %171, 3
  call void @arrayInit(%struct.Array* %indices431, i64 4, i32 %mul436)
  %length437 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %positions, i32 0, i32 3
  %172 = load i32, i32* %length437, align 8
  %mul438 = mul i32 %172, 2
  call void @vertexHashMapInit(%struct.VertexHashMap* %vertexHashMap, i32 %mul438)
  %173 = load i8, i8* %generateNormals, align 1
  %tobool439 = trunc i8 %173 to i1
  br i1 %tobool439, label %if.then440, label %if.end466

if.then440:                                       ; preds = %if.end430
  store i32 0, i32* %maxObjectFaces, align 4
  store i32 0, i32* %i441, align 4
  br label %for.cond442

for.cond442:                                      ; preds = %for.inc457, %if.then440
  %174 = load i32, i32* %i441, align 4
  %length443 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %175 = load i32, i32* %length443, align 8
  %cmp444 = icmp ult i32 %174, %175
  br i1 %cmp444, label %for.body446, label %for.end459

for.body446:                                      ; preds = %for.cond442
  %data448 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %176 = load i8*, i8** %data448, align 8
  %elementSize449 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %177 = load i32, i32* %elementSize449, align 8
  %178 = load i32, i32* %i441, align 4
  %mul450 = mul i32 %177, %178
  %idxprom451 = zext i32 %mul450 to i64
  %arrayidx452 = getelementptr inbounds i8, i8* %176, i64 %idxprom451
  %179 = bitcast i8* %arrayidx452 to %struct.TempObject*
  store %struct.TempObject* %179, %struct.TempObject** %tempObject447, align 8
  %180 = load i32, i32* %maxObjectFaces, align 4
  %181 = load %struct.TempObject*, %struct.TempObject** %tempObject447, align 8
  %numFaces453 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %181, i32 0, i32 2
  %182 = load i32, i32* %numFaces453, align 4
  %cmp454 = icmp ugt i32 %180, %182
  br i1 %cmp454, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body446
  %183 = load i32, i32* %maxObjectFaces, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body446
  %184 = load %struct.TempObject*, %struct.TempObject** %tempObject447, align 8
  %numFaces456 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %184, i32 0, i32 2
  %185 = load i32, i32* %numFaces456, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %183, %cond.true ], [ %185, %cond.false ]
  store i32 %cond, i32* %maxObjectFaces, align 4
  br label %for.inc457

for.inc457:                                       ; preds = %cond.end
  %186 = load i32, i32* %i441, align 4
  %inc458 = add i32 %186, 1
  store i32 %inc458, i32* %i441, align 4
  br label %for.cond442

for.end459:                                       ; preds = %for.cond442
  %187 = load i32, i32* %maxObjectFaces, align 4
  %cmp460 = icmp ugt i32 %187, 32
  br i1 %cmp460, label %cond.true462, label %cond.false463

cond.true462:                                     ; preds = %for.end459
  %188 = load i32, i32* %maxObjectFaces, align 4
  br label %cond.end464

cond.false463:                                    ; preds = %for.end459
  br label %cond.end464

cond.end464:                                      ; preds = %cond.false463, %cond.true462
  %cond465 = phi i32 [ %188, %cond.true462 ], [ 32, %cond.false463 ]
  call void @normalHashMapInit(%struct.NormalHashMap* %normalHashMap, i32 %cond465, %struct.ChunkedArray* %normals)
  br label %if.end466

if.end466:                                        ; preds = %cond.end464, %if.end430
  store i32 0, i32* %i467, align 4
  br label %for.cond468

for.cond468:                                      ; preds = %for.inc638, %if.end466
  %189 = load i32, i32* %i467, align 4
  %length469 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %190 = load i32, i32* %length469, align 8
  %cmp470 = icmp ult i32 %189, %190
  br i1 %cmp470, label %for.body472, label %for.end640

for.body472:                                      ; preds = %for.cond468
  %data474 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %191 = load i8*, i8** %data474, align 8
  %elementSize475 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %192 = load i32, i32* %elementSize475, align 8
  %193 = load i32, i32* %i467, align 4
  %mul476 = mul i32 %192, %193
  %idxprom477 = zext i32 %mul476 to i64
  %arrayidx478 = getelementptr inbounds i8, i8* %191, i64 %idxprom477
  %194 = bitcast i8* %arrayidx478 to %struct.TempObject*
  store %struct.TempObject* %194, %struct.TempObject** %tempObject473, align 8
  %195 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %numFaces479 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %195, i32 0, i32 2
  %196 = load i32, i32* %numFaces479, align 4
  %tobool480 = icmp ne i32 %196, 0
  br i1 %tobool480, label %if.end482, label %if.then481

if.then481:                                       ; preds = %for.body472
  br label %for.inc638

if.end482:                                        ; preds = %for.body472
  %name484 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 0
  %arraydecay485 = getelementptr inbounds [64 x i8], [64 x i8]* %name484, i32 0, i32 0
  %197 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %name486 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %197, i32 0, i32 0
  %arraydecay487 = getelementptr inbounds [64 x i8], [64 x i8]* %name486, i32 0, i32 0
  %198 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %name488 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %198, i32 0, i32 0
  %arraydecay489 = getelementptr inbounds [64 x i8], [64 x i8]* %name488, i32 0, i32 0
  %call490 = call i64 @strLength(i8* %arraydecay489, i64 64)
  call void @strCopy(i8* %arraydecay485, i64 64, i8* %arraydecay487, i64 %call490)
  %199 = load i8, i8* %generateNormals, align 1
  %tobool491 = trunc i8 %199 to i1
  br i1 %tobool491, label %if.then492, label %if.end493

if.then492:                                       ; preds = %if.end482
  call void @normalHashMapClear(%struct.NormalHashMap* %normalHashMap)
  br label %if.end493

if.end493:                                        ; preds = %if.then492, %if.end482
  %length494 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 1
  %200 = load i32, i32* %length494, align 8
  %firstMesh = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 1
  store i32 %200, i32* %firstMesh, align 4
  %numMeshes = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 2
  store i32 0, i32* %numMeshes, align 4
  store i32 -1, i32* %material, align 4
  br label %for.cond495

for.cond495:                                      ; preds = %for.inc606, %if.end493
  %201 = load i32, i32* %material, align 4
  %length496 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %202 = load i32, i32* %length496, align 8
  %cmp497 = icmp slt i32 %201, %202
  br i1 %cmp497, label %for.body499, label %for.end608

for.body499:                                      ; preds = %for.cond495
  %length500 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %203 = load i32, i32* %length500, align 8
  %firstIndex = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 1
  store i32 %203, i32* %firstIndex, align 4
  %numIndices = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  store i32 0, i32* %numIndices, align 4
  %204 = load i32, i32* %material, align 4
  %materialIndex501 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 0
  store i32 %204, i32* %materialIndex501, align 4
  store i32 0, i32* %j502, align 4
  br label %for.cond503

for.cond503:                                      ; preds = %for.inc596, %for.body499
  %205 = load i32, i32* %j502, align 4
  %206 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %numFaces504 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %206, i32 0, i32 2
  %207 = load i32, i32* %numFaces504, align 4
  %cmp505 = icmp ult i32 %205, %207
  br i1 %cmp505, label %for.body507, label %for.end598

for.body507:                                      ; preds = %for.cond503
  %208 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %firstFace509 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %208, i32 0, i32 1
  %209 = load i32, i32* %firstFace509, align 4
  %210 = load i32, i32* %j502, align 4
  %add510 = add i32 %209, %210
  %call511 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %faces, i32 %add510)
  %211 = bitcast i8* %call511 to %struct.Face*
  store %struct.Face* %211, %struct.Face** %face508, align 8
  %212 = load %struct.Face*, %struct.Face** %face508, align 8
  %materialIndex512 = getelementptr inbounds %struct.Face, %struct.Face* %212, i32 0, i32 0
  %213 = load i16, i16* %materialIndex512, align 4
  %conv513 = sext i16 %213 to i32
  %214 = load i32, i32* %material, align 4
  %conv514 = trunc i32 %214 to i16
  %conv515 = sext i16 %conv514 to i32
  %cmp516 = icmp ne i32 %conv513, %conv515
  br i1 %cmp516, label %if.then518, label %if.end519

if.then518:                                       ; preds = %for.body507
  br label %for.inc596

if.end519:                                        ; preds = %for.body507
  store i32 -1, i32* %faceNormalIndex, align 4
  %215 = load i8, i8* %generateNormals, align 1
  %tobool520 = trunc i8 %215 to i1
  br i1 %tobool520, label %land.lhs.true522, label %if.end552

land.lhs.true522:                                 ; preds = %if.end519
  %216 = load %struct.Face*, %struct.Face** %face508, align 8
  %smoothingGroup523 = getelementptr inbounds %struct.Face, %struct.Face* %216, i32 0, i32 1
  %217 = load i16, i16* %smoothingGroup523, align 2
  %conv524 = zext i16 %217 to i32
  %cmp525 = icmp eq i32 %conv524, 0
  br i1 %cmp525, label %if.then527, label %if.end552

if.then527:                                       ; preds = %land.lhs.true522
  store i32 0, i32* %k, align 4
  br label %for.cond528

for.cond528:                                      ; preds = %for.inc549, %if.then527
  %218 = load i32, i32* %k, align 4
  %cmp529 = icmp slt i32 %218, 3
  br i1 %cmp529, label %for.body531, label %for.end551

for.body531:                                      ; preds = %for.cond528
  %219 = load %struct.Face*, %struct.Face** %face508, align 8
  %indices532 = getelementptr inbounds %struct.Face, %struct.Face* %219, i32 0, i32 2
  %220 = load i32, i32* %k, align 4
  %idxprom533 = sext i32 %220 to i64
  %arrayidx534 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices532, i64 0, i64 %idxprom533
  %vn535 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx534, i32 0, i32 2
  %221 = load i32, i32* %vn535, align 4
  %length536 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %222 = load i32, i32* %length536, align 8
  %cmp537 = icmp uge i32 %221, %222
  br i1 %cmp537, label %if.then539, label %if.end548

if.then539:                                       ; preds = %for.body531
  %data540 = getelementptr inbounds %struct.Array, %struct.Array* %faceNormals, i32 0, i32 0
  %223 = load i8*, i8** %data540, align 8
  %elementSize541 = getelementptr inbounds %struct.Array, %struct.Array* %faceNormals, i32 0, i32 3
  %224 = load i32, i32* %elementSize541, align 8
  %225 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %firstFace542 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %225, i32 0, i32 1
  %226 = load i32, i32* %firstFace542, align 4
  %227 = load i32, i32* %j502, align 4
  %add543 = add i32 %226, %227
  %mul544 = mul i32 %224, %add543
  %idxprom545 = zext i32 %mul544 to i64
  %arrayidx546 = getelementptr inbounds i8, i8* %223, i64 %idxprom545
  %228 = bitcast i8* %arrayidx546 to %struct.vec3*
  %call547 = call i32 @normalHashMapInsert(%struct.NormalHashMap* %normalHashMap, %struct.vec3* %228)
  store i32 %call547, i32* %faceNormalIndex, align 4
  br label %for.end551

if.end548:                                        ; preds = %for.body531
  br label %for.inc549

for.inc549:                                       ; preds = %if.end548
  %229 = load i32, i32* %k, align 4
  %inc550 = add nsw i32 %229, 1
  store i32 %inc550, i32* %k, align 4
  br label %for.cond528

for.end551:                                       ; preds = %if.then539, %for.cond528
  br label %if.end552

if.end552:                                        ; preds = %for.end551, %land.lhs.true522, %if.end519
  store i32 0, i32* %k553, align 4
  br label %for.cond554

for.cond554:                                      ; preds = %for.inc593, %if.end552
  %230 = load i32, i32* %k553, align 4
  %cmp555 = icmp slt i32 %230, 3
  br i1 %cmp555, label %for.body557, label %for.end595

for.body557:                                      ; preds = %for.cond554
  %231 = load %struct.Face*, %struct.Face** %face508, align 8
  %indices559 = getelementptr inbounds %struct.Face, %struct.Face* %231, i32 0, i32 2
  %232 = load i32, i32* %k553, align 4
  %idxprom560 = sext i32 %232 to i64
  %arrayidx561 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices559, i64 0, i64 %idxprom560
  store %struct.IndexTriplet* %arrayidx561, %struct.IndexTriplet** %triplet558, align 8
  %233 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %vn563 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %233, i32 0, i32 2
  %234 = load i32, i32* %vn563, align 4
  store i32 %234, i32* %vn562, align 4
  %235 = load i8, i8* %generateNormals, align 1
  %tobool564 = trunc i8 %235 to i1
  br i1 %tobool564, label %if.then565, label %if.end582

if.then565:                                       ; preds = %for.body557
  %236 = load %struct.Face*, %struct.Face** %face508, align 8
  %smoothingGroup566 = getelementptr inbounds %struct.Face, %struct.Face* %236, i32 0, i32 1
  %237 = load i16, i16* %smoothingGroup566, align 2
  %conv567 = zext i16 %237 to i32
  %cmp568 = icmp sgt i32 %conv567, 0
  br i1 %cmp568, label %if.then570, label %if.else576

if.then570:                                       ; preds = %if.then565
  %238 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %v572 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %238, i32 0, i32 0
  %239 = load i32, i32* %v572, align 4
  %240 = load %struct.Face*, %struct.Face** %face508, align 8
  %smoothingGroup573 = getelementptr inbounds %struct.Face, %struct.Face* %240, i32 0, i32 1
  %241 = load i16, i16* %smoothingGroup573, align 2
  %call574 = call { <2 x float>, float } @calculateSmoothNormal(i32 %239, %struct.ChunkedArray* %faces, %struct.Array* %faceNormals, i16 zeroext %241)
  store { <2 x float>, float } %call574, { <2 x float>, float }* %tmp, align 8
  %242 = bitcast { <2 x float>, float }* %tmp to i8*
  %243 = bitcast %struct.vec3* %normal571 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %243, i8* %242, i64 12, i32 4, i1 false)
  %call575 = call i32 @normalHashMapInsert(%struct.NormalHashMap* %normalHashMap, %struct.vec3* %normal571)
  store i32 %call575, i32* %vn562, align 4
  br label %if.end581

if.else576:                                       ; preds = %if.then565
  %244 = load i32, i32* %faceNormalIndex, align 4
  %cmp577 = icmp ne i32 %244, -1
  br i1 %cmp577, label %if.then579, label %if.end580

if.then579:                                       ; preds = %if.else576
  %245 = load i32, i32* %faceNormalIndex, align 4
  store i32 %245, i32* %vn562, align 4
  br label %if.end580

if.end580:                                        ; preds = %if.then579, %if.else576
  br label %if.end581

if.end581:                                        ; preds = %if.end580, %if.then570
  br label %if.end582

if.end582:                                        ; preds = %if.end581, %for.body557
  %246 = load i32, i32* %i467, align 4
  %247 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %v583 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %247, i32 0, i32 0
  %248 = load i32, i32* %v583, align 4
  %249 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %vt584 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %249, i32 0, i32 1
  %250 = load i32, i32* %vt584, align 4
  %251 = load i32, i32* %vn562, align 4
  %call585 = call i32 @vertexHashMapInsert(%struct.VertexHashMap* %vertexHashMap, i32 %246, i32 %248, i32 %250, i32 %251)
  store i32 %call585, i32* %index, align 4
  %252 = load i32, i32* %index, align 4
  %cmp586 = icmp ugt i32 %252, 65535
  br i1 %cmp586, label %if.then588, label %if.end590

if.then588:                                       ; preds = %if.end582
  %253 = load i32, i32* %flags, align 4
  %or589 = or i32 %253, 4
  store i32 %or589, i32* %flags, align 4
  br label %if.end590

if.end590:                                        ; preds = %if.then588, %if.end582
  %254 = bitcast i32* %index to i8*
  call void @arrayAppend(%struct.Array* %indices431, i8* %254)
  %numIndices591 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  %255 = load i32, i32* %numIndices591, align 4
  %inc592 = add i32 %255, 1
  store i32 %inc592, i32* %numIndices591, align 4
  br label %for.inc593

for.inc593:                                       ; preds = %if.end590
  %256 = load i32, i32* %k553, align 4
  %inc594 = add nsw i32 %256, 1
  store i32 %inc594, i32* %k553, align 4
  br label %for.cond554

for.end595:                                       ; preds = %for.cond554
  br label %for.inc596

for.inc596:                                       ; preds = %for.end595, %if.then518
  %257 = load i32, i32* %j502, align 4
  %inc597 = add i32 %257, 1
  store i32 %inc597, i32* %j502, align 4
  br label %for.cond503

for.end598:                                       ; preds = %for.cond503
  %numIndices599 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  %258 = load i32, i32* %numIndices599, align 4
  %cmp600 = icmp ugt i32 %258, 0
  br i1 %cmp600, label %if.then602, label %if.end605

if.then602:                                       ; preds = %for.end598
  %259 = bitcast %struct.objzMesh* %mesh to i8*
  call void @arrayAppend(%struct.Array* %meshes, i8* %259)
  %numMeshes603 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 2
  %260 = load i32, i32* %numMeshes603, align 4
  %inc604 = add i32 %260, 1
  store i32 %inc604, i32* %numMeshes603, align 4
  br label %if.end605

if.end605:                                        ; preds = %if.then602, %for.end598
  br label %for.inc606

for.inc606:                                       ; preds = %if.end605
  %261 = load i32, i32* %material, align 4
  %inc607 = add nsw i32 %261, 1
  store i32 %inc607, i32* %material, align 4
  br label %for.cond495

for.end608:                                       ; preds = %for.cond495
  %length609 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %262 = load i32, i32* %length609, align 8
  %cmp610 = icmp ugt i32 %262, 0
  br i1 %cmp610, label %if.then612, label %if.else626

if.then612:                                       ; preds = %for.end608
  %data613 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 0
  %263 = load i8*, i8** %data613, align 8
  %elementSize614 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 3
  %264 = load i32, i32* %elementSize614, align 8
  %length615 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %265 = load i32, i32* %length615, align 8
  %sub616 = sub i32 %265, 1
  %mul617 = mul i32 %264, %sub616
  %idxprom618 = zext i32 %mul617 to i64
  %arrayidx619 = getelementptr inbounds i8, i8* %263, i64 %idxprom618
  %266 = bitcast i8* %arrayidx619 to %struct.objzObject*
  store %struct.objzObject* %266, %struct.objzObject** %prev, align 8
  %267 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %firstIndex620 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %267, i32 0, i32 3
  %268 = load i32, i32* %firstIndex620, align 4
  %269 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %numIndices621 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %269, i32 0, i32 4
  %270 = load i32, i32* %numIndices621, align 4
  %add622 = add i32 %268, %270
  %firstIndex623 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 3
  store i32 %add622, i32* %firstIndex623, align 4
  %271 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %firstVertex = getelementptr inbounds %struct.objzObject, %struct.objzObject* %271, i32 0, i32 5
  %272 = load i32, i32* %firstVertex, align 4
  %273 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %numVertices = getelementptr inbounds %struct.objzObject, %struct.objzObject* %273, i32 0, i32 6
  %274 = load i32, i32* %numVertices, align 4
  %add624 = add i32 %272, %274
  %firstVertex625 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 5
  store i32 %add624, i32* %firstVertex625, align 4
  br label %if.end629

if.else626:                                       ; preds = %for.end608
  %firstIndex627 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 3
  store i32 0, i32* %firstIndex627, align 4
  %firstVertex628 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 5
  store i32 0, i32* %firstVertex628, align 4
  br label %if.end629

if.end629:                                        ; preds = %if.else626, %if.then612
  %length630 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %275 = load i32, i32* %length630, align 8
  %firstIndex631 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 3
  %276 = load i32, i32* %firstIndex631, align 4
  %sub632 = sub i32 %275, %276
  %numIndices633 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 4
  store i32 %sub632, i32* %numIndices633, align 4
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length634 = getelementptr inbounds %struct.Array, %struct.Array* %vertices, i32 0, i32 1
  %277 = load i32, i32* %length634, align 8
  %firstVertex635 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 5
  %278 = load i32, i32* %firstVertex635, align 4
  %sub636 = sub i32 %277, %278
  %numVertices637 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 6
  store i32 %sub636, i32* %numVertices637, align 4
  %279 = bitcast %struct.objzObject* %object483 to i8*
  call void @arrayAppend(%struct.Array* %objects, i8* %279)
  br label %for.inc638

for.inc638:                                       ; preds = %if.end629, %if.then481
  %280 = load i32, i32* %i467, align 4
  %inc639 = add i32 %280, 1
  store i32 %inc639, i32* %i467, align 4
  br label %for.cond468

for.end640:                                       ; preds = %for.cond468
  %281 = load i8, i8* %generateNormals, align 1
  %tobool641 = trunc i8 %281 to i1
  br i1 %tobool641, label %if.then642, label %if.end643

if.then642:                                       ; preds = %for.end640
  call void @normalHashMapDestroy(%struct.NormalHashMap* %normalHashMap)
  br label %if.end643

if.end643:                                        ; preds = %if.then642, %for.end640
  call void @arrayDestroy(%struct.Array* %tempObjects)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %faces)
  call void @arrayDestroy(%struct.Array* %faceNormals)
  %call644 = call i8* @objz_realloc(i8* null, i64 88, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1181)
  %282 = bitcast i8* %call644 to %struct.objzModel*
  store %struct.objzModel* %282, %struct.objzModel** %model, align 8
  %283 = load i32, i32* %flags, align 4
  %284 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %flags645 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %284, i32 0, i32 0
  store i32 %283, i32* %flags645, align 8
  %285 = load i32, i32* @s_indexFormat, align 4
  %cmp646 = icmp eq i32 %285, 1
  br i1 %cmp646, label %if.then650, label %lor.lhs.false648

lor.lhs.false648:                                 ; preds = %if.end643
  %286 = load i32, i32* %flags, align 4
  %and = and i32 %286, 4
  %tobool649 = icmp ne i32 %and, 0
  br i1 %tobool649, label %if.then650, label %if.else653

if.then650:                                       ; preds = %lor.lhs.false648, %if.end643
  %data651 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 0
  %287 = load i8*, i8** %data651, align 8
  %288 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %indices652 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %288, i32 0, i32 1
  store i8* %287, i8** %indices652, align 8
  br label %if.end679

if.else653:                                       ; preds = %lor.lhs.false648
  %289 = load i32, i32* %flags, align 4
  %and654 = and i32 %289, -5
  store i32 %and654, i32* %flags, align 4
  %length655 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %290 = load i32, i32* %length655, align 8
  %conv656 = zext i32 %290 to i64
  %mul657 = mul i64 2, %conv656
  %call658 = call i8* @objz_realloc(i8* null, i64 %mul657, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1187)
  %291 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %indices659 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %291, i32 0, i32 1
  store i8* %call658, i8** %indices659, align 8
  store i32 0, i32* %i660, align 4
  br label %for.cond661

for.cond661:                                      ; preds = %for.inc676, %if.else653
  %292 = load i32, i32* %i660, align 4
  %length662 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %293 = load i32, i32* %length662, align 8
  %cmp663 = icmp ult i32 %292, %293
  br i1 %cmp663, label %for.body665, label %for.end678

for.body665:                                      ; preds = %for.cond661
  %data667 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 0
  %294 = load i8*, i8** %data667, align 8
  %elementSize668 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 3
  %295 = load i32, i32* %elementSize668, align 8
  %296 = load i32, i32* %i660, align 4
  %mul669 = mul i32 %295, %296
  %idxprom670 = zext i32 %mul669 to i64
  %arrayidx671 = getelementptr inbounds i8, i8* %294, i64 %idxprom670
  %297 = bitcast i8* %arrayidx671 to i32*
  store i32* %297, i32** %index666, align 8
  %298 = load i32*, i32** %index666, align 8
  %299 = load i32, i32* %298, align 4
  %conv672 = trunc i32 %299 to i16
  %300 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %indices673 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %300, i32 0, i32 1
  %301 = load i8*, i8** %indices673, align 8
  %302 = bitcast i8* %301 to i16*
  %303 = load i32, i32* %i660, align 4
  %idxprom674 = zext i32 %303 to i64
  %arrayidx675 = getelementptr inbounds i16, i16* %302, i64 %idxprom674
  store i16 %conv672, i16* %arrayidx675, align 2
  br label %for.inc676

for.inc676:                                       ; preds = %for.body665
  %304 = load i32, i32* %i660, align 4
  %inc677 = add i32 %304, 1
  store i32 %inc677, i32* %i660, align 4
  br label %for.cond661

for.end678:                                       ; preds = %for.cond661
  call void @arrayDestroy(%struct.Array* %indices431)
  br label %if.end679

if.end679:                                        ; preds = %for.end678, %if.then650
  %length680 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %305 = load i32, i32* %length680, align 8
  %306 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numIndices681 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %306, i32 0, i32 2
  store i32 %305, i32* %numIndices681, align 8
  %data682 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 0
  %307 = load i8*, i8** %data682, align 8
  %308 = bitcast i8* %307 to %struct.objzMaterial*
  %309 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %materials683 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %309, i32 0, i32 3
  store %struct.objzMaterial* %308, %struct.objzMaterial** %materials683, align 8
  %length684 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %310 = load i32, i32* %length684, align 8
  %311 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numMaterials = getelementptr inbounds %struct.objzModel, %struct.objzModel* %311, i32 0, i32 4
  store i32 %310, i32* %numMaterials, align 8
  %data685 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 0
  %312 = load i8*, i8** %data685, align 8
  %313 = bitcast i8* %312 to %struct.objzMesh*
  %314 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %meshes686 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %314, i32 0, i32 5
  store %struct.objzMesh* %313, %struct.objzMesh** %meshes686, align 8
  %length687 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 1
  %315 = load i32, i32* %length687, align 8
  %316 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numMeshes688 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %316, i32 0, i32 6
  store i32 %315, i32* %numMeshes688, align 8
  %data689 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 0
  %317 = load i8*, i8** %data689, align 8
  %318 = bitcast i8* %317 to %struct.objzObject*
  %319 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %objects690 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %319, i32 0, i32 7
  store %struct.objzObject* %318, %struct.objzObject** %objects690, align 8
  %length691 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %320 = load i32, i32* %length691, align 8
  %321 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numObjects = getelementptr inbounds %struct.objzModel, %struct.objzModel* %321, i32 0, i32 8
  store i32 %320, i32* %numObjects, align 8
  %322 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8
  %vertices692 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length693 = getelementptr inbounds %struct.Array, %struct.Array* %vertices692, i32 0, i32 1
  %323 = load i32, i32* %length693, align 8
  %conv694 = zext i32 %323 to i64
  %mul695 = mul i64 %322, %conv694
  %call696 = call i8* @objz_realloc(i8* null, i64 %mul695, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1201)
  %324 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %vertices697 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %324, i32 0, i32 9
  store i8* %call696, i8** %vertices697, align 8
  store i32 0, i32* %i698, align 4
  br label %for.cond699

for.cond699:                                      ; preds = %for.inc761, %if.end679
  %325 = load i32, i32* %i698, align 4
  %vertices700 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length701 = getelementptr inbounds %struct.Array, %struct.Array* %vertices700, i32 0, i32 1
  %326 = load i32, i32* %length701, align 8
  %cmp702 = icmp ult i32 %325, %326
  br i1 %cmp702, label %for.body704, label %for.end763

for.body704:                                      ; preds = %for.cond699
  %327 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %vertices705 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %327, i32 0, i32 9
  %328 = load i8*, i8** %vertices705, align 8
  %329 = load i32, i32* %i698, align 4
  %conv706 = zext i32 %329 to i64
  %330 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8
  %mul707 = mul i64 %conv706, %330
  %arrayidx708 = getelementptr inbounds i8, i8* %328, i64 %mul707
  store i8* %arrayidx708, i8** %vOut, align 8
  %vertices709 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %data710 = getelementptr inbounds %struct.Array, %struct.Array* %vertices709, i32 0, i32 0
  %331 = load i8*, i8** %data710, align 8
  %vertices711 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %elementSize712 = getelementptr inbounds %struct.Array, %struct.Array* %vertices711, i32 0, i32 3
  %332 = load i32, i32* %elementSize712, align 8
  %333 = load i32, i32* %i698, align 4
  %mul713 = mul i32 %332, %333
  %idxprom714 = zext i32 %mul713 to i64
  %arrayidx715 = getelementptr inbounds i8, i8* %331, i64 %idxprom714
  %334 = bitcast i8* %arrayidx715 to %struct.HashedVertex*
  store %struct.HashedVertex* %334, %struct.HashedVertex** %vIn, align 8
  %335 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %cmp716 = icmp ne i64 %335, -1
  br i1 %cmp716, label %if.then718, label %if.end724

if.then718:                                       ; preds = %for.body704
  %336 = load i8*, i8** %vOut, align 8
  %337 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %arrayidx719 = getelementptr inbounds i8, i8* %336, i64 %337
  %338 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %pos720 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %338, i32 0, i32 1
  %339 = load i32, i32* %pos720, align 4
  %call721 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %339)
  %340 = load i8*, i8** %vOut, align 8
  %341 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %arrayidx722 = getelementptr inbounds i8, i8* %340, i64 %341
  %342 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx722, i1 false, i1 true)
  %call723 = call i8* @__memcpy_chk(i8* %arrayidx719, i8* %call721, i64 12, i64 %342) #7
  br label %if.end724

if.end724:                                        ; preds = %if.then718, %for.body704
  %343 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %cmp725 = icmp ne i64 %343, -1
  br i1 %cmp725, label %if.then727, label %if.end742

if.then727:                                       ; preds = %if.end724
  %344 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %texcoord728 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %344, i32 0, i32 2
  %345 = load i32, i32* %texcoord728, align 4
  %cmp729 = icmp eq i32 %345, -1
  br i1 %cmp729, label %if.then731, label %if.else735

if.then731:                                       ; preds = %if.then727
  %346 = load i8*, i8** %vOut, align 8
  %347 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx732 = getelementptr inbounds i8, i8* %346, i64 %347
  %348 = load i8*, i8** %vOut, align 8
  %349 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx733 = getelementptr inbounds i8, i8* %348, i64 %349
  %350 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx733, i1 false, i1 true)
  %call734 = call i8* @__memset_chk(i8* %arrayidx732, i32 0, i64 8, i64 %350) #7
  br label %if.end741

if.else735:                                       ; preds = %if.then727
  %351 = load i8*, i8** %vOut, align 8
  %352 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx736 = getelementptr inbounds i8, i8* %351, i64 %352
  %353 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %texcoord737 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %353, i32 0, i32 2
  %354 = load i32, i32* %texcoord737, align 4
  %call738 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %texcoords, i32 %354)
  %355 = load i8*, i8** %vOut, align 8
  %356 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx739 = getelementptr inbounds i8, i8* %355, i64 %356
  %357 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx739, i1 false, i1 true)
  %call740 = call i8* @__memcpy_chk(i8* %arrayidx736, i8* %call738, i64 8, i64 %357) #7
  br label %if.end741

if.end741:                                        ; preds = %if.else735, %if.then731
  br label %if.end742

if.end742:                                        ; preds = %if.end741, %if.end724
  %358 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %cmp743 = icmp ne i64 %358, -1
  br i1 %cmp743, label %if.then745, label %if.end760

if.then745:                                       ; preds = %if.end742
  %359 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %normal746 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %359, i32 0, i32 3
  %360 = load i32, i32* %normal746, align 4
  %cmp747 = icmp eq i32 %360, -1
  br i1 %cmp747, label %if.then749, label %if.else753

if.then749:                                       ; preds = %if.then745
  %361 = load i8*, i8** %vOut, align 8
  %362 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx750 = getelementptr inbounds i8, i8* %361, i64 %362
  %363 = load i8*, i8** %vOut, align 8
  %364 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx751 = getelementptr inbounds i8, i8* %363, i64 %364
  %365 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx751, i1 false, i1 true)
  %call752 = call i8* @__memset_chk(i8* %arrayidx750, i32 0, i64 12, i64 %365) #7
  br label %if.end759

if.else753:                                       ; preds = %if.then745
  %366 = load i8*, i8** %vOut, align 8
  %367 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx754 = getelementptr inbounds i8, i8* %366, i64 %367
  %368 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %normal755 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %368, i32 0, i32 3
  %369 = load i32, i32* %normal755, align 4
  %call756 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %normals, i32 %369)
  %370 = load i8*, i8** %vOut, align 8
  %371 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx757 = getelementptr inbounds i8, i8* %370, i64 %371
  %372 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx757, i1 false, i1 true)
  %call758 = call i8* @__memcpy_chk(i8* %arrayidx754, i8* %call756, i64 12, i64 %372) #7
  br label %if.end759

if.end759:                                        ; preds = %if.else753, %if.then749
  br label %if.end760

if.end760:                                        ; preds = %if.end759, %if.end742
  br label %for.inc761

for.inc761:                                       ; preds = %if.end760
  %373 = load i32, i32* %i698, align 4
  %inc762 = add i32 %373, 1
  store i32 %inc762, i32* %i698, align 4
  br label %for.cond699

for.end763:                                       ; preds = %for.cond699
  %vertices764 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length765 = getelementptr inbounds %struct.Array, %struct.Array* %vertices764, i32 0, i32 1
  %374 = load i32, i32* %length765, align 8
  %375 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numVertices766 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %375, i32 0, i32 10
  store i32 %374, i32* %numVertices766, align 8
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %positions)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %texcoords)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %normals)
  call void @vertexHashMapDestroy(%struct.VertexHashMap* %vertexHashMap)
  %376 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  store %struct.objzModel* %376, %struct.objzModel** %retval, align 8
  br label %return

error:                                            ; preds = %if.then325, %if.then313, %if.then301, %if.then265, %if.then237, %if.then220, %if.then190, %if.then130, %if.then64, %if.then41, %if.end36
  call void @fileClose(%struct.File* %file)
  call void @arrayDestroy(%struct.Array* %materialLibs)
  call void @arrayDestroy(%struct.Array* %materials)
  call void @arrayDestroy(%struct.Array* %tempObjects)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %positions)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %texcoords)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %normals)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %faces)
  call void @arrayDestroy(%struct.Array* %faceIndices)
  call void @arrayDestroy(%struct.Array* %tempFaceIndices)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end763, %if.then11, %if.then2, %if.then
  %377 = load %struct.objzModel*, %struct.objzModel** %retval, align 8
  ret %struct.objzModel* %377
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @appendError(i8* %_format, ...) #0 {
entry:
  %_format.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %buffer = alloca [1024 x i8], align 16
  %newline = alloca i8*, align 8
  store i8* %_format, i8** %_format.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %_format.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %0, %struct.__va_list_tag* %arraydecay3)
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %1 = load i8, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23, i32 0, i32 0), i8** %newline, align 8
  %2 = load i8*, i8** %newline, align 8
  call void @strConcat(i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i64 1024, i8* %2, i64 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %arraydecay6 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %call8 = call i64 @strLength(i8* %arraydecay7, i64 1024)
  call void @strConcat(i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i64 1024, i8* %arraydecay6, i64 %call8)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @arrayInit(%struct.Array* %_array, i64 %_elementSize, i32 %_initialCapacity) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  %_elementSize.addr = alloca i64, align 8
  %_initialCapacity.addr = alloca i32, align 4
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8
  store i64 %_elementSize, i64* %_elementSize.addr, align 8
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  store i8* null, i8** %data, align 8
  %1 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity = getelementptr inbounds %struct.Array, %struct.Array* %1, i32 0, i32 2
  store i32 0, i32* %capacity, align 4
  %2 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 1
  store i32 0, i32* %length, align 8
  %3 = load i64, i64* %_elementSize.addr, align 8
  %conv = trunc i64 %3 to i32
  %4 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 3
  store i32 %conv, i32* %elementSize, align 8
  %5 = load i32, i32* %_initialCapacity.addr, align 4
  %6 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %initialCapacity = getelementptr inbounds %struct.Array, %struct.Array* %6, i32 0, i32 4
  store i32 %5, i32* %initialCapacity, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @chunkedArrayInit(%struct.ChunkedArray* %_array, i64 %_elementSize, i32 %_chunkLength) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_elementSize.addr = alloca i64, align 8
  %_chunkLength.addr = alloca i32, align 4
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i64 %_elementSize, i64* %_elementSize.addr, align 8
  store i32 %_chunkLength, i32* %_chunkLength.addr, align 4
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 0
  call void @arrayInit(%struct.Array* %chunks, i64 8, i32 32)
  %1 = load i32, i32* %_chunkLength.addr, align 4
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 1
  store i32 %1, i32* %elementsPerChunk, align 8
  %3 = load i64, i64* %_elementSize.addr, align 8
  %4 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %4, i32 0, i32 2
  store i64 %3, i64* %elementSize, align 8
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 3
  store i32 0, i32* %length, align 8
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @initLexer(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  store i8* null, i8** %buf, align 8
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 2
  store i32 1, i32* %column, align 4
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 1
  store i32 0, i32* %line, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @lexerSetLine(%struct.Lexer* %_lexer, i8* %_buf) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_buf.addr = alloca i8*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store i8* %_buf, i8** %_buf.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 2
  store i32 1, i32* %column, align 4
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 1
  %2 = load i32, i32* %line, align 8
  %inc = add i32 %2, 1
  store i32 %inc, i32* %line, align 8
  %3 = load i8*, i8** %_buf.addr, align 8
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 0
  store i8* %3, i8** %buf, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @tokenize(%struct.Lexer* %_lexer, %struct.Token* %_token, i1 zeroext %includeWhitespace) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_token.addr = alloca %struct.Token*, align 8
  %includeWhitespace.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store %struct.Token* %_token, %struct.Token** %_token.addr, align 8
  %frombool = zext i1 %includeWhitespace to i8
  store i8 %frombool, i8* %includeWhitespace.addr, align 1
  store i32 0, i32* %i, align 4
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  call void @skipWhitespace(%struct.Lexer* %0)
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 1
  %2 = load i32, i32* %line, align 8
  %3 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %line1 = getelementptr inbounds %struct.Token, %struct.Token* %3, i32 0, i32 1
  store i32 %2, i32* %line1, align 4
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 2
  %5 = load i32, i32* %column, align 4
  %6 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %column2 = getelementptr inbounds %struct.Token, %struct.Token* %6, i32 0, i32 2
  store i32 %5, i32* %column2, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %7 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call = call zeroext i1 @isEol(%struct.Lexer* %7)
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %8 = load i8, i8* %includeWhitespace.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %9 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call3 = call zeroext i1 @isWhitespace(%struct.Lexer* %9)
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %for.cond
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %10 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %10, i32 0, i32 0
  %11 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %11, i64 0
  %12 = load i8, i8* %arrayidx, align 1
  %13 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text = getelementptr inbounds %struct.Token, %struct.Token* %13, i32 0, i32 0
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  %idxprom = zext i32 %14 to i64
  %arrayidx4 = getelementptr inbounds [256 x i8], [256 x i8]* %text, i64 0, i64 %idxprom
  store i8 %12, i8* %arrayidx4, align 1
  %15 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf5 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %15, i32 0, i32 0
  %16 = load i8*, i8** %buf5, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr, i8** %buf5, align 8
  %17 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column6 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %17, i32 0, i32 2
  %18 = load i32, i32* %column6, align 4
  %inc7 = add i32 %18, 1
  store i32 %inc7, i32* %column6, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then
  %19 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text8 = getelementptr inbounds %struct.Token, %struct.Token* %19, i32 0, i32 0
  %20 = load i32, i32* %i, align 4
  %idxprom9 = zext i32 %20 to i64
  %arrayidx10 = getelementptr inbounds [256 x i8], [256 x i8]* %text8, i64 0, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1
  ret void
}

declare i32 @strcasecmp(i8*, i8*) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @arrayAppend(%struct.Array* %_array, i8* %_element) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  %_element.addr = alloca i8*, align 8
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8
  store i8* %_element, i8** %_element.addr, align 8
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 3
  %3 = load i32, i32* %elementSize, align 8
  %4 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %initialCapacity = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 4
  %5 = load i32, i32* %initialCapacity, align 4
  %mul = mul i32 %3, %5
  %conv = zext i32 %mul to i64
  %call = call i8* @objz_realloc(i8* null, i64 %conv, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 187)
  %6 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data1 = getelementptr inbounds %struct.Array, %struct.Array* %6, i32 0, i32 0
  store i8* %call, i8** %data1, align 8
  %7 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %initialCapacity2 = getelementptr inbounds %struct.Array, %struct.Array* %7, i32 0, i32 4
  %8 = load i32, i32* %initialCapacity2, align 4
  %9 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity = getelementptr inbounds %struct.Array, %struct.Array* %9, i32 0, i32 2
  store i32 %8, i32* %capacity, align 4
  br label %if.end15

if.else:                                          ; preds = %entry
  %10 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length = getelementptr inbounds %struct.Array, %struct.Array* %10, i32 0, i32 1
  %11 = load i32, i32* %length, align 8
  %12 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity3 = getelementptr inbounds %struct.Array, %struct.Array* %12, i32 0, i32 2
  %13 = load i32, i32* %capacity3, align 4
  %cmp = icmp eq i32 %11, %13
  br i1 %cmp, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %14 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity6 = getelementptr inbounds %struct.Array, %struct.Array* %14, i32 0, i32 2
  %15 = load i32, i32* %capacity6, align 4
  %mul7 = mul i32 %15, 2
  store i32 %mul7, i32* %capacity6, align 4
  %16 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data8 = getelementptr inbounds %struct.Array, %struct.Array* %16, i32 0, i32 0
  %17 = load i8*, i8** %data8, align 8
  %18 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity9 = getelementptr inbounds %struct.Array, %struct.Array* %18, i32 0, i32 2
  %19 = load i32, i32* %capacity9, align 4
  %20 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize10 = getelementptr inbounds %struct.Array, %struct.Array* %20, i32 0, i32 3
  %21 = load i32, i32* %elementSize10, align 8
  %mul11 = mul i32 %19, %21
  %conv12 = zext i32 %mul11 to i64
  %call13 = call i8* @objz_realloc(i8* %17, i64 %conv12, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 191)
  %22 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data14 = getelementptr inbounds %struct.Array, %struct.Array* %22, i32 0, i32 0
  store i8* %call13, i8** %data14, align 8
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then
  %23 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data16 = getelementptr inbounds %struct.Array, %struct.Array* %23, i32 0, i32 0
  %24 = load i8*, i8** %data16, align 8
  %25 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length17 = getelementptr inbounds %struct.Array, %struct.Array* %25, i32 0, i32 1
  %26 = load i32, i32* %length17, align 8
  %27 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize18 = getelementptr inbounds %struct.Array, %struct.Array* %27, i32 0, i32 3
  %28 = load i32, i32* %elementSize18, align 8
  %mul19 = mul i32 %26, %28
  %idxprom = zext i32 %mul19 to i64
  %arrayidx = getelementptr inbounds i8, i8* %24, i64 %idxprom
  %29 = load i8*, i8** %_element.addr, align 8
  %30 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize20 = getelementptr inbounds %struct.Array, %struct.Array* %30, i32 0, i32 3
  %31 = load i32, i32* %elementSize20, align 8
  %conv21 = zext i32 %31 to i64
  %32 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data22 = getelementptr inbounds %struct.Array, %struct.Array* %32, i32 0, i32 0
  %33 = load i8*, i8** %data22, align 8
  %34 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length23 = getelementptr inbounds %struct.Array, %struct.Array* %34, i32 0, i32 1
  %35 = load i32, i32* %length23, align 8
  %36 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize24 = getelementptr inbounds %struct.Array, %struct.Array* %36, i32 0, i32 3
  %37 = load i32, i32* %elementSize24, align 8
  %mul25 = mul i32 %35, %37
  %idxprom26 = zext i32 %mul25 to i64
  %arrayidx27 = getelementptr inbounds i8, i8* %33, i64 %idxprom26
  %38 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx27, i1 false, i1 true)
  %call28 = call i8* @__memcpy_chk(i8* %arrayidx, i8* %29, i64 %conv21, i64 %38) #7
  %39 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length29 = getelementptr inbounds %struct.Array, %struct.Array* %39, i32 0, i32 1
  %40 = load i32, i32* %length29, align 8
  %inc = add i32 %40, 1
  store i32 %inc, i32* %length29, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @isEol(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  %1 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 0
  ret i1 %cmp
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @parseVertexAttribIndices(%struct.Token* %_token, i32* %_out) #0 {
entry:
  %retval = alloca i1, align 1
  %_token.addr = alloca %struct.Token*, align 8
  %_out.addr = alloca i32*, align 8
  %v = alloca i32*, align 8
  %vt = alloca i32*, align 8
  %vn = alloca i32*, align 8
  %delim = alloca i8*, align 8
  %start = alloca i8*, align 8
  %eol = alloca i8, align 1
  %end = alloca i8*, align 8
  %skipNormal = alloca i8, align 1
  store %struct.Token* %_token, %struct.Token** %_token.addr, align 8
  store i32* %_out, i32** %_out.addr, align 8
  %0 = load i32*, i32** %_out.addr, align 8
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 0
  store i32* %arrayidx, i32** %v, align 8
  %1 = load i32*, i32** %_out.addr, align 8
  %arrayidx1 = getelementptr inbounds i32, i32* %1, i64 1
  store i32* %arrayidx1, i32** %vt, align 8
  %2 = load i32*, i32** %_out.addr, align 8
  %arrayidx2 = getelementptr inbounds i32, i32* %2, i64 2
  store i32* %arrayidx2, i32** %vn, align 8
  %3 = load i32*, i32** %vn, align 8
  store i32 2147483647, i32* %3, align 4
  %4 = load i32*, i32** %vt, align 8
  store i32 2147483647, i32* %4, align 4
  %5 = load i32*, i32** %v, align 8
  store i32 2147483647, i32* %5, align 4
  %6 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text = getelementptr inbounds %struct.Token, %struct.Token* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.24, i32 0, i32 0), i8** %delim, align 8
  %7 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text3 = getelementptr inbounds %struct.Token, %struct.Token* %7, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %text3, i32 0, i32 0
  store i8* %arraydecay4, i8** %start, align 8
  store i8 0, i8* %eol, align 1
  %8 = load i8*, i8** %start, align 8
  %9 = load i8*, i8** %delim, align 8
  %call5 = call i8* @strstr(i8* %8, i8* %9)
  store i8* %call5, i8** %end, align 8
  %10 = load i8*, i8** %end, align 8
  %tobool = icmp ne i8* %10, null
  br i1 %tobool, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %11 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text7 = getelementptr inbounds %struct.Token, %struct.Token* %11, i32 0, i32 0
  %12 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text8 = getelementptr inbounds %struct.Token, %struct.Token* %12, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [256 x i8], [256 x i8]* %text8, i32 0, i32 0
  %call10 = call i64 @strLength(i8* %arraydecay9, i64 256)
  %arrayidx11 = getelementptr inbounds [256 x i8], [256 x i8]* %text7, i64 0, i64 %call10
  store i8* %arrayidx11, i8** %end, align 8
  store i8 1, i8* %eol, align 1
  br label %if.end15

if.else:                                          ; preds = %if.end
  %13 = load i8*, i8** %end, align 8
  %14 = load i8*, i8** %start, align 8
  %cmp12 = icmp eq i8* %13, %14
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.else
  store i1 false, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then6
  %15 = load i8*, i8** %end, align 8
  store i8 0, i8* %15, align 1
  %16 = load i8*, i8** %start, align 8
  %call16 = call i32 @atoi(i8* %16)
  %17 = load i32*, i32** %v, align 8
  store i32 %call16, i32* %17, align 4
  %18 = load i8, i8* %eol, align 1
  %tobool17 = trunc i8 %18 to i1
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  store i1 true, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end15
  %19 = load i8*, i8** %end, align 8
  %add.ptr = getelementptr inbounds i8, i8* %19, i64 1
  store i8* %add.ptr, i8** %start, align 8
  %20 = load i8*, i8** %start, align 8
  %21 = load i8, i8* %20, align 1
  %conv = sext i8 %21 to i32
  %cmp20 = icmp eq i32 %conv, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end19
  store i1 true, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %if.end19
  %22 = load i8*, i8** %start, align 8
  %23 = load i8*, i8** %delim, align 8
  %call24 = call i8* @strstr(i8* %22, i8* %23)
  store i8* %call24, i8** %end, align 8
  store i8 0, i8* %skipNormal, align 1
  %24 = load i8*, i8** %end, align 8
  %tobool25 = icmp ne i8* %24, null
  br i1 %tobool25, label %if.end32, label %if.then26

if.then26:                                        ; preds = %if.end23
  store i8 1, i8* %skipNormal, align 1
  %25 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text27 = getelementptr inbounds %struct.Token, %struct.Token* %25, i32 0, i32 0
  %26 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text28 = getelementptr inbounds %struct.Token, %struct.Token* %26, i32 0, i32 0
  %arraydecay29 = getelementptr inbounds [256 x i8], [256 x i8]* %text28, i32 0, i32 0
  %call30 = call i64 @strLength(i8* %arraydecay29, i64 256)
  %sub = sub i64 %call30, 1
  %arrayidx31 = getelementptr inbounds [256 x i8], [256 x i8]* %text27, i64 0, i64 %sub
  store i8* %arrayidx31, i8** %end, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then26, %if.end23
  %27 = load i8*, i8** %end, align 8
  store i8 0, i8* %27, align 1
  %28 = load i8*, i8** %start, align 8
  %29 = load i8*, i8** %end, align 8
  %cmp33 = icmp ne i8* %28, %29
  br i1 %cmp33, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end32
  %30 = load i8*, i8** %start, align 8
  %call36 = call i32 @atoi(i8* %30)
  %31 = load i32*, i32** %vt, align 8
  store i32 %call36, i32* %31, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end32
  %32 = load i8, i8* %skipNormal, align 1
  %tobool38 = trunc i8 %32 to i1
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end37
  store i1 true, i1* %retval, align 1
  br label %return

if.end40:                                         ; preds = %if.end37
  %33 = load i8*, i8** %end, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %33, i64 1
  store i8* %add.ptr41, i8** %start, align 8
  %34 = load i8*, i8** %start, align 8
  %35 = load i8, i8* %34, align 1
  %conv42 = sext i8 %35 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end40
  %36 = load i8*, i8** %start, align 8
  %call46 = call i32 @atoi(i8* %36)
  %37 = load i32*, i32** %vn, align 8
  store i32 %call46, i32* %37, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end40
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end47, %if.then39, %if.then22, %if.then18, %if.then13, %if.then
  %38 = load i1, i1* %retval, align 1
  ret i1 %38
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @fixVertexAttribIndex(i32 %_index, i32 %_n) #0 {
entry:
  %retval = alloca i32, align 4
  %_index.addr = alloca i32, align 4
  %_n.addr = alloca i32, align 4
  store i32 %_index, i32* %_index.addr, align 4
  store i32 %_n, i32* %_n.addr, align 4
  %0 = load i32, i32* %_index.addr, align 4
  %cmp = icmp eq i32 %0, 2147483647
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %_index.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load i32, i32* %_index.addr, align 4
  %3 = load i32, i32* %_n.addr, align 4
  %add = add i32 %2, %3
  store i32 %add, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i32, i32* %_index.addr, align 4
  %sub = sub nsw i32 %4, 1
  store i32 %sub, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @chunkedArrayAppend(%struct.ChunkedArray* %_array, i8* %_element) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_element.addr = alloca i8*, align 8
  %newChunk = alloca i8*, align 8
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i8* %_element, i8** %_element.addr, align 8
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 3
  %1 = load i32, i32* %length, align 8
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 0
  %length1 = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 1
  %3 = load i32, i32* %length1, align 8
  %4 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %4, i32 0, i32 1
  %5 = load i32, i32* %elementsPerChunk, align 8
  %mul = mul i32 %3, %5
  %cmp = icmp uge i32 %1, %mul
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %6, i32 0, i32 1
  %7 = load i32, i32* %elementsPerChunk2, align 8
  %conv = zext i32 %7 to i64
  %8 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %8, i32 0, i32 2
  %9 = load i64, i64* %elementSize, align 8
  %mul3 = mul i64 %conv, %9
  %call = call i8* @objz_realloc(i8* null, i64 %mul3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 225)
  store i8* %call, i8** %newChunk, align 8
  %10 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks4 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %10, i32 0, i32 0
  %11 = bitcast i8** %newChunk to i8*
  call void @arrayAppend(%struct.Array* %chunks4, i8* %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks5 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %12, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks5, i32 0, i32 0
  %13 = load i8*, i8** %data, align 8
  %14 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks6 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %14, i32 0, i32 0
  %elementSize7 = getelementptr inbounds %struct.Array, %struct.Array* %chunks6, i32 0, i32 3
  %15 = load i32, i32* %elementSize7, align 8
  %16 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length8 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %16, i32 0, i32 3
  %17 = load i32, i32* %length8, align 8
  %18 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk9 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %18, i32 0, i32 1
  %19 = load i32, i32* %elementsPerChunk9, align 8
  %div = udiv i32 %17, %19
  %mul10 = mul i32 %15, %div
  %idxprom = zext i32 %mul10 to i64
  %arrayidx = getelementptr inbounds i8, i8* %13, i64 %idxprom
  %20 = bitcast i8* %arrayidx to i8**
  store i8** %20, i8*** %chunk, align 8
  %21 = load i8**, i8*** %chunk, align 8
  %22 = load i8*, i8** %21, align 8
  %23 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize11 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %23, i32 0, i32 2
  %24 = load i64, i64* %elementSize11, align 8
  %25 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length12 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %25, i32 0, i32 3
  %26 = load i32, i32* %length12, align 8
  %27 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk13 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %27, i32 0, i32 1
  %28 = load i32, i32* %elementsPerChunk13, align 8
  %rem = urem i32 %26, %28
  %conv14 = zext i32 %rem to i64
  %mul15 = mul i64 %24, %conv14
  %arrayidx16 = getelementptr inbounds i8, i8* %22, i64 %mul15
  %29 = load i8*, i8** %_element.addr, align 8
  %30 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize17 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %30, i32 0, i32 2
  %31 = load i64, i64* %elementSize17, align 8
  %32 = load i8**, i8*** %chunk, align 8
  %33 = load i8*, i8** %32, align 8
  %34 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize18 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %34, i32 0, i32 2
  %35 = load i64, i64* %elementSize18, align 8
  %36 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length19 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %36, i32 0, i32 3
  %37 = load i32, i32* %length19, align 8
  %38 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk20 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %38, i32 0, i32 1
  %39 = load i32, i32* %elementsPerChunk20, align 8
  %rem21 = urem i32 %37, %39
  %conv22 = zext i32 %rem21 to i64
  %mul23 = mul i64 %35, %conv22
  %arrayidx24 = getelementptr inbounds i8, i8* %33, i64 %mul23
  %40 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx24, i1 false, i1 true)
  %call25 = call i8* @__memcpy_chk(i8* %arrayidx16, i8* %29, i64 %31, i64 %40) #7
  %41 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length26 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %41, i32 0, i32 3
  %42 = load i32, i32* %length26, align 8
  %inc = add i32 %42, 1
  store i32 %inc, i32* %length26, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @triangulate(%struct.Array* %_indices, %struct.ChunkedArray* %_positions, %struct.Array* %_tempIndices, %struct.ChunkedArray* %_faces, i32 %_materialIndex, i16 zeroext %_smoothingGroup) #0 {
entry:
  %_indices.addr = alloca %struct.Array*, align 8
  %_positions.addr = alloca %struct.ChunkedArray*, align 8
  %_tempIndices.addr = alloca %struct.Array*, align 8
  %_faces.addr = alloca %struct.ChunkedArray*, align 8
  %_materialIndex.addr = alloca i32, align 4
  %_smoothingGroup.addr = alloca i16, align 2
  %axes = alloca [2 x i32], align 4
  %i = alloca i32, align 4
  %indices = alloca %struct.IndexTriplet*, align 8
  %v = alloca [3 x %struct.vec3], align 16
  %j = alloca i32, align 4
  %edges = alloca [2 x %struct.vec3], align 16
  %corner = alloca %struct.vec3, align 4
  %area = alloca float, align 4
  %i116 = alloca i32, align 4
  %i0 = alloca %struct.IndexTriplet*, align 8
  %i1 = alloca %struct.IndexTriplet*, align 8
  %v0 = alloca float*, align 8
  %v1 = alloca float*, align 8
  %remainingIndices = alloca %struct.Array*, align 8
  %i161 = alloca i32, align 4
  %remainingIterations = alloca i32, align 4
  %previousRemainingIndices = alloca i32, align 4
  %guess_vert = alloca i32, align 4
  %ind = alloca [3 x %struct.IndexTriplet*], align 16
  %vx = alloca [3 x float], align 4
  %vy = alloca [3 x float], align 4
  %i191 = alloca i32, align 4
  %pos = alloca float*, align 8
  %edge0 = alloca [2 x float], align 4
  %edge1 = alloca [2 x float], align 4
  %cross = alloca float, align 4
  %overlap = alloca i8, align 1
  %otherVert = alloca i32, align 4
  %idx = alloca i32, align 4
  %ovi = alloca i32, align 4
  %tx = alloca float, align 4
  %ty = alloca float, align 4
  %face = alloca %struct.Face, align 4
  %i286 = alloca i32, align 4
  %removed_vert_index = alloca i32, align 4
  %remainingIndicesData = alloca %struct.IndexTriplet*, align 8
  %face321 = alloca %struct.Face, align 4
  %i322 = alloca i32, align 4
  store %struct.Array* %_indices, %struct.Array** %_indices.addr, align 8
  store %struct.ChunkedArray* %_positions, %struct.ChunkedArray** %_positions.addr, align 8
  store %struct.Array* %_tempIndices, %struct.Array** %_tempIndices.addr, align 8
  store %struct.ChunkedArray* %_faces, %struct.ChunkedArray** %_faces.addr, align 8
  store i32 %_materialIndex, i32* %_materialIndex.addr, align 4
  store i16 %_smoothingGroup, i16* %_smoothingGroup.addr, align 2
  %0 = bitcast [2 x i32]* %axes to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([2 x i32]* @triangulate.axes to i8*), i64 8, i32 4, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc113, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 1
  %3 = load i32, i32* %length, align 8
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end115

for.body:                                         ; preds = %for.cond
  %4 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 0
  %5 = load i8*, i8** %data, align 8
  %6 = bitcast i8* %5 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %6, %struct.IndexTriplet** %indices, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %7 = load i32, i32* %j, align 4
  %cmp2 = icmp slt i32 %7, 3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %8 = load i32, i32* %j, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 %idxprom
  %9 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %10 = load %struct.IndexTriplet*, %struct.IndexTriplet** %indices, align 8
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %j, align 4
  %add = add i32 %11, %12
  %13 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length4 = getelementptr inbounds %struct.Array, %struct.Array* %13, i32 0, i32 1
  %14 = load i32, i32* %length4, align 8
  %rem = urem i32 %add, %14
  %idxprom5 = zext i32 %rem to i64
  %arrayidx6 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %10, i64 %idxprom5
  %v7 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx6, i32 0, i32 0
  %15 = load i32, i32* %v7, align 4
  %call = call i8* @chunkedArrayElement(%struct.ChunkedArray* %9, i32 %15)
  %16 = bitcast i8* %call to %struct.vec3*
  %17 = bitcast %struct.vec3* %arrayidx to i8*
  %18 = bitcast %struct.vec3* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 12, i32 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %19 = load i32, i32* %j, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %arrayidx8 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx8, i32 0, i32 0
  %20 = load float, float* %x, align 4
  %arrayidx9 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %x10 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx9, i32 0, i32 0
  %21 = load float, float* %x10, align 16
  %sub = fsub float %20, %21
  %arrayidx11 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x12 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx11, i32 0, i32 0
  store float %sub, float* %x12, align 16
  %arrayidx13 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx13, i32 0, i32 1
  %22 = load float, float* %y, align 4
  %arrayidx14 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %y15 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx14, i32 0, i32 1
  %23 = load float, float* %y15, align 4
  %sub16 = fsub float %22, %23
  %arrayidx17 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y18 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx17, i32 0, i32 1
  store float %sub16, float* %y18, align 4
  %arrayidx19 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx19, i32 0, i32 2
  %24 = load float, float* %z, align 4
  %arrayidx20 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %z21 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx20, i32 0, i32 2
  %25 = load float, float* %z21, align 8
  %sub22 = fsub float %24, %25
  %arrayidx23 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z24 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx23, i32 0, i32 2
  store float %sub22, float* %z24, align 8
  %arrayidx25 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %x26 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx25, i32 0, i32 0
  %26 = load float, float* %x26, align 8
  %arrayidx27 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %x28 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx27, i32 0, i32 0
  %27 = load float, float* %x28, align 4
  %sub29 = fsub float %26, %27
  %arrayidx30 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x31 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx30, i32 0, i32 0
  store float %sub29, float* %x31, align 4
  %arrayidx32 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %y33 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx32, i32 0, i32 1
  %28 = load float, float* %y33, align 4
  %arrayidx34 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %y35 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx34, i32 0, i32 1
  %29 = load float, float* %y35, align 4
  %sub36 = fsub float %28, %29
  %arrayidx37 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y38 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx37, i32 0, i32 1
  store float %sub36, float* %y38, align 4
  %arrayidx39 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %z40 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx39, i32 0, i32 2
  %30 = load float, float* %z40, align 8
  %arrayidx41 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %z42 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx41, i32 0, i32 2
  %31 = load float, float* %z42, align 4
  %sub43 = fsub float %30, %31
  %arrayidx44 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z45 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx44, i32 0, i32 2
  store float %sub43, float* %z45, align 4
  %arrayidx46 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y47 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx46, i32 0, i32 1
  %32 = load float, float* %y47, align 4
  %arrayidx48 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z49 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx48, i32 0, i32 2
  %33 = load float, float* %z49, align 4
  %mul = fmul float %32, %33
  %arrayidx50 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z51 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx50, i32 0, i32 2
  %34 = load float, float* %z51, align 8
  %arrayidx52 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y53 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx52, i32 0, i32 1
  %35 = load float, float* %y53, align 4
  %mul54 = fmul float %34, %35
  %sub55 = fsub float %mul, %mul54
  %x56 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  store float %sub55, float* %x56, align 4
  %arrayidx57 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z58 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx57, i32 0, i32 2
  %36 = load float, float* %z58, align 8
  %arrayidx59 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x60 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx59, i32 0, i32 0
  %37 = load float, float* %x60, align 4
  %mul61 = fmul float %36, %37
  %arrayidx62 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x63 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx62, i32 0, i32 0
  %38 = load float, float* %x63, align 16
  %arrayidx64 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z65 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx64, i32 0, i32 2
  %39 = load float, float* %z65, align 4
  %mul66 = fmul float %38, %39
  %sub67 = fsub float %mul61, %mul66
  %y68 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  store float %sub67, float* %y68, align 4
  %arrayidx69 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x70 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx69, i32 0, i32 0
  %40 = load float, float* %x70, align 16
  %arrayidx71 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y72 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx71, i32 0, i32 1
  %41 = load float, float* %y72, align 4
  %mul73 = fmul float %40, %41
  %arrayidx74 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y75 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx74, i32 0, i32 1
  %42 = load float, float* %y75, align 4
  %arrayidx76 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x77 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx76, i32 0, i32 0
  %43 = load float, float* %x77, align 4
  %mul78 = fmul float %42, %43
  %sub79 = fsub float %mul73, %mul78
  %z80 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  store float %sub79, float* %z80, align 4
  %x81 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %44 = load float, float* %x81, align 4
  %45 = call float @llvm.fabs.f32(float %44)
  %x82 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  store float %45, float* %x82, align 4
  %y83 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %46 = load float, float* %y83, align 4
  %47 = call float @llvm.fabs.f32(float %46)
  %y84 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  store float %47, float* %y84, align 4
  %z85 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %48 = load float, float* %z85, align 4
  %49 = call float @llvm.fabs.f32(float %48)
  %z86 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  store float %49, float* %z86, align 4
  %x87 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %50 = load float, float* %x87, align 4
  %cmp88 = fcmp ogt float %50, 0x3E80000000000000
  br i1 %cmp88, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %y89 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %51 = load float, float* %y89, align 4
  %cmp90 = fcmp ogt float %51, 0x3E80000000000000
  br i1 %cmp90, label %if.then, label %lor.lhs.false91

lor.lhs.false91:                                  ; preds = %lor.lhs.false
  %z92 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %52 = load float, float* %z92, align 4
  %cmp93 = fcmp ogt float %52, 0x3E80000000000000
  br i1 %cmp93, label %if.then, label %if.end112

if.then:                                          ; preds = %lor.lhs.false91, %lor.lhs.false, %for.end
  %x94 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %53 = load float, float* %x94, align 4
  %y95 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %54 = load float, float* %y95, align 4
  %cmp96 = fcmp ogt float %53, %54
  br i1 %cmp96, label %land.lhs.true, label %if.then100

land.lhs.true:                                    ; preds = %if.then
  %x97 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %55 = load float, float* %x97, align 4
  %z98 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %56 = load float, float* %z98, align 4
  %cmp99 = fcmp ogt float %55, %56
  br i1 %cmp99, label %if.end111, label %if.then100

if.then100:                                       ; preds = %land.lhs.true, %if.then
  %arrayidx101 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  store i32 0, i32* %arrayidx101, align 4
  %z102 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %57 = load float, float* %z102, align 4
  %x103 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %58 = load float, float* %x103, align 4
  %cmp104 = fcmp ogt float %57, %58
  br i1 %cmp104, label %land.lhs.true105, label %if.end

land.lhs.true105:                                 ; preds = %if.then100
  %z106 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %59 = load float, float* %z106, align 4
  %y107 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %60 = load float, float* %y107, align 4
  %cmp108 = fcmp ogt float %59, %60
  br i1 %cmp108, label %if.then109, label %if.end

if.then109:                                       ; preds = %land.lhs.true105
  %arrayidx110 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  store i32 1, i32* %arrayidx110, align 4
  br label %if.end

if.end:                                           ; preds = %if.then109, %land.lhs.true105, %if.then100
  br label %if.end111

if.end111:                                        ; preds = %if.end, %land.lhs.true
  br label %for.end115

if.end112:                                        ; preds = %lor.lhs.false91
  br label %for.inc113

for.inc113:                                       ; preds = %if.end112
  %61 = load i32, i32* %i, align 4
  %inc114 = add i32 %61, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond

for.end115:                                       ; preds = %if.end111, %for.cond
  store float 0.000000e+00, float* %area, align 4
  store i32 0, i32* %i116, align 4
  br label %for.cond117

for.cond117:                                      ; preds = %for.inc157, %for.end115
  %62 = load i32, i32* %i116, align 4
  %63 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length118 = getelementptr inbounds %struct.Array, %struct.Array* %63, i32 0, i32 1
  %64 = load i32, i32* %length118, align 8
  %cmp119 = icmp ult i32 %62, %64
  br i1 %cmp119, label %for.body120, label %for.end159

for.body120:                                      ; preds = %for.cond117
  %65 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data121 = getelementptr inbounds %struct.Array, %struct.Array* %65, i32 0, i32 0
  %66 = load i8*, i8** %data121, align 8
  %67 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %67, i32 0, i32 3
  %68 = load i32, i32* %elementSize, align 8
  %69 = load i32, i32* %i116, align 4
  %add122 = add i32 %69, 0
  %70 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length123 = getelementptr inbounds %struct.Array, %struct.Array* %70, i32 0, i32 1
  %71 = load i32, i32* %length123, align 8
  %rem124 = urem i32 %add122, %71
  %mul125 = mul i32 %68, %rem124
  %idxprom126 = zext i32 %mul125 to i64
  %arrayidx127 = getelementptr inbounds i8, i8* %66, i64 %idxprom126
  %72 = bitcast i8* %arrayidx127 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %72, %struct.IndexTriplet** %i0, align 8
  %73 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data128 = getelementptr inbounds %struct.Array, %struct.Array* %73, i32 0, i32 0
  %74 = load i8*, i8** %data128, align 8
  %75 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %elementSize129 = getelementptr inbounds %struct.Array, %struct.Array* %75, i32 0, i32 3
  %76 = load i32, i32* %elementSize129, align 8
  %77 = load i32, i32* %i116, align 4
  %add130 = add i32 %77, 1
  %78 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length131 = getelementptr inbounds %struct.Array, %struct.Array* %78, i32 0, i32 1
  %79 = load i32, i32* %length131, align 8
  %rem132 = urem i32 %add130, %79
  %mul133 = mul i32 %76, %rem132
  %idxprom134 = zext i32 %mul133 to i64
  %arrayidx135 = getelementptr inbounds i8, i8* %74, i64 %idxprom134
  %80 = bitcast i8* %arrayidx135 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %80, %struct.IndexTriplet** %i1, align 8
  %81 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %82 = load %struct.IndexTriplet*, %struct.IndexTriplet** %i0, align 8
  %v136 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %82, i32 0, i32 0
  %83 = load i32, i32* %v136, align 4
  %call137 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %81, i32 %83)
  %84 = bitcast i8* %call137 to float*
  store float* %84, float** %v0, align 8
  %85 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %86 = load %struct.IndexTriplet*, %struct.IndexTriplet** %i1, align 8
  %v138 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %86, i32 0, i32 0
  %87 = load i32, i32* %v138, align 4
  %call139 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %85, i32 %87)
  %88 = bitcast i8* %call139 to float*
  store float* %88, float** %v1, align 8
  %89 = load float*, float** %v0, align 8
  %arrayidx140 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %90 = load i32, i32* %arrayidx140, align 4
  %idxprom141 = zext i32 %90 to i64
  %arrayidx142 = getelementptr inbounds float, float* %89, i64 %idxprom141
  %91 = load float, float* %arrayidx142, align 4
  %92 = load float*, float** %v1, align 8
  %arrayidx143 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %93 = load i32, i32* %arrayidx143, align 4
  %idxprom144 = zext i32 %93 to i64
  %arrayidx145 = getelementptr inbounds float, float* %92, i64 %idxprom144
  %94 = load float, float* %arrayidx145, align 4
  %mul146 = fmul float %91, %94
  %95 = load float*, float** %v0, align 8
  %arrayidx147 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %96 = load i32, i32* %arrayidx147, align 4
  %idxprom148 = zext i32 %96 to i64
  %arrayidx149 = getelementptr inbounds float, float* %95, i64 %idxprom148
  %97 = load float, float* %arrayidx149, align 4
  %98 = load float*, float** %v1, align 8
  %arrayidx150 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %99 = load i32, i32* %arrayidx150, align 4
  %idxprom151 = zext i32 %99 to i64
  %arrayidx152 = getelementptr inbounds float, float* %98, i64 %idxprom151
  %100 = load float, float* %arrayidx152, align 4
  %mul153 = fmul float %97, %100
  %sub154 = fsub float %mul146, %mul153
  %mul155 = fmul float %sub154, 5.000000e-01
  %101 = load float, float* %area, align 4
  %add156 = fadd float %101, %mul155
  store float %add156, float* %area, align 4
  br label %for.inc157

for.inc157:                                       ; preds = %for.body120
  %102 = load i32, i32* %i116, align 4
  %inc158 = add i32 %102, 1
  store i32 %inc158, i32* %i116, align 4
  br label %for.cond117

for.end159:                                       ; preds = %for.cond117
  %103 = load %struct.Array*, %struct.Array** %_tempIndices.addr, align 8
  store %struct.Array* %103, %struct.Array** %remainingIndices, align 8
  %104 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length160 = getelementptr inbounds %struct.Array, %struct.Array* %104, i32 0, i32 1
  store i32 0, i32* %length160, align 8
  store i32 0, i32* %i161, align 4
  br label %for.cond162

for.cond162:                                      ; preds = %for.inc171, %for.end159
  %105 = load i32, i32* %i161, align 4
  %106 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length163 = getelementptr inbounds %struct.Array, %struct.Array* %106, i32 0, i32 1
  %107 = load i32, i32* %length163, align 8
  %cmp164 = icmp ult i32 %105, %107
  br i1 %cmp164, label %for.body165, label %for.end173

for.body165:                                      ; preds = %for.cond162
  %108 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %109 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data166 = getelementptr inbounds %struct.Array, %struct.Array* %109, i32 0, i32 0
  %110 = load i8*, i8** %data166, align 8
  %111 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %elementSize167 = getelementptr inbounds %struct.Array, %struct.Array* %111, i32 0, i32 3
  %112 = load i32, i32* %elementSize167, align 8
  %113 = load i32, i32* %i161, align 4
  %mul168 = mul i32 %112, %113
  %idxprom169 = zext i32 %mul168 to i64
  %arrayidx170 = getelementptr inbounds i8, i8* %110, i64 %idxprom169
  call void @arrayAppend(%struct.Array* %108, i8* %arrayidx170)
  br label %for.inc171

for.inc171:                                       ; preds = %for.body165
  %114 = load i32, i32* %i161, align 4
  %inc172 = add i32 %114, 1
  store i32 %inc172, i32* %i161, align 4
  br label %for.cond162

for.end173:                                       ; preds = %for.cond162
  %115 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length174 = getelementptr inbounds %struct.Array, %struct.Array* %115, i32 0, i32 1
  %116 = load i32, i32* %length174, align 8
  store i32 %116, i32* %remainingIterations, align 4
  %117 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length175 = getelementptr inbounds %struct.Array, %struct.Array* %117, i32 0, i32 1
  %118 = load i32, i32* %length175, align 8
  store i32 %118, i32* %previousRemainingIndices, align 4
  store i32 0, i32* %guess_vert, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.end, %if.then283, %if.then247, %for.end173
  %119 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length176 = getelementptr inbounds %struct.Array, %struct.Array* %119, i32 0, i32 1
  %120 = load i32, i32* %length176, align 8
  %cmp177 = icmp ugt i32 %120, 3
  br i1 %cmp177, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %121 = load i32, i32* %remainingIterations, align 4
  %cmp178 = icmp ugt i32 %121, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %122 = phi i1 [ false, %while.cond ], [ %cmp178, %land.rhs ]
  br i1 %122, label %while.body, label %while.end316

while.body:                                       ; preds = %land.end
  %123 = load i32, i32* %guess_vert, align 4
  %124 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length179 = getelementptr inbounds %struct.Array, %struct.Array* %124, i32 0, i32 1
  %125 = load i32, i32* %length179, align 8
  %cmp180 = icmp uge i32 %123, %125
  br i1 %cmp180, label %if.then181, label %if.end184

if.then181:                                       ; preds = %while.body
  %126 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length182 = getelementptr inbounds %struct.Array, %struct.Array* %126, i32 0, i32 1
  %127 = load i32, i32* %length182, align 8
  %128 = load i32, i32* %guess_vert, align 4
  %sub183 = sub i32 %128, %127
  store i32 %sub183, i32* %guess_vert, align 4
  br label %if.end184

if.end184:                                        ; preds = %if.then181, %while.body
  %129 = load i32, i32* %previousRemainingIndices, align 4
  %130 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length185 = getelementptr inbounds %struct.Array, %struct.Array* %130, i32 0, i32 1
  %131 = load i32, i32* %length185, align 8
  %cmp186 = icmp ne i32 %129, %131
  br i1 %cmp186, label %if.then187, label %if.else

if.then187:                                       ; preds = %if.end184
  %132 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length188 = getelementptr inbounds %struct.Array, %struct.Array* %132, i32 0, i32 1
  %133 = load i32, i32* %length188, align 8
  store i32 %133, i32* %previousRemainingIndices, align 4
  %134 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length189 = getelementptr inbounds %struct.Array, %struct.Array* %134, i32 0, i32 1
  %135 = load i32, i32* %length189, align 8
  store i32 %135, i32* %remainingIterations, align 4
  br label %if.end190

if.else:                                          ; preds = %if.end184
  %136 = load i32, i32* %remainingIterations, align 4
  %dec = add i32 %136, -1
  store i32 %dec, i32* %remainingIterations, align 4
  br label %if.end190

if.end190:                                        ; preds = %if.else, %if.then187
  store i32 0, i32* %i191, align 4
  br label %for.cond192

for.cond192:                                      ; preds = %for.inc219, %if.end190
  %137 = load i32, i32* %i191, align 4
  %cmp193 = icmp ult i32 %137, 3
  br i1 %cmp193, label %for.body194, label %for.end221

for.body194:                                      ; preds = %for.cond192
  %138 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data195 = getelementptr inbounds %struct.Array, %struct.Array* %138, i32 0, i32 0
  %139 = load i8*, i8** %data195, align 8
  %140 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %elementSize196 = getelementptr inbounds %struct.Array, %struct.Array* %140, i32 0, i32 3
  %141 = load i32, i32* %elementSize196, align 8
  %142 = load i32, i32* %guess_vert, align 4
  %143 = load i32, i32* %i191, align 4
  %add197 = add i32 %142, %143
  %144 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length198 = getelementptr inbounds %struct.Array, %struct.Array* %144, i32 0, i32 1
  %145 = load i32, i32* %length198, align 8
  %rem199 = urem i32 %add197, %145
  %mul200 = mul i32 %141, %rem199
  %idxprom201 = zext i32 %mul200 to i64
  %arrayidx202 = getelementptr inbounds i8, i8* %139, i64 %idxprom201
  %146 = bitcast i8* %arrayidx202 to %struct.IndexTriplet*
  %147 = load i32, i32* %i191, align 4
  %idxprom203 = zext i32 %147 to i64
  %arrayidx204 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom203
  store %struct.IndexTriplet* %146, %struct.IndexTriplet** %arrayidx204, align 8
  %148 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %149 = load i32, i32* %i191, align 4
  %idxprom205 = zext i32 %149 to i64
  %arrayidx206 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom205
  %150 = load %struct.IndexTriplet*, %struct.IndexTriplet** %arrayidx206, align 8
  %v207 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %150, i32 0, i32 0
  %151 = load i32, i32* %v207, align 4
  %call208 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %148, i32 %151)
  %152 = bitcast i8* %call208 to float*
  store float* %152, float** %pos, align 8
  %153 = load float*, float** %pos, align 8
  %arrayidx209 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %154 = load i32, i32* %arrayidx209, align 4
  %idxprom210 = zext i32 %154 to i64
  %arrayidx211 = getelementptr inbounds float, float* %153, i64 %idxprom210
  %155 = load float, float* %arrayidx211, align 4
  %156 = load i32, i32* %i191, align 4
  %idxprom212 = zext i32 %156 to i64
  %arrayidx213 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 %idxprom212
  store float %155, float* %arrayidx213, align 4
  %157 = load float*, float** %pos, align 8
  %arrayidx214 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %158 = load i32, i32* %arrayidx214, align 4
  %idxprom215 = zext i32 %158 to i64
  %arrayidx216 = getelementptr inbounds float, float* %157, i64 %idxprom215
  %159 = load float, float* %arrayidx216, align 4
  %160 = load i32, i32* %i191, align 4
  %idxprom217 = zext i32 %160 to i64
  %arrayidx218 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 %idxprom217
  store float %159, float* %arrayidx218, align 4
  br label %for.inc219

for.inc219:                                       ; preds = %for.body194
  %161 = load i32, i32* %i191, align 4
  %inc220 = add i32 %161, 1
  store i32 %inc220, i32* %i191, align 4
  br label %for.cond192

for.end221:                                       ; preds = %for.cond192
  %arrayidx222 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 1
  %162 = load float, float* %arrayidx222, align 4
  %arrayidx223 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 0
  %163 = load float, float* %arrayidx223, align 4
  %sub224 = fsub float %162, %163
  %arrayidx225 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 0
  store float %sub224, float* %arrayidx225, align 4
  %arrayidx226 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 1
  %164 = load float, float* %arrayidx226, align 4
  %arrayidx227 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 0
  %165 = load float, float* %arrayidx227, align 4
  %sub228 = fsub float %164, %165
  %arrayidx229 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 1
  store float %sub228, float* %arrayidx229, align 4
  %arrayidx230 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 2
  %166 = load float, float* %arrayidx230, align 4
  %arrayidx231 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 1
  %167 = load float, float* %arrayidx231, align 4
  %sub232 = fsub float %166, %167
  %arrayidx233 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 0
  store float %sub232, float* %arrayidx233, align 4
  %arrayidx234 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 2
  %168 = load float, float* %arrayidx234, align 4
  %arrayidx235 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 1
  %169 = load float, float* %arrayidx235, align 4
  %sub236 = fsub float %168, %169
  %arrayidx237 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 1
  store float %sub236, float* %arrayidx237, align 4
  %arrayidx238 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 0
  %170 = load float, float* %arrayidx238, align 4
  %arrayidx239 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 1
  %171 = load float, float* %arrayidx239, align 4
  %mul240 = fmul float %170, %171
  %arrayidx241 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 1
  %172 = load float, float* %arrayidx241, align 4
  %arrayidx242 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 0
  %173 = load float, float* %arrayidx242, align 4
  %mul243 = fmul float %172, %173
  %sub244 = fsub float %mul240, %mul243
  store float %sub244, float* %cross, align 4
  %174 = load float, float* %cross, align 4
  %175 = load float, float* %area, align 4
  %mul245 = fmul float %174, %175
  %cmp246 = fcmp olt float %mul245, 0.000000e+00
  br i1 %cmp246, label %if.then247, label %if.end249

if.then247:                                       ; preds = %for.end221
  %176 = load i32, i32* %guess_vert, align 4
  %add248 = add i32 %176, 1
  store i32 %add248, i32* %guess_vert, align 4
  br label %while.cond

if.end249:                                        ; preds = %for.end221
  store i8 0, i8* %overlap, align 1
  store i32 3, i32* %otherVert, align 4
  br label %for.cond250

for.cond250:                                      ; preds = %for.inc279, %if.end249
  %177 = load i32, i32* %otherVert, align 4
  %178 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length251 = getelementptr inbounds %struct.Array, %struct.Array* %178, i32 0, i32 1
  %179 = load i32, i32* %length251, align 8
  %cmp252 = icmp ult i32 %177, %179
  br i1 %cmp252, label %for.body253, label %for.end281

for.body253:                                      ; preds = %for.cond250
  %180 = load i32, i32* %guess_vert, align 4
  %181 = load i32, i32* %otherVert, align 4
  %add254 = add i32 %180, %181
  %182 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length255 = getelementptr inbounds %struct.Array, %struct.Array* %182, i32 0, i32 1
  %183 = load i32, i32* %length255, align 8
  %rem256 = urem i32 %add254, %183
  store i32 %rem256, i32* %idx, align 4
  %184 = load i32, i32* %idx, align 4
  %185 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length257 = getelementptr inbounds %struct.Array, %struct.Array* %185, i32 0, i32 1
  %186 = load i32, i32* %length257, align 8
  %cmp258 = icmp uge i32 %184, %186
  br i1 %cmp258, label %if.then259, label %if.end260

if.then259:                                       ; preds = %for.body253
  br label %for.inc279

if.end260:                                        ; preds = %for.body253
  %187 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data261 = getelementptr inbounds %struct.Array, %struct.Array* %187, i32 0, i32 0
  %188 = load i8*, i8** %data261, align 8
  %189 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %elementSize262 = getelementptr inbounds %struct.Array, %struct.Array* %189, i32 0, i32 3
  %190 = load i32, i32* %elementSize262, align 8
  %191 = load i32, i32* %idx, align 4
  %mul263 = mul i32 %190, %191
  %idxprom264 = zext i32 %mul263 to i64
  %arrayidx265 = getelementptr inbounds i8, i8* %188, i64 %idxprom264
  %192 = bitcast i8* %arrayidx265 to %struct.IndexTriplet*
  %v266 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %192, i32 0, i32 0
  %193 = load i32, i32* %v266, align 4
  store i32 %193, i32* %ovi, align 4
  %194 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %195 = load i32, i32* %ovi, align 4
  %call267 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %194, i32 %195)
  %196 = bitcast i8* %call267 to float*
  %arrayidx268 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %197 = load i32, i32* %arrayidx268, align 4
  %idxprom269 = zext i32 %197 to i64
  %arrayidx270 = getelementptr inbounds float, float* %196, i64 %idxprom269
  %198 = load float, float* %arrayidx270, align 4
  store float %198, float* %tx, align 4
  %199 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %200 = load i32, i32* %ovi, align 4
  %call271 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %199, i32 %200)
  %201 = bitcast i8* %call271 to float*
  %arrayidx272 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %202 = load i32, i32* %arrayidx272, align 4
  %idxprom273 = zext i32 %202 to i64
  %arrayidx274 = getelementptr inbounds float, float* %201, i64 %idxprom273
  %203 = load float, float* %arrayidx274, align 4
  store float %203, float* %ty, align 4
  %arraydecay = getelementptr inbounds [3 x float], [3 x float]* %vx, i32 0, i32 0
  %arraydecay275 = getelementptr inbounds [3 x float], [3 x float]* %vy, i32 0, i32 0
  %204 = load float, float* %tx, align 4
  %205 = load float, float* %ty, align 4
  %call276 = call i32 @pnpoly(i32 3, float* %arraydecay, float* %arraydecay275, float %204, float %205)
  %tobool = icmp ne i32 %call276, 0
  br i1 %tobool, label %if.then277, label %if.end278

if.then277:                                       ; preds = %if.end260
  store i8 1, i8* %overlap, align 1
  br label %for.end281

if.end278:                                        ; preds = %if.end260
  br label %for.inc279

for.inc279:                                       ; preds = %if.end278, %if.then259
  %206 = load i32, i32* %otherVert, align 4
  %inc280 = add i32 %206, 1
  store i32 %inc280, i32* %otherVert, align 4
  br label %for.cond250

for.end281:                                       ; preds = %if.then277, %for.cond250
  %207 = load i8, i8* %overlap, align 1
  %tobool282 = trunc i8 %207 to i1
  br i1 %tobool282, label %if.then283, label %if.end285

if.then283:                                       ; preds = %for.end281
  %208 = load i32, i32* %guess_vert, align 4
  %add284 = add i32 %208, 1
  store i32 %add284, i32* %guess_vert, align 4
  br label %while.cond

if.end285:                                        ; preds = %for.end281
  store i32 0, i32* %i286, align 4
  br label %for.cond287

for.cond287:                                      ; preds = %for.inc295, %if.end285
  %209 = load i32, i32* %i286, align 4
  %cmp288 = icmp slt i32 %209, 3
  br i1 %cmp288, label %for.body289, label %for.end297

for.body289:                                      ; preds = %for.cond287
  %indices290 = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 2
  %210 = load i32, i32* %i286, align 4
  %idxprom291 = sext i32 %210 to i64
  %arrayidx292 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices290, i64 0, i64 %idxprom291
  %211 = load i32, i32* %i286, align 4
  %idxprom293 = sext i32 %211 to i64
  %arrayidx294 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom293
  %212 = load %struct.IndexTriplet*, %struct.IndexTriplet** %arrayidx294, align 8
  %213 = bitcast %struct.IndexTriplet* %arrayidx292 to i8*
  %214 = bitcast %struct.IndexTriplet* %212 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %213, i8* %214, i64 12, i32 4, i1 false)
  br label %for.inc295

for.inc295:                                       ; preds = %for.body289
  %215 = load i32, i32* %i286, align 4
  %inc296 = add nsw i32 %215, 1
  store i32 %inc296, i32* %i286, align 4
  br label %for.cond287

for.end297:                                       ; preds = %for.cond287
  %216 = load i32, i32* %_materialIndex.addr, align 4
  %conv = trunc i32 %216 to i16
  %materialIndex = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 0
  store i16 %conv, i16* %materialIndex, align 4
  %217 = load i16, i16* %_smoothingGroup.addr, align 2
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 1
  store i16 %217, i16* %smoothingGroup, align 2
  %218 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %219 = bitcast %struct.Face* %face to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %218, i8* %219)
  %220 = load i32, i32* %guess_vert, align 4
  %add298 = add i32 %220, 1
  %221 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length299 = getelementptr inbounds %struct.Array, %struct.Array* %221, i32 0, i32 1
  %222 = load i32, i32* %length299, align 8
  %rem300 = urem i32 %add298, %222
  store i32 %rem300, i32* %removed_vert_index, align 4
  br label %while.cond301

while.cond301:                                    ; preds = %while.body306, %for.end297
  %223 = load i32, i32* %removed_vert_index, align 4
  %add302 = add i32 %223, 1
  %224 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length303 = getelementptr inbounds %struct.Array, %struct.Array* %224, i32 0, i32 1
  %225 = load i32, i32* %length303, align 8
  %cmp304 = icmp ult i32 %add302, %225
  br i1 %cmp304, label %while.body306, label %while.end

while.body306:                                    ; preds = %while.cond301
  %226 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data307 = getelementptr inbounds %struct.Array, %struct.Array* %226, i32 0, i32 0
  %227 = load i8*, i8** %data307, align 8
  %228 = bitcast i8* %227 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %228, %struct.IndexTriplet** %remainingIndicesData, align 8
  %229 = load %struct.IndexTriplet*, %struct.IndexTriplet** %remainingIndicesData, align 8
  %230 = load i32, i32* %removed_vert_index, align 4
  %idxprom308 = zext i32 %230 to i64
  %arrayidx309 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %229, i64 %idxprom308
  %231 = load %struct.IndexTriplet*, %struct.IndexTriplet** %remainingIndicesData, align 8
  %232 = load i32, i32* %removed_vert_index, align 4
  %add310 = add i32 %232, 1
  %idxprom311 = zext i32 %add310 to i64
  %arrayidx312 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %231, i64 %idxprom311
  %233 = bitcast %struct.IndexTriplet* %arrayidx309 to i8*
  %234 = bitcast %struct.IndexTriplet* %arrayidx312 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %233, i8* %234, i64 12, i32 4, i1 false)
  %235 = load i32, i32* %removed_vert_index, align 4
  %add313 = add i32 %235, 1
  store i32 %add313, i32* %removed_vert_index, align 4
  br label %while.cond301

while.end:                                        ; preds = %while.cond301
  %236 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length314 = getelementptr inbounds %struct.Array, %struct.Array* %236, i32 0, i32 1
  %237 = load i32, i32* %length314, align 8
  %dec315 = add i32 %237, -1
  store i32 %dec315, i32* %length314, align 8
  br label %while.cond

while.end316:                                     ; preds = %land.end
  %238 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length317 = getelementptr inbounds %struct.Array, %struct.Array* %238, i32 0, i32 1
  %239 = load i32, i32* %length317, align 8
  %cmp318 = icmp eq i32 %239, 3
  br i1 %cmp318, label %if.then320, label %if.end341

if.then320:                                       ; preds = %while.end316
  store i32 0, i32* %i322, align 4
  br label %for.cond323

for.cond323:                                      ; preds = %for.inc335, %if.then320
  %240 = load i32, i32* %i322, align 4
  %cmp324 = icmp slt i32 %240, 3
  br i1 %cmp324, label %for.body326, label %for.end337

for.body326:                                      ; preds = %for.cond323
  %indices327 = getelementptr inbounds %struct.Face, %struct.Face* %face321, i32 0, i32 2
  %241 = load i32, i32* %i322, align 4
  %idxprom328 = sext i32 %241 to i64
  %arrayidx329 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices327, i64 0, i64 %idxprom328
  %242 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data330 = getelementptr inbounds %struct.Array, %struct.Array* %242, i32 0, i32 0
  %243 = load i8*, i8** %data330, align 8
  %244 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %elementSize331 = getelementptr inbounds %struct.Array, %struct.Array* %244, i32 0, i32 3
  %245 = load i32, i32* %elementSize331, align 8
  %246 = load i32, i32* %i322, align 4
  %mul332 = mul i32 %245, %246
  %idxprom333 = zext i32 %mul332 to i64
  %arrayidx334 = getelementptr inbounds i8, i8* %243, i64 %idxprom333
  %247 = bitcast i8* %arrayidx334 to %struct.IndexTriplet*
  %248 = bitcast %struct.IndexTriplet* %arrayidx329 to i8*
  %249 = bitcast %struct.IndexTriplet* %247 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %248, i8* %249, i64 12, i32 4, i1 false)
  br label %for.inc335

for.inc335:                                       ; preds = %for.body326
  %250 = load i32, i32* %i322, align 4
  %inc336 = add nsw i32 %250, 1
  store i32 %inc336, i32* %i322, align 4
  br label %for.cond323

for.end337:                                       ; preds = %for.cond323
  %251 = load i32, i32* %_materialIndex.addr, align 4
  %conv338 = trunc i32 %251 to i16
  %materialIndex339 = getelementptr inbounds %struct.Face, %struct.Face* %face321, i32 0, i32 0
  store i16 %conv338, i16* %materialIndex339, align 4
  %252 = load i16, i16* %_smoothingGroup.addr, align 2
  %smoothingGroup340 = getelementptr inbounds %struct.Face, %struct.Face* %face321, i32 0, i32 1
  store i16 %252, i16* %smoothingGroup340, align 2
  %253 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %254 = bitcast %struct.Face* %face321 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %253, i8* %254)
  br label %if.end341

if.end341:                                        ; preds = %for.end337, %while.end316
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @strCopy(i8* %_dest, i64 %_destSize, i8* %_src, i64 %_count) #0 {
entry:
  %_dest.addr = alloca i8*, align 8
  %_destSize.addr = alloca i64, align 8
  %_src.addr = alloca i8*, align 8
  %_count.addr = alloca i64, align 8
  %n = alloca i64, align 8
  store i8* %_dest, i8** %_dest.addr, align 8
  store i64 %_destSize, i64* %_destSize.addr, align 8
  store i8* %_src, i8** %_src.addr, align 8
  store i64 %_count, i64* %_count.addr, align 8
  %0 = load i64, i64* %_destSize.addr, align 8
  %sub = sub i64 %0, 1
  %1 = load i8*, i8** %_src.addr, align 8
  %2 = load i64, i64* %_count.addr, align 8
  %call = call i64 @strLength(i8* %1, i64 %2)
  %cmp = icmp ult i64 %sub, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i64, i64* %_destSize.addr, align 8
  %sub1 = sub i64 %3, 1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i8*, i8** %_src.addr, align 8
  %5 = load i64, i64* %_count.addr, align 8
  %call2 = call i64 @strLength(i8* %4, i64 %5)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub1, %cond.true ], [ %call2, %cond.false ]
  store i64 %cond, i64* %n, align 8
  %6 = load i8*, i8** %_dest.addr, align 8
  %7 = load i8*, i8** %_src.addr, align 8
  %8 = load i64, i64* %n, align 8
  %9 = load i8*, i8** %_dest.addr, align 8
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call3 = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 %8, i64 %10) #7
  %11 = load i8*, i8** %_dest.addr, align 8
  %12 = load i64, i64* %n, align 8
  %arrayidx = getelementptr inbounds i8, i8* %11, i64 %12
  store i8 0, i8* %arrayidx, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @strLength(i8* %_str, i64 %_size) #0 {
entry:
  %_str.addr = alloca i8*, align 8
  %_size.addr = alloca i64, align 8
  %c = alloca i8*, align 8
  %len = alloca i64, align 8
  store i8* %_str, i8** %_str.addr, align 8
  store i64 %_size, i64* %_size.addr, align 8
  %0 = load i8*, i8** %_str.addr, align 8
  store i8* %0, i8** %c, align 8
  store i64 0, i64* %len, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i8*, i8** %c, align 8
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %3 = load i64, i64* %len, align 8
  %4 = load i64, i64* %_size.addr, align 8
  %cmp2 = icmp ult i64 %3, %4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %5 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %5, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %6 = load i8*, i8** %c, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %6, i32 1
  store i8* %incdec.ptr, i8** %c, align 8
  %7 = load i64, i64* %len, align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* %len, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %8 = load i64, i64* %len, align 8
  ret i64 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @strConcat(i8* %_dest, i64 %_destSize, i8* %_src, i64 %_count) #0 {
entry:
  %_dest.addr = alloca i8*, align 8
  %_destSize.addr = alloca i64, align 8
  %_src.addr = alloca i8*, align 8
  %_count.addr = alloca i64, align 8
  %start = alloca i64, align 8
  store i8* %_dest, i8** %_dest.addr, align 8
  store i64 %_destSize, i64* %_destSize.addr, align 8
  store i8* %_src, i8** %_src.addr, align 8
  store i64 %_count, i64* %_count.addr, align 8
  %0 = load i8*, i8** %_dest.addr, align 8
  %1 = load i64, i64* %_destSize.addr, align 8
  %call = call i64 @strLength(i8* %0, i64 %1)
  store i64 %call, i64* %start, align 8
  %2 = load i8*, i8** %_dest.addr, align 8
  %3 = load i64, i64* %start, align 8
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 %3
  %4 = load i64, i64* %_destSize.addr, align 8
  %5 = load i64, i64* %start, align 8
  %sub = sub i64 %4, %5
  %6 = load i8*, i8** %_src.addr, align 8
  %7 = load i64, i64* %_count.addr, align 8
  call void @strCopy(i8* %arrayidx, i64 %sub, i8* %6, i64 %7)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @loadMaterialFile(i8* %_objFilename, i8* %_materialName, %struct.Array* %_materials) #0 {
entry:
  %retval = alloca i1, align 1
  %_objFilename.addr = alloca i8*, align 8
  %_materialName.addr = alloca i8*, align 8
  %_materials.addr = alloca %struct.Array*, align 8
  %filename = alloca [256 x i8], align 16
  %lastSlash = alloca i8*, align 8
  %i = alloca i32, align 4
  %file = alloca %struct.File, align 8
  %bom32 = alloca i32*, align 8
  %bom16 = alloca i16*, align 8
  %lexer = alloca %struct.Lexer, align 8
  %token = alloca %struct.Token, align 4
  %mat = alloca %struct.objzMaterial, align 4
  %result = alloca i8, align 1
  %line = alloca i8*, align 8
  %i66 = alloca i64, align 8
  %prop = alloca %struct.MaterialProperty*, align 8
  %dest = alloca i8*, align 8
  %argToken = alloca %struct.Token, align 4
  %j = alloca i32, align 4
  %match = alloca i8, align 1
  %k = alloca i64, align 8
  %arg = alloca %struct.MaterialMapArg*, align 8
  store i8* %_objFilename, i8** %_objFilename.addr, align 8
  store i8* %_materialName, i8** %_materialName.addr, align 8
  store %struct.Array* %_materials, %struct.Array** %_materials.addr, align 8
  %0 = bitcast [256 x i8]* %filename to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 256, i32 16, i1 false)
  %1 = load i8*, i8** %_objFilename.addr, align 8
  %call = call i8* @strrchr(i8* %1, i32 47)
  store i8* %call, i8** %lastSlash, align 8
  %2 = load i8*, i8** %lastSlash, align 8
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %_objFilename.addr, align 8
  %call1 = call i8* @strrchr(i8* %3, i32 92)
  store i8* %call1, i8** %lastSlash, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8*, i8** %lastSlash, align 8
  %tobool2 = icmp ne i8* %4, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %5 = load i8*, i8** %_objFilename.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1
  %8 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i64 0, i64 %idxprom4
  store i8 %7, i8* %arrayidx5, align 1
  %9 = load i8*, i8** %_objFilename.addr, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr inbounds i8, i8* %9, i64 %idxprom6
  %11 = load i8*, i8** %lastSlash, align 8
  %cmp = icmp eq i8* %arrayidx7, %11
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.cond
  br label %for.end

if.end9:                                          ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %12 = load i32, i32* %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then8
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %13 = load i8*, i8** %_materialName.addr, align 8
  %14 = load i8*, i8** %_materialName.addr, align 8
  %call10 = call i64 @strLength(i8* %14, i64 256)
  call void @strConcat(i8* %arraydecay, i64 256, i8* %13, i64 %call10)
  br label %if.end13

if.else:                                          ; preds = %if.end
  %arraydecay11 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %15 = load i8*, i8** %_materialName.addr, align 8
  %16 = load i8*, i8** %_materialName.addr, align 8
  %call12 = call i64 @strLength(i8* %16, i64 256)
  call void @strCopy(i8* %arraydecay11, i64 256, i8* %15, i64 %call12)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %for.end
  %arraydecay14 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %call15 = call zeroext i1 @fileOpen(%struct.File* %file, i8* %arraydecay14)
  br i1 %call15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end13
  %arraydecay17 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.25, i32 0, i32 0), i8* %arraydecay17)
  store i1 true, i1* %retval, align 1
  br label %return

if.end18:                                         ; preds = %if.end13
  %buffer = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %17 = load i8*, i8** %buffer, align 8
  %18 = bitcast i8* %17 to i32*
  store i32* %18, i32** %bom32, align 8
  %19 = load i32*, i32** %bom32, align 8
  %20 = load i32, i32* %19, align 4
  %cmp19 = icmp eq i32 %20, 65279
  br i1 %cmp19, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %21 = load i32*, i32** %bom32, align 8
  %22 = load i32, i32* %21, align 4
  %cmp20 = icmp eq i32 %22, -131072
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %lor.lhs.false, %if.end18
  %arraydecay22 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i8* %arraydecay22)
  store i1 false, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %lor.lhs.false
  %buffer24 = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %23 = load i8*, i8** %buffer24, align 8
  %24 = bitcast i8* %23 to i16*
  store i16* %24, i16** %bom16, align 8
  %25 = load i16*, i16** %bom16, align 8
  %26 = load i16, i16* %25, align 2
  %conv = zext i16 %26 to i32
  %cmp25 = icmp eq i32 %conv, 65534
  br i1 %cmp25, label %if.then31, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %if.end23
  %27 = load i16*, i16** %bom16, align 8
  %28 = load i16, i16* %27, align 2
  %conv28 = zext i16 %28 to i32
  %cmp29 = icmp eq i32 %conv28, 65279
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %lor.lhs.false27, %if.end23
  %arraydecay32 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i8* %arraydecay32)
  store i1 false, i1* %retval, align 1
  br label %return

if.end33:                                         ; preds = %lor.lhs.false27
  call void @initLexer(%struct.Lexer* %lexer)
  call void @materialInit(%struct.objzMaterial* %mat)
  store i8 0, i8* %result, align 1
  br label %for.cond34

for.cond34:                                       ; preds = %if.end140, %if.end33
  %call35 = call i8* @fileReadLine(%struct.File* %file)
  store i8* %call35, i8** %line, align 8
  %29 = load i8*, i8** %line, align 8
  %tobool36 = icmp ne i8* %29, null
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %for.cond34
  br label %for.end141

if.end38:                                         ; preds = %for.cond34
  %30 = load i8*, i8** %line, align 8
  call void @lexerSetLine(%struct.Lexer* %lexer, i8* %30)
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay39 = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call40 = call i32 @strcasecmp(i8* %arraydecay39, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %cmp41 = icmp eq i32 %call40, 0
  br i1 %cmp41, label %if.then43, label %if.else65

if.then43:                                        ; preds = %if.end38
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text44 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [256 x i8], [256 x i8]* %text44, i64 0, i64 0
  %31 = load i8, i8* %arrayidx45, align 4
  %conv46 = sext i8 %31 to i32
  %cmp47 = icmp eq i32 %conv46, 0
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.then43
  %line50 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %32 = load i32, i32* %line50, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %33 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.27, i32 0, i32 0), i32 %32, i32 %33)
  br label %cleanup

if.end51:                                         ; preds = %if.then43
  %name = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arrayidx52 = getelementptr inbounds [64 x i8], [64 x i8]* %name, i64 0, i64 0
  %34 = load i8, i8* %arrayidx52, align 4
  %conv53 = sext i8 %34 to i32
  %cmp54 = icmp ne i32 %conv53, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end51
  %35 = load %struct.Array*, %struct.Array** %_materials.addr, align 8
  %36 = bitcast %struct.objzMaterial* %mat to i8*
  call void @arrayAppend(%struct.Array* %35, i8* %36)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end51
  call void @materialInit(%struct.objzMaterial* %mat)
  %name58 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arraydecay59 = getelementptr inbounds [64 x i8], [64 x i8]* %name58, i32 0, i32 0
  %text60 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay61 = getelementptr inbounds [256 x i8], [256 x i8]* %text60, i32 0, i32 0
  %text62 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [256 x i8], [256 x i8]* %text62, i32 0, i32 0
  %call64 = call i64 @strLength(i8* %arraydecay63, i64 256)
  call void @strCopy(i8* %arraydecay59, i64 64, i8* %arraydecay61, i64 %call64)
  br label %if.end140

if.else65:                                        ; preds = %if.end38
  store i64 0, i64* %i66, align 8
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc137, %if.else65
  %37 = load i64, i64* %i66, align 8
  %cmp68 = icmp ult i64 %37, 14
  br i1 %cmp68, label %for.body, label %for.end139

for.body:                                         ; preds = %for.cond67
  %38 = load i64, i64* %i66, align 8
  %arrayidx70 = getelementptr inbounds [14 x %struct.MaterialProperty], [14 x %struct.MaterialProperty]* @s_materialProperties, i64 0, i64 %38
  store %struct.MaterialProperty* %arrayidx70, %struct.MaterialProperty** %prop, align 8
  %39 = bitcast %struct.objzMaterial* %mat to i8*
  %40 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %offset = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %40, i32 0, i32 2
  %41 = load i64, i64* %offset, align 8
  %arrayidx71 = getelementptr inbounds i8, i8* %39, i64 %41
  store i8* %arrayidx71, i8** %dest, align 8
  %text72 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay73 = getelementptr inbounds [256 x i8], [256 x i8]* %text72, i32 0, i32 0
  %42 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %name74 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %42, i32 0, i32 0
  %43 = load i8*, i8** %name74, align 8
  %call75 = call i32 @strcasecmp(i8* %arraydecay73, i8* %43)
  %cmp76 = icmp eq i32 %call75, 0
  br i1 %cmp76, label %if.then78, label %if.end136

if.then78:                                        ; preds = %for.body
  %44 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %type = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %44, i32 0, i32 1
  %45 = load i32, i32* %type, align 8
  %cmp79 = icmp eq i32 %45, 0
  br i1 %cmp79, label %if.then81, label %if.else125

if.then81:                                        ; preds = %if.then78
  store i32 0, i32* %j, align 4
  br label %for.cond82

for.cond82:                                       ; preds = %for.inc122, %if.then81
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %argToken, i1 zeroext false)
  %text83 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arrayidx84 = getelementptr inbounds [256 x i8], [256 x i8]* %text83, i64 0, i64 0
  %46 = load i8, i8* %arrayidx84, align 4
  %conv85 = sext i8 %46 to i32
  %cmp86 = icmp eq i32 %conv85, 0
  br i1 %cmp86, label %if.then88, label %if.end96

if.then88:                                        ; preds = %for.cond82
  %47 = load i32, i32* %j, align 4
  %cmp89 = icmp eq i32 %47, 0
  br i1 %cmp89, label %if.then91, label %if.end95

if.then91:                                        ; preds = %if.then88
  %line92 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %48 = load i32, i32* %line92, align 4
  %column93 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %49 = load i32, i32* %column93, align 4
  %50 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %name94 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %50, i32 0, i32 0
  %51 = load i8*, i8** %name94, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28, i32 0, i32 0), i32 %48, i32 %49, i8* %51)
  br label %cleanup

if.end95:                                         ; preds = %if.then88
  br label %for.end124

if.end96:                                         ; preds = %for.cond82
  store i8 0, i8* %match, align 1
  store i64 0, i64* %k, align 8
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc111, %if.end96
  %52 = load i64, i64* %k, align 8
  %cmp98 = icmp ult i64 %52, 12
  br i1 %cmp98, label %for.body100, label %for.end113

for.body100:                                      ; preds = %for.cond97
  %53 = load i64, i64* %k, align 8
  %arrayidx101 = getelementptr inbounds [12 x %struct.MaterialMapArg], [12 x %struct.MaterialMapArg]* @s_materialMapArgs, i64 0, i64 %53
  store %struct.MaterialMapArg* %arrayidx101, %struct.MaterialMapArg** %arg, align 8
  %text102 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay103 = getelementptr inbounds [256 x i8], [256 x i8]* %text102, i32 0, i32 0
  %54 = load %struct.MaterialMapArg*, %struct.MaterialMapArg** %arg, align 8
  %name104 = getelementptr inbounds %struct.MaterialMapArg, %struct.MaterialMapArg* %54, i32 0, i32 0
  %55 = load i8*, i8** %name104, align 8
  %call105 = call i32 @strcasecmp(i8* %arraydecay103, i8* %55)
  %cmp106 = icmp eq i32 %call105, 0
  br i1 %cmp106, label %if.then108, label %if.end110

if.then108:                                       ; preds = %for.body100
  store i8 1, i8* %match, align 1
  %56 = load %struct.MaterialMapArg*, %struct.MaterialMapArg** %arg, align 8
  %n = getelementptr inbounds %struct.MaterialMapArg, %struct.MaterialMapArg* %56, i32 0, i32 1
  %57 = load i32, i32* %n, align 8
  %call109 = call zeroext i1 @skipTokens(%struct.Lexer* %lexer, i32 %57)
  br label %for.end113

if.end110:                                        ; preds = %for.body100
  br label %for.inc111

for.inc111:                                       ; preds = %if.end110
  %58 = load i64, i64* %k, align 8
  %inc112 = add i64 %58, 1
  store i64 %inc112, i64* %k, align 8
  br label %for.cond97

for.end113:                                       ; preds = %if.then108, %for.cond97
  %59 = load i8, i8* %match, align 1
  %tobool114 = trunc i8 %59 to i1
  br i1 %tobool114, label %if.end121, label %if.then115

if.then115:                                       ; preds = %for.end113
  %60 = load i8*, i8** %dest, align 8
  %text116 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay117 = getelementptr inbounds [256 x i8], [256 x i8]* %text116, i32 0, i32 0
  %text118 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay119 = getelementptr inbounds [256 x i8], [256 x i8]* %text118, i32 0, i32 0
  %call120 = call i64 @strLength(i8* %arraydecay119, i64 256)
  call void @strCopy(i8* %60, i64 64, i8* %arraydecay117, i64 %call120)
  br label %if.end121

if.end121:                                        ; preds = %if.then115, %for.end113
  br label %for.inc122

for.inc122:                                       ; preds = %if.end121
  %61 = load i32, i32* %j, align 4
  %inc123 = add nsw i32 %61, 1
  store i32 %inc123, i32* %j, align 4
  br label %for.cond82

for.end124:                                       ; preds = %if.end95
  br label %if.end135

if.else125:                                       ; preds = %if.then78
  %62 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %type126 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %62, i32 0, i32 1
  %63 = load i32, i32* %type126, align 8
  %cmp127 = icmp eq i32 %63, 1
  br i1 %cmp127, label %if.then129, label %if.end134

if.then129:                                       ; preds = %if.else125
  %64 = load i8*, i8** %dest, align 8
  %65 = bitcast i8* %64 to float*
  %66 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %n130 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %66, i32 0, i32 3
  %67 = load i32, i32* %n130, align 8
  %call131 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %65, i32 %67)
  br i1 %call131, label %if.end133, label %if.then132

if.then132:                                       ; preds = %if.then129
  br label %cleanup

if.end133:                                        ; preds = %if.then129
  br label %if.end134

if.end134:                                        ; preds = %if.end133, %if.else125
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %for.end124
  br label %for.end139

if.end136:                                        ; preds = %for.body
  br label %for.inc137

for.inc137:                                       ; preds = %if.end136
  %68 = load i64, i64* %i66, align 8
  %inc138 = add i64 %68, 1
  store i64 %inc138, i64* %i66, align 8
  br label %for.cond67

for.end139:                                       ; preds = %if.end135, %for.cond67
  br label %if.end140

if.end140:                                        ; preds = %for.end139, %if.end57
  br label %for.cond34

for.end141:                                       ; preds = %if.then37
  %name142 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arrayidx143 = getelementptr inbounds [64 x i8], [64 x i8]* %name142, i64 0, i64 0
  %69 = load i8, i8* %arrayidx143, align 4
  %conv144 = sext i8 %69 to i32
  %cmp145 = icmp ne i32 %conv144, 0
  br i1 %cmp145, label %if.then147, label %if.end148

if.then147:                                       ; preds = %for.end141
  %70 = load %struct.Array*, %struct.Array** %_materials.addr, align 8
  %71 = bitcast %struct.objzMaterial* %mat to i8*
  call void @arrayAppend(%struct.Array* %70, i8* %71)
  br label %if.end148

if.end148:                                        ; preds = %if.then147, %for.end141
  store i8 1, i8* %result, align 1
  br label %cleanup

cleanup:                                          ; preds = %if.end148, %if.then132, %if.then91, %if.then49
  call void @fileClose(%struct.File* %file)
  %72 = load i8, i8* %result, align 1
  %tobool149 = trunc i8 %72 to i1
  store i1 %tobool149, i1* %retval, align 1
  br label %return

return:                                           ; preds = %cleanup, %if.then31, %if.then21, %if.then16
  %73 = load i1, i1* %retval, align 1
  ret i1 %73
}

declare i32 @atoi(i8*) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @parseFloats(%struct.Lexer* %_lexer, float* %_result, i32 %n) #0 {
entry:
  %retval = alloca i1, align 1
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_result.addr = alloca float*, align 8
  %n.addr = alloca i32, align 4
  %token = alloca %struct.Token, align 4
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store float* %_result, float** %_result.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  call void @tokenize(%struct.Lexer* %2, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %line = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %3 = load i32, i32* %line, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %4 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56, i32 0, i32 0), i32 %3, i32 %4)
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  %text2 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %text2, i32 0, i32 0
  %call4 = call double @atof(i8* %arraydecay3)
  %conv = fptrunc double %call4 to float
  %5 = load float*, float** %_result.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds float, float* %5, i64 %idxprom
  store float %conv, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %8 = load i1, i1* %retval, align 1
  ret i1 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @arrayDestroy(%struct.Array* %_array) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8
  %call = call i8* @objz_realloc(i8* %1, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 182)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @chunkedArrayElement(%struct.ChunkedArray* %_array, i32 %_index) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_index.addr = alloca i32, align 4
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i32 %_index, i32* %_index.addr, align 4
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks1 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 0
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %chunks1, i32 0, i32 3
  %3 = load i32, i32* %elementSize, align 8
  %4 = load i32, i32* %_index.addr, align 4
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 1
  %6 = load i32, i32* %elementsPerChunk, align 8
  %div = udiv i32 %4, %6
  %mul = mul i32 %3, %div
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %idxprom
  %7 = bitcast i8* %arrayidx to i8**
  store i8** %7, i8*** %chunk, align 8
  %8 = load i8**, i8*** %chunk, align 8
  %9 = load i8*, i8** %8, align 8
  %10 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %10, i32 0, i32 2
  %11 = load i64, i64* %elementSize2, align 8
  %12 = load i32, i32* %_index.addr, align 4
  %13 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk3 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %13, i32 0, i32 1
  %14 = load i32, i32* %elementsPerChunk3, align 8
  %rem = urem i32 %12, %14
  %conv = zext i32 %rem to i64
  %mul4 = mul i64 %11, %conv
  %arrayidx5 = getelementptr inbounds i8, i8* %9, i64 %mul4
  ret i8* %arrayidx5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @vec3Normalize(%struct.vec3* %_out, %struct.vec3* %_in) #0 {
entry:
  %_out.addr = alloca %struct.vec3*, align 8
  %_in.addr = alloca %struct.vec3*, align 8
  %len = alloca float, align 4
  store %struct.vec3* %_out, %struct.vec3** %_out.addr, align 8
  store %struct.vec3* %_in, %struct.vec3** %_in.addr, align 8
  %0 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %0, i32 0, i32 0
  %1 = load float, float* %x, align 4
  %2 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x1 = getelementptr inbounds %struct.vec3, %struct.vec3* %2, i32 0, i32 0
  %3 = load float, float* %x1, align 4
  %mul = fmul float %1, %3
  %4 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %4, i32 0, i32 1
  %5 = load float, float* %y, align 4
  %6 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y2 = getelementptr inbounds %struct.vec3, %struct.vec3* %6, i32 0, i32 1
  %7 = load float, float* %y2, align 4
  %mul3 = fmul float %5, %7
  %add = fadd float %mul, %mul3
  %8 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %8, i32 0, i32 2
  %9 = load float, float* %z, align 4
  %10 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z4 = getelementptr inbounds %struct.vec3, %struct.vec3* %10, i32 0, i32 2
  %11 = load float, float* %z4, align 4
  %mul5 = fmul float %9, %11
  %add6 = fadd float %add, %mul5
  store float %add6, float* %len, align 4
  %12 = load float, float* %len, align 4
  %cmp = fcmp ogt float %12, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %13 = load float, float* %len, align 4
  %14 = call float @llvm.sqrt.f32(float %13)
  %div = fdiv float 1.000000e+00, %14
  store float %div, float* %len, align 4
  %15 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x7 = getelementptr inbounds %struct.vec3, %struct.vec3* %15, i32 0, i32 0
  %16 = load float, float* %x7, align 4
  %17 = load float, float* %len, align 4
  %mul8 = fmul float %16, %17
  %18 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %x9 = getelementptr inbounds %struct.vec3, %struct.vec3* %18, i32 0, i32 0
  store float %mul8, float* %x9, align 4
  %19 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y10 = getelementptr inbounds %struct.vec3, %struct.vec3* %19, i32 0, i32 1
  %20 = load float, float* %y10, align 4
  %21 = load float, float* %len, align 4
  %mul11 = fmul float %20, %21
  %22 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %y12 = getelementptr inbounds %struct.vec3, %struct.vec3* %22, i32 0, i32 1
  store float %mul11, float* %y12, align 4
  %23 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z13 = getelementptr inbounds %struct.vec3, %struct.vec3* %23, i32 0, i32 2
  %24 = load float, float* %z13, align 4
  %25 = load float, float* %len, align 4
  %mul14 = fmul float %24, %25
  %26 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %z15 = getelementptr inbounds %struct.vec3, %struct.vec3* %26, i32 0, i32 2
  store float %mul14, float* %z15, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %27 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x16 = getelementptr inbounds %struct.vec3, %struct.vec3* %27, i32 0, i32 0
  %28 = load float, float* %x16, align 4
  %29 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %x17 = getelementptr inbounds %struct.vec3, %struct.vec3* %29, i32 0, i32 0
  store float %28, float* %x17, align 4
  %30 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y18 = getelementptr inbounds %struct.vec3, %struct.vec3* %30, i32 0, i32 1
  %31 = load float, float* %y18, align 4
  %32 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %y19 = getelementptr inbounds %struct.vec3, %struct.vec3* %32, i32 0, i32 1
  store float %31, float* %y19, align 4
  %33 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z20 = getelementptr inbounds %struct.vec3, %struct.vec3* %33, i32 0, i32 2
  %34 = load float, float* %z20, align 4
  %35 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %z21 = getelementptr inbounds %struct.vec3, %struct.vec3* %35, i32 0, i32 2
  store float %34, float* %z21, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @vertexHashMapInit(%struct.VertexHashMap* %_map, i32 %_initialCapacity) #0 {
entry:
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  %_initialCapacity.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4
  %0 = load i32, i32* %_initialCapacity.addr, align 4
  %conv = uitofp i32 %0 to float
  %mul = fmul float %conv, 0x3FF4CCCCC0000000
  %conv1 = fptoui float %mul to i32
  %1 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %1, i32 0, i32 1
  store i32 %conv1, i32* %numSlots, align 8
  %2 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots2 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots2, align 8
  %conv3 = zext i32 %3 to i64
  %mul4 = mul i64 4, %conv3
  %call = call i8* @objz_realloc(i8* null, i64 %mul4, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 549)
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %5, i32 0, i32 0
  store i32* %4, i32** %slots, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots5 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %7, i32 0, i32 1
  %8 = load i32, i32* %numSlots5, align 8
  %cmp = icmp ult i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots7 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %9, i32 0, i32 0
  %10 = load i32*, i32** %slots7, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom = zext i32 %11 to i64
  %arrayidx = getelementptr inbounds i32, i32* %10, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %13, i32 0, i32 2
  %14 = load i32, i32* %_initialCapacity.addr, align 4
  call void @arrayInit(%struct.Array* %vertices, i64 20, i32 %14)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @normalHashMapInit(%struct.NormalHashMap* %_map, i32 %_initialCapacity, %struct.ChunkedArray* %_normals) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %_initialCapacity.addr = alloca i32, align 4
  %_normals.addr = alloca %struct.ChunkedArray*, align 8
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4
  store %struct.ChunkedArray* %_normals, %struct.ChunkedArray** %_normals.addr, align 8
  %0 = load i32, i32* %_initialCapacity.addr, align 4
  %conv = uitofp i32 %0 to float
  %mul = fmul float %conv, 0x3FF4CCCCC0000000
  %conv1 = fptoui float %mul to i32
  %1 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %1, i32 0, i32 1
  store i32 %conv1, i32* %numSlots, align 8
  %2 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots2 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots2, align 8
  %conv3 = zext i32 %3 to i64
  %mul4 = mul i64 4, %conv3
  %call = call i8* @objz_realloc(i8* null, i64 %mul4, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 607)
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %5, i32 0, i32 0
  store i32* %4, i32** %slots, align 8
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_normals.addr, align 8
  %7 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %7, i32 0, i32 3
  store %struct.ChunkedArray* %6, %struct.ChunkedArray** %normals, align 8
  %8 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %8, i32 0, i32 2
  %9 = load i32, i32* %_initialCapacity.addr, align 4
  call void @arrayInit(%struct.Array* %hashedNormals, i64 8, i32 %9)
  %10 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  call void @normalHashMapClear(%struct.NormalHashMap* %10)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @normalHashMapClear(%struct.NormalHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %i = alloca i32, align 4
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %1, i32 0, i32 1
  %2 = load i32, i32* %numSlots, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %3, i32 0, i32 0
  %4 = load i32*, i32** %slots, align 8
  %5 = load i32, i32* %i, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %7, i32 0, i32 2
  %length = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals, i32 0, i32 1
  store i32 0, i32* %length, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @normalHashMapInsert(%struct.NormalHashMap* %_map, %struct.vec3* %_normal) #0 {
entry:
  %retval = alloca i32, align 4
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %_normal.addr = alloca %struct.vec3*, align 8
  %hashData = alloca [3 x i32], align 4
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca %struct.HashedNormal*, align 8
  %n18 = alloca %struct.HashedNormal, align 4
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  store %struct.vec3* %_normal, %struct.vec3** %_normal.addr, align 8
  %0 = bitcast [3 x i32]* %hashData to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 12, i32 4, i1 false)
  %1 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %1, i32 0, i32 0
  %2 = load float, float* %x, align 4
  %mul = fmul float %2, 5.000000e-01
  %add = fadd float %mul, 1.275000e+02
  %conv = fptoui float %add to i32
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 0
  store i32 %conv, i32* %arrayidx, align 4
  %3 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %3, i32 0, i32 1
  %4 = load float, float* %y, align 4
  %mul1 = fmul float %4, 5.000000e-01
  %add2 = fadd float %mul1, 1.275000e+02
  %conv3 = fptoui float %add2 to i32
  %arrayidx4 = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 1
  store i32 %conv3, i32* %arrayidx4, align 4
  %5 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %5, i32 0, i32 2
  %6 = load float, float* %z, align 4
  %mul5 = fmul float %6, 5.000000e-01
  %add6 = fadd float %mul5, 1.275000e+02
  %conv7 = fptoui float %add6 to i32
  %arrayidx8 = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 2
  store i32 %conv7, i32* %arrayidx8, align 4
  %arraydecay = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i32 0, i32 0
  %7 = bitcast i32* %arraydecay to i8*
  %call = call i32 @sdbmHash(i8* %7, i32 12)
  %8 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %8, i32 0, i32 1
  %9 = load i32, i32* %numSlots, align 8
  %rem = urem i32 %call, %9
  store i32 %rem, i32* %hash, align 4
  %10 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %10, i32 0, i32 0
  %11 = load i32*, i32** %slots, align 8
  %12 = load i32, i32* %hash, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx9 = getelementptr inbounds i32, i32* %11, i64 %idxprom
  %13 = load i32, i32* %arrayidx9, align 4
  store i32 %13, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %14 = load i32, i32* %i, align 4
  %cmp = icmp ne i32 %14, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %15, i32 0, i32 2
  %data = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals11 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %17, i32 0, i32 2
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals11, i32 0, i32 3
  %18 = load i32, i32* %elementSize, align 8
  %19 = load i32, i32* %i, align 4
  %mul12 = mul i32 %18, %19
  %idxprom13 = zext i32 %mul12 to i64
  %arrayidx14 = getelementptr inbounds i8, i8* %16, i64 %idxprom13
  %20 = bitcast i8* %arrayidx14 to %struct.HashedNormal*
  store %struct.HashedNormal* %20, %struct.HashedNormal** %n, align 8
  %21 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %21, i32 0, i32 3
  %22 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals, align 8
  %23 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8
  %normalIndex = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %23, i32 0, i32 0
  %24 = load i32, i32* %normalIndex, align 4
  %call15 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %22, i32 %24)
  %25 = bitcast i8* %call15 to %struct.vec3*
  %26 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %call16 = call zeroext i1 @vec3Equal(%struct.vec3* %25, %struct.vec3* %26, float 0x3E80000000000000)
  br i1 %call16, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %27 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8
  %normalIndex17 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %27, i32 0, i32 0
  %28 = load i32, i32* %normalIndex17, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %while.body
  %29 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8
  %hashNext = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %29, i32 0, i32 1
  %30 = load i32, i32* %hashNext, align 4
  store i32 %30, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %31 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals19 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %31, i32 0, i32 3
  %32 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals19, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %32, i32 0, i32 3
  %33 = load i32, i32* %length, align 8
  %normalIndex20 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 0
  store i32 %33, i32* %normalIndex20, align 4
  %34 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots21 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %34, i32 0, i32 0
  %35 = load i32*, i32** %slots21, align 8
  %36 = load i32, i32* %hash, align 4
  %idxprom22 = zext i32 %36 to i64
  %arrayidx23 = getelementptr inbounds i32, i32* %35, i64 %idxprom22
  %37 = load i32, i32* %arrayidx23, align 4
  %hashNext24 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 1
  store i32 %37, i32* %hashNext24, align 4
  %38 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals25 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %38, i32 0, i32 2
  %length26 = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals25, i32 0, i32 1
  %39 = load i32, i32* %length26, align 8
  %40 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots27 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %40, i32 0, i32 0
  %41 = load i32*, i32** %slots27, align 8
  %42 = load i32, i32* %hash, align 4
  %idxprom28 = zext i32 %42 to i64
  %arrayidx29 = getelementptr inbounds i32, i32* %41, i64 %idxprom28
  store i32 %39, i32* %arrayidx29, align 4
  %43 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals30 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %43, i32 0, i32 2
  %44 = bitcast %struct.HashedNormal* %n18 to i8*
  call void @arrayAppend(%struct.Array* %hashedNormals30, i8* %44)
  %45 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals31 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %45, i32 0, i32 3
  %46 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals31, align 8
  %47 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %48 = bitcast %struct.vec3* %47 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %46, i8* %48)
  %normalIndex32 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 0
  %49 = load i32, i32* %normalIndex32, align 4
  store i32 %49, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %50 = load i32, i32* %retval, align 4
  ret i32 %50
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal { <2 x float>, float } @calculateSmoothNormal(i32 %_pos, %struct.ChunkedArray* %_faces, %struct.Array* %_faceNormals, i16 zeroext %_smoothingGroup) #0 {
entry:
  %retval = alloca %struct.vec3, align 4
  %_pos.addr = alloca i32, align 4
  %_faces.addr = alloca %struct.ChunkedArray*, align 8
  %_faceNormals.addr = alloca %struct.Array*, align 8
  %_smoothingGroup.addr = alloca i16, align 2
  %normal = alloca %struct.vec3, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %face = alloca %struct.Face*, align 8
  %j = alloca i32, align 4
  %s = alloca float, align 4
  %tmp = alloca { <2 x float>, float }, align 8
  store i32 %_pos, i32* %_pos.addr, align 4
  store %struct.ChunkedArray* %_faces, %struct.ChunkedArray** %_faces.addr, align 8
  store %struct.Array* %_faceNormals, %struct.Array** %_faceNormals.addr, align 8
  store i16 %_smoothingGroup, i16* %_smoothingGroup.addr, align 2
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  store float 0.000000e+00, float* %x, align 4
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  store float 0.000000e+00, float* %y, align 4
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  store float 0.000000e+00, float* %z, align 4
  store i32 0, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc36, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %1, i32 0, i32 3
  %2 = load i32, i32* %length, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end38

for.body:                                         ; preds = %for.cond
  %3 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %4 = load i32, i32* %i, align 4
  %call = call i8* @chunkedArrayElement(%struct.ChunkedArray* %3, i32 %4)
  %5 = bitcast i8* %call to %struct.Face*
  store %struct.Face* %5, %struct.Face** %face, align 8
  %6 = load %struct.Face*, %struct.Face** %face, align 8
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %6, i32 0, i32 1
  %7 = load i16, i16* %smoothingGroup, align 2
  %conv = zext i16 %7 to i32
  %8 = load i16, i16* %_smoothingGroup.addr, align 2
  %conv1 = zext i16 %8 to i32
  %cmp2 = icmp ne i32 %conv, %conv1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc36

if.end:                                           ; preds = %for.body
  store i32 0, i32* %j, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %if.end
  %9 = load i32, i32* %j, align 4
  %cmp5 = icmp slt i32 %9, 3
  br i1 %cmp5, label %for.body7, label %for.end

for.body7:                                        ; preds = %for.cond4
  %10 = load %struct.Face*, %struct.Face** %face, align 8
  %indices = getelementptr inbounds %struct.Face, %struct.Face* %10, i32 0, i32 2
  %11 = load i32, i32* %j, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices, i64 0, i64 %idxprom
  %v = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx, i32 0, i32 0
  %12 = load i32, i32* %v, align 4
  %13 = load i32, i32* %_pos.addr, align 4
  %cmp8 = icmp eq i32 %12, %13
  br i1 %cmp8, label %if.then10, label %if.end34

if.then10:                                        ; preds = %for.body7
  %x11 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  %14 = load float, float* %x11, align 4
  %15 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %15, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %17, i32 0, i32 3
  %18 = load i32, i32* %elementSize, align 8
  %19 = load i32, i32* %i, align 4
  %mul = mul i32 %18, %19
  %idxprom12 = zext i32 %mul to i64
  %arrayidx13 = getelementptr inbounds i8, i8* %16, i64 %idxprom12
  %20 = bitcast i8* %arrayidx13 to %struct.vec3*
  %x14 = getelementptr inbounds %struct.vec3, %struct.vec3* %20, i32 0, i32 0
  %21 = load float, float* %x14, align 4
  %add = fadd float %14, %21
  %x15 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  store float %add, float* %x15, align 4
  %y16 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  %22 = load float, float* %y16, align 4
  %23 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %data17 = getelementptr inbounds %struct.Array, %struct.Array* %23, i32 0, i32 0
  %24 = load i8*, i8** %data17, align 8
  %25 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %elementSize18 = getelementptr inbounds %struct.Array, %struct.Array* %25, i32 0, i32 3
  %26 = load i32, i32* %elementSize18, align 8
  %27 = load i32, i32* %i, align 4
  %mul19 = mul i32 %26, %27
  %idxprom20 = zext i32 %mul19 to i64
  %arrayidx21 = getelementptr inbounds i8, i8* %24, i64 %idxprom20
  %28 = bitcast i8* %arrayidx21 to %struct.vec3*
  %y22 = getelementptr inbounds %struct.vec3, %struct.vec3* %28, i32 0, i32 1
  %29 = load float, float* %y22, align 4
  %add23 = fadd float %22, %29
  %y24 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  store float %add23, float* %y24, align 4
  %z25 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  %30 = load float, float* %z25, align 4
  %31 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %data26 = getelementptr inbounds %struct.Array, %struct.Array* %31, i32 0, i32 0
  %32 = load i8*, i8** %data26, align 8
  %33 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %elementSize27 = getelementptr inbounds %struct.Array, %struct.Array* %33, i32 0, i32 3
  %34 = load i32, i32* %elementSize27, align 8
  %35 = load i32, i32* %i, align 4
  %mul28 = mul i32 %34, %35
  %idxprom29 = zext i32 %mul28 to i64
  %arrayidx30 = getelementptr inbounds i8, i8* %32, i64 %idxprom29
  %36 = bitcast i8* %arrayidx30 to %struct.vec3*
  %z31 = getelementptr inbounds %struct.vec3, %struct.vec3* %36, i32 0, i32 2
  %37 = load float, float* %z31, align 4
  %add32 = fadd float %30, %37
  %z33 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  store float %add32, float* %z33, align 4
  %38 = load i32, i32* %n, align 4
  %inc = add nsw i32 %38, 1
  store i32 %inc, i32* %n, align 4
  br label %for.end

if.end34:                                         ; preds = %for.body7
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %39 = load i32, i32* %j, align 4
  %inc35 = add nsw i32 %39, 1
  store i32 %inc35, i32* %j, align 4
  br label %for.cond4

for.end:                                          ; preds = %if.then10, %for.cond4
  br label %for.inc36

for.inc36:                                        ; preds = %for.end, %if.then
  %40 = load i32, i32* %i, align 4
  %inc37 = add i32 %40, 1
  store i32 %inc37, i32* %i, align 4
  br label %for.cond

for.end38:                                        ; preds = %for.cond
  %41 = load i32, i32* %n, align 4
  %conv39 = sitofp i32 %41 to float
  %div = fdiv float 1.000000e+00, %conv39
  store float %div, float* %s, align 4
  %x40 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  %42 = load float, float* %x40, align 4
  %43 = load float, float* %s, align 4
  %mul41 = fmul float %42, %43
  %x42 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  store float %mul41, float* %x42, align 4
  %y43 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  %44 = load float, float* %y43, align 4
  %45 = load float, float* %s, align 4
  %mul44 = fmul float %44, %45
  %y45 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  store float %mul44, float* %y45, align 4
  %z46 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  %46 = load float, float* %z46, align 4
  %47 = load float, float* %s, align 4
  %mul47 = fmul float %46, %47
  %z48 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  store float %mul47, float* %z48, align 4
  call void @vec3Normalize(%struct.vec3* %normal, %struct.vec3* %normal)
  %48 = bitcast %struct.vec3* %retval to i8*
  %49 = bitcast %struct.vec3* %normal to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %48, i8* %49, i64 12, i32 4, i1 false)
  %50 = bitcast { <2 x float>, float }* %tmp to i8*
  %51 = bitcast %struct.vec3* %retval to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %50, i8* %51, i64 12, i32 4, i1 false)
  %52 = load { <2 x float>, float }, { <2 x float>, float }* %tmp, align 8
  ret { <2 x float>, float } %52
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @vertexHashMapInsert(%struct.VertexHashMap* %_map, i32 %_object, i32 %_pos, i32 %_texcoord, i32 %_normal) #0 {
entry:
  %retval = alloca i32, align 4
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  %_object.addr = alloca i32, align 4
  %_pos.addr = alloca i32, align 4
  %_texcoord.addr = alloca i32, align 4
  %_normal.addr = alloca i32, align 4
  %hashData = alloca [4 x i32], align 16
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  %v = alloca %struct.HashedVertex*, align 8
  %v20 = alloca %struct.HashedVertex, align 4
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8
  store i32 %_object, i32* %_object.addr, align 4
  store i32 %_pos, i32* %_pos.addr, align 4
  store i32 %_texcoord, i32* %_texcoord.addr, align 4
  store i32 %_normal, i32* %_normal.addr, align 4
  %0 = bitcast [4 x i32]* %hashData to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 16, i32 16, i1 false)
  %1 = load i32, i32* %_object.addr, align 4
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 0
  store i32 %1, i32* %arrayidx, align 16
  %2 = load i32, i32* %_pos.addr, align 4
  %arrayidx1 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 1
  store i32 %2, i32* %arrayidx1, align 4
  %3 = load i32, i32* %_texcoord.addr, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %_texcoord.addr, align 4
  %arrayidx2 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 2
  store i32 %4, i32* %arrayidx2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, i32* %_normal.addr, align 4
  %cmp3 = icmp ne i32 %5, -1
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %6 = load i32, i32* %_normal.addr, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 3
  store i32 %6, i32* %arrayidx5, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i32 0, i32 0
  %7 = bitcast i32* %arraydecay to i8*
  %call = call i32 @sdbmHash(i8* %7, i32 16)
  %8 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %8, i32 0, i32 1
  %9 = load i32, i32* %numSlots, align 8
  %rem = urem i32 %call, %9
  store i32 %rem, i32* %hash, align 4
  %10 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %10, i32 0, i32 0
  %11 = load i32*, i32** %slots, align 8
  %12 = load i32, i32* %hash, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx7 = getelementptr inbounds i32, i32* %11, i64 %idxprom
  %13 = load i32, i32* %arrayidx7, align 4
  store i32 %13, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.end6
  %14 = load i32, i32* %i, align 4
  %cmp8 = icmp ne i32 %14, -1
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %15, i32 0, i32 2
  %data = getelementptr inbounds %struct.Array, %struct.Array* %vertices, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices9 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %17, i32 0, i32 2
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %vertices9, i32 0, i32 3
  %18 = load i32, i32* %elementSize, align 8
  %19 = load i32, i32* %i, align 4
  %mul = mul i32 %18, %19
  %idxprom10 = zext i32 %mul to i64
  %arrayidx11 = getelementptr inbounds i8, i8* %16, i64 %idxprom10
  %20 = bitcast i8* %arrayidx11 to %struct.HashedVertex*
  store %struct.HashedVertex* %20, %struct.HashedVertex** %v, align 8
  %21 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %object = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %21, i32 0, i32 0
  %22 = load i32, i32* %object, align 4
  %23 = load i32, i32* %_object.addr, align 4
  %cmp12 = icmp eq i32 %22, %23
  br i1 %cmp12, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %while.body
  %24 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %pos = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %24, i32 0, i32 1
  %25 = load i32, i32* %pos, align 4
  %26 = load i32, i32* %_pos.addr, align 4
  %cmp13 = icmp eq i32 %25, %26
  br i1 %cmp13, label %land.lhs.true14, label %if.end19

land.lhs.true14:                                  ; preds = %land.lhs.true
  %27 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %texcoord = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %27, i32 0, i32 2
  %28 = load i32, i32* %texcoord, align 4
  %29 = load i32, i32* %_texcoord.addr, align 4
  %cmp15 = icmp eq i32 %28, %29
  br i1 %cmp15, label %land.lhs.true16, label %if.end19

land.lhs.true16:                                  ; preds = %land.lhs.true14
  %30 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %normal = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %30, i32 0, i32 3
  %31 = load i32, i32* %normal, align 4
  %32 = load i32, i32* %_normal.addr, align 4
  %cmp17 = icmp eq i32 %31, %32
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true16
  %33 = load i32, i32* %i, align 4
  store i32 %33, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %land.lhs.true16, %land.lhs.true14, %land.lhs.true, %while.body
  %34 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %hashNext = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %34, i32 0, i32 4
  %35 = load i32, i32* %hashNext, align 4
  store i32 %35, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i32, i32* %_object.addr, align 4
  %object21 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 0
  store i32 %36, i32* %object21, align 4
  %37 = load i32, i32* %_pos.addr, align 4
  %pos22 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 1
  store i32 %37, i32* %pos22, align 4
  %38 = load i32, i32* %_texcoord.addr, align 4
  %texcoord23 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 2
  store i32 %38, i32* %texcoord23, align 4
  %39 = load i32, i32* %_normal.addr, align 4
  %normal24 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 3
  store i32 %39, i32* %normal24, align 4
  %40 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots25 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %40, i32 0, i32 0
  %41 = load i32*, i32** %slots25, align 8
  %42 = load i32, i32* %hash, align 4
  %idxprom26 = zext i32 %42 to i64
  %arrayidx27 = getelementptr inbounds i32, i32* %41, i64 %idxprom26
  %43 = load i32, i32* %arrayidx27, align 4
  %hashNext28 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 4
  store i32 %43, i32* %hashNext28, align 4
  %44 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices29 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %44, i32 0, i32 2
  %length = getelementptr inbounds %struct.Array, %struct.Array* %vertices29, i32 0, i32 1
  %45 = load i32, i32* %length, align 8
  %46 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots30 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %46, i32 0, i32 0
  %47 = load i32*, i32** %slots30, align 8
  %48 = load i32, i32* %hash, align 4
  %idxprom31 = zext i32 %48 to i64
  %arrayidx32 = getelementptr inbounds i32, i32* %47, i64 %idxprom31
  store i32 %45, i32* %arrayidx32, align 4
  %49 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices33 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %49, i32 0, i32 2
  %50 = bitcast %struct.HashedVertex* %v20 to i8*
  call void @arrayAppend(%struct.Array* %vertices33, i8* %50)
  %51 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots34 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %51, i32 0, i32 0
  %52 = load i32*, i32** %slots34, align 8
  %53 = load i32, i32* %hash, align 4
  %idxprom35 = zext i32 %53 to i64
  %arrayidx36 = getelementptr inbounds i32, i32* %52, i64 %idxprom35
  %54 = load i32, i32* %arrayidx36, align 4
  store i32 %54, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then18
  %55 = load i32, i32* %retval, align 4
  ret i32 %55
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @normalHashMapDestroy(%struct.NormalHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  %0 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %0, i32 0, i32 0
  %1 = load i32*, i32** %slots, align 8
  %2 = bitcast i32* %1 to i8*
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 614)
  %3 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %3, i32 0, i32 2
  call void @arrayDestroy(%struct.Array* %hashedNormals)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @chunkedArrayDestroy(%struct.ChunkedArray* %_array) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %i = alloca i32, align 4
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %1, i32 0, i32 0
  %length = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 1
  %2 = load i32, i32* %length, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks1 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %3, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks1, i32 0, i32 0
  %4 = load i8*, i8** %data, align 8
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 0
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %chunks2, i32 0, i32 3
  %6 = load i32, i32* %elementSize, align 8
  %7 = load i32, i32* %i, align 4
  %mul = mul i32 %6, %7
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %8 = bitcast i8* %arrayidx to i8**
  store i8** %8, i8*** %chunk, align 8
  %9 = load i8**, i8*** %chunk, align 8
  %10 = load i8*, i8** %9, align 8
  %call = call i8* @objz_realloc(i8* %10, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 218)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks3 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %12, i32 0, i32 0
  call void @arrayDestroy(%struct.Array* %chunks3)
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #3

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #4

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #3

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @vertexHashMapDestroy(%struct.VertexHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8
  %0 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %0, i32 0, i32 0
  %1 = load i32*, i32** %slots, align 8
  %2 = bitcast i32* %1 to i8*
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 556)
  %3 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %3, i32 0, i32 2
  call void @arrayDestroy(%struct.Array* %vertices)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @objz_destroy(%struct.objzModel* %_model) #0 {
entry:
  %_model.addr = alloca %struct.objzModel*, align 8
  store %struct.objzModel* %_model, %struct.objzModel** %_model.addr, align 8
  %0 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %tobool = icmp ne %struct.objzModel* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %indices = getelementptr inbounds %struct.objzModel, %struct.objzModel* %1, i32 0, i32 1
  %2 = load i8*, i8** %indices, align 8
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1243)
  %3 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %materials = getelementptr inbounds %struct.objzModel, %struct.objzModel* %3, i32 0, i32 3
  %4 = load %struct.objzMaterial*, %struct.objzMaterial** %materials, align 8
  %5 = bitcast %struct.objzMaterial* %4 to i8*
  %call1 = call i8* @objz_realloc(i8* %5, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1244)
  %6 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %meshes = getelementptr inbounds %struct.objzModel, %struct.objzModel* %6, i32 0, i32 5
  %7 = load %struct.objzMesh*, %struct.objzMesh** %meshes, align 8
  %8 = bitcast %struct.objzMesh* %7 to i8*
  %call2 = call i8* @objz_realloc(i8* %8, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1245)
  %9 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %objects = getelementptr inbounds %struct.objzModel, %struct.objzModel* %9, i32 0, i32 7
  %10 = load %struct.objzObject*, %struct.objzObject** %objects, align 8
  %11 = bitcast %struct.objzObject* %10 to i8*
  %call3 = call i8* @objz_realloc(i8* %11, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1246)
  %12 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %vertices = getelementptr inbounds %struct.objzModel, %struct.objzModel* %12, i32 0, i32 9
  %13 = load i8*, i8** %vertices, align 8
  %call4 = call i8* @objz_realloc(i8* %13, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1247)
  %14 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %15 = bitcast %struct.objzModel* %14 to i8*
  %call5 = call i8* @objz_realloc(i8* %15, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1248)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i8* @objz_getError() #0 {
entry:
  %retval = alloca i8*, align 8
  %0 = load i8, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i8*, i8** %retval, align 8
  ret i8* %1
}

; Function Attrs: allocsize(1)
declare i8* @realloc(i8*, i64) #5

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: cold noreturn
declare void @abort() #6

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

declare i32 @__vsnprintf_chk(i8*, i64, i32, i64, i8*, %struct.__va_list_tag*) #1

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @skipWhitespace(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end3, %entry
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call = call zeroext i1 @isEol(%struct.Lexer* %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call1 = call zeroext i1 @isWhitespace(%struct.Lexer* %1)
  br i1 %call1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %for.end

if.end3:                                          ; preds = %if.end
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 0
  %3 = load i8*, i8** %buf, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %buf, align 8
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 2
  %5 = load i32, i32* %column, align 4
  %inc = add i32 %5, 1
  store i32 %inc, i32* %column, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then2, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @isWhitespace(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  %1 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf2 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %3, i32 0, i32 0
  %4 = load i8*, i8** %buf2, align 8
  %arrayidx3 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i8, i8* %arrayidx3, align 1
  %conv4 = sext i8 %5 to i32
  %cmp5 = icmp eq i32 %conv4, 9
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %6 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf7 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %6, i32 0, i32 0
  %7 = load i8*, i8** %buf7, align 8
  %arrayidx8 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = load i8, i8* %arrayidx8, align 1
  %conv9 = sext i8 %8 to i32
  %cmp10 = icmp eq i32 %conv9, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %9 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp10, %lor.rhs ]
  ret i1 %9
}

declare i8* @strstr(i8*, i8*) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.fabs.f32(float) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @pnpoly(i32 %nvert, float* %vertx, float* %verty, float %testx, float %testy) #0 {
entry:
  %nvert.addr = alloca i32, align 4
  %vertx.addr = alloca float*, align 8
  %verty.addr = alloca float*, align 8
  %testx.addr = alloca float, align 4
  %testy.addr = alloca float, align 4
  %c = alloca i8, align 1
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store i32 %nvert, i32* %nvert.addr, align 4
  store float* %vertx, float** %vertx.addr, align 8
  store float* %verty, float** %verty.addr, align 8
  store float %testx, float* %testx.addr, align 4
  store float %testy, float* %testy.addr, align 4
  store i8 0, i8* %c, align 1
  store i32 0, i32* %i, align 4
  %0 = load i32, i32* %nvert.addr, align 4
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* %nvert.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load float*, float** %verty.addr, align 8
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds float, float* %3, i64 %idxprom
  %5 = load float, float* %arrayidx, align 4
  %6 = load float, float* %testy.addr, align 4
  %cmp1 = fcmp ogt float %5, %6
  %conv = zext i1 %cmp1 to i32
  %7 = load float*, float** %verty.addr, align 8
  %8 = load i32, i32* %j, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr inbounds float, float* %7, i64 %idxprom2
  %9 = load float, float* %arrayidx3, align 4
  %10 = load float, float* %testy.addr, align 4
  %cmp4 = fcmp ogt float %9, %10
  %conv5 = zext i1 %cmp4 to i32
  %cmp6 = icmp ne i32 %conv, %conv5
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %11 = load float, float* %testx.addr, align 4
  %12 = load float*, float** %vertx.addr, align 8
  %13 = load i32, i32* %j, align 4
  %idxprom8 = sext i32 %13 to i64
  %arrayidx9 = getelementptr inbounds float, float* %12, i64 %idxprom8
  %14 = load float, float* %arrayidx9, align 4
  %15 = load float*, float** %vertx.addr, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom10 = sext i32 %16 to i64
  %arrayidx11 = getelementptr inbounds float, float* %15, i64 %idxprom10
  %17 = load float, float* %arrayidx11, align 4
  %sub12 = fsub float %14, %17
  %18 = load float, float* %testy.addr, align 4
  %19 = load float*, float** %verty.addr, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr inbounds float, float* %19, i64 %idxprom13
  %21 = load float, float* %arrayidx14, align 4
  %sub15 = fsub float %18, %21
  %mul = fmul float %sub12, %sub15
  %22 = load float*, float** %verty.addr, align 8
  %23 = load i32, i32* %j, align 4
  %idxprom16 = sext i32 %23 to i64
  %arrayidx17 = getelementptr inbounds float, float* %22, i64 %idxprom16
  %24 = load float, float* %arrayidx17, align 4
  %25 = load float*, float** %verty.addr, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom18 = sext i32 %26 to i64
  %arrayidx19 = getelementptr inbounds float, float* %25, i64 %idxprom18
  %27 = load float, float* %arrayidx19, align 4
  %sub20 = fsub float %24, %27
  %div = fdiv float %mul, %sub20
  %28 = load float*, float** %vertx.addr, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom21 = sext i32 %29 to i64
  %arrayidx22 = getelementptr inbounds float, float* %28, i64 %idxprom21
  %30 = load float, float* %arrayidx22, align 4
  %add = fadd float %div, %30
  %cmp23 = fcmp olt float %11, %add
  br i1 %cmp23, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %31 = load i8, i8* %c, align 1
  %tobool = trunc i8 %31 to i1
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %c, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %32 = load i32, i32* %i, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, i32* %i, align 4
  store i32 %32, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %33 = load i8, i8* %c, align 1
  %tobool25 = trunc i8 %33 to i1
  %conv26 = zext i1 %tobool25 to i32
  ret i32 %conv26
}

declare i8* @strrchr(i8*, i32) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @materialInit(%struct.objzMaterial* %_mat) #0 {
entry:
  %_mat.addr = alloca %struct.objzMaterial*, align 8
  store %struct.objzMaterial* %_mat, %struct.objzMaterial** %_mat.addr, align 8
  %0 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %1 = bitcast %struct.objzMaterial* %0 to i8*
  %2 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %3 = bitcast %struct.objzMaterial* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 568, i64 %4) #7
  %5 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %diffuse = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %5, i32 0, i32 2
  %arrayidx = getelementptr inbounds [3 x float], [3 x float]* %diffuse, i64 0, i64 2
  store float 1.000000e+00, float* %arrayidx, align 4
  %6 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %diffuse1 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %6, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [3 x float], [3 x float]* %diffuse1, i64 0, i64 1
  store float 1.000000e+00, float* %arrayidx2, align 4
  %7 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %diffuse3 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %7, i32 0, i32 2
  %arrayidx4 = getelementptr inbounds [3 x float], [3 x float]* %diffuse3, i64 0, i64 0
  store float 1.000000e+00, float* %arrayidx4, align 4
  %8 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %opacity = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %8, i32 0, i32 6
  store float 1.000000e+00, float* %opacity, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @skipTokens(%struct.Lexer* %_lexer, i32 %_n) #0 {
entry:
  %retval = alloca i1, align 1
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_n.addr = alloca i32, align 4
  %token = alloca %struct.Token, align 4
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store i32 %_n, i32* %_n.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %_n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  call void @tokenize(%struct.Lexer* %2, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %line = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %3 = load i32, i32* %line, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %4 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.55, i32 0, i32 0), i32 %3, i32 %4)
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %6 = load i1, i1* %retval, align 1
  ret i1 %6
}

declare double @atof(i8*) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.sqrt.f32(float) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @sdbmHash(i8* %_data, i32 %_size) #0 {
entry:
  %_data.addr = alloca i8*, align 8
  %_size.addr = alloca i32, align 4
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %_data, i8** %_data.addr, align 8
  store i32 %_size, i32* %_size.addr, align 4
  store i32 0, i32* %hash, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %_size.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %_data.addr, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %4 to i32
  %5 = load i32, i32* %hash, align 4
  %shl = shl i32 %5, 6
  %add = add i32 %conv, %shl
  %6 = load i32, i32* %hash, align 4
  %shl1 = shl i32 %6, 16
  %add2 = add i32 %add, %shl1
  %7 = load i32, i32* %hash, align 4
  %sub = sub i32 %add2, %7
  store i32 %sub, i32* %hash, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load i32, i32* %hash, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @vec3Equal(%struct.vec3* %_a, %struct.vec3* %_b, float %epsilon) #0 {
entry:
  %_a.addr = alloca %struct.vec3*, align 8
  %_b.addr = alloca %struct.vec3*, align 8
  %epsilon.addr = alloca float, align 4
  store %struct.vec3* %_a, %struct.vec3** %_a.addr, align 8
  store %struct.vec3* %_b, %struct.vec3** %_b.addr, align 8
  store float %epsilon, float* %epsilon.addr, align 4
  %0 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %0, i32 0, i32 0
  %1 = load float, float* %x, align 4
  %2 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8
  %x1 = getelementptr inbounds %struct.vec3, %struct.vec3* %2, i32 0, i32 0
  %3 = load float, float* %x1, align 4
  %sub = fsub float %1, %3
  %4 = call float @llvm.fabs.f32(float %sub)
  %5 = load float, float* %epsilon.addr, align 4
  %cmp = fcmp ole float %4, %5
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %6, i32 0, i32 1
  %7 = load float, float* %y, align 4
  %8 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8
  %y2 = getelementptr inbounds %struct.vec3, %struct.vec3* %8, i32 0, i32 1
  %9 = load float, float* %y2, align 4
  %sub3 = fsub float %7, %9
  %10 = call float @llvm.fabs.f32(float %sub3)
  %11 = load float, float* %epsilon.addr, align 4
  %cmp4 = fcmp ole float %10, %11
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %12 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %12, i32 0, i32 2
  %13 = load float, float* %z, align 4
  %14 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8
  %z5 = getelementptr inbounds %struct.vec3, %struct.vec3* %14, i32 0, i32 2
  %15 = load float, float* %z5, align 4
  %sub6 = fsub float %13, %15
  %16 = call float @llvm.fabs.f32(float %sub6)
  %17 = load float, float* %epsilon.addr, align 4
  %cmp7 = fcmp ole float %16, %17
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %18 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %18
}

attributes #0 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone speculatable }
attributes #5 = { allocsize(1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { cold noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { allocsize(1) }
attributes #9 = { cold noreturn }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 6.0.1 (https://github.com/llvm-mirror/clang.git 2f27999df400d17b33cdd412fdd606a88208dfcc) (https://github.com/llvm-mirror/llvm.git 5136df4d089a086b70d452160ad5451861269498)"}
