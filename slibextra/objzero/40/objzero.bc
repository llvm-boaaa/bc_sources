; ModuleID = 'objzero.c'
source_filename = "objzero.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.VertexFormat = type { i64, i64, i64, i64 }
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.MaterialProperty = type { i8*, i32, i64, i32 }
%struct.MaterialMapArg = type { i8*, i32 }
%struct.File = type { i8*, i64, i64 }
%struct.objzModel = type { i32, i8*, i32, %struct.objzMaterial*, i32, %struct.objzMesh*, i32, %struct.objzObject*, i32, i8*, i32 }
%struct.objzMaterial = type { [64 x i8], [3 x float], [3 x float], [3 x float], [3 x float], float, float, [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8] }
%struct.objzMesh = type { i32, i32, i32 }
%struct.objzObject = type { [64 x i8], i32, i32, i32, i32, i32, i32 }
%struct.Array = type { i8*, i32, i32, i32, i32 }
%struct.ChunkedArray = type { %struct.Array, i32, i64, i32 }
%struct.Lexer = type { i8*, i32, i32 }
%struct.Token = type { [256 x i8], i32, i32 }
%struct.TempObject = type { [64 x i8], i32, i32 }
%struct.IndexTriplet = type { i32, i32, i32 }
%struct.Face = type { i16, i16, [3 x %struct.IndexTriplet] }
%struct.vec3 = type { float, float, float }
%struct.VertexHashMap = type { i32*, i32, %struct.Array }
%struct.NormalHashMap = type { i32*, i32, %struct.Array, %struct.ChunkedArray* }
%struct.HashedVertex = type { i32, i32, i32, i32, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.HashedNormal = type { i32, i32 }

@.str = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.1 = private unnamed_addr constant [10 x i8] c"objzero.c\00", align 1
@s_realloc = internal global i8* (i8*, i64)* null, align 8
@s_indexFormat = internal global i32 0, align 4
@s_vertexDecl = internal global %struct.VertexFormat { i64 32, i64 0, i64 12, i64 20 }, align 8
@s_error = internal global [1024 x i8] zeroinitializer, align 16
@.str.2 = private unnamed_addr constant [25 x i8] c"Failed to read file '%s'\00", align 1
@.str.3 = private unnamed_addr constant [43 x i8] c"UTF-32 encoding not supported in file '%s'\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"UTF-16 encoding not supported in file '%s'\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.6 = private unnamed_addr constant [29 x i8] c"(%u:%u) Failed to parse face\00", align 1
@.str.7 = private unnamed_addr constant [39 x i8] c"(%u:%u) Face needs at least 3 vertices\00", align 1
@.str.8 = private unnamed_addr constant [2 x i8] c"g\00", align 1
@.str.9 = private unnamed_addr constant [2 x i8] c"o\00", align 1
@.str.10 = private unnamed_addr constant [32 x i8] c"(%u:%u) Expected name after 'o'\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"mtllib\00", align 1
@.str.13 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'mtllib'\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@.str.15 = private unnamed_addr constant [33 x i8] c"(%u:%u) Expected value after 's'\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.17 = private unnamed_addr constant [7 x i8] c"usemtl\00", align 1
@.str.18 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'usemtl'\00", align 1
@.str.19 = private unnamed_addr constant [2 x i8] c"v\00", align 1
@.str.20 = private unnamed_addr constant [3 x i8] c"vn\00", align 1
@.str.21 = private unnamed_addr constant [3 x i8] c"vt\00", align 1
@__stderrp = external global %struct.__sFILE*, align 8
@.str.22 = private unnamed_addr constant [32 x i8] c"Memory allocation failed %s %d\0A\00", align 1
@.str.23 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.24 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@triangulate.axes = private unnamed_addr constant [2 x i32] [i32 1, i32 2], align 4
@.str.25 = private unnamed_addr constant [34 x i8] c"Failed to read material file '%s'\00", align 1
@.str.26 = private unnamed_addr constant [7 x i8] c"newmtl\00", align 1
@.str.27 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'newmtl'\00", align 1
@s_materialProperties = internal global [14 x %struct.MaterialProperty] [%struct.MaterialProperty { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.29, i32 0, i32 0), i32 1, i64 116, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.30, i32 0, i32 0), i32 1, i64 64, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.31, i32 0, i32 0), i32 1, i64 76, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i32 1, i64 88, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.33, i32 0, i32 0), i32 1, i64 100, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0), i32 1, i64 112, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i32 0, i64 184, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.36, i32 0, i32 0), i32 0, i64 184, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.37, i32 0, i32 0), i32 0, i64 120, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.38, i32 0, i32 0), i32 0, i64 248, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.39, i32 0, i32 0), i32 0, i64 312, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i32 0, i64 376, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i32 0, i64 440, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.42, i32 0, i32 0), i32 0, i64 504, i32 1 }], align 16
@.str.28 = private unnamed_addr constant [34 x i8] c"(%u:%u) Expected token after '%s'\00", align 1
@s_materialMapArgs = internal global [12 x %struct.MaterialMapArg] [%struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.45, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.46, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.49, i32 0, i32 0), i32 2 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.50, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.51, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.53, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54, i32 0, i32 0), i32 1 }], align 16
@.str.29 = private unnamed_addr constant [2 x i8] c"d\00", align 1
@.str.30 = private unnamed_addr constant [3 x i8] c"Ka\00", align 1
@.str.31 = private unnamed_addr constant [3 x i8] c"Kd\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"Ke\00", align 1
@.str.33 = private unnamed_addr constant [3 x i8] c"Ks\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"Ns\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"bump\00", align 1
@.str.36 = private unnamed_addr constant [9 x i8] c"map_Bump\00", align 1
@.str.37 = private unnamed_addr constant [7 x i8] c"map_Ka\00", align 1
@.str.38 = private unnamed_addr constant [7 x i8] c"map_Kd\00", align 1
@.str.39 = private unnamed_addr constant [7 x i8] c"map_Ke\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"map_Ks\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"map_Ns\00", align 1
@.str.42 = private unnamed_addr constant [6 x i8] c"map_d\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"-blendu\00", align 1
@.str.44 = private unnamed_addr constant [8 x i8] c"-blendv\00", align 1
@.str.45 = private unnamed_addr constant [4 x i8] c"-bm\00", align 1
@.str.46 = private unnamed_addr constant [7 x i8] c"-boost\00", align 1
@.str.47 = private unnamed_addr constant [7 x i8] c"-clamp\00", align 1
@.str.48 = private unnamed_addr constant [9 x i8] c"-imfchan\00", align 1
@.str.49 = private unnamed_addr constant [4 x i8] c"-mm\00", align 1
@.str.50 = private unnamed_addr constant [3 x i8] c"-o\00", align 1
@.str.51 = private unnamed_addr constant [3 x i8] c"-s\00", align 1
@.str.52 = private unnamed_addr constant [3 x i8] c"-t\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"-texres\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c"-type\00", align 1
@.str.55 = private unnamed_addr constant [30 x i8] c"(%u:%u) Error skipping tokens\00", align 1
@.str.56 = private unnamed_addr constant [28 x i8] c"(%u:%u) Error parsing float\00", align 1

; Function Attrs: noinline nounwind ssp uwtable
define zeroext i1 @fileOpen(%struct.File* %_file, i8* %_filename) #0 {
entry:
  %retval = alloca i1, align 1
  %_file.addr = alloca %struct.File*, align 8
  %_filename.addr = alloca i8*, align 8
  %handle = alloca %struct.__sFILE*, align 8
  %bytesRead = alloca i64, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8
  store i8* %_filename, i8** %_filename.addr, align 8
  %0 = load i8*, i8** %_filename.addr, align 8
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %handle, align 8
  %1 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %tobool = icmp ne %struct.__sFILE* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call1 = call i32 @fseek(%struct.__sFILE* %2, i64 0, i32 2)
  %3 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call2 = call i64 @ftell(%struct.__sFILE* %3)
  %4 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length = getelementptr inbounds %struct.File, %struct.File* %4, i32 0, i32 1
  store i64 %call2, i64* %length, align 8
  %5 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call3 = call i32 @fseek(%struct.__sFILE* %5, i64 0, i32 0)
  %6 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length4 = getelementptr inbounds %struct.File, %struct.File* %6, i32 0, i32 1
  %7 = load i64, i64* %length4, align 8
  %cmp = icmp eq i64 %7, 0
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %8 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call6 = call i32 @fclose(%struct.__sFILE* %8)
  store i1 false, i1* %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  %9 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos = getelementptr inbounds %struct.File, %struct.File* %9, i32 0, i32 2
  store i64 0, i64* %pos, align 8
  %10 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length8 = getelementptr inbounds %struct.File, %struct.File* %10, i32 0, i32 1
  %11 = load i64, i64* %length8, align 8
  %add = add i64 %11, 1
  %call9 = call i8* @objz_realloc(i8* null, i64 %add, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 338)
  %12 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer = getelementptr inbounds %struct.File, %struct.File* %12, i32 0, i32 0
  store i8* %call9, i8** %buffer, align 8
  %13 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer10 = getelementptr inbounds %struct.File, %struct.File* %13, i32 0, i32 0
  %14 = load i8*, i8** %buffer10, align 8
  %15 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length11 = getelementptr inbounds %struct.File, %struct.File* %15, i32 0, i32 1
  %16 = load i64, i64* %length11, align 8
  %17 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call12 = call i64 @fread(i8* %14, i64 1, i64 %16, %struct.__sFILE* %17)
  store i64 %call12, i64* %bytesRead, align 8
  %18 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8
  %call13 = call i32 @fclose(%struct.__sFILE* %18)
  %19 = load i64, i64* %bytesRead, align 8
  %20 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length14 = getelementptr inbounds %struct.File, %struct.File* %20, i32 0, i32 1
  %21 = load i64, i64* %length14, align 8
  %cmp15 = icmp ult i64 %19, %21
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end7
  %22 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer17 = getelementptr inbounds %struct.File, %struct.File* %22, i32 0, i32 0
  %23 = load i8*, i8** %buffer17, align 8
  %call18 = call i8* @objz_realloc(i8* %23, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 342)
  store i1 false, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end7
  %24 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer20 = getelementptr inbounds %struct.File, %struct.File* %24, i32 0, i32 0
  %25 = load i8*, i8** %buffer20, align 8
  %26 = load %struct.File*, %struct.File** %_file.addr, align 8
  %length21 = getelementptr inbounds %struct.File, %struct.File* %26, i32 0, i32 1
  %27 = load i64, i64* %length21, align 8
  %arrayidx = getelementptr inbounds i8, i8* %25, i64 %27
  store i8 0, i8* %arrayidx, align 1
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end19, %if.then16, %if.then5, %if.then
  %28 = load i1, i1* %retval, align 1
  ret i1 %28
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #1

declare i32 @fseek(%struct.__sFILE*, i64, i32) #1

declare i64 @ftell(%struct.__sFILE*) #1

declare i32 @fclose(%struct.__sFILE*) #1

; Function Attrs: noinline nounwind ssp uwtable
define internal i8* @objz_realloc(i8* %_ptr, i64 %_size, i8* %_file, i32 %_line) #0 {
entry:
  %retval = alloca i8*, align 8
  %_ptr.addr = alloca i8*, align 8
  %_size.addr = alloca i64, align 8
  %_file.addr = alloca i8*, align 8
  %_line.addr = alloca i32, align 4
  %result = alloca i8*, align 8
  store i8* %_ptr, i8** %_ptr.addr, align 8
  store i64 %_size, i64* %_size.addr, align 8
  store i8* %_file, i8** %_file.addr, align 8
  store i32 %_line, i32* %_line.addr, align 4
  %0 = load i8*, i8** %_ptr.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %_size.addr, align 8
  %tobool1 = icmp ne i64 %1, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i8* (i8*, i64)*, i8* (i8*, i64)** @s_realloc, align 8
  %tobool2 = icmp ne i8* (i8*, i64)* %2, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load i8* (i8*, i64)*, i8* (i8*, i64)** @s_realloc, align 8
  %4 = load i8*, i8** %_ptr.addr, align 8
  %5 = load i64, i64* %_size.addr, align 8
  %call = call i8* %3(i8* %4, i64 %5)
  store i8* %call, i8** %result, align 8
  br label %if.end5

if.else:                                          ; preds = %if.end
  %6 = load i8*, i8** %_ptr.addr, align 8
  %7 = load i64, i64* %_size.addr, align 8
  %call4 = call i8* @realloc(i8* %6, i64 %7) #9
  store i8* %call4, i8** %result, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then3
  %8 = load i64, i64* %_size.addr, align 8
  %cmp = icmp ugt i64 %8, 0
  br i1 %cmp, label %land.lhs.true6, label %if.end10

land.lhs.true6:                                   ; preds = %if.end5
  %9 = load i8*, i8** %result, align 8
  %tobool7 = icmp ne i8* %9, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true6
  %10 = load %struct.__sFILE*, %struct.__sFILE** @__stderrp, align 8
  %11 = load i8*, i8** %_file.addr, align 8
  %12 = load i32, i32* %_line.addr, align 4
  %call9 = call i32 (%struct.__sFILE*, i8*, ...) @fprintf(%struct.__sFILE* %10, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.22, i32 0, i32 0), i8* %11, i32 %12)
  call void @abort() #10
  unreachable

if.end10:                                         ; preds = %land.lhs.true6, %if.end5
  %13 = load i8*, i8** %result, align 8
  store i8* %13, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then
  %14 = load i8*, i8** %retval, align 8
  ret i8* %14
}

declare i64 @fread(i8*, i64, i64, %struct.__sFILE*) #1

; Function Attrs: noinline nounwind ssp uwtable
define void @fileClose(%struct.File* %_file) #0 {
entry:
  %_file.addr = alloca %struct.File*, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8
  %0 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer = getelementptr inbounds %struct.File, %struct.File* %0, i32 0, i32 0
  %1 = load i8*, i8** %buffer, align 8
  %call = call i8* @objz_realloc(i8* %1, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 350)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define i8* @fileReadLine(%struct.File* %_file) #0 {
entry:
  %retval = alloca i8*, align 8
  %_file.addr = alloca %struct.File*, align 8
  %start = alloca i8*, align 8
  %c = alloca i8*, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8
  %0 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer = getelementptr inbounds %struct.File, %struct.File* %0, i32 0, i32 0
  %1 = load i8*, i8** %buffer, align 8
  %2 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos = getelementptr inbounds %struct.File, %struct.File* %2, i32 0, i32 2
  %3 = load i64, i64* %pos, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %3
  %4 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer2 = getelementptr inbounds %struct.File, %struct.File* %5, i32 0, i32 0
  %6 = load i8*, i8** %buffer2, align 8
  %7 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos3 = getelementptr inbounds %struct.File, %struct.File* %7, i32 0, i32 2
  %8 = load i64, i64* %pos3, align 8
  %arrayidx4 = getelementptr inbounds i8, i8* %6, i64 %8
  store i8* %arrayidx4, i8** %start, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end23, %if.end
  %9 = load %struct.File*, %struct.File** %_file.addr, align 8
  %buffer5 = getelementptr inbounds %struct.File, %struct.File* %9, i32 0, i32 0
  %10 = load i8*, i8** %buffer5, align 8
  %11 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos6 = getelementptr inbounds %struct.File, %struct.File* %11, i32 0, i32 2
  %12 = load i64, i64* %pos6, align 8
  %arrayidx7 = getelementptr inbounds i8, i8* %10, i64 %12
  store i8* %arrayidx7, i8** %c, align 8
  %13 = load i8*, i8** %c, align 8
  %14 = load i8, i8* %13, align 1
  %conv8 = sext i8 %14 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.cond
  br label %for.end

if.end12:                                         ; preds = %for.cond
  %15 = load i8*, i8** %c, align 8
  %16 = load i8, i8* %15, align 1
  %conv13 = sext i8 %16 to i32
  %cmp14 = icmp eq i32 %conv13, 13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end12
  %17 = load i8*, i8** %c, align 8
  store i8 0, i8* %17, align 1
  br label %if.end23

if.else:                                          ; preds = %if.end12
  %18 = load i8*, i8** %c, align 8
  %19 = load i8, i8* %18, align 1
  %conv17 = sext i8 %19 to i32
  %cmp18 = icmp eq i32 %conv17, 10
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.else
  %20 = load i8*, i8** %c, align 8
  store i8 0, i8* %20, align 1
  %21 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos21 = getelementptr inbounds %struct.File, %struct.File* %21, i32 0, i32 2
  %22 = load i64, i64* %pos21, align 8
  %inc = add i64 %22, 1
  store i64 %inc, i64* %pos21, align 8
  br label %for.end

if.end22:                                         ; preds = %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then16
  %23 = load %struct.File*, %struct.File** %_file.addr, align 8
  %pos24 = getelementptr inbounds %struct.File, %struct.File* %23, i32 0, i32 2
  %24 = load i64, i64* %pos24, align 8
  %inc25 = add i64 %24, 1
  store i64 %inc25, i64* %pos24, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then20, %if.then11
  %25 = load i8*, i8** %start, align 8
  store i8* %25, i8** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %26 = load i8*, i8** %retval, align 8
  ret i8* %26
}

; Function Attrs: noinline nounwind ssp uwtable
define void @objz_setRealloc(i8* (i8*, i64)* %_realloc) #0 {
entry:
  %_realloc.addr = alloca i8* (i8*, i64)*, align 8
  store i8* (i8*, i64)* %_realloc, i8* (i8*, i64)** %_realloc.addr, align 8
  %0 = load i8* (i8*, i64)*, i8* (i8*, i64)** %_realloc.addr, align 8
  store i8* (i8*, i64)* %0, i8* (i8*, i64)** @s_realloc, align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define void @objz_setIndexFormat(i32 %_format) #0 {
entry:
  %_format.addr = alloca i32, align 4
  store i32 %_format, i32* %_format.addr, align 4
  %0 = load i32, i32* %_format.addr, align 4
  store i32 %0, i32* @s_indexFormat, align 4
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define void @objz_setVertexFormat(i64 %_stride, i64 %_positionOffset, i64 %_texcoordOffset, i64 %_normalOffset) #0 {
entry:
  %_stride.addr = alloca i64, align 8
  %_positionOffset.addr = alloca i64, align 8
  %_texcoordOffset.addr = alloca i64, align 8
  %_normalOffset.addr = alloca i64, align 8
  store i64 %_stride, i64* %_stride.addr, align 8
  store i64 %_positionOffset, i64* %_positionOffset.addr, align 8
  store i64 %_texcoordOffset, i64* %_texcoordOffset.addr, align 8
  store i64 %_normalOffset, i64* %_normalOffset.addr, align 8
  %0 = load i64, i64* %_stride.addr, align 8
  store i64 %0, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8
  %1 = load i64, i64* %_positionOffset.addr, align 8
  store i64 %1, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %2 = load i64, i64* %_texcoordOffset.addr, align 8
  store i64 %2, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %3 = load i64, i64* %_normalOffset.addr, align 8
  store i64 %3, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define %struct.objzModel* @objz_load(i8* %_filename) #0 {
entry:
  %retval = alloca %struct.objzModel*, align 8
  %_filename.addr = alloca i8*, align 8
  %file = alloca %struct.File, align 8
  %bom32 = alloca i32*, align 8
  %bom16 = alloca i16*, align 8
  %materialLibs = alloca %struct.Array, align 8
  %materials = alloca %struct.Array, align 8
  %tempObjects = alloca %struct.Array, align 8
  %positions = alloca %struct.ChunkedArray, align 8
  %texcoords = alloca %struct.ChunkedArray, align 8
  %normals = alloca %struct.ChunkedArray, align 8
  %faces = alloca %struct.ChunkedArray, align 8
  %faceIndices = alloca %struct.Array, align 8
  %tempFaceIndices = alloca %struct.Array, align 8
  %generateNormals = alloca i8, align 1
  %currentGroupName = alloca [64 x i8], align 16
  %currentObjectName = alloca [64 x i8], align 16
  %currentMaterialIndex = alloca i32, align 4
  %currentSmoothingGroup = alloca i16, align 2
  %flags = alloca i32, align 4
  %lexer = alloca %struct.Lexer, align 8
  %token = alloca %struct.Token, align 4
  %line = alloca i8*, align 8
  %o = alloca %struct.TempObject, align 4
  %object = alloca %struct.TempObject*, align 8
  %tripletToken = alloca %struct.Token, align 4
  %rawTriplet = alloca [3 x i32], align 4
  %triplet = alloca %struct.IndexTriplet, align 4
  %face = alloca %struct.Face, align 4
  %i = alloca i32, align 4
  %prevFacesLength = alloca i32, align 4
  %isGroup = alloca i8, align 1
  %o141 = alloca %struct.TempObject, align 4
  %alreadyLoaded = alloca i8, align 1
  %i194 = alloca i32, align 4
  %i269 = alloca i32, align 4
  %mat = alloca %struct.objzMaterial*, align 8
  %pos = alloca [3 x float], align 4
  %normal = alloca [3 x float], align 4
  %texcoord = alloca [2 x float], align 4
  %faceNormals = alloca %struct.Array, align 8
  %i346 = alloca i32, align 4
  %tempObject = alloca %struct.TempObject*, align 8
  %j = alloca i32, align 4
  %face362 = alloca %struct.Face*, align 8
  %edge0 = alloca %struct.vec3, align 4
  %edge1 = alloca %struct.vec3, align 4
  %normal366 = alloca %struct.vec3, align 4
  %p0 = alloca %struct.vec3*, align 8
  %p1 = alloca %struct.vec3*, align 8
  %p2 = alloca %struct.vec3*, align 8
  %meshes = alloca %struct.Array, align 8
  %objects = alloca %struct.Array, align 8
  %indices431 = alloca %struct.Array, align 8
  %vertexHashMap = alloca %struct.VertexHashMap, align 8
  %normalHashMap = alloca %struct.NormalHashMap, align 8
  %maxObjectFaces = alloca i32, align 4
  %i441 = alloca i32, align 4
  %tempObject447 = alloca %struct.TempObject*, align 8
  %i467 = alloca i32, align 4
  %tempObject473 = alloca %struct.TempObject*, align 8
  %object483 = alloca %struct.objzObject, align 4
  %material = alloca i32, align 4
  %mesh = alloca %struct.objzMesh, align 4
  %j502 = alloca i32, align 4
  %face508 = alloca %struct.Face*, align 8
  %faceNormalIndex = alloca i32, align 4
  %k = alloca i32, align 4
  %k553 = alloca i32, align 4
  %triplet558 = alloca %struct.IndexTriplet*, align 8
  %vn562 = alloca i32, align 4
  %normal571 = alloca %struct.vec3, align 4
  %tmp = alloca { <2 x float>, float }, align 8
  %index = alloca i32, align 4
  %prev = alloca %struct.objzObject*, align 8
  %model = alloca %struct.objzModel*, align 8
  %i664 = alloca i32, align 4
  %index671 = alloca i32*, align 8
  %i704 = alloca i32, align 4
  %vOut = alloca i8*, align 8
  %vIn = alloca %struct.HashedVertex*, align 8
  store i8* %_filename, i8** %_filename.addr, align 8
  store i8 0, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16
  %0 = load i8*, i8** %_filename.addr, align 8
  %call = call zeroext i1 @fileOpen(%struct.File* %file, i8* %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %_filename.addr, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.2, i32 0, i32 0), i8* %1)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %buffer = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %2 = load i8*, i8** %buffer, align 8
  %3 = bitcast i8* %2 to i32*
  store i32* %3, i32** %bom32, align 8
  %4 = load i32*, i32** %bom32, align 8
  %5 = load i32, i32* %4, align 4
  %cmp = icmp eq i32 %5, 65279
  br i1 %cmp, label %if.then2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load i32*, i32** %bom32, align 8
  %7 = load i32, i32* %6, align 4
  %cmp1 = icmp eq i32 %7, -131072
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %8 = load i8*, i8** %_filename.addr, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i8* %8)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %buffer4 = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %9 = load i8*, i8** %buffer4, align 8
  %10 = bitcast i8* %9 to i16*
  store i16* %10, i16** %bom16, align 8
  %11 = load i16*, i16** %bom16, align 8
  %12 = load i16, i16* %11, align 2
  %conv = zext i16 %12 to i32
  %cmp5 = icmp eq i32 %conv, 65534
  br i1 %cmp5, label %if.then11, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end3
  %13 = load i16*, i16** %bom16, align 8
  %14 = load i16, i16* %13, align 2
  %conv8 = zext i16 %14 to i32
  %cmp9 = icmp eq i32 %conv8, 65279
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false7, %if.end3
  %15 = load i8*, i8** %_filename.addr, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i8* %15)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

if.end12:                                         ; preds = %lor.lhs.false7
  call void @arrayInit(%struct.Array* %materialLibs, i64 256, i32 1)
  call void @arrayInit(%struct.Array* %materials, i64 568, i32 16)
  call void @arrayInit(%struct.Array* %tempObjects, i64 72, i32 64)
  call void @chunkedArrayInit(%struct.ChunkedArray* %positions, i64 12, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %texcoords, i64 8, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %normals, i64 12, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %faces, i64 40, i32 100000)
  call void @arrayInit(%struct.Array* %faceIndices, i64 12, i32 8)
  call void @arrayInit(%struct.Array* %tempFaceIndices, i64 12, i32 8)
  store i8 0, i8* %generateNormals, align 1
  %16 = bitcast [64 x i8]* %currentGroupName to i8*
  call void @llvm.memset.p0i8.i64(i8* %16, i8 0, i64 64, i32 16, i1 false)
  %17 = bitcast [64 x i8]* %currentObjectName to i8*
  call void @llvm.memset.p0i8.i64(i8* %17, i8 0, i64 64, i32 16, i1 false)
  store i32 -1, i32* %currentMaterialIndex, align 4
  store i16 0, i16* %currentSmoothingGroup, align 2
  store i32 0, i32* %flags, align 4
  call void @initLexer(%struct.Lexer* %lexer)
  br label %for.cond

for.cond:                                         ; preds = %if.end336, %if.end12
  %call13 = call i8* @fileReadLine(%struct.File* %file)
  store i8* %call13, i8** %line, align 8
  %18 = load i8*, i8** %line, align 8
  %tobool = icmp ne i8* %18, null
  br i1 %tobool, label %if.end15, label %if.then14

if.then14:                                        ; preds = %for.cond
  br label %for.end337

if.end15:                                         ; preds = %for.cond
  %19 = load i8*, i8** %line, align 8
  call void @lexerSetLine(%struct.Lexer* %lexer, i8* %19)
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call16 = call i32 @strcasecmp(i8* %arraydecay, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.else91

if.then19:                                        ; preds = %if.end15
  %length = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %20 = load i32, i32* %length, align 8
  %cmp20 = icmp eq i32 %20, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then19
  %name = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 0
  %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* %name, i64 0, i64 0
  store i8 0, i8* %arrayidx, align 4
  %numFaces = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 2
  store i32 0, i32* %numFaces, align 4
  %firstFace = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 1
  store i32 0, i32* %firstFace, align 4
  %21 = bitcast %struct.TempObject* %o to i8*
  call void @arrayAppend(%struct.Array* %tempObjects, i8* %21)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then19
  %data = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %22 = load i8*, i8** %data, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %23 = load i32, i32* %elementSize, align 8
  %length24 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %24 = load i32, i32* %length24, align 8
  %sub = sub i32 %24, 1
  %mul = mul i32 %23, %sub
  %idxprom = zext i32 %mul to i64
  %arrayidx25 = getelementptr inbounds i8, i8* %22, i64 %idxprom
  %25 = bitcast i8* %arrayidx25 to %struct.TempObject*
  store %struct.TempObject* %25, %struct.TempObject** %object, align 8
  %length26 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  store i32 0, i32* %length26, align 8
  br label %for.cond27

for.cond27:                                       ; preds = %if.end60, %if.end23
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %tripletToken, i1 zeroext false)
  %text28 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 0
  %arrayidx29 = getelementptr inbounds [256 x i8], [256 x i8]* %text28, i64 0, i64 0
  %26 = load i8, i8* %arrayidx29, align 4
  %conv30 = sext i8 %26 to i32
  %cmp31 = icmp eq i32 %conv30, 0
  br i1 %cmp31, label %if.then33, label %if.end38

if.then33:                                        ; preds = %for.cond27
  %call34 = call zeroext i1 @isEol(%struct.Lexer* %lexer)
  br i1 %call34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then33
  br label %for.end

if.end36:                                         ; preds = %if.then33
  %line37 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 1
  %27 = load i32, i32* %line37, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 2
  %28 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6, i32 0, i32 0), i32 %27, i32 %28)
  br label %error

if.end38:                                         ; preds = %for.cond27
  %arraydecay39 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i32 0, i32 0
  %call40 = call zeroext i1 @parseVertexAttribIndices(%struct.Token* %tripletToken, i32* %arraydecay39)
  br i1 %call40, label %if.end44, label %if.then41

if.then41:                                        ; preds = %if.end38
  %line42 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 1
  %29 = load i32, i32* %line42, align 4
  %column43 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 2
  %30 = load i32, i32* %column43, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6, i32 0, i32 0), i32 %29, i32 %30)
  br label %error

if.end44:                                         ; preds = %if.end38
  %arrayidx45 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 0
  %31 = load i32, i32* %arrayidx45, align 4
  %length46 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %positions, i32 0, i32 3
  %32 = load i32, i32* %length46, align 8
  %call47 = call i32 @fixVertexAttribIndex(i32 %31, i32 %32)
  %v = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 0
  store i32 %call47, i32* %v, align 4
  %arrayidx48 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 1
  %33 = load i32, i32* %arrayidx48, align 4
  %length49 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %texcoords, i32 0, i32 3
  %34 = load i32, i32* %length49, align 8
  %call50 = call i32 @fixVertexAttribIndex(i32 %33, i32 %34)
  %vt = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 1
  store i32 %call50, i32* %vt, align 4
  %arrayidx51 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 2
  %35 = load i32, i32* %arrayidx51, align 4
  %length52 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %36 = load i32, i32* %length52, align 8
  %call53 = call i32 @fixVertexAttribIndex(i32 %35, i32 %36)
  %vn = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 2
  store i32 %call53, i32* %vn, align 4
  %37 = bitcast %struct.IndexTriplet* %triplet to i8*
  call void @arrayAppend(%struct.Array* %faceIndices, i8* %37)
  %vn54 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 2
  %38 = load i32, i32* %vn54, align 4
  %cmp55 = icmp eq i32 %38, -1
  br i1 %cmp55, label %land.lhs.true, label %if.end60

land.lhs.true:                                    ; preds = %if.end44
  %39 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %cmp57 = icmp ne i64 %39, -1
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %land.lhs.true
  store i8 1, i8* %generateNormals, align 1
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %land.lhs.true, %if.end44
  br label %for.cond27

for.end:                                          ; preds = %if.then35
  %length61 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  %40 = load i32, i32* %length61, align 8
  %cmp62 = icmp ult i32 %40, 3
  br i1 %cmp62, label %if.then64, label %if.end67

if.then64:                                        ; preds = %for.end
  %line65 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %41 = load i32, i32* %line65, align 4
  %column66 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %42 = load i32, i32* %column66, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.7, i32 0, i32 0), i32 %41, i32 %42)
  br label %error

if.end67:                                         ; preds = %for.end
  %length68 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  %43 = load i32, i32* %length68, align 8
  %cmp69 = icmp eq i32 %43, 3
  br i1 %cmp69, label %if.then71, label %if.else

if.then71:                                        ; preds = %if.end67
  %44 = load i32, i32* %currentMaterialIndex, align 4
  %conv72 = trunc i32 %44 to i16
  %materialIndex = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 0
  store i16 %conv72, i16* %materialIndex, align 4
  %45 = load i16, i16* %currentSmoothingGroup, align 2
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 1
  store i16 %45, i16* %smoothingGroup, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond73

for.cond73:                                       ; preds = %for.inc, %if.then71
  %46 = load i32, i32* %i, align 4
  %cmp74 = icmp slt i32 %46, 3
  br i1 %cmp74, label %for.body, label %for.end83

for.body:                                         ; preds = %for.cond73
  %indices = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 2
  %47 = load i32, i32* %i, align 4
  %idxprom76 = sext i32 %47 to i64
  %arrayidx77 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices, i64 0, i64 %idxprom76
  %data78 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 0
  %48 = load i8*, i8** %data78, align 8
  %elementSize79 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 3
  %49 = load i32, i32* %elementSize79, align 8
  %50 = load i32, i32* %i, align 4
  %mul80 = mul i32 %49, %50
  %idxprom81 = zext i32 %mul80 to i64
  %arrayidx82 = getelementptr inbounds i8, i8* %48, i64 %idxprom81
  %51 = bitcast i8* %arrayidx82 to %struct.IndexTriplet*
  %52 = bitcast %struct.IndexTriplet* %arrayidx77 to i8*
  %53 = bitcast %struct.IndexTriplet* %51 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* %53, i64 12, i32 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %54 = load i32, i32* %i, align 4
  %inc = add nsw i32 %54, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond73

for.end83:                                        ; preds = %for.cond73
  %55 = bitcast %struct.Face* %face to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %faces, i8* %55)
  %56 = load %struct.TempObject*, %struct.TempObject** %object, align 8
  %numFaces84 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %56, i32 0, i32 2
  %57 = load i32, i32* %numFaces84, align 4
  %inc85 = add i32 %57, 1
  store i32 %inc85, i32* %numFaces84, align 4
  br label %if.end90

if.else:                                          ; preds = %if.end67
  %length86 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %58 = load i32, i32* %length86, align 8
  store i32 %58, i32* %prevFacesLength, align 4
  %59 = load i32, i32* %currentMaterialIndex, align 4
  %60 = load i16, i16* %currentSmoothingGroup, align 2
  call void @triangulate(%struct.Array* %faceIndices, %struct.ChunkedArray* %positions, %struct.Array* %tempFaceIndices, %struct.ChunkedArray* %faces, i32 %59, i16 zeroext %60)
  %length87 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %61 = load i32, i32* %length87, align 8
  %62 = load i32, i32* %prevFacesLength, align 4
  %sub88 = sub i32 %61, %62
  %63 = load %struct.TempObject*, %struct.TempObject** %object, align 8
  %numFaces89 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %63, i32 0, i32 2
  %64 = load i32, i32* %numFaces89, align 4
  %add = add i32 %64, %sub88
  store i32 %add, i32* %numFaces89, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.else, %for.end83
  br label %if.end336

if.else91:                                        ; preds = %if.end15
  %text92 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay93 = getelementptr inbounds [256 x i8], [256 x i8]* %text92, i32 0, i32 0
  %call94 = call i32 @strcasecmp(i8* %arraydecay93, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  %cmp95 = icmp eq i32 %call94, 0
  br i1 %cmp95, label %if.then103, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.else91
  %text98 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay99 = getelementptr inbounds [256 x i8], [256 x i8]* %text98, i32 0, i32 0
  %call100 = call i32 @strcasecmp(i8* %arraydecay99, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0))
  %cmp101 = icmp eq i32 %call100, 0
  br i1 %cmp101, label %if.then103, label %if.else178

if.then103:                                       ; preds = %lor.lhs.false97, %if.else91
  %text104 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay105 = getelementptr inbounds [256 x i8], [256 x i8]* %text104, i32 0, i32 0
  %call106 = call i32 @strcasecmp(i8* %arraydecay105, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  %cmp107 = icmp eq i32 %call106, 0
  %frombool = zext i1 %cmp107 to i8
  store i8 %frombool, i8* %isGroup, align 1
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext true)
  %65 = load i8, i8* %isGroup, align 1
  %tobool109 = trunc i8 %65 to i1
  br i1 %tobool109, label %if.then110, label %if.else124

if.then110:                                       ; preds = %if.then103
  %text111 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx112 = getelementptr inbounds [256 x i8], [256 x i8]* %text111, i64 0, i64 0
  %66 = load i8, i8* %arrayidx112, align 4
  %conv113 = sext i8 %66 to i32
  %cmp114 = icmp ne i32 %conv113, 0
  br i1 %cmp114, label %if.then116, label %if.end123

if.then116:                                       ; preds = %if.then110
  %arraydecay117 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %text118 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay119 = getelementptr inbounds [256 x i8], [256 x i8]* %text118, i32 0, i32 0
  %text120 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay121 = getelementptr inbounds [256 x i8], [256 x i8]* %text120, i32 0, i32 0
  %call122 = call i64 @strLength(i8* %arraydecay121, i64 256)
  call void @strCopy(i8* %arraydecay117, i64 64, i8* %arraydecay119, i64 %call122)
  br label %if.end123

if.end123:                                        ; preds = %if.then116, %if.then110
  br label %if.end140

if.else124:                                       ; preds = %if.then103
  %text125 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx126 = getelementptr inbounds [256 x i8], [256 x i8]* %text125, i64 0, i64 0
  %67 = load i8, i8* %arrayidx126, align 4
  %conv127 = sext i8 %67 to i32
  %cmp128 = icmp eq i32 %conv127, 0
  br i1 %cmp128, label %if.then130, label %if.end133

if.then130:                                       ; preds = %if.else124
  %line131 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %68 = load i32, i32* %line131, align 4
  %column132 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %69 = load i32, i32* %column132, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.10, i32 0, i32 0), i32 %68, i32 %69)
  br label %error

if.end133:                                        ; preds = %if.else124
  %arraydecay134 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %text135 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay136 = getelementptr inbounds [256 x i8], [256 x i8]* %text135, i32 0, i32 0
  %text137 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay138 = getelementptr inbounds [256 x i8], [256 x i8]* %text137, i32 0, i32 0
  %call139 = call i64 @strLength(i8* %arraydecay138, i64 256)
  call void @strCopy(i8* %arraydecay134, i64 64, i8* %arraydecay136, i64 %call139)
  br label %if.end140

if.end140:                                        ; preds = %if.end133, %if.end123
  %name142 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arrayidx143 = getelementptr inbounds [64 x i8], [64 x i8]* %name142, i64 0, i64 0
  store i8 0, i8* %arrayidx143, align 4
  %arrayidx144 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i64 0, i64 0
  %70 = load i8, i8* %arrayidx144, align 16
  %conv145 = sext i8 %70 to i32
  %cmp146 = icmp ne i32 %conv145, 0
  br i1 %cmp146, label %if.then148, label %if.end154

if.then148:                                       ; preds = %if.end140
  %name149 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay150 = getelementptr inbounds [64 x i8], [64 x i8]* %name149, i32 0, i32 0
  %arraydecay151 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %arraydecay152 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %call153 = call i64 @strLength(i8* %arraydecay152, i64 64)
  call void @strCopy(i8* %arraydecay150, i64 64, i8* %arraydecay151, i64 %call153)
  br label %if.end154

if.end154:                                        ; preds = %if.then148, %if.end140
  %arrayidx155 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i64 0, i64 0
  %71 = load i8, i8* %arrayidx155, align 16
  %conv156 = sext i8 %71 to i32
  %cmp157 = icmp ne i32 %conv156, 0
  br i1 %cmp157, label %if.then159, label %if.end174

if.then159:                                       ; preds = %if.end154
  %name160 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay161 = getelementptr inbounds [64 x i8], [64 x i8]* %name160, i32 0, i32 0
  %call162 = call i64 @strLength(i8* %arraydecay161, i64 64)
  %cmp163 = icmp ugt i64 %call162, 0
  br i1 %cmp163, label %if.then165, label %if.end168

if.then165:                                       ; preds = %if.then159
  %name166 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay167 = getelementptr inbounds [64 x i8], [64 x i8]* %name166, i32 0, i32 0
  call void @strConcat(i8* %arraydecay167, i64 64, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0), i64 1)
  br label %if.end168

if.end168:                                        ; preds = %if.then165, %if.then159
  %name169 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 0
  %arraydecay170 = getelementptr inbounds [64 x i8], [64 x i8]* %name169, i32 0, i32 0
  %arraydecay171 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %arraydecay172 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %call173 = call i64 @strLength(i8* %arraydecay172, i64 64)
  call void @strConcat(i8* %arraydecay170, i64 64, i8* %arraydecay171, i64 %call173)
  br label %if.end174

if.end174:                                        ; preds = %if.end168, %if.end154
  %length175 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %72 = load i32, i32* %length175, align 8
  %firstFace176 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 1
  store i32 %72, i32* %firstFace176, align 4
  %numFaces177 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o141, i32 0, i32 2
  store i32 0, i32* %numFaces177, align 4
  %73 = bitcast %struct.TempObject* %o141 to i8*
  call void @arrayAppend(%struct.Array* %tempObjects, i8* %73)
  br label %if.end335

if.else178:                                       ; preds = %lor.lhs.false97
  %text179 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay180 = getelementptr inbounds [256 x i8], [256 x i8]* %text179, i32 0, i32 0
  %call181 = call i32 @strcasecmp(i8* %arraydecay180, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0))
  %cmp182 = icmp eq i32 %call181, 0
  br i1 %cmp182, label %if.then184, label %if.else225

if.then184:                                       ; preds = %if.else178
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext true)
  %text185 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx186 = getelementptr inbounds [256 x i8], [256 x i8]* %text185, i64 0, i64 0
  %74 = load i8, i8* %arrayidx186, align 4
  %conv187 = sext i8 %74 to i32
  %cmp188 = icmp eq i32 %conv187, 0
  br i1 %cmp188, label %if.then190, label %if.end193

if.then190:                                       ; preds = %if.then184
  %line191 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %75 = load i32, i32* %line191, align 4
  %column192 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %76 = load i32, i32* %column192, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.13, i32 0, i32 0), i32 %75, i32 %76)
  br label %error

if.end193:                                        ; preds = %if.then184
  store i8 0, i8* %alreadyLoaded, align 1
  store i32 0, i32* %i194, align 4
  br label %for.cond195

for.cond195:                                      ; preds = %for.inc212, %if.end193
  %77 = load i32, i32* %i194, align 4
  %length196 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 1
  %78 = load i32, i32* %length196, align 8
  %cmp197 = icmp ult i32 %77, %78
  br i1 %cmp197, label %for.body199, label %for.end214

for.body199:                                      ; preds = %for.cond195
  %text200 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay201 = getelementptr inbounds [256 x i8], [256 x i8]* %text200, i32 0, i32 0
  %data202 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 0
  %79 = load i8*, i8** %data202, align 8
  %elementSize203 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 3
  %80 = load i32, i32* %elementSize203, align 8
  %81 = load i32, i32* %i194, align 4
  %mul204 = mul i32 %80, %81
  %idxprom205 = zext i32 %mul204 to i64
  %arrayidx206 = getelementptr inbounds i8, i8* %79, i64 %idxprom205
  %call207 = call i32 @strcasecmp(i8* %arraydecay201, i8* %arrayidx206)
  %cmp208 = icmp eq i32 %call207, 0
  br i1 %cmp208, label %if.then210, label %if.end211

if.then210:                                       ; preds = %for.body199
  store i8 1, i8* %alreadyLoaded, align 1
  br label %for.end214

if.end211:                                        ; preds = %for.body199
  br label %for.inc212

for.inc212:                                       ; preds = %if.end211
  %82 = load i32, i32* %i194, align 4
  %inc213 = add i32 %82, 1
  store i32 %inc213, i32* %i194, align 4
  br label %for.cond195

for.end214:                                       ; preds = %if.then210, %for.cond195
  %83 = load i8, i8* %alreadyLoaded, align 1
  %tobool215 = trunc i8 %83 to i1
  br i1 %tobool215, label %if.end224, label %if.then216

if.then216:                                       ; preds = %for.end214
  %84 = load i8*, i8** %_filename.addr, align 8
  %text217 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay218 = getelementptr inbounds [256 x i8], [256 x i8]* %text217, i32 0, i32 0
  %call219 = call zeroext i1 @loadMaterialFile(i8* %84, i8* %arraydecay218, %struct.Array* %materials)
  br i1 %call219, label %if.end221, label %if.then220

if.then220:                                       ; preds = %if.then216
  br label %error

if.end221:                                        ; preds = %if.then216
  %text222 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay223 = getelementptr inbounds [256 x i8], [256 x i8]* %text222, i32 0, i32 0
  call void @arrayAppend(%struct.Array* %materialLibs, i8* %arraydecay223)
  br label %if.end224

if.end224:                                        ; preds = %if.end221, %for.end214
  br label %if.end334

if.else225:                                       ; preds = %if.else178
  %text226 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay227 = getelementptr inbounds [256 x i8], [256 x i8]* %text226, i32 0, i32 0
  %call228 = call i32 @strcasecmp(i8* %arraydecay227, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  %cmp229 = icmp eq i32 %call228, 0
  br i1 %cmp229, label %if.then231, label %if.else253

if.then231:                                       ; preds = %if.else225
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text232 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx233 = getelementptr inbounds [256 x i8], [256 x i8]* %text232, i64 0, i64 0
  %85 = load i8, i8* %arrayidx233, align 4
  %conv234 = sext i8 %85 to i32
  %cmp235 = icmp eq i32 %conv234, 0
  br i1 %cmp235, label %if.then237, label %if.end240

if.then237:                                       ; preds = %if.then231
  %line238 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %86 = load i32, i32* %line238, align 4
  %column239 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %87 = load i32, i32* %column239, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.15, i32 0, i32 0), i32 %86, i32 %87)
  br label %error

if.end240:                                        ; preds = %if.then231
  %text241 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay242 = getelementptr inbounds [256 x i8], [256 x i8]* %text241, i32 0, i32 0
  %call243 = call i32 @strcasecmp(i8* %arraydecay242, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0))
  %cmp244 = icmp eq i32 %call243, 0
  br i1 %cmp244, label %if.then246, label %if.else247

if.then246:                                       ; preds = %if.end240
  store i16 0, i16* %currentSmoothingGroup, align 2
  br label %if.end252

if.else247:                                       ; preds = %if.end240
  %text248 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay249 = getelementptr inbounds [256 x i8], [256 x i8]* %text248, i32 0, i32 0
  %call250 = call i32 @atoi(i8* %arraydecay249)
  %conv251 = trunc i32 %call250 to i16
  store i16 %conv251, i16* %currentSmoothingGroup, align 2
  br label %if.end252

if.end252:                                        ; preds = %if.else247, %if.then246
  br label %if.end333

if.else253:                                       ; preds = %if.else225
  %text254 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay255 = getelementptr inbounds [256 x i8], [256 x i8]* %text254, i32 0, i32 0
  %call256 = call i32 @strcasecmp(i8* %arraydecay255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i32 0, i32 0))
  %cmp257 = icmp eq i32 %call256, 0
  br i1 %cmp257, label %if.then259, label %if.else292

if.then259:                                       ; preds = %if.else253
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text260 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx261 = getelementptr inbounds [256 x i8], [256 x i8]* %text260, i64 0, i64 0
  %88 = load i8, i8* %arrayidx261, align 4
  %conv262 = sext i8 %88 to i32
  %cmp263 = icmp eq i32 %conv262, 0
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %if.then259
  %line266 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %89 = load i32, i32* %line266, align 4
  %column267 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %90 = load i32, i32* %column267, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.18, i32 0, i32 0), i32 %89, i32 %90)
  br label %error

if.end268:                                        ; preds = %if.then259
  store i32 -1, i32* %currentMaterialIndex, align 4
  store i32 0, i32* %i269, align 4
  br label %for.cond270

for.cond270:                                      ; preds = %for.inc289, %if.end268
  %91 = load i32, i32* %i269, align 4
  %length271 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %92 = load i32, i32* %length271, align 8
  %cmp272 = icmp ult i32 %91, %92
  br i1 %cmp272, label %for.body274, label %for.end291

for.body274:                                      ; preds = %for.cond270
  %data275 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 0
  %93 = load i8*, i8** %data275, align 8
  %elementSize276 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 3
  %94 = load i32, i32* %elementSize276, align 8
  %95 = load i32, i32* %i269, align 4
  %mul277 = mul i32 %94, %95
  %idxprom278 = zext i32 %mul277 to i64
  %arrayidx279 = getelementptr inbounds i8, i8* %93, i64 %idxprom278
  %96 = bitcast i8* %arrayidx279 to %struct.objzMaterial*
  store %struct.objzMaterial* %96, %struct.objzMaterial** %mat, align 8
  %97 = load %struct.objzMaterial*, %struct.objzMaterial** %mat, align 8
  %name280 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %97, i32 0, i32 0
  %arraydecay281 = getelementptr inbounds [64 x i8], [64 x i8]* %name280, i32 0, i32 0
  %text282 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay283 = getelementptr inbounds [256 x i8], [256 x i8]* %text282, i32 0, i32 0
  %call284 = call i32 @strcasecmp(i8* %arraydecay281, i8* %arraydecay283)
  %cmp285 = icmp eq i32 %call284, 0
  br i1 %cmp285, label %if.then287, label %if.end288

if.then287:                                       ; preds = %for.body274
  %98 = load i32, i32* %i269, align 4
  store i32 %98, i32* %currentMaterialIndex, align 4
  br label %for.end291

if.end288:                                        ; preds = %for.body274
  br label %for.inc289

for.inc289:                                       ; preds = %if.end288
  %99 = load i32, i32* %i269, align 4
  %inc290 = add i32 %99, 1
  store i32 %inc290, i32* %i269, align 4
  br label %for.cond270

for.end291:                                       ; preds = %if.then287, %for.cond270
  br label %if.end332

if.else292:                                       ; preds = %if.else253
  %text293 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay294 = getelementptr inbounds [256 x i8], [256 x i8]* %text293, i32 0, i32 0
  %call295 = call i32 @strcasecmp(i8* %arraydecay294, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.19, i32 0, i32 0))
  %cmp296 = icmp eq i32 %call295, 0
  br i1 %cmp296, label %if.then298, label %if.else304

if.then298:                                       ; preds = %if.else292
  %arraydecay299 = getelementptr inbounds [3 x float], [3 x float]* %pos, i32 0, i32 0
  %call300 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay299, i32 3)
  br i1 %call300, label %if.end302, label %if.then301

if.then301:                                       ; preds = %if.then298
  br label %error

if.end302:                                        ; preds = %if.then298
  %arraydecay303 = getelementptr inbounds [3 x float], [3 x float]* %pos, i32 0, i32 0
  %100 = bitcast float* %arraydecay303 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %positions, i8* %100)
  br label %if.end331

if.else304:                                       ; preds = %if.else292
  %text305 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay306 = getelementptr inbounds [256 x i8], [256 x i8]* %text305, i32 0, i32 0
  %call307 = call i32 @strcasecmp(i8* %arraydecay306, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0))
  %cmp308 = icmp eq i32 %call307, 0
  br i1 %cmp308, label %if.then310, label %if.else316

if.then310:                                       ; preds = %if.else304
  %arraydecay311 = getelementptr inbounds [3 x float], [3 x float]* %normal, i32 0, i32 0
  %call312 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay311, i32 3)
  br i1 %call312, label %if.end314, label %if.then313

if.then313:                                       ; preds = %if.then310
  br label %error

if.end314:                                        ; preds = %if.then310
  %arraydecay315 = getelementptr inbounds [3 x float], [3 x float]* %normal, i32 0, i32 0
  %101 = bitcast float* %arraydecay315 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %normals, i8* %101)
  %102 = load i32, i32* %flags, align 4
  %or = or i32 %102, 2
  store i32 %or, i32* %flags, align 4
  br label %if.end330

if.else316:                                       ; preds = %if.else304
  %text317 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay318 = getelementptr inbounds [256 x i8], [256 x i8]* %text317, i32 0, i32 0
  %call319 = call i32 @strcasecmp(i8* %arraydecay318, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0))
  %cmp320 = icmp eq i32 %call319, 0
  br i1 %cmp320, label %if.then322, label %if.end329

if.then322:                                       ; preds = %if.else316
  %arraydecay323 = getelementptr inbounds [2 x float], [2 x float]* %texcoord, i32 0, i32 0
  %call324 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay323, i32 2)
  br i1 %call324, label %if.end326, label %if.then325

if.then325:                                       ; preds = %if.then322
  br label %error

if.end326:                                        ; preds = %if.then322
  %arraydecay327 = getelementptr inbounds [2 x float], [2 x float]* %texcoord, i32 0, i32 0
  %103 = bitcast float* %arraydecay327 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %texcoords, i8* %103)
  %104 = load i32, i32* %flags, align 4
  %or328 = or i32 %104, 1
  store i32 %or328, i32* %flags, align 4
  br label %if.end329

if.end329:                                        ; preds = %if.end326, %if.else316
  br label %if.end330

if.end330:                                        ; preds = %if.end329, %if.end314
  br label %if.end331

if.end331:                                        ; preds = %if.end330, %if.end302
  br label %if.end332

if.end332:                                        ; preds = %if.end331, %for.end291
  br label %if.end333

if.end333:                                        ; preds = %if.end332, %if.end252
  br label %if.end334

if.end334:                                        ; preds = %if.end333, %if.end224
  br label %if.end335

if.end335:                                        ; preds = %if.end334, %if.end174
  br label %if.end336

if.end336:                                        ; preds = %if.end335, %if.end90
  br label %for.cond

for.end337:                                       ; preds = %if.then14
  %length338 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %105 = load i32, i32* %length338, align 8
  %cmp339 = icmp eq i32 %105, 0
  br i1 %cmp339, label %if.then341, label %if.end342

if.then341:                                       ; preds = %for.end337
  store i8 1, i8* %generateNormals, align 1
  br label %if.end342

if.end342:                                        ; preds = %if.then341, %for.end337
  call void @arrayDestroy(%struct.Array* %materialLibs)
  call void @arrayDestroy(%struct.Array* %faceIndices)
  call void @arrayDestroy(%struct.Array* %tempFaceIndices)
  call void @fileClose(%struct.File* %file)
  %length343 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %106 = load i32, i32* %length343, align 8
  call void @arrayInit(%struct.Array* %faceNormals, i64 12, i32 %106)
  %107 = load i8, i8* %generateNormals, align 1
  %tobool344 = trunc i8 %107 to i1
  br i1 %tobool344, label %if.then345, label %if.end430

if.then345:                                       ; preds = %if.end342
  store i32 0, i32* %i346, align 4
  br label %for.cond347

for.cond347:                                      ; preds = %for.inc427, %if.then345
  %108 = load i32, i32* %i346, align 4
  %length348 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %109 = load i32, i32* %length348, align 8
  %cmp349 = icmp ult i32 %108, %109
  br i1 %cmp349, label %for.body351, label %for.end429

for.body351:                                      ; preds = %for.cond347
  %data352 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %110 = load i8*, i8** %data352, align 8
  %elementSize353 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %111 = load i32, i32* %elementSize353, align 8
  %112 = load i32, i32* %i346, align 4
  %mul354 = mul i32 %111, %112
  %idxprom355 = zext i32 %mul354 to i64
  %arrayidx356 = getelementptr inbounds i8, i8* %110, i64 %idxprom355
  %113 = bitcast i8* %arrayidx356 to %struct.TempObject*
  store %struct.TempObject* %113, %struct.TempObject** %tempObject, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond357

for.cond357:                                      ; preds = %for.inc424, %for.body351
  %114 = load i32, i32* %j, align 4
  %115 = load %struct.TempObject*, %struct.TempObject** %tempObject, align 8
  %numFaces358 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %115, i32 0, i32 2
  %116 = load i32, i32* %numFaces358, align 4
  %cmp359 = icmp ult i32 %114, %116
  br i1 %cmp359, label %for.body361, label %for.end426

for.body361:                                      ; preds = %for.cond357
  %117 = load %struct.TempObject*, %struct.TempObject** %tempObject, align 8
  %firstFace363 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %117, i32 0, i32 1
  %118 = load i32, i32* %firstFace363, align 4
  %119 = load i32, i32* %j, align 4
  %add364 = add i32 %118, %119
  %call365 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %faces, i32 %add364)
  %120 = bitcast i8* %call365 to %struct.Face*
  store %struct.Face* %120, %struct.Face** %face362, align 8
  %121 = load %struct.Face*, %struct.Face** %face362, align 8
  %indices367 = getelementptr inbounds %struct.Face, %struct.Face* %121, i32 0, i32 2
  %arrayidx368 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices367, i64 0, i64 0
  %v369 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx368, i32 0, i32 0
  %122 = load i32, i32* %v369, align 4
  %call370 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %122)
  %123 = bitcast i8* %call370 to %struct.vec3*
  store %struct.vec3* %123, %struct.vec3** %p0, align 8
  %124 = load %struct.Face*, %struct.Face** %face362, align 8
  %indices371 = getelementptr inbounds %struct.Face, %struct.Face* %124, i32 0, i32 2
  %arrayidx372 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices371, i64 0, i64 1
  %v373 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx372, i32 0, i32 0
  %125 = load i32, i32* %v373, align 4
  %call374 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %125)
  %126 = bitcast i8* %call374 to %struct.vec3*
  store %struct.vec3* %126, %struct.vec3** %p1, align 8
  %127 = load %struct.Face*, %struct.Face** %face362, align 8
  %indices375 = getelementptr inbounds %struct.Face, %struct.Face* %127, i32 0, i32 2
  %arrayidx376 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices375, i64 0, i64 2
  %v377 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx376, i32 0, i32 0
  %128 = load i32, i32* %v377, align 4
  %call378 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %128)
  %129 = bitcast i8* %call378 to %struct.vec3*
  store %struct.vec3* %129, %struct.vec3** %p2, align 8
  %130 = load %struct.vec3*, %struct.vec3** %p1, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %130, i32 0, i32 0
  %131 = load float, float* %x, align 4
  %132 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %x379 = getelementptr inbounds %struct.vec3, %struct.vec3* %132, i32 0, i32 0
  %133 = load float, float* %x379, align 4
  %sub380 = fsub float %131, %133
  %x381 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  store float %sub380, float* %x381, align 4
  %134 = load %struct.vec3*, %struct.vec3** %p1, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %134, i32 0, i32 1
  %135 = load float, float* %y, align 4
  %136 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %y382 = getelementptr inbounds %struct.vec3, %struct.vec3* %136, i32 0, i32 1
  %137 = load float, float* %y382, align 4
  %sub383 = fsub float %135, %137
  %y384 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  store float %sub383, float* %y384, align 4
  %138 = load %struct.vec3*, %struct.vec3** %p1, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %138, i32 0, i32 2
  %139 = load float, float* %z, align 4
  %140 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %z385 = getelementptr inbounds %struct.vec3, %struct.vec3* %140, i32 0, i32 2
  %141 = load float, float* %z385, align 4
  %sub386 = fsub float %139, %141
  %z387 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  store float %sub386, float* %z387, align 4
  %142 = load %struct.vec3*, %struct.vec3** %p2, align 8
  %x388 = getelementptr inbounds %struct.vec3, %struct.vec3* %142, i32 0, i32 0
  %143 = load float, float* %x388, align 4
  %144 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %x389 = getelementptr inbounds %struct.vec3, %struct.vec3* %144, i32 0, i32 0
  %145 = load float, float* %x389, align 4
  %sub390 = fsub float %143, %145
  %x391 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  store float %sub390, float* %x391, align 4
  %146 = load %struct.vec3*, %struct.vec3** %p2, align 8
  %y392 = getelementptr inbounds %struct.vec3, %struct.vec3* %146, i32 0, i32 1
  %147 = load float, float* %y392, align 4
  %148 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %y393 = getelementptr inbounds %struct.vec3, %struct.vec3* %148, i32 0, i32 1
  %149 = load float, float* %y393, align 4
  %sub394 = fsub float %147, %149
  %y395 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  store float %sub394, float* %y395, align 4
  %150 = load %struct.vec3*, %struct.vec3** %p2, align 8
  %z396 = getelementptr inbounds %struct.vec3, %struct.vec3* %150, i32 0, i32 2
  %151 = load float, float* %z396, align 4
  %152 = load %struct.vec3*, %struct.vec3** %p0, align 8
  %z397 = getelementptr inbounds %struct.vec3, %struct.vec3* %152, i32 0, i32 2
  %153 = load float, float* %z397, align 4
  %sub398 = fsub float %151, %153
  %z399 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  store float %sub398, float* %z399, align 4
  %y400 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  %154 = load float, float* %y400, align 4
  %z401 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  %155 = load float, float* %z401, align 4
  %mul402 = fmul float %154, %155
  %z403 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  %156 = load float, float* %z403, align 4
  %y404 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  %157 = load float, float* %y404, align 4
  %mul405 = fmul float %156, %157
  %sub406 = fsub float %mul402, %mul405
  %x407 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal366, i32 0, i32 0
  store float %sub406, float* %x407, align 4
  %z408 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  %158 = load float, float* %z408, align 4
  %x409 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  %159 = load float, float* %x409, align 4
  %mul410 = fmul float %158, %159
  %x411 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  %160 = load float, float* %x411, align 4
  %z412 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  %161 = load float, float* %z412, align 4
  %mul413 = fmul float %160, %161
  %sub414 = fsub float %mul410, %mul413
  %y415 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal366, i32 0, i32 1
  store float %sub414, float* %y415, align 4
  %x416 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  %162 = load float, float* %x416, align 4
  %y417 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  %163 = load float, float* %y417, align 4
  %mul418 = fmul float %162, %163
  %y419 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  %164 = load float, float* %y419, align 4
  %x420 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  %165 = load float, float* %x420, align 4
  %mul421 = fmul float %164, %165
  %sub422 = fsub float %mul418, %mul421
  %z423 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal366, i32 0, i32 2
  store float %sub422, float* %z423, align 4
  call void @vec3Normalize(%struct.vec3* %normal366, %struct.vec3* %normal366)
  %166 = bitcast %struct.vec3* %normal366 to i8*
  call void @arrayAppend(%struct.Array* %faceNormals, i8* %166)
  br label %for.inc424

for.inc424:                                       ; preds = %for.body361
  %167 = load i32, i32* %j, align 4
  %inc425 = add i32 %167, 1
  store i32 %inc425, i32* %j, align 4
  br label %for.cond357

for.end426:                                       ; preds = %for.cond357
  br label %for.inc427

for.inc427:                                       ; preds = %for.end426
  %168 = load i32, i32* %i346, align 4
  %inc428 = add i32 %168, 1
  store i32 %inc428, i32* %i346, align 4
  br label %for.cond347

for.end429:                                       ; preds = %for.cond347
  br label %if.end430

if.end430:                                        ; preds = %for.end429, %if.end342
  %length432 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %169 = load i32, i32* %length432, align 8
  %mul433 = mul i32 %169, 4
  call void @arrayInit(%struct.Array* %meshes, i64 12, i32 %mul433)
  %length434 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %170 = load i32, i32* %length434, align 8
  call void @arrayInit(%struct.Array* %objects, i64 88, i32 %170)
  %length435 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %171 = load i32, i32* %length435, align 8
  %mul436 = mul i32 %171, 3
  call void @arrayInit(%struct.Array* %indices431, i64 4, i32 %mul436)
  %length437 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %positions, i32 0, i32 3
  %172 = load i32, i32* %length437, align 8
  %mul438 = mul i32 %172, 2
  call void @vertexHashMapInit(%struct.VertexHashMap* %vertexHashMap, i32 %mul438)
  %173 = load i8, i8* %generateNormals, align 1
  %tobool439 = trunc i8 %173 to i1
  br i1 %tobool439, label %if.then440, label %if.end466

if.then440:                                       ; preds = %if.end430
  store i32 0, i32* %maxObjectFaces, align 4
  store i32 0, i32* %i441, align 4
  br label %for.cond442

for.cond442:                                      ; preds = %for.inc457, %if.then440
  %174 = load i32, i32* %i441, align 4
  %length443 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %175 = load i32, i32* %length443, align 8
  %cmp444 = icmp ult i32 %174, %175
  br i1 %cmp444, label %for.body446, label %for.end459

for.body446:                                      ; preds = %for.cond442
  %data448 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %176 = load i8*, i8** %data448, align 8
  %elementSize449 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %177 = load i32, i32* %elementSize449, align 8
  %178 = load i32, i32* %i441, align 4
  %mul450 = mul i32 %177, %178
  %idxprom451 = zext i32 %mul450 to i64
  %arrayidx452 = getelementptr inbounds i8, i8* %176, i64 %idxprom451
  %179 = bitcast i8* %arrayidx452 to %struct.TempObject*
  store %struct.TempObject* %179, %struct.TempObject** %tempObject447, align 8
  %180 = load i32, i32* %maxObjectFaces, align 4
  %181 = load %struct.TempObject*, %struct.TempObject** %tempObject447, align 8
  %numFaces453 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %181, i32 0, i32 2
  %182 = load i32, i32* %numFaces453, align 4
  %cmp454 = icmp ugt i32 %180, %182
  br i1 %cmp454, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body446
  %183 = load i32, i32* %maxObjectFaces, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body446
  %184 = load %struct.TempObject*, %struct.TempObject** %tempObject447, align 8
  %numFaces456 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %184, i32 0, i32 2
  %185 = load i32, i32* %numFaces456, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %183, %cond.true ], [ %185, %cond.false ]
  store i32 %cond, i32* %maxObjectFaces, align 4
  br label %for.inc457

for.inc457:                                       ; preds = %cond.end
  %186 = load i32, i32* %i441, align 4
  %inc458 = add i32 %186, 1
  store i32 %inc458, i32* %i441, align 4
  br label %for.cond442

for.end459:                                       ; preds = %for.cond442
  %187 = load i32, i32* %maxObjectFaces, align 4
  %cmp460 = icmp ugt i32 %187, 32
  br i1 %cmp460, label %cond.true462, label %cond.false463

cond.true462:                                     ; preds = %for.end459
  %188 = load i32, i32* %maxObjectFaces, align 4
  br label %cond.end464

cond.false463:                                    ; preds = %for.end459
  br label %cond.end464

cond.end464:                                      ; preds = %cond.false463, %cond.true462
  %cond465 = phi i32 [ %188, %cond.true462 ], [ 32, %cond.false463 ]
  call void @normalHashMapInit(%struct.NormalHashMap* %normalHashMap, i32 %cond465, %struct.ChunkedArray* %normals)
  br label %if.end466

if.end466:                                        ; preds = %cond.end464, %if.end430
  store i32 0, i32* %i467, align 4
  br label %for.cond468

for.cond468:                                      ; preds = %for.inc640, %if.end466
  %189 = load i32, i32* %i467, align 4
  %length469 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %190 = load i32, i32* %length469, align 8
  %cmp470 = icmp ult i32 %189, %190
  br i1 %cmp470, label %for.body472, label %for.end642

for.body472:                                      ; preds = %for.cond468
  %data474 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %191 = load i8*, i8** %data474, align 8
  %elementSize475 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %192 = load i32, i32* %elementSize475, align 8
  %193 = load i32, i32* %i467, align 4
  %mul476 = mul i32 %192, %193
  %idxprom477 = zext i32 %mul476 to i64
  %arrayidx478 = getelementptr inbounds i8, i8* %191, i64 %idxprom477
  %194 = bitcast i8* %arrayidx478 to %struct.TempObject*
  store %struct.TempObject* %194, %struct.TempObject** %tempObject473, align 8
  %195 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %numFaces479 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %195, i32 0, i32 2
  %196 = load i32, i32* %numFaces479, align 4
  %tobool480 = icmp ne i32 %196, 0
  br i1 %tobool480, label %if.end482, label %if.then481

if.then481:                                       ; preds = %for.body472
  br label %for.inc640

if.end482:                                        ; preds = %for.body472
  %name484 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 0
  %arraydecay485 = getelementptr inbounds [64 x i8], [64 x i8]* %name484, i32 0, i32 0
  %197 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %name486 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %197, i32 0, i32 0
  %arraydecay487 = getelementptr inbounds [64 x i8], [64 x i8]* %name486, i32 0, i32 0
  %198 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %name488 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %198, i32 0, i32 0
  %arraydecay489 = getelementptr inbounds [64 x i8], [64 x i8]* %name488, i32 0, i32 0
  %call490 = call i64 @strLength(i8* %arraydecay489, i64 64)
  call void @strCopy(i8* %arraydecay485, i64 64, i8* %arraydecay487, i64 %call490)
  %199 = load i8, i8* %generateNormals, align 1
  %tobool491 = trunc i8 %199 to i1
  br i1 %tobool491, label %if.then492, label %if.end493

if.then492:                                       ; preds = %if.end482
  call void @normalHashMapClear(%struct.NormalHashMap* %normalHashMap)
  br label %if.end493

if.end493:                                        ; preds = %if.then492, %if.end482
  %length494 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 1
  %200 = load i32, i32* %length494, align 8
  %firstMesh = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 1
  store i32 %200, i32* %firstMesh, align 4
  %numMeshes = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 2
  store i32 0, i32* %numMeshes, align 4
  store i32 -1, i32* %material, align 4
  br label %for.cond495

for.cond495:                                      ; preds = %for.inc607, %if.end493
  %201 = load i32, i32* %material, align 4
  %length496 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %202 = load i32, i32* %length496, align 8
  %cmp497 = icmp slt i32 %201, %202
  br i1 %cmp497, label %for.body499, label %for.end609

for.body499:                                      ; preds = %for.cond495
  %length500 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %203 = load i32, i32* %length500, align 8
  %firstIndex = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 1
  store i32 %203, i32* %firstIndex, align 4
  %numIndices = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  store i32 0, i32* %numIndices, align 4
  %204 = load i32, i32* %material, align 4
  %materialIndex501 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 0
  store i32 %204, i32* %materialIndex501, align 4
  store i32 0, i32* %j502, align 4
  br label %for.cond503

for.cond503:                                      ; preds = %for.inc597, %for.body499
  %205 = load i32, i32* %j502, align 4
  %206 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %numFaces504 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %206, i32 0, i32 2
  %207 = load i32, i32* %numFaces504, align 4
  %cmp505 = icmp ult i32 %205, %207
  br i1 %cmp505, label %for.body507, label %for.end599

for.body507:                                      ; preds = %for.cond503
  %208 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %firstFace509 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %208, i32 0, i32 1
  %209 = load i32, i32* %firstFace509, align 4
  %210 = load i32, i32* %j502, align 4
  %add510 = add i32 %209, %210
  %call511 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %faces, i32 %add510)
  %211 = bitcast i8* %call511 to %struct.Face*
  store %struct.Face* %211, %struct.Face** %face508, align 8
  %212 = load %struct.Face*, %struct.Face** %face508, align 8
  %materialIndex512 = getelementptr inbounds %struct.Face, %struct.Face* %212, i32 0, i32 0
  %213 = load i16, i16* %materialIndex512, align 4
  %conv513 = sext i16 %213 to i32
  %214 = load i32, i32* %material, align 4
  %conv514 = trunc i32 %214 to i16
  %conv515 = sext i16 %conv514 to i32
  %cmp516 = icmp ne i32 %conv513, %conv515
  br i1 %cmp516, label %if.then518, label %if.end519

if.then518:                                       ; preds = %for.body507
  br label %for.inc597

if.end519:                                        ; preds = %for.body507
  store i32 -1, i32* %faceNormalIndex, align 4
  %215 = load i8, i8* %generateNormals, align 1
  %tobool520 = trunc i8 %215 to i1
  br i1 %tobool520, label %land.lhs.true522, label %if.end552

land.lhs.true522:                                 ; preds = %if.end519
  %216 = load %struct.Face*, %struct.Face** %face508, align 8
  %smoothingGroup523 = getelementptr inbounds %struct.Face, %struct.Face* %216, i32 0, i32 1
  %217 = load i16, i16* %smoothingGroup523, align 2
  %conv524 = zext i16 %217 to i32
  %cmp525 = icmp eq i32 %conv524, 0
  br i1 %cmp525, label %if.then527, label %if.end552

if.then527:                                       ; preds = %land.lhs.true522
  store i32 0, i32* %k, align 4
  br label %for.cond528

for.cond528:                                      ; preds = %for.inc549, %if.then527
  %218 = load i32, i32* %k, align 4
  %cmp529 = icmp slt i32 %218, 3
  br i1 %cmp529, label %for.body531, label %for.end551

for.body531:                                      ; preds = %for.cond528
  %219 = load %struct.Face*, %struct.Face** %face508, align 8
  %indices532 = getelementptr inbounds %struct.Face, %struct.Face* %219, i32 0, i32 2
  %220 = load i32, i32* %k, align 4
  %idxprom533 = sext i32 %220 to i64
  %arrayidx534 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices532, i64 0, i64 %idxprom533
  %vn535 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx534, i32 0, i32 2
  %221 = load i32, i32* %vn535, align 4
  %length536 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %222 = load i32, i32* %length536, align 8
  %cmp537 = icmp uge i32 %221, %222
  br i1 %cmp537, label %if.then539, label %if.end548

if.then539:                                       ; preds = %for.body531
  %data540 = getelementptr inbounds %struct.Array, %struct.Array* %faceNormals, i32 0, i32 0
  %223 = load i8*, i8** %data540, align 8
  %elementSize541 = getelementptr inbounds %struct.Array, %struct.Array* %faceNormals, i32 0, i32 3
  %224 = load i32, i32* %elementSize541, align 8
  %225 = load %struct.TempObject*, %struct.TempObject** %tempObject473, align 8
  %firstFace542 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %225, i32 0, i32 1
  %226 = load i32, i32* %firstFace542, align 4
  %227 = load i32, i32* %j502, align 4
  %add543 = add i32 %226, %227
  %mul544 = mul i32 %224, %add543
  %idxprom545 = zext i32 %mul544 to i64
  %arrayidx546 = getelementptr inbounds i8, i8* %223, i64 %idxprom545
  %228 = bitcast i8* %arrayidx546 to %struct.vec3*
  %call547 = call i32 @normalHashMapInsert(%struct.NormalHashMap* %normalHashMap, %struct.vec3* %228)
  store i32 %call547, i32* %faceNormalIndex, align 4
  br label %for.end551

if.end548:                                        ; preds = %for.body531
  br label %for.inc549

for.inc549:                                       ; preds = %if.end548
  %229 = load i32, i32* %k, align 4
  %inc550 = add nsw i32 %229, 1
  store i32 %inc550, i32* %k, align 4
  br label %for.cond528

for.end551:                                       ; preds = %if.then539, %for.cond528
  br label %if.end552

if.end552:                                        ; preds = %for.end551, %land.lhs.true522, %if.end519
  store i32 0, i32* %k553, align 4
  br label %for.cond554

for.cond554:                                      ; preds = %for.inc594, %if.end552
  %230 = load i32, i32* %k553, align 4
  %cmp555 = icmp slt i32 %230, 3
  br i1 %cmp555, label %for.body557, label %for.end596

for.body557:                                      ; preds = %for.cond554
  %231 = load %struct.Face*, %struct.Face** %face508, align 8
  %indices559 = getelementptr inbounds %struct.Face, %struct.Face* %231, i32 0, i32 2
  %232 = load i32, i32* %k553, align 4
  %idxprom560 = sext i32 %232 to i64
  %arrayidx561 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices559, i64 0, i64 %idxprom560
  store %struct.IndexTriplet* %arrayidx561, %struct.IndexTriplet** %triplet558, align 8
  %233 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %vn563 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %233, i32 0, i32 2
  %234 = load i32, i32* %vn563, align 4
  store i32 %234, i32* %vn562, align 4
  %235 = load i8, i8* %generateNormals, align 1
  %tobool564 = trunc i8 %235 to i1
  br i1 %tobool564, label %if.then565, label %if.end582

if.then565:                                       ; preds = %for.body557
  %236 = load %struct.Face*, %struct.Face** %face508, align 8
  %smoothingGroup566 = getelementptr inbounds %struct.Face, %struct.Face* %236, i32 0, i32 1
  %237 = load i16, i16* %smoothingGroup566, align 2
  %conv567 = zext i16 %237 to i32
  %cmp568 = icmp sgt i32 %conv567, 0
  br i1 %cmp568, label %if.then570, label %if.else576

if.then570:                                       ; preds = %if.then565
  %238 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %v572 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %238, i32 0, i32 0
  %239 = load i32, i32* %v572, align 4
  %240 = load %struct.Face*, %struct.Face** %face508, align 8
  %smoothingGroup573 = getelementptr inbounds %struct.Face, %struct.Face* %240, i32 0, i32 1
  %241 = load i16, i16* %smoothingGroup573, align 2
  %call574 = call { <2 x float>, float } @calculateSmoothNormal(i32 %239, %struct.ChunkedArray* %faces, %struct.Array* %faceNormals, i16 zeroext %241)
  store { <2 x float>, float } %call574, { <2 x float>, float }* %tmp, align 8
  %242 = bitcast { <2 x float>, float }* %tmp to i8*
  %243 = bitcast %struct.vec3* %normal571 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %243, i8* %242, i64 12, i32 4, i1 false)
  %call575 = call i32 @normalHashMapInsert(%struct.NormalHashMap* %normalHashMap, %struct.vec3* %normal571)
  store i32 %call575, i32* %vn562, align 4
  br label %if.end581

if.else576:                                       ; preds = %if.then565
  %244 = load i32, i32* %faceNormalIndex, align 4
  %cmp577 = icmp ne i32 %244, -1
  br i1 %cmp577, label %if.then579, label %if.end580

if.then579:                                       ; preds = %if.else576
  %245 = load i32, i32* %faceNormalIndex, align 4
  store i32 %245, i32* %vn562, align 4
  br label %if.end580

if.end580:                                        ; preds = %if.then579, %if.else576
  br label %if.end581

if.end581:                                        ; preds = %if.end580, %if.then570
  br label %if.end582

if.end582:                                        ; preds = %if.end581, %for.body557
  %246 = load i32, i32* %i467, align 4
  %247 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %v584 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %247, i32 0, i32 0
  %248 = load i32, i32* %v584, align 4
  %249 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet558, align 8
  %vt585 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %249, i32 0, i32 1
  %250 = load i32, i32* %vt585, align 4
  %251 = load i32, i32* %vn562, align 4
  %call586 = call i32 @vertexHashMapInsert(%struct.VertexHashMap* %vertexHashMap, i32 %246, i32 %248, i32 %250, i32 %251)
  store i32 %call586, i32* %index, align 4
  %252 = load i32, i32* %index, align 4
  %cmp587 = icmp ugt i32 %252, 65535
  br i1 %cmp587, label %if.then589, label %if.end591

if.then589:                                       ; preds = %if.end582
  %253 = load i32, i32* %flags, align 4
  %or590 = or i32 %253, 4
  store i32 %or590, i32* %flags, align 4
  br label %if.end591

if.end591:                                        ; preds = %if.then589, %if.end582
  %254 = bitcast i32* %index to i8*
  call void @arrayAppend(%struct.Array* %indices431, i8* %254)
  %numIndices592 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  %255 = load i32, i32* %numIndices592, align 4
  %inc593 = add i32 %255, 1
  store i32 %inc593, i32* %numIndices592, align 4
  br label %for.inc594

for.inc594:                                       ; preds = %if.end591
  %256 = load i32, i32* %k553, align 4
  %inc595 = add nsw i32 %256, 1
  store i32 %inc595, i32* %k553, align 4
  br label %for.cond554

for.end596:                                       ; preds = %for.cond554
  br label %for.inc597

for.inc597:                                       ; preds = %for.end596, %if.then518
  %257 = load i32, i32* %j502, align 4
  %inc598 = add i32 %257, 1
  store i32 %inc598, i32* %j502, align 4
  br label %for.cond503

for.end599:                                       ; preds = %for.cond503
  %numIndices600 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  %258 = load i32, i32* %numIndices600, align 4
  %cmp601 = icmp ugt i32 %258, 0
  br i1 %cmp601, label %if.then603, label %if.end606

if.then603:                                       ; preds = %for.end599
  %259 = bitcast %struct.objzMesh* %mesh to i8*
  call void @arrayAppend(%struct.Array* %meshes, i8* %259)
  %numMeshes604 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 2
  %260 = load i32, i32* %numMeshes604, align 4
  %inc605 = add i32 %260, 1
  store i32 %inc605, i32* %numMeshes604, align 4
  br label %if.end606

if.end606:                                        ; preds = %if.then603, %for.end599
  br label %for.inc607

for.inc607:                                       ; preds = %if.end606
  %261 = load i32, i32* %material, align 4
  %inc608 = add nsw i32 %261, 1
  store i32 %inc608, i32* %material, align 4
  br label %for.cond495

for.end609:                                       ; preds = %for.cond495
  %length610 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %262 = load i32, i32* %length610, align 8
  %cmp611 = icmp ugt i32 %262, 0
  br i1 %cmp611, label %if.then613, label %if.else628

if.then613:                                       ; preds = %for.end609
  %data615 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 0
  %263 = load i8*, i8** %data615, align 8
  %elementSize616 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 3
  %264 = load i32, i32* %elementSize616, align 8
  %length617 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %265 = load i32, i32* %length617, align 8
  %sub618 = sub i32 %265, 1
  %mul619 = mul i32 %264, %sub618
  %idxprom620 = zext i32 %mul619 to i64
  %arrayidx621 = getelementptr inbounds i8, i8* %263, i64 %idxprom620
  %266 = bitcast i8* %arrayidx621 to %struct.objzObject*
  store %struct.objzObject* %266, %struct.objzObject** %prev, align 8
  %267 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %firstIndex622 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %267, i32 0, i32 3
  %268 = load i32, i32* %firstIndex622, align 4
  %269 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %numIndices623 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %269, i32 0, i32 4
  %270 = load i32, i32* %numIndices623, align 4
  %add624 = add i32 %268, %270
  %firstIndex625 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 3
  store i32 %add624, i32* %firstIndex625, align 4
  %271 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %firstVertex = getelementptr inbounds %struct.objzObject, %struct.objzObject* %271, i32 0, i32 5
  %272 = load i32, i32* %firstVertex, align 4
  %273 = load %struct.objzObject*, %struct.objzObject** %prev, align 8
  %numVertices = getelementptr inbounds %struct.objzObject, %struct.objzObject* %273, i32 0, i32 6
  %274 = load i32, i32* %numVertices, align 4
  %add626 = add i32 %272, %274
  %firstVertex627 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 5
  store i32 %add626, i32* %firstVertex627, align 4
  br label %if.end631

if.else628:                                       ; preds = %for.end609
  %firstIndex629 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 3
  store i32 0, i32* %firstIndex629, align 4
  %firstVertex630 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 5
  store i32 0, i32* %firstVertex630, align 4
  br label %if.end631

if.end631:                                        ; preds = %if.else628, %if.then613
  %length632 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %275 = load i32, i32* %length632, align 8
  %firstIndex633 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 3
  %276 = load i32, i32* %firstIndex633, align 4
  %sub634 = sub i32 %275, %276
  %numIndices635 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 4
  store i32 %sub634, i32* %numIndices635, align 4
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length636 = getelementptr inbounds %struct.Array, %struct.Array* %vertices, i32 0, i32 1
  %277 = load i32, i32* %length636, align 8
  %firstVertex637 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 5
  %278 = load i32, i32* %firstVertex637, align 4
  %sub638 = sub i32 %277, %278
  %numVertices639 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object483, i32 0, i32 6
  store i32 %sub638, i32* %numVertices639, align 4
  %279 = bitcast %struct.objzObject* %object483 to i8*
  call void @arrayAppend(%struct.Array* %objects, i8* %279)
  br label %for.inc640

for.inc640:                                       ; preds = %if.end631, %if.then481
  %280 = load i32, i32* %i467, align 4
  %inc641 = add i32 %280, 1
  store i32 %inc641, i32* %i467, align 4
  br label %for.cond468

for.end642:                                       ; preds = %for.cond468
  %281 = load i8, i8* %generateNormals, align 1
  %tobool643 = trunc i8 %281 to i1
  br i1 %tobool643, label %if.then644, label %if.end645

if.then644:                                       ; preds = %for.end642
  call void @normalHashMapDestroy(%struct.NormalHashMap* %normalHashMap)
  br label %if.end645

if.end645:                                        ; preds = %if.then644, %for.end642
  call void @arrayDestroy(%struct.Array* %tempObjects)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %faces)
  call void @arrayDestroy(%struct.Array* %faceNormals)
  %call647 = call i8* @objz_realloc(i8* null, i64 88, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1181)
  %282 = bitcast i8* %call647 to %struct.objzModel*
  store %struct.objzModel* %282, %struct.objzModel** %model, align 8
  %283 = load i32, i32* %flags, align 4
  %284 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %flags648 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %284, i32 0, i32 0
  store i32 %283, i32* %flags648, align 8
  %285 = load i32, i32* @s_indexFormat, align 4
  %cmp649 = icmp eq i32 %285, 1
  br i1 %cmp649, label %if.then653, label %lor.lhs.false651

lor.lhs.false651:                                 ; preds = %if.end645
  %286 = load i32, i32* %flags, align 4
  %and = and i32 %286, 4
  %tobool652 = icmp ne i32 %and, 0
  br i1 %tobool652, label %if.then653, label %if.else656

if.then653:                                       ; preds = %lor.lhs.false651, %if.end645
  %data654 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 0
  %287 = load i8*, i8** %data654, align 8
  %288 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %indices655 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %288, i32 0, i32 1
  store i8* %287, i8** %indices655, align 8
  br label %if.end684

if.else656:                                       ; preds = %lor.lhs.false651
  %289 = load i32, i32* %flags, align 4
  %and657 = and i32 %289, -5
  store i32 %and657, i32* %flags, align 4
  %length658 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %290 = load i32, i32* %length658, align 8
  %conv659 = zext i32 %290 to i64
  %mul660 = mul i64 2, %conv659
  %call661 = call i8* @objz_realloc(i8* null, i64 %mul660, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1187)
  %291 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %indices662 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %291, i32 0, i32 1
  store i8* %call661, i8** %indices662, align 8
  store i32 0, i32* %i664, align 4
  br label %for.cond665

for.cond665:                                      ; preds = %for.inc681, %if.else656
  %292 = load i32, i32* %i664, align 4
  %length666 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %293 = load i32, i32* %length666, align 8
  %cmp667 = icmp ult i32 %292, %293
  br i1 %cmp667, label %for.body669, label %for.end683

for.body669:                                      ; preds = %for.cond665
  %data672 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 0
  %294 = load i8*, i8** %data672, align 8
  %elementSize673 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 3
  %295 = load i32, i32* %elementSize673, align 8
  %296 = load i32, i32* %i664, align 4
  %mul674 = mul i32 %295, %296
  %idxprom675 = zext i32 %mul674 to i64
  %arrayidx676 = getelementptr inbounds i8, i8* %294, i64 %idxprom675
  %297 = bitcast i8* %arrayidx676 to i32*
  store i32* %297, i32** %index671, align 8
  %298 = load i32*, i32** %index671, align 8
  %299 = load i32, i32* %298, align 4
  %conv677 = trunc i32 %299 to i16
  %300 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %indices678 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %300, i32 0, i32 1
  %301 = load i8*, i8** %indices678, align 8
  %302 = bitcast i8* %301 to i16*
  %303 = load i32, i32* %i664, align 4
  %idxprom679 = zext i32 %303 to i64
  %arrayidx680 = getelementptr inbounds i16, i16* %302, i64 %idxprom679
  store i16 %conv677, i16* %arrayidx680, align 2
  br label %for.inc681

for.inc681:                                       ; preds = %for.body669
  %304 = load i32, i32* %i664, align 4
  %inc682 = add i32 %304, 1
  store i32 %inc682, i32* %i664, align 4
  br label %for.cond665

for.end683:                                       ; preds = %for.cond665
  call void @arrayDestroy(%struct.Array* %indices431)
  br label %if.end684

if.end684:                                        ; preds = %for.end683, %if.then653
  %length685 = getelementptr inbounds %struct.Array, %struct.Array* %indices431, i32 0, i32 1
  %305 = load i32, i32* %length685, align 8
  %306 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numIndices686 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %306, i32 0, i32 2
  store i32 %305, i32* %numIndices686, align 8
  %data687 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 0
  %307 = load i8*, i8** %data687, align 8
  %308 = bitcast i8* %307 to %struct.objzMaterial*
  %309 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %materials688 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %309, i32 0, i32 3
  store %struct.objzMaterial* %308, %struct.objzMaterial** %materials688, align 8
  %length689 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %310 = load i32, i32* %length689, align 8
  %311 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numMaterials = getelementptr inbounds %struct.objzModel, %struct.objzModel* %311, i32 0, i32 4
  store i32 %310, i32* %numMaterials, align 8
  %data690 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 0
  %312 = load i8*, i8** %data690, align 8
  %313 = bitcast i8* %312 to %struct.objzMesh*
  %314 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %meshes691 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %314, i32 0, i32 5
  store %struct.objzMesh* %313, %struct.objzMesh** %meshes691, align 8
  %length692 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 1
  %315 = load i32, i32* %length692, align 8
  %316 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numMeshes693 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %316, i32 0, i32 6
  store i32 %315, i32* %numMeshes693, align 8
  %data694 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 0
  %317 = load i8*, i8** %data694, align 8
  %318 = bitcast i8* %317 to %struct.objzObject*
  %319 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %objects695 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %319, i32 0, i32 7
  store %struct.objzObject* %318, %struct.objzObject** %objects695, align 8
  %length696 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %320 = load i32, i32* %length696, align 8
  %321 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numObjects = getelementptr inbounds %struct.objzModel, %struct.objzModel* %321, i32 0, i32 8
  store i32 %320, i32* %numObjects, align 8
  %322 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8
  %vertices697 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length698 = getelementptr inbounds %struct.Array, %struct.Array* %vertices697, i32 0, i32 1
  %323 = load i32, i32* %length698, align 8
  %conv699 = zext i32 %323 to i64
  %mul700 = mul i64 %322, %conv699
  %call701 = call i8* @objz_realloc(i8* null, i64 %mul700, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1201)
  %324 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %vertices702 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %324, i32 0, i32 9
  store i8* %call701, i8** %vertices702, align 8
  store i32 0, i32* %i704, align 4
  br label %for.cond705

for.cond705:                                      ; preds = %for.inc769, %if.end684
  %325 = load i32, i32* %i704, align 4
  %vertices706 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length707 = getelementptr inbounds %struct.Array, %struct.Array* %vertices706, i32 0, i32 1
  %326 = load i32, i32* %length707, align 8
  %cmp708 = icmp ult i32 %325, %326
  br i1 %cmp708, label %for.body710, label %for.end771

for.body710:                                      ; preds = %for.cond705
  %327 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %vertices712 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %327, i32 0, i32 9
  %328 = load i8*, i8** %vertices712, align 8
  %329 = load i32, i32* %i704, align 4
  %conv713 = zext i32 %329 to i64
  %330 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8
  %mul714 = mul i64 %conv713, %330
  %arrayidx715 = getelementptr inbounds i8, i8* %328, i64 %mul714
  store i8* %arrayidx715, i8** %vOut, align 8
  %vertices717 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %data718 = getelementptr inbounds %struct.Array, %struct.Array* %vertices717, i32 0, i32 0
  %331 = load i8*, i8** %data718, align 8
  %vertices719 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %elementSize720 = getelementptr inbounds %struct.Array, %struct.Array* %vertices719, i32 0, i32 3
  %332 = load i32, i32* %elementSize720, align 8
  %333 = load i32, i32* %i704, align 4
  %mul721 = mul i32 %332, %333
  %idxprom722 = zext i32 %mul721 to i64
  %arrayidx723 = getelementptr inbounds i8, i8* %331, i64 %idxprom722
  %334 = bitcast i8* %arrayidx723 to %struct.HashedVertex*
  store %struct.HashedVertex* %334, %struct.HashedVertex** %vIn, align 8
  %335 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %cmp724 = icmp ne i64 %335, -1
  br i1 %cmp724, label %if.then726, label %if.end732

if.then726:                                       ; preds = %for.body710
  %336 = load i8*, i8** %vOut, align 8
  %337 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %arrayidx727 = getelementptr inbounds i8, i8* %336, i64 %337
  %338 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %pos728 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %338, i32 0, i32 1
  %339 = load i32, i32* %pos728, align 4
  %call729 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %339)
  %340 = load i8*, i8** %vOut, align 8
  %341 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8
  %arrayidx730 = getelementptr inbounds i8, i8* %340, i64 %341
  %342 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx730, i1 false)
  %call731 = call i8* @__memcpy_chk(i8* %arrayidx727, i8* %call729, i64 12, i64 %342) #7
  br label %if.end732

if.end732:                                        ; preds = %if.then726, %for.body710
  %343 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %cmp733 = icmp ne i64 %343, -1
  br i1 %cmp733, label %if.then735, label %if.end750

if.then735:                                       ; preds = %if.end732
  %344 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %texcoord736 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %344, i32 0, i32 2
  %345 = load i32, i32* %texcoord736, align 4
  %cmp737 = icmp eq i32 %345, -1
  br i1 %cmp737, label %if.then739, label %if.else743

if.then739:                                       ; preds = %if.then735
  %346 = load i8*, i8** %vOut, align 8
  %347 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx740 = getelementptr inbounds i8, i8* %346, i64 %347
  %348 = load i8*, i8** %vOut, align 8
  %349 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx741 = getelementptr inbounds i8, i8* %348, i64 %349
  %350 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx741, i1 false)
  %call742 = call i8* @__memset_chk(i8* %arrayidx740, i32 0, i64 8, i64 %350) #7
  br label %if.end749

if.else743:                                       ; preds = %if.then735
  %351 = load i8*, i8** %vOut, align 8
  %352 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx744 = getelementptr inbounds i8, i8* %351, i64 %352
  %353 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %texcoord745 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %353, i32 0, i32 2
  %354 = load i32, i32* %texcoord745, align 4
  %call746 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %texcoords, i32 %354)
  %355 = load i8*, i8** %vOut, align 8
  %356 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8
  %arrayidx747 = getelementptr inbounds i8, i8* %355, i64 %356
  %357 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx747, i1 false)
  %call748 = call i8* @__memcpy_chk(i8* %arrayidx744, i8* %call746, i64 8, i64 %357) #7
  br label %if.end749

if.end749:                                        ; preds = %if.else743, %if.then739
  br label %if.end750

if.end750:                                        ; preds = %if.end749, %if.end732
  %358 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %cmp751 = icmp ne i64 %358, -1
  br i1 %cmp751, label %if.then753, label %if.end768

if.then753:                                       ; preds = %if.end750
  %359 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %normal754 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %359, i32 0, i32 3
  %360 = load i32, i32* %normal754, align 4
  %cmp755 = icmp eq i32 %360, -1
  br i1 %cmp755, label %if.then757, label %if.else761

if.then757:                                       ; preds = %if.then753
  %361 = load i8*, i8** %vOut, align 8
  %362 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx758 = getelementptr inbounds i8, i8* %361, i64 %362
  %363 = load i8*, i8** %vOut, align 8
  %364 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx759 = getelementptr inbounds i8, i8* %363, i64 %364
  %365 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx759, i1 false)
  %call760 = call i8* @__memset_chk(i8* %arrayidx758, i32 0, i64 12, i64 %365) #7
  br label %if.end767

if.else761:                                       ; preds = %if.then753
  %366 = load i8*, i8** %vOut, align 8
  %367 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx762 = getelementptr inbounds i8, i8* %366, i64 %367
  %368 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8
  %normal763 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %368, i32 0, i32 3
  %369 = load i32, i32* %normal763, align 4
  %call764 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %normals, i32 %369)
  %370 = load i8*, i8** %vOut, align 8
  %371 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8
  %arrayidx765 = getelementptr inbounds i8, i8* %370, i64 %371
  %372 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx765, i1 false)
  %call766 = call i8* @__memcpy_chk(i8* %arrayidx762, i8* %call764, i64 12, i64 %372) #7
  br label %if.end767

if.end767:                                        ; preds = %if.else761, %if.then757
  br label %if.end768

if.end768:                                        ; preds = %if.end767, %if.end750
  br label %for.inc769

for.inc769:                                       ; preds = %if.end768
  %373 = load i32, i32* %i704, align 4
  %inc770 = add i32 %373, 1
  store i32 %inc770, i32* %i704, align 4
  br label %for.cond705

for.end771:                                       ; preds = %for.cond705
  %vertices772 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length773 = getelementptr inbounds %struct.Array, %struct.Array* %vertices772, i32 0, i32 1
  %374 = load i32, i32* %length773, align 8
  %375 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  %numVertices774 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %375, i32 0, i32 10
  store i32 %374, i32* %numVertices774, align 8
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %positions)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %texcoords)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %normals)
  call void @vertexHashMapDestroy(%struct.VertexHashMap* %vertexHashMap)
  %376 = load %struct.objzModel*, %struct.objzModel** %model, align 8
  store %struct.objzModel* %376, %struct.objzModel** %retval, align 8
  br label %return

error:                                            ; preds = %if.then325, %if.then313, %if.then301, %if.then265, %if.then237, %if.then220, %if.then190, %if.then130, %if.then64, %if.then41, %if.end36
  call void @fileClose(%struct.File* %file)
  call void @arrayDestroy(%struct.Array* %materialLibs)
  call void @arrayDestroy(%struct.Array* %materials)
  call void @arrayDestroy(%struct.Array* %tempObjects)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %positions)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %texcoords)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %normals)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %faces)
  call void @arrayDestroy(%struct.Array* %faceIndices)
  call void @arrayDestroy(%struct.Array* %tempFaceIndices)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end771, %if.then11, %if.then2, %if.then
  %377 = load %struct.objzModel*, %struct.objzModel** %retval, align 8
  ret %struct.objzModel* %377
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @appendError(i8* %_format, ...) #0 {
entry:
  %_format.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %buffer = alloca [1024 x i8], align 16
  %newline = alloca i8*, align 8
  store i8* %_format, i8** %_format.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %_format.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %0, %struct.__va_list_tag* %arraydecay3)
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %1 = load i8, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23, i32 0, i32 0), i8** %newline, align 8
  %2 = load i8*, i8** %newline, align 8
  call void @strConcat(i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i64 1024, i8* %2, i64 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %arraydecay6 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %call8 = call i64 @strLength(i8* %arraydecay7, i64 1024)
  call void @strConcat(i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i64 1024, i8* %arraydecay6, i64 %call8)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @arrayInit(%struct.Array* %_array, i64 %_elementSize, i32 %_initialCapacity) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  %_elementSize.addr = alloca i64, align 8
  %_initialCapacity.addr = alloca i32, align 4
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8
  store i64 %_elementSize, i64* %_elementSize.addr, align 8
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  store i8* null, i8** %data, align 8
  %1 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity = getelementptr inbounds %struct.Array, %struct.Array* %1, i32 0, i32 2
  store i32 0, i32* %capacity, align 4
  %2 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 1
  store i32 0, i32* %length, align 8
  %3 = load i64, i64* %_elementSize.addr, align 8
  %conv = trunc i64 %3 to i32
  %4 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 3
  store i32 %conv, i32* %elementSize, align 8
  %5 = load i32, i32* %_initialCapacity.addr, align 4
  %6 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %initialCapacity = getelementptr inbounds %struct.Array, %struct.Array* %6, i32 0, i32 4
  store i32 %5, i32* %initialCapacity, align 4
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @chunkedArrayInit(%struct.ChunkedArray* %_array, i64 %_elementSize, i32 %_chunkLength) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_elementSize.addr = alloca i64, align 8
  %_chunkLength.addr = alloca i32, align 4
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i64 %_elementSize, i64* %_elementSize.addr, align 8
  store i32 %_chunkLength, i32* %_chunkLength.addr, align 4
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 0
  call void @arrayInit(%struct.Array* %chunks, i64 8, i32 32)
  %1 = load i32, i32* %_chunkLength.addr, align 4
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 1
  store i32 %1, i32* %elementsPerChunk, align 8
  %3 = load i64, i64* %_elementSize.addr, align 8
  %4 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %4, i32 0, i32 2
  store i64 %3, i64* %elementSize, align 8
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 3
  store i32 0, i32* %length, align 8
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

; Function Attrs: noinline nounwind ssp uwtable
define internal void @initLexer(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  store i8* null, i8** %buf, align 8
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 2
  store i32 1, i32* %column, align 4
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 1
  store i32 0, i32* %line, align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @lexerSetLine(%struct.Lexer* %_lexer, i8* %_buf) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_buf.addr = alloca i8*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store i8* %_buf, i8** %_buf.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 2
  store i32 1, i32* %column, align 4
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 1
  %2 = load i32, i32* %line, align 8
  %inc = add i32 %2, 1
  store i32 %inc, i32* %line, align 8
  %3 = load i8*, i8** %_buf.addr, align 8
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 0
  store i8* %3, i8** %buf, align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @tokenize(%struct.Lexer* %_lexer, %struct.Token* %_token, i1 zeroext %includeWhitespace) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_token.addr = alloca %struct.Token*, align 8
  %includeWhitespace.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store %struct.Token* %_token, %struct.Token** %_token.addr, align 8
  %frombool = zext i1 %includeWhitespace to i8
  store i8 %frombool, i8* %includeWhitespace.addr, align 1
  store i32 0, i32* %i, align 4
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  call void @skipWhitespace(%struct.Lexer* %0)
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 1
  %2 = load i32, i32* %line, align 8
  %3 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %line1 = getelementptr inbounds %struct.Token, %struct.Token* %3, i32 0, i32 1
  store i32 %2, i32* %line1, align 4
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 2
  %5 = load i32, i32* %column, align 4
  %6 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %column2 = getelementptr inbounds %struct.Token, %struct.Token* %6, i32 0, i32 2
  store i32 %5, i32* %column2, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %7 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call = call zeroext i1 @isEol(%struct.Lexer* %7)
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %8 = load i8, i8* %includeWhitespace.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %9 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call3 = call zeroext i1 @isWhitespace(%struct.Lexer* %9)
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %for.cond
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %10 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %10, i32 0, i32 0
  %11 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %11, i64 0
  %12 = load i8, i8* %arrayidx, align 1
  %13 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text = getelementptr inbounds %struct.Token, %struct.Token* %13, i32 0, i32 0
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  %idxprom = zext i32 %14 to i64
  %arrayidx4 = getelementptr inbounds [256 x i8], [256 x i8]* %text, i64 0, i64 %idxprom
  store i8 %12, i8* %arrayidx4, align 1
  %15 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf5 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %15, i32 0, i32 0
  %16 = load i8*, i8** %buf5, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr, i8** %buf5, align 8
  %17 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column6 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %17, i32 0, i32 2
  %18 = load i32, i32* %column6, align 4
  %inc7 = add i32 %18, 1
  store i32 %inc7, i32* %column6, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then
  %19 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text8 = getelementptr inbounds %struct.Token, %struct.Token* %19, i32 0, i32 0
  %20 = load i32, i32* %i, align 4
  %idxprom9 = zext i32 %20 to i64
  %arrayidx10 = getelementptr inbounds [256 x i8], [256 x i8]* %text8, i64 0, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1
  ret void
}

declare i32 @strcasecmp(i8*, i8*) #1

; Function Attrs: noinline nounwind ssp uwtable
define internal void @arrayAppend(%struct.Array* %_array, i8* %_element) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  %_element.addr = alloca i8*, align 8
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8
  store i8* %_element, i8** %_element.addr, align 8
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 3
  %3 = load i32, i32* %elementSize, align 8
  %4 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %initialCapacity = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 4
  %5 = load i32, i32* %initialCapacity, align 4
  %mul = mul i32 %3, %5
  %conv = zext i32 %mul to i64
  %call = call i8* @objz_realloc(i8* null, i64 %conv, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 187)
  %6 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data1 = getelementptr inbounds %struct.Array, %struct.Array* %6, i32 0, i32 0
  store i8* %call, i8** %data1, align 8
  %7 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %initialCapacity2 = getelementptr inbounds %struct.Array, %struct.Array* %7, i32 0, i32 4
  %8 = load i32, i32* %initialCapacity2, align 4
  %9 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity = getelementptr inbounds %struct.Array, %struct.Array* %9, i32 0, i32 2
  store i32 %8, i32* %capacity, align 4
  br label %if.end15

if.else:                                          ; preds = %entry
  %10 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length = getelementptr inbounds %struct.Array, %struct.Array* %10, i32 0, i32 1
  %11 = load i32, i32* %length, align 8
  %12 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity3 = getelementptr inbounds %struct.Array, %struct.Array* %12, i32 0, i32 2
  %13 = load i32, i32* %capacity3, align 4
  %cmp = icmp eq i32 %11, %13
  br i1 %cmp, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %14 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity6 = getelementptr inbounds %struct.Array, %struct.Array* %14, i32 0, i32 2
  %15 = load i32, i32* %capacity6, align 4
  %mul7 = mul i32 %15, 2
  store i32 %mul7, i32* %capacity6, align 4
  %16 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data8 = getelementptr inbounds %struct.Array, %struct.Array* %16, i32 0, i32 0
  %17 = load i8*, i8** %data8, align 8
  %18 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %capacity9 = getelementptr inbounds %struct.Array, %struct.Array* %18, i32 0, i32 2
  %19 = load i32, i32* %capacity9, align 4
  %20 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize10 = getelementptr inbounds %struct.Array, %struct.Array* %20, i32 0, i32 3
  %21 = load i32, i32* %elementSize10, align 8
  %mul11 = mul i32 %19, %21
  %conv12 = zext i32 %mul11 to i64
  %call13 = call i8* @objz_realloc(i8* %17, i64 %conv12, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 191)
  %22 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data14 = getelementptr inbounds %struct.Array, %struct.Array* %22, i32 0, i32 0
  store i8* %call13, i8** %data14, align 8
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then
  %23 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data16 = getelementptr inbounds %struct.Array, %struct.Array* %23, i32 0, i32 0
  %24 = load i8*, i8** %data16, align 8
  %25 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length17 = getelementptr inbounds %struct.Array, %struct.Array* %25, i32 0, i32 1
  %26 = load i32, i32* %length17, align 8
  %27 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize18 = getelementptr inbounds %struct.Array, %struct.Array* %27, i32 0, i32 3
  %28 = load i32, i32* %elementSize18, align 8
  %mul19 = mul i32 %26, %28
  %idxprom = zext i32 %mul19 to i64
  %arrayidx = getelementptr inbounds i8, i8* %24, i64 %idxprom
  %29 = load i8*, i8** %_element.addr, align 8
  %30 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize20 = getelementptr inbounds %struct.Array, %struct.Array* %30, i32 0, i32 3
  %31 = load i32, i32* %elementSize20, align 8
  %conv21 = zext i32 %31 to i64
  %32 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data22 = getelementptr inbounds %struct.Array, %struct.Array* %32, i32 0, i32 0
  %33 = load i8*, i8** %data22, align 8
  %34 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length23 = getelementptr inbounds %struct.Array, %struct.Array* %34, i32 0, i32 1
  %35 = load i32, i32* %length23, align 8
  %36 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %elementSize24 = getelementptr inbounds %struct.Array, %struct.Array* %36, i32 0, i32 3
  %37 = load i32, i32* %elementSize24, align 8
  %mul25 = mul i32 %35, %37
  %idxprom26 = zext i32 %mul25 to i64
  %arrayidx27 = getelementptr inbounds i8, i8* %33, i64 %idxprom26
  %38 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx27, i1 false)
  %call28 = call i8* @__memcpy_chk(i8* %arrayidx, i8* %29, i64 %conv21, i64 %38) #7
  %39 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %length29 = getelementptr inbounds %struct.Array, %struct.Array* %39, i32 0, i32 1
  %40 = load i32, i32* %length29, align 8
  %inc = add i32 %40, 1
  store i32 %inc, i32* %length29, align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @isEol(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  %1 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 0
  ret i1 %cmp
}

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @parseVertexAttribIndices(%struct.Token* %_token, i32* %_out) #0 {
entry:
  %retval = alloca i1, align 1
  %_token.addr = alloca %struct.Token*, align 8
  %_out.addr = alloca i32*, align 8
  %v = alloca i32*, align 8
  %vt = alloca i32*, align 8
  %vn = alloca i32*, align 8
  %delim = alloca i8*, align 8
  %start = alloca i8*, align 8
  %eol = alloca i8, align 1
  %end = alloca i8*, align 8
  %skipNormal = alloca i8, align 1
  store %struct.Token* %_token, %struct.Token** %_token.addr, align 8
  store i32* %_out, i32** %_out.addr, align 8
  %0 = load i32*, i32** %_out.addr, align 8
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 0
  store i32* %arrayidx, i32** %v, align 8
  %1 = load i32*, i32** %_out.addr, align 8
  %arrayidx1 = getelementptr inbounds i32, i32* %1, i64 1
  store i32* %arrayidx1, i32** %vt, align 8
  %2 = load i32*, i32** %_out.addr, align 8
  %arrayidx2 = getelementptr inbounds i32, i32* %2, i64 2
  store i32* %arrayidx2, i32** %vn, align 8
  %3 = load i32*, i32** %vn, align 8
  store i32 2147483647, i32* %3, align 4
  %4 = load i32*, i32** %vt, align 8
  store i32 2147483647, i32* %4, align 4
  %5 = load i32*, i32** %v, align 8
  store i32 2147483647, i32* %5, align 4
  %6 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text = getelementptr inbounds %struct.Token, %struct.Token* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.24, i32 0, i32 0), i8** %delim, align 8
  %7 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text3 = getelementptr inbounds %struct.Token, %struct.Token* %7, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %text3, i32 0, i32 0
  store i8* %arraydecay4, i8** %start, align 8
  store i8 0, i8* %eol, align 1
  %8 = load i8*, i8** %start, align 8
  %9 = load i8*, i8** %delim, align 8
  %call5 = call i8* @strstr(i8* %8, i8* %9)
  store i8* %call5, i8** %end, align 8
  %10 = load i8*, i8** %end, align 8
  %tobool = icmp ne i8* %10, null
  br i1 %tobool, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %11 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text7 = getelementptr inbounds %struct.Token, %struct.Token* %11, i32 0, i32 0
  %12 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text8 = getelementptr inbounds %struct.Token, %struct.Token* %12, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [256 x i8], [256 x i8]* %text8, i32 0, i32 0
  %call10 = call i64 @strLength(i8* %arraydecay9, i64 256)
  %arrayidx11 = getelementptr inbounds [256 x i8], [256 x i8]* %text7, i64 0, i64 %call10
  store i8* %arrayidx11, i8** %end, align 8
  store i8 1, i8* %eol, align 1
  br label %if.end15

if.else:                                          ; preds = %if.end
  %13 = load i8*, i8** %end, align 8
  %14 = load i8*, i8** %start, align 8
  %cmp12 = icmp eq i8* %13, %14
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.else
  store i1 false, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then6
  %15 = load i8*, i8** %end, align 8
  store i8 0, i8* %15, align 1
  %16 = load i8*, i8** %start, align 8
  %call16 = call i32 @atoi(i8* %16)
  %17 = load i32*, i32** %v, align 8
  store i32 %call16, i32* %17, align 4
  %18 = load i8, i8* %eol, align 1
  %tobool17 = trunc i8 %18 to i1
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  store i1 true, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end15
  %19 = load i8*, i8** %end, align 8
  %add.ptr = getelementptr inbounds i8, i8* %19, i64 1
  store i8* %add.ptr, i8** %start, align 8
  %20 = load i8*, i8** %start, align 8
  %21 = load i8, i8* %20, align 1
  %conv = sext i8 %21 to i32
  %cmp20 = icmp eq i32 %conv, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end19
  store i1 true, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %if.end19
  %22 = load i8*, i8** %start, align 8
  %23 = load i8*, i8** %delim, align 8
  %call24 = call i8* @strstr(i8* %22, i8* %23)
  store i8* %call24, i8** %end, align 8
  store i8 0, i8* %skipNormal, align 1
  %24 = load i8*, i8** %end, align 8
  %tobool25 = icmp ne i8* %24, null
  br i1 %tobool25, label %if.end32, label %if.then26

if.then26:                                        ; preds = %if.end23
  store i8 1, i8* %skipNormal, align 1
  %25 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text27 = getelementptr inbounds %struct.Token, %struct.Token* %25, i32 0, i32 0
  %26 = load %struct.Token*, %struct.Token** %_token.addr, align 8
  %text28 = getelementptr inbounds %struct.Token, %struct.Token* %26, i32 0, i32 0
  %arraydecay29 = getelementptr inbounds [256 x i8], [256 x i8]* %text28, i32 0, i32 0
  %call30 = call i64 @strLength(i8* %arraydecay29, i64 256)
  %sub = sub i64 %call30, 1
  %arrayidx31 = getelementptr inbounds [256 x i8], [256 x i8]* %text27, i64 0, i64 %sub
  store i8* %arrayidx31, i8** %end, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then26, %if.end23
  %27 = load i8*, i8** %end, align 8
  store i8 0, i8* %27, align 1
  %28 = load i8*, i8** %start, align 8
  %29 = load i8*, i8** %end, align 8
  %cmp33 = icmp ne i8* %28, %29
  br i1 %cmp33, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end32
  %30 = load i8*, i8** %start, align 8
  %call36 = call i32 @atoi(i8* %30)
  %31 = load i32*, i32** %vt, align 8
  store i32 %call36, i32* %31, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end32
  %32 = load i8, i8* %skipNormal, align 1
  %tobool38 = trunc i8 %32 to i1
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end37
  store i1 true, i1* %retval, align 1
  br label %return

if.end40:                                         ; preds = %if.end37
  %33 = load i8*, i8** %end, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %33, i64 1
  store i8* %add.ptr41, i8** %start, align 8
  %34 = load i8*, i8** %start, align 8
  %35 = load i8, i8* %34, align 1
  %conv42 = sext i8 %35 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end40
  %36 = load i8*, i8** %start, align 8
  %call46 = call i32 @atoi(i8* %36)
  %37 = load i32*, i32** %vn, align 8
  store i32 %call46, i32* %37, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end40
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end47, %if.then39, %if.then22, %if.then18, %if.then13, %if.then
  %38 = load i1, i1* %retval, align 1
  ret i1 %38
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i32 @fixVertexAttribIndex(i32 %_index, i32 %_n) #0 {
entry:
  %retval = alloca i32, align 4
  %_index.addr = alloca i32, align 4
  %_n.addr = alloca i32, align 4
  store i32 %_index, i32* %_index.addr, align 4
  store i32 %_n, i32* %_n.addr, align 4
  %0 = load i32, i32* %_index.addr, align 4
  %cmp = icmp eq i32 %0, 2147483647
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %_index.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load i32, i32* %_index.addr, align 4
  %3 = load i32, i32* %_n.addr, align 4
  %add = add i32 %2, %3
  store i32 %add, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i32, i32* %_index.addr, align 4
  %sub = sub nsw i32 %4, 1
  store i32 %sub, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: noinline nounwind ssp uwtable
define internal void @chunkedArrayAppend(%struct.ChunkedArray* %_array, i8* %_element) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_element.addr = alloca i8*, align 8
  %newChunk = alloca i8*, align 8
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i8* %_element, i8** %_element.addr, align 8
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 3
  %1 = load i32, i32* %length, align 8
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 0
  %length1 = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 1
  %3 = load i32, i32* %length1, align 8
  %4 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %4, i32 0, i32 1
  %5 = load i32, i32* %elementsPerChunk, align 8
  %mul = mul i32 %3, %5
  %cmp = icmp uge i32 %1, %mul
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %6, i32 0, i32 1
  %7 = load i32, i32* %elementsPerChunk2, align 8
  %conv = zext i32 %7 to i64
  %8 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %8, i32 0, i32 2
  %9 = load i64, i64* %elementSize, align 8
  %mul3 = mul i64 %conv, %9
  %call = call i8* @objz_realloc(i8* null, i64 %mul3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 225)
  store i8* %call, i8** %newChunk, align 8
  %10 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks4 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %10, i32 0, i32 0
  %11 = bitcast i8** %newChunk to i8*
  call void @arrayAppend(%struct.Array* %chunks4, i8* %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks5 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %12, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks5, i32 0, i32 0
  %13 = load i8*, i8** %data, align 8
  %14 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks6 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %14, i32 0, i32 0
  %elementSize7 = getelementptr inbounds %struct.Array, %struct.Array* %chunks6, i32 0, i32 3
  %15 = load i32, i32* %elementSize7, align 8
  %16 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length8 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %16, i32 0, i32 3
  %17 = load i32, i32* %length8, align 8
  %18 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk9 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %18, i32 0, i32 1
  %19 = load i32, i32* %elementsPerChunk9, align 8
  %div = udiv i32 %17, %19
  %mul10 = mul i32 %15, %div
  %idxprom = zext i32 %mul10 to i64
  %arrayidx = getelementptr inbounds i8, i8* %13, i64 %idxprom
  %20 = bitcast i8* %arrayidx to i8**
  store i8** %20, i8*** %chunk, align 8
  %21 = load i8**, i8*** %chunk, align 8
  %22 = load i8*, i8** %21, align 8
  %23 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize11 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %23, i32 0, i32 2
  %24 = load i64, i64* %elementSize11, align 8
  %25 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length12 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %25, i32 0, i32 3
  %26 = load i32, i32* %length12, align 8
  %27 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk13 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %27, i32 0, i32 1
  %28 = load i32, i32* %elementsPerChunk13, align 8
  %rem = urem i32 %26, %28
  %conv14 = zext i32 %rem to i64
  %mul15 = mul i64 %24, %conv14
  %arrayidx16 = getelementptr inbounds i8, i8* %22, i64 %mul15
  %29 = load i8*, i8** %_element.addr, align 8
  %30 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize17 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %30, i32 0, i32 2
  %31 = load i64, i64* %elementSize17, align 8
  %32 = load i8**, i8*** %chunk, align 8
  %33 = load i8*, i8** %32, align 8
  %34 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize18 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %34, i32 0, i32 2
  %35 = load i64, i64* %elementSize18, align 8
  %36 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length19 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %36, i32 0, i32 3
  %37 = load i32, i32* %length19, align 8
  %38 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk20 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %38, i32 0, i32 1
  %39 = load i32, i32* %elementsPerChunk20, align 8
  %rem21 = urem i32 %37, %39
  %conv22 = zext i32 %rem21 to i64
  %mul23 = mul i64 %35, %conv22
  %arrayidx24 = getelementptr inbounds i8, i8* %33, i64 %mul23
  %40 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx24, i1 false)
  %call25 = call i8* @__memcpy_chk(i8* %arrayidx16, i8* %29, i64 %31, i64 %40) #7
  %41 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %length26 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %41, i32 0, i32 3
  %42 = load i32, i32* %length26, align 8
  %inc = add i32 %42, 1
  store i32 %inc, i32* %length26, align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @triangulate(%struct.Array* %_indices, %struct.ChunkedArray* %_positions, %struct.Array* %_tempIndices, %struct.ChunkedArray* %_faces, i32 %_materialIndex, i16 zeroext %_smoothingGroup) #0 {
entry:
  %_indices.addr = alloca %struct.Array*, align 8
  %_positions.addr = alloca %struct.ChunkedArray*, align 8
  %_tempIndices.addr = alloca %struct.Array*, align 8
  %_faces.addr = alloca %struct.ChunkedArray*, align 8
  %_materialIndex.addr = alloca i32, align 4
  %_smoothingGroup.addr = alloca i16, align 2
  %axes = alloca [2 x i32], align 4
  %i = alloca i32, align 4
  %indices = alloca %struct.IndexTriplet*, align 8
  %v = alloca [3 x %struct.vec3], align 16
  %j = alloca i32, align 4
  %edges = alloca [2 x %struct.vec3], align 16
  %corner = alloca %struct.vec3, align 4
  %area = alloca float, align 4
  %i119 = alloca i32, align 4
  %i0 = alloca %struct.IndexTriplet*, align 8
  %i1 = alloca %struct.IndexTriplet*, align 8
  %v0 = alloca float*, align 8
  %v1 = alloca float*, align 8
  %remainingIndices = alloca %struct.Array*, align 8
  %i164 = alloca i32, align 4
  %remainingIterations = alloca i32, align 4
  %previousRemainingIndices = alloca i32, align 4
  %guess_vert = alloca i32, align 4
  %ind = alloca [3 x %struct.IndexTriplet*], align 16
  %vx = alloca [3 x float], align 4
  %vy = alloca [3 x float], align 4
  %i194 = alloca i32, align 4
  %pos = alloca float*, align 8
  %edge0 = alloca [2 x float], align 4
  %edge1 = alloca [2 x float], align 4
  %cross = alloca float, align 4
  %overlap = alloca i8, align 1
  %otherVert = alloca i32, align 4
  %idx = alloca i32, align 4
  %ovi = alloca i32, align 4
  %tx = alloca float, align 4
  %ty = alloca float, align 4
  %face = alloca %struct.Face, align 4
  %i289 = alloca i32, align 4
  %removed_vert_index = alloca i32, align 4
  %remainingIndicesData = alloca %struct.IndexTriplet*, align 8
  %face324 = alloca %struct.Face, align 4
  %i325 = alloca i32, align 4
  store %struct.Array* %_indices, %struct.Array** %_indices.addr, align 8
  store %struct.ChunkedArray* %_positions, %struct.ChunkedArray** %_positions.addr, align 8
  store %struct.Array* %_tempIndices, %struct.Array** %_tempIndices.addr, align 8
  store %struct.ChunkedArray* %_faces, %struct.ChunkedArray** %_faces.addr, align 8
  store i32 %_materialIndex, i32* %_materialIndex.addr, align 4
  store i16 %_smoothingGroup, i16* %_smoothingGroup.addr, align 2
  %0 = bitcast [2 x i32]* %axes to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([2 x i32]* @triangulate.axes to i8*), i64 8, i32 4, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc116, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 1
  %3 = load i32, i32* %length, align 8
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end118

for.body:                                         ; preds = %for.cond
  %4 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 0
  %5 = load i8*, i8** %data, align 8
  %6 = bitcast i8* %5 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %6, %struct.IndexTriplet** %indices, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %7 = load i32, i32* %j, align 4
  %cmp2 = icmp slt i32 %7, 3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %8 = load i32, i32* %j, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 %idxprom
  %9 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %10 = load %struct.IndexTriplet*, %struct.IndexTriplet** %indices, align 8
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %j, align 4
  %add = add i32 %11, %12
  %13 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length4 = getelementptr inbounds %struct.Array, %struct.Array* %13, i32 0, i32 1
  %14 = load i32, i32* %length4, align 8
  %rem = urem i32 %add, %14
  %idxprom5 = zext i32 %rem to i64
  %arrayidx6 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %10, i64 %idxprom5
  %v7 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx6, i32 0, i32 0
  %15 = load i32, i32* %v7, align 4
  %call = call i8* @chunkedArrayElement(%struct.ChunkedArray* %9, i32 %15)
  %16 = bitcast i8* %call to %struct.vec3*
  %17 = bitcast %struct.vec3* %arrayidx to i8*
  %18 = bitcast %struct.vec3* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 12, i32 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %19 = load i32, i32* %j, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %arrayidx8 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx8, i32 0, i32 0
  %20 = load float, float* %x, align 4
  %arrayidx9 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %x10 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx9, i32 0, i32 0
  %21 = load float, float* %x10, align 16
  %sub = fsub float %20, %21
  %arrayidx11 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x12 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx11, i32 0, i32 0
  store float %sub, float* %x12, align 16
  %arrayidx13 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx13, i32 0, i32 1
  %22 = load float, float* %y, align 4
  %arrayidx14 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %y15 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx14, i32 0, i32 1
  %23 = load float, float* %y15, align 4
  %sub16 = fsub float %22, %23
  %arrayidx17 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y18 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx17, i32 0, i32 1
  store float %sub16, float* %y18, align 4
  %arrayidx19 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx19, i32 0, i32 2
  %24 = load float, float* %z, align 4
  %arrayidx20 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %z21 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx20, i32 0, i32 2
  %25 = load float, float* %z21, align 8
  %sub22 = fsub float %24, %25
  %arrayidx23 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z24 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx23, i32 0, i32 2
  store float %sub22, float* %z24, align 8
  %arrayidx25 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %x26 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx25, i32 0, i32 0
  %26 = load float, float* %x26, align 8
  %arrayidx27 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %x28 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx27, i32 0, i32 0
  %27 = load float, float* %x28, align 4
  %sub29 = fsub float %26, %27
  %arrayidx30 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x31 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx30, i32 0, i32 0
  store float %sub29, float* %x31, align 4
  %arrayidx32 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %y33 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx32, i32 0, i32 1
  %28 = load float, float* %y33, align 4
  %arrayidx34 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %y35 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx34, i32 0, i32 1
  %29 = load float, float* %y35, align 4
  %sub36 = fsub float %28, %29
  %arrayidx37 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y38 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx37, i32 0, i32 1
  store float %sub36, float* %y38, align 4
  %arrayidx39 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %z40 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx39, i32 0, i32 2
  %30 = load float, float* %z40, align 8
  %arrayidx41 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %z42 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx41, i32 0, i32 2
  %31 = load float, float* %z42, align 4
  %sub43 = fsub float %30, %31
  %arrayidx44 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z45 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx44, i32 0, i32 2
  store float %sub43, float* %z45, align 4
  %arrayidx46 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y47 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx46, i32 0, i32 1
  %32 = load float, float* %y47, align 4
  %arrayidx48 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z49 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx48, i32 0, i32 2
  %33 = load float, float* %z49, align 4
  %mul = fmul float %32, %33
  %arrayidx50 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z51 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx50, i32 0, i32 2
  %34 = load float, float* %z51, align 8
  %arrayidx52 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y53 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx52, i32 0, i32 1
  %35 = load float, float* %y53, align 4
  %mul54 = fmul float %34, %35
  %sub55 = fsub float %mul, %mul54
  %x56 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  store float %sub55, float* %x56, align 4
  %arrayidx57 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z58 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx57, i32 0, i32 2
  %36 = load float, float* %z58, align 8
  %arrayidx59 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x60 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx59, i32 0, i32 0
  %37 = load float, float* %x60, align 4
  %mul61 = fmul float %36, %37
  %arrayidx62 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x63 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx62, i32 0, i32 0
  %38 = load float, float* %x63, align 16
  %arrayidx64 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z65 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx64, i32 0, i32 2
  %39 = load float, float* %z65, align 4
  %mul66 = fmul float %38, %39
  %sub67 = fsub float %mul61, %mul66
  %y68 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  store float %sub67, float* %y68, align 4
  %arrayidx69 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x70 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx69, i32 0, i32 0
  %40 = load float, float* %x70, align 16
  %arrayidx71 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y72 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx71, i32 0, i32 1
  %41 = load float, float* %y72, align 4
  %mul73 = fmul float %40, %41
  %arrayidx74 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y75 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx74, i32 0, i32 1
  %42 = load float, float* %y75, align 4
  %arrayidx76 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x77 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx76, i32 0, i32 0
  %43 = load float, float* %x77, align 4
  %mul78 = fmul float %42, %43
  %sub79 = fsub float %mul73, %mul78
  %z80 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  store float %sub79, float* %z80, align 4
  %x81 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %44 = load float, float* %x81, align 4
  %call82 = call float @fabsf(float %44) #4
  %x83 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  store float %call82, float* %x83, align 4
  %y84 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %45 = load float, float* %y84, align 4
  %call85 = call float @fabsf(float %45) #4
  %y86 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  store float %call85, float* %y86, align 4
  %z87 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %46 = load float, float* %z87, align 4
  %call88 = call float @fabsf(float %46) #4
  %z89 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  store float %call88, float* %z89, align 4
  %x90 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %47 = load float, float* %x90, align 4
  %cmp91 = fcmp ogt float %47, 0x3E80000000000000
  br i1 %cmp91, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %y92 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %48 = load float, float* %y92, align 4
  %cmp93 = fcmp ogt float %48, 0x3E80000000000000
  br i1 %cmp93, label %if.then, label %lor.lhs.false94

lor.lhs.false94:                                  ; preds = %lor.lhs.false
  %z95 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %49 = load float, float* %z95, align 4
  %cmp96 = fcmp ogt float %49, 0x3E80000000000000
  br i1 %cmp96, label %if.then, label %if.end115

if.then:                                          ; preds = %lor.lhs.false94, %lor.lhs.false, %for.end
  %x97 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %50 = load float, float* %x97, align 4
  %y98 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %51 = load float, float* %y98, align 4
  %cmp99 = fcmp ogt float %50, %51
  br i1 %cmp99, label %land.lhs.true, label %if.then103

land.lhs.true:                                    ; preds = %if.then
  %x100 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %52 = load float, float* %x100, align 4
  %z101 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %53 = load float, float* %z101, align 4
  %cmp102 = fcmp ogt float %52, %53
  br i1 %cmp102, label %if.end114, label %if.then103

if.then103:                                       ; preds = %land.lhs.true, %if.then
  %arrayidx104 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  store i32 0, i32* %arrayidx104, align 4
  %z105 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %54 = load float, float* %z105, align 4
  %x106 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %55 = load float, float* %x106, align 4
  %cmp107 = fcmp ogt float %54, %55
  br i1 %cmp107, label %land.lhs.true108, label %if.end

land.lhs.true108:                                 ; preds = %if.then103
  %z109 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %56 = load float, float* %z109, align 4
  %y110 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %57 = load float, float* %y110, align 4
  %cmp111 = fcmp ogt float %56, %57
  br i1 %cmp111, label %if.then112, label %if.end

if.then112:                                       ; preds = %land.lhs.true108
  %arrayidx113 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  store i32 1, i32* %arrayidx113, align 4
  br label %if.end

if.end:                                           ; preds = %if.then112, %land.lhs.true108, %if.then103
  br label %if.end114

if.end114:                                        ; preds = %if.end, %land.lhs.true
  br label %for.end118

if.end115:                                        ; preds = %lor.lhs.false94
  br label %for.inc116

for.inc116:                                       ; preds = %if.end115
  %58 = load i32, i32* %i, align 4
  %inc117 = add i32 %58, 1
  store i32 %inc117, i32* %i, align 4
  br label %for.cond

for.end118:                                       ; preds = %if.end114, %for.cond
  store float 0.000000e+00, float* %area, align 4
  store i32 0, i32* %i119, align 4
  br label %for.cond120

for.cond120:                                      ; preds = %for.inc160, %for.end118
  %59 = load i32, i32* %i119, align 4
  %60 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length121 = getelementptr inbounds %struct.Array, %struct.Array* %60, i32 0, i32 1
  %61 = load i32, i32* %length121, align 8
  %cmp122 = icmp ult i32 %59, %61
  br i1 %cmp122, label %for.body123, label %for.end162

for.body123:                                      ; preds = %for.cond120
  %62 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data124 = getelementptr inbounds %struct.Array, %struct.Array* %62, i32 0, i32 0
  %63 = load i8*, i8** %data124, align 8
  %64 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %64, i32 0, i32 3
  %65 = load i32, i32* %elementSize, align 8
  %66 = load i32, i32* %i119, align 4
  %add125 = add i32 %66, 0
  %67 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length126 = getelementptr inbounds %struct.Array, %struct.Array* %67, i32 0, i32 1
  %68 = load i32, i32* %length126, align 8
  %rem127 = urem i32 %add125, %68
  %mul128 = mul i32 %65, %rem127
  %idxprom129 = zext i32 %mul128 to i64
  %arrayidx130 = getelementptr inbounds i8, i8* %63, i64 %idxprom129
  %69 = bitcast i8* %arrayidx130 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %69, %struct.IndexTriplet** %i0, align 8
  %70 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data131 = getelementptr inbounds %struct.Array, %struct.Array* %70, i32 0, i32 0
  %71 = load i8*, i8** %data131, align 8
  %72 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %elementSize132 = getelementptr inbounds %struct.Array, %struct.Array* %72, i32 0, i32 3
  %73 = load i32, i32* %elementSize132, align 8
  %74 = load i32, i32* %i119, align 4
  %add133 = add i32 %74, 1
  %75 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length134 = getelementptr inbounds %struct.Array, %struct.Array* %75, i32 0, i32 1
  %76 = load i32, i32* %length134, align 8
  %rem135 = urem i32 %add133, %76
  %mul136 = mul i32 %73, %rem135
  %idxprom137 = zext i32 %mul136 to i64
  %arrayidx138 = getelementptr inbounds i8, i8* %71, i64 %idxprom137
  %77 = bitcast i8* %arrayidx138 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %77, %struct.IndexTriplet** %i1, align 8
  %78 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %79 = load %struct.IndexTriplet*, %struct.IndexTriplet** %i0, align 8
  %v139 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %79, i32 0, i32 0
  %80 = load i32, i32* %v139, align 4
  %call140 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %78, i32 %80)
  %81 = bitcast i8* %call140 to float*
  store float* %81, float** %v0, align 8
  %82 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %83 = load %struct.IndexTriplet*, %struct.IndexTriplet** %i1, align 8
  %v141 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %83, i32 0, i32 0
  %84 = load i32, i32* %v141, align 4
  %call142 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %82, i32 %84)
  %85 = bitcast i8* %call142 to float*
  store float* %85, float** %v1, align 8
  %86 = load float*, float** %v0, align 8
  %arrayidx143 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %87 = load i32, i32* %arrayidx143, align 4
  %idxprom144 = zext i32 %87 to i64
  %arrayidx145 = getelementptr inbounds float, float* %86, i64 %idxprom144
  %88 = load float, float* %arrayidx145, align 4
  %89 = load float*, float** %v1, align 8
  %arrayidx146 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %90 = load i32, i32* %arrayidx146, align 4
  %idxprom147 = zext i32 %90 to i64
  %arrayidx148 = getelementptr inbounds float, float* %89, i64 %idxprom147
  %91 = load float, float* %arrayidx148, align 4
  %mul149 = fmul float %88, %91
  %92 = load float*, float** %v0, align 8
  %arrayidx150 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %93 = load i32, i32* %arrayidx150, align 4
  %idxprom151 = zext i32 %93 to i64
  %arrayidx152 = getelementptr inbounds float, float* %92, i64 %idxprom151
  %94 = load float, float* %arrayidx152, align 4
  %95 = load float*, float** %v1, align 8
  %arrayidx153 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %96 = load i32, i32* %arrayidx153, align 4
  %idxprom154 = zext i32 %96 to i64
  %arrayidx155 = getelementptr inbounds float, float* %95, i64 %idxprom154
  %97 = load float, float* %arrayidx155, align 4
  %mul156 = fmul float %94, %97
  %sub157 = fsub float %mul149, %mul156
  %mul158 = fmul float %sub157, 5.000000e-01
  %98 = load float, float* %area, align 4
  %add159 = fadd float %98, %mul158
  store float %add159, float* %area, align 4
  br label %for.inc160

for.inc160:                                       ; preds = %for.body123
  %99 = load i32, i32* %i119, align 4
  %inc161 = add i32 %99, 1
  store i32 %inc161, i32* %i119, align 4
  br label %for.cond120

for.end162:                                       ; preds = %for.cond120
  %100 = load %struct.Array*, %struct.Array** %_tempIndices.addr, align 8
  store %struct.Array* %100, %struct.Array** %remainingIndices, align 8
  %101 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length163 = getelementptr inbounds %struct.Array, %struct.Array* %101, i32 0, i32 1
  store i32 0, i32* %length163, align 8
  store i32 0, i32* %i164, align 4
  br label %for.cond165

for.cond165:                                      ; preds = %for.inc174, %for.end162
  %102 = load i32, i32* %i164, align 4
  %103 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %length166 = getelementptr inbounds %struct.Array, %struct.Array* %103, i32 0, i32 1
  %104 = load i32, i32* %length166, align 8
  %cmp167 = icmp ult i32 %102, %104
  br i1 %cmp167, label %for.body168, label %for.end176

for.body168:                                      ; preds = %for.cond165
  %105 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %106 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %data169 = getelementptr inbounds %struct.Array, %struct.Array* %106, i32 0, i32 0
  %107 = load i8*, i8** %data169, align 8
  %108 = load %struct.Array*, %struct.Array** %_indices.addr, align 8
  %elementSize170 = getelementptr inbounds %struct.Array, %struct.Array* %108, i32 0, i32 3
  %109 = load i32, i32* %elementSize170, align 8
  %110 = load i32, i32* %i164, align 4
  %mul171 = mul i32 %109, %110
  %idxprom172 = zext i32 %mul171 to i64
  %arrayidx173 = getelementptr inbounds i8, i8* %107, i64 %idxprom172
  call void @arrayAppend(%struct.Array* %105, i8* %arrayidx173)
  br label %for.inc174

for.inc174:                                       ; preds = %for.body168
  %111 = load i32, i32* %i164, align 4
  %inc175 = add i32 %111, 1
  store i32 %inc175, i32* %i164, align 4
  br label %for.cond165

for.end176:                                       ; preds = %for.cond165
  %112 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length177 = getelementptr inbounds %struct.Array, %struct.Array* %112, i32 0, i32 1
  %113 = load i32, i32* %length177, align 8
  store i32 %113, i32* %remainingIterations, align 4
  %114 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length178 = getelementptr inbounds %struct.Array, %struct.Array* %114, i32 0, i32 1
  %115 = load i32, i32* %length178, align 8
  store i32 %115, i32* %previousRemainingIndices, align 4
  store i32 0, i32* %guess_vert, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.end, %if.then286, %if.then250, %for.end176
  %116 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length179 = getelementptr inbounds %struct.Array, %struct.Array* %116, i32 0, i32 1
  %117 = load i32, i32* %length179, align 8
  %cmp180 = icmp ugt i32 %117, 3
  br i1 %cmp180, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %118 = load i32, i32* %remainingIterations, align 4
  %cmp181 = icmp ugt i32 %118, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %119 = phi i1 [ false, %while.cond ], [ %cmp181, %land.rhs ]
  br i1 %119, label %while.body, label %while.end319

while.body:                                       ; preds = %land.end
  %120 = load i32, i32* %guess_vert, align 4
  %121 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length182 = getelementptr inbounds %struct.Array, %struct.Array* %121, i32 0, i32 1
  %122 = load i32, i32* %length182, align 8
  %cmp183 = icmp uge i32 %120, %122
  br i1 %cmp183, label %if.then184, label %if.end187

if.then184:                                       ; preds = %while.body
  %123 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length185 = getelementptr inbounds %struct.Array, %struct.Array* %123, i32 0, i32 1
  %124 = load i32, i32* %length185, align 8
  %125 = load i32, i32* %guess_vert, align 4
  %sub186 = sub i32 %125, %124
  store i32 %sub186, i32* %guess_vert, align 4
  br label %if.end187

if.end187:                                        ; preds = %if.then184, %while.body
  %126 = load i32, i32* %previousRemainingIndices, align 4
  %127 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length188 = getelementptr inbounds %struct.Array, %struct.Array* %127, i32 0, i32 1
  %128 = load i32, i32* %length188, align 8
  %cmp189 = icmp ne i32 %126, %128
  br i1 %cmp189, label %if.then190, label %if.else

if.then190:                                       ; preds = %if.end187
  %129 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length191 = getelementptr inbounds %struct.Array, %struct.Array* %129, i32 0, i32 1
  %130 = load i32, i32* %length191, align 8
  store i32 %130, i32* %previousRemainingIndices, align 4
  %131 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length192 = getelementptr inbounds %struct.Array, %struct.Array* %131, i32 0, i32 1
  %132 = load i32, i32* %length192, align 8
  store i32 %132, i32* %remainingIterations, align 4
  br label %if.end193

if.else:                                          ; preds = %if.end187
  %133 = load i32, i32* %remainingIterations, align 4
  %dec = add i32 %133, -1
  store i32 %dec, i32* %remainingIterations, align 4
  br label %if.end193

if.end193:                                        ; preds = %if.else, %if.then190
  store i32 0, i32* %i194, align 4
  br label %for.cond195

for.cond195:                                      ; preds = %for.inc222, %if.end193
  %134 = load i32, i32* %i194, align 4
  %cmp196 = icmp ult i32 %134, 3
  br i1 %cmp196, label %for.body197, label %for.end224

for.body197:                                      ; preds = %for.cond195
  %135 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data198 = getelementptr inbounds %struct.Array, %struct.Array* %135, i32 0, i32 0
  %136 = load i8*, i8** %data198, align 8
  %137 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %elementSize199 = getelementptr inbounds %struct.Array, %struct.Array* %137, i32 0, i32 3
  %138 = load i32, i32* %elementSize199, align 8
  %139 = load i32, i32* %guess_vert, align 4
  %140 = load i32, i32* %i194, align 4
  %add200 = add i32 %139, %140
  %141 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length201 = getelementptr inbounds %struct.Array, %struct.Array* %141, i32 0, i32 1
  %142 = load i32, i32* %length201, align 8
  %rem202 = urem i32 %add200, %142
  %mul203 = mul i32 %138, %rem202
  %idxprom204 = zext i32 %mul203 to i64
  %arrayidx205 = getelementptr inbounds i8, i8* %136, i64 %idxprom204
  %143 = bitcast i8* %arrayidx205 to %struct.IndexTriplet*
  %144 = load i32, i32* %i194, align 4
  %idxprom206 = zext i32 %144 to i64
  %arrayidx207 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom206
  store %struct.IndexTriplet* %143, %struct.IndexTriplet** %arrayidx207, align 8
  %145 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %146 = load i32, i32* %i194, align 4
  %idxprom208 = zext i32 %146 to i64
  %arrayidx209 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom208
  %147 = load %struct.IndexTriplet*, %struct.IndexTriplet** %arrayidx209, align 8
  %v210 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %147, i32 0, i32 0
  %148 = load i32, i32* %v210, align 4
  %call211 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %145, i32 %148)
  %149 = bitcast i8* %call211 to float*
  store float* %149, float** %pos, align 8
  %150 = load float*, float** %pos, align 8
  %arrayidx212 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %151 = load i32, i32* %arrayidx212, align 4
  %idxprom213 = zext i32 %151 to i64
  %arrayidx214 = getelementptr inbounds float, float* %150, i64 %idxprom213
  %152 = load float, float* %arrayidx214, align 4
  %153 = load i32, i32* %i194, align 4
  %idxprom215 = zext i32 %153 to i64
  %arrayidx216 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 %idxprom215
  store float %152, float* %arrayidx216, align 4
  %154 = load float*, float** %pos, align 8
  %arrayidx217 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %155 = load i32, i32* %arrayidx217, align 4
  %idxprom218 = zext i32 %155 to i64
  %arrayidx219 = getelementptr inbounds float, float* %154, i64 %idxprom218
  %156 = load float, float* %arrayidx219, align 4
  %157 = load i32, i32* %i194, align 4
  %idxprom220 = zext i32 %157 to i64
  %arrayidx221 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 %idxprom220
  store float %156, float* %arrayidx221, align 4
  br label %for.inc222

for.inc222:                                       ; preds = %for.body197
  %158 = load i32, i32* %i194, align 4
  %inc223 = add i32 %158, 1
  store i32 %inc223, i32* %i194, align 4
  br label %for.cond195

for.end224:                                       ; preds = %for.cond195
  %arrayidx225 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 1
  %159 = load float, float* %arrayidx225, align 4
  %arrayidx226 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 0
  %160 = load float, float* %arrayidx226, align 4
  %sub227 = fsub float %159, %160
  %arrayidx228 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 0
  store float %sub227, float* %arrayidx228, align 4
  %arrayidx229 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 1
  %161 = load float, float* %arrayidx229, align 4
  %arrayidx230 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 0
  %162 = load float, float* %arrayidx230, align 4
  %sub231 = fsub float %161, %162
  %arrayidx232 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 1
  store float %sub231, float* %arrayidx232, align 4
  %arrayidx233 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 2
  %163 = load float, float* %arrayidx233, align 4
  %arrayidx234 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 1
  %164 = load float, float* %arrayidx234, align 4
  %sub235 = fsub float %163, %164
  %arrayidx236 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 0
  store float %sub235, float* %arrayidx236, align 4
  %arrayidx237 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 2
  %165 = load float, float* %arrayidx237, align 4
  %arrayidx238 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 1
  %166 = load float, float* %arrayidx238, align 4
  %sub239 = fsub float %165, %166
  %arrayidx240 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 1
  store float %sub239, float* %arrayidx240, align 4
  %arrayidx241 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 0
  %167 = load float, float* %arrayidx241, align 4
  %arrayidx242 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 1
  %168 = load float, float* %arrayidx242, align 4
  %mul243 = fmul float %167, %168
  %arrayidx244 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 1
  %169 = load float, float* %arrayidx244, align 4
  %arrayidx245 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 0
  %170 = load float, float* %arrayidx245, align 4
  %mul246 = fmul float %169, %170
  %sub247 = fsub float %mul243, %mul246
  store float %sub247, float* %cross, align 4
  %171 = load float, float* %cross, align 4
  %172 = load float, float* %area, align 4
  %mul248 = fmul float %171, %172
  %cmp249 = fcmp olt float %mul248, 0.000000e+00
  br i1 %cmp249, label %if.then250, label %if.end252

if.then250:                                       ; preds = %for.end224
  %173 = load i32, i32* %guess_vert, align 4
  %add251 = add i32 %173, 1
  store i32 %add251, i32* %guess_vert, align 4
  br label %while.cond

if.end252:                                        ; preds = %for.end224
  store i8 0, i8* %overlap, align 1
  store i32 3, i32* %otherVert, align 4
  br label %for.cond253

for.cond253:                                      ; preds = %for.inc282, %if.end252
  %174 = load i32, i32* %otherVert, align 4
  %175 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length254 = getelementptr inbounds %struct.Array, %struct.Array* %175, i32 0, i32 1
  %176 = load i32, i32* %length254, align 8
  %cmp255 = icmp ult i32 %174, %176
  br i1 %cmp255, label %for.body256, label %for.end284

for.body256:                                      ; preds = %for.cond253
  %177 = load i32, i32* %guess_vert, align 4
  %178 = load i32, i32* %otherVert, align 4
  %add257 = add i32 %177, %178
  %179 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length258 = getelementptr inbounds %struct.Array, %struct.Array* %179, i32 0, i32 1
  %180 = load i32, i32* %length258, align 8
  %rem259 = urem i32 %add257, %180
  store i32 %rem259, i32* %idx, align 4
  %181 = load i32, i32* %idx, align 4
  %182 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length260 = getelementptr inbounds %struct.Array, %struct.Array* %182, i32 0, i32 1
  %183 = load i32, i32* %length260, align 8
  %cmp261 = icmp uge i32 %181, %183
  br i1 %cmp261, label %if.then262, label %if.end263

if.then262:                                       ; preds = %for.body256
  br label %for.inc282

if.end263:                                        ; preds = %for.body256
  %184 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data264 = getelementptr inbounds %struct.Array, %struct.Array* %184, i32 0, i32 0
  %185 = load i8*, i8** %data264, align 8
  %186 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %elementSize265 = getelementptr inbounds %struct.Array, %struct.Array* %186, i32 0, i32 3
  %187 = load i32, i32* %elementSize265, align 8
  %188 = load i32, i32* %idx, align 4
  %mul266 = mul i32 %187, %188
  %idxprom267 = zext i32 %mul266 to i64
  %arrayidx268 = getelementptr inbounds i8, i8* %185, i64 %idxprom267
  %189 = bitcast i8* %arrayidx268 to %struct.IndexTriplet*
  %v269 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %189, i32 0, i32 0
  %190 = load i32, i32* %v269, align 4
  store i32 %190, i32* %ovi, align 4
  %191 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %192 = load i32, i32* %ovi, align 4
  %call270 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %191, i32 %192)
  %193 = bitcast i8* %call270 to float*
  %arrayidx271 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %194 = load i32, i32* %arrayidx271, align 4
  %idxprom272 = zext i32 %194 to i64
  %arrayidx273 = getelementptr inbounds float, float* %193, i64 %idxprom272
  %195 = load float, float* %arrayidx273, align 4
  store float %195, float* %tx, align 4
  %196 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8
  %197 = load i32, i32* %ovi, align 4
  %call274 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %196, i32 %197)
  %198 = bitcast i8* %call274 to float*
  %arrayidx275 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %199 = load i32, i32* %arrayidx275, align 4
  %idxprom276 = zext i32 %199 to i64
  %arrayidx277 = getelementptr inbounds float, float* %198, i64 %idxprom276
  %200 = load float, float* %arrayidx277, align 4
  store float %200, float* %ty, align 4
  %arraydecay = getelementptr inbounds [3 x float], [3 x float]* %vx, i32 0, i32 0
  %arraydecay278 = getelementptr inbounds [3 x float], [3 x float]* %vy, i32 0, i32 0
  %201 = load float, float* %tx, align 4
  %202 = load float, float* %ty, align 4
  %call279 = call i32 @pnpoly(i32 3, float* %arraydecay, float* %arraydecay278, float %201, float %202)
  %tobool = icmp ne i32 %call279, 0
  br i1 %tobool, label %if.then280, label %if.end281

if.then280:                                       ; preds = %if.end263
  store i8 1, i8* %overlap, align 1
  br label %for.end284

if.end281:                                        ; preds = %if.end263
  br label %for.inc282

for.inc282:                                       ; preds = %if.end281, %if.then262
  %203 = load i32, i32* %otherVert, align 4
  %inc283 = add i32 %203, 1
  store i32 %inc283, i32* %otherVert, align 4
  br label %for.cond253

for.end284:                                       ; preds = %if.then280, %for.cond253
  %204 = load i8, i8* %overlap, align 1
  %tobool285 = trunc i8 %204 to i1
  br i1 %tobool285, label %if.then286, label %if.end288

if.then286:                                       ; preds = %for.end284
  %205 = load i32, i32* %guess_vert, align 4
  %add287 = add i32 %205, 1
  store i32 %add287, i32* %guess_vert, align 4
  br label %while.cond

if.end288:                                        ; preds = %for.end284
  store i32 0, i32* %i289, align 4
  br label %for.cond290

for.cond290:                                      ; preds = %for.inc298, %if.end288
  %206 = load i32, i32* %i289, align 4
  %cmp291 = icmp slt i32 %206, 3
  br i1 %cmp291, label %for.body292, label %for.end300

for.body292:                                      ; preds = %for.cond290
  %indices293 = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 2
  %207 = load i32, i32* %i289, align 4
  %idxprom294 = sext i32 %207 to i64
  %arrayidx295 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices293, i64 0, i64 %idxprom294
  %208 = load i32, i32* %i289, align 4
  %idxprom296 = sext i32 %208 to i64
  %arrayidx297 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom296
  %209 = load %struct.IndexTriplet*, %struct.IndexTriplet** %arrayidx297, align 8
  %210 = bitcast %struct.IndexTriplet* %arrayidx295 to i8*
  %211 = bitcast %struct.IndexTriplet* %209 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %210, i8* %211, i64 12, i32 4, i1 false)
  br label %for.inc298

for.inc298:                                       ; preds = %for.body292
  %212 = load i32, i32* %i289, align 4
  %inc299 = add nsw i32 %212, 1
  store i32 %inc299, i32* %i289, align 4
  br label %for.cond290

for.end300:                                       ; preds = %for.cond290
  %213 = load i32, i32* %_materialIndex.addr, align 4
  %conv = trunc i32 %213 to i16
  %materialIndex = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 0
  store i16 %conv, i16* %materialIndex, align 4
  %214 = load i16, i16* %_smoothingGroup.addr, align 2
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 1
  store i16 %214, i16* %smoothingGroup, align 2
  %215 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %216 = bitcast %struct.Face* %face to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %215, i8* %216)
  %217 = load i32, i32* %guess_vert, align 4
  %add301 = add i32 %217, 1
  %218 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length302 = getelementptr inbounds %struct.Array, %struct.Array* %218, i32 0, i32 1
  %219 = load i32, i32* %length302, align 8
  %rem303 = urem i32 %add301, %219
  store i32 %rem303, i32* %removed_vert_index, align 4
  br label %while.cond304

while.cond304:                                    ; preds = %while.body309, %for.end300
  %220 = load i32, i32* %removed_vert_index, align 4
  %add305 = add i32 %220, 1
  %221 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length306 = getelementptr inbounds %struct.Array, %struct.Array* %221, i32 0, i32 1
  %222 = load i32, i32* %length306, align 8
  %cmp307 = icmp ult i32 %add305, %222
  br i1 %cmp307, label %while.body309, label %while.end

while.body309:                                    ; preds = %while.cond304
  %223 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data310 = getelementptr inbounds %struct.Array, %struct.Array* %223, i32 0, i32 0
  %224 = load i8*, i8** %data310, align 8
  %225 = bitcast i8* %224 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %225, %struct.IndexTriplet** %remainingIndicesData, align 8
  %226 = load %struct.IndexTriplet*, %struct.IndexTriplet** %remainingIndicesData, align 8
  %227 = load i32, i32* %removed_vert_index, align 4
  %idxprom311 = zext i32 %227 to i64
  %arrayidx312 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %226, i64 %idxprom311
  %228 = load %struct.IndexTriplet*, %struct.IndexTriplet** %remainingIndicesData, align 8
  %229 = load i32, i32* %removed_vert_index, align 4
  %add313 = add i32 %229, 1
  %idxprom314 = zext i32 %add313 to i64
  %arrayidx315 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %228, i64 %idxprom314
  %230 = bitcast %struct.IndexTriplet* %arrayidx312 to i8*
  %231 = bitcast %struct.IndexTriplet* %arrayidx315 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %230, i8* %231, i64 12, i32 4, i1 false)
  %232 = load i32, i32* %removed_vert_index, align 4
  %add316 = add i32 %232, 1
  store i32 %add316, i32* %removed_vert_index, align 4
  br label %while.cond304

while.end:                                        ; preds = %while.cond304
  %233 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length317 = getelementptr inbounds %struct.Array, %struct.Array* %233, i32 0, i32 1
  %234 = load i32, i32* %length317, align 8
  %dec318 = add i32 %234, -1
  store i32 %dec318, i32* %length317, align 8
  br label %while.cond

while.end319:                                     ; preds = %land.end
  %235 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %length320 = getelementptr inbounds %struct.Array, %struct.Array* %235, i32 0, i32 1
  %236 = load i32, i32* %length320, align 8
  %cmp321 = icmp eq i32 %236, 3
  br i1 %cmp321, label %if.then323, label %if.end344

if.then323:                                       ; preds = %while.end319
  store i32 0, i32* %i325, align 4
  br label %for.cond326

for.cond326:                                      ; preds = %for.inc338, %if.then323
  %237 = load i32, i32* %i325, align 4
  %cmp327 = icmp slt i32 %237, 3
  br i1 %cmp327, label %for.body329, label %for.end340

for.body329:                                      ; preds = %for.cond326
  %indices330 = getelementptr inbounds %struct.Face, %struct.Face* %face324, i32 0, i32 2
  %238 = load i32, i32* %i325, align 4
  %idxprom331 = sext i32 %238 to i64
  %arrayidx332 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices330, i64 0, i64 %idxprom331
  %239 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %data333 = getelementptr inbounds %struct.Array, %struct.Array* %239, i32 0, i32 0
  %240 = load i8*, i8** %data333, align 8
  %241 = load %struct.Array*, %struct.Array** %remainingIndices, align 8
  %elementSize334 = getelementptr inbounds %struct.Array, %struct.Array* %241, i32 0, i32 3
  %242 = load i32, i32* %elementSize334, align 8
  %243 = load i32, i32* %i325, align 4
  %mul335 = mul i32 %242, %243
  %idxprom336 = zext i32 %mul335 to i64
  %arrayidx337 = getelementptr inbounds i8, i8* %240, i64 %idxprom336
  %244 = bitcast i8* %arrayidx337 to %struct.IndexTriplet*
  %245 = bitcast %struct.IndexTriplet* %arrayidx332 to i8*
  %246 = bitcast %struct.IndexTriplet* %244 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %245, i8* %246, i64 12, i32 4, i1 false)
  br label %for.inc338

for.inc338:                                       ; preds = %for.body329
  %247 = load i32, i32* %i325, align 4
  %inc339 = add nsw i32 %247, 1
  store i32 %inc339, i32* %i325, align 4
  br label %for.cond326

for.end340:                                       ; preds = %for.cond326
  %248 = load i32, i32* %_materialIndex.addr, align 4
  %conv341 = trunc i32 %248 to i16
  %materialIndex342 = getelementptr inbounds %struct.Face, %struct.Face* %face324, i32 0, i32 0
  store i16 %conv341, i16* %materialIndex342, align 4
  %249 = load i16, i16* %_smoothingGroup.addr, align 2
  %smoothingGroup343 = getelementptr inbounds %struct.Face, %struct.Face* %face324, i32 0, i32 1
  store i16 %249, i16* %smoothingGroup343, align 2
  %250 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %251 = bitcast %struct.Face* %face324 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %250, i8* %251)
  br label %if.end344

if.end344:                                        ; preds = %for.end340, %while.end319
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @strCopy(i8* %_dest, i64 %_destSize, i8* %_src, i64 %_count) #0 {
entry:
  %_dest.addr = alloca i8*, align 8
  %_destSize.addr = alloca i64, align 8
  %_src.addr = alloca i8*, align 8
  %_count.addr = alloca i64, align 8
  %n = alloca i64, align 8
  store i8* %_dest, i8** %_dest.addr, align 8
  store i64 %_destSize, i64* %_destSize.addr, align 8
  store i8* %_src, i8** %_src.addr, align 8
  store i64 %_count, i64* %_count.addr, align 8
  %0 = load i64, i64* %_destSize.addr, align 8
  %sub = sub i64 %0, 1
  %1 = load i8*, i8** %_src.addr, align 8
  %2 = load i64, i64* %_count.addr, align 8
  %call = call i64 @strLength(i8* %1, i64 %2)
  %cmp = icmp ult i64 %sub, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i64, i64* %_destSize.addr, align 8
  %sub1 = sub i64 %3, 1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i8*, i8** %_src.addr, align 8
  %5 = load i64, i64* %_count.addr, align 8
  %call2 = call i64 @strLength(i8* %4, i64 %5)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub1, %cond.true ], [ %call2, %cond.false ]
  store i64 %cond, i64* %n, align 8
  %6 = load i8*, i8** %_dest.addr, align 8
  %7 = load i8*, i8** %_src.addr, align 8
  %8 = load i64, i64* %n, align 8
  %9 = load i8*, i8** %_dest.addr, align 8
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false)
  %call3 = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 %8, i64 %10) #7
  %11 = load i8*, i8** %_dest.addr, align 8
  %12 = load i64, i64* %n, align 8
  %arrayidx = getelementptr inbounds i8, i8* %11, i64 %12
  store i8 0, i8* %arrayidx, align 1
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @strLength(i8* %_str, i64 %_size) #0 {
entry:
  %_str.addr = alloca i8*, align 8
  %_size.addr = alloca i64, align 8
  %c = alloca i8*, align 8
  %len = alloca i64, align 8
  store i8* %_str, i8** %_str.addr, align 8
  store i64 %_size, i64* %_size.addr, align 8
  %0 = load i8*, i8** %_str.addr, align 8
  store i8* %0, i8** %c, align 8
  store i64 0, i64* %len, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i8*, i8** %c, align 8
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %3 = load i64, i64* %len, align 8
  %4 = load i64, i64* %_size.addr, align 8
  %cmp2 = icmp ult i64 %3, %4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %5 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %5, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %6 = load i8*, i8** %c, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %6, i32 1
  store i8* %incdec.ptr, i8** %c, align 8
  %7 = load i64, i64* %len, align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* %len, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %8 = load i64, i64* %len, align 8
  ret i64 %8
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @strConcat(i8* %_dest, i64 %_destSize, i8* %_src, i64 %_count) #0 {
entry:
  %_dest.addr = alloca i8*, align 8
  %_destSize.addr = alloca i64, align 8
  %_src.addr = alloca i8*, align 8
  %_count.addr = alloca i64, align 8
  %start = alloca i64, align 8
  store i8* %_dest, i8** %_dest.addr, align 8
  store i64 %_destSize, i64* %_destSize.addr, align 8
  store i8* %_src, i8** %_src.addr, align 8
  store i64 %_count, i64* %_count.addr, align 8
  %0 = load i8*, i8** %_dest.addr, align 8
  %1 = load i64, i64* %_destSize.addr, align 8
  %call = call i64 @strLength(i8* %0, i64 %1)
  store i64 %call, i64* %start, align 8
  %2 = load i8*, i8** %_dest.addr, align 8
  %3 = load i64, i64* %start, align 8
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 %3
  %4 = load i64, i64* %_destSize.addr, align 8
  %5 = load i64, i64* %start, align 8
  %sub = sub i64 %4, %5
  %6 = load i8*, i8** %_src.addr, align 8
  %7 = load i64, i64* %_count.addr, align 8
  call void @strCopy(i8* %arrayidx, i64 %sub, i8* %6, i64 %7)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @loadMaterialFile(i8* %_objFilename, i8* %_materialName, %struct.Array* %_materials) #0 {
entry:
  %retval = alloca i1, align 1
  %_objFilename.addr = alloca i8*, align 8
  %_materialName.addr = alloca i8*, align 8
  %_materials.addr = alloca %struct.Array*, align 8
  %filename = alloca [256 x i8], align 16
  %lastSlash = alloca i8*, align 8
  %i = alloca i32, align 4
  %file = alloca %struct.File, align 8
  %bom32 = alloca i32*, align 8
  %bom16 = alloca i16*, align 8
  %lexer = alloca %struct.Lexer, align 8
  %token = alloca %struct.Token, align 4
  %mat = alloca %struct.objzMaterial, align 4
  %result = alloca i8, align 1
  %line = alloca i8*, align 8
  %i66 = alloca i64, align 8
  %prop = alloca %struct.MaterialProperty*, align 8
  %dest = alloca i8*, align 8
  %argToken = alloca %struct.Token, align 4
  %j = alloca i32, align 4
  %match = alloca i8, align 1
  %k = alloca i64, align 8
  %arg = alloca %struct.MaterialMapArg*, align 8
  store i8* %_objFilename, i8** %_objFilename.addr, align 8
  store i8* %_materialName, i8** %_materialName.addr, align 8
  store %struct.Array* %_materials, %struct.Array** %_materials.addr, align 8
  %0 = bitcast [256 x i8]* %filename to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 256, i32 16, i1 false)
  %1 = load i8*, i8** %_objFilename.addr, align 8
  %call = call i8* @strrchr(i8* %1, i32 47)
  store i8* %call, i8** %lastSlash, align 8
  %2 = load i8*, i8** %lastSlash, align 8
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %_objFilename.addr, align 8
  %call1 = call i8* @strrchr(i8* %3, i32 92)
  store i8* %call1, i8** %lastSlash, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8*, i8** %lastSlash, align 8
  %tobool2 = icmp ne i8* %4, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %5 = load i8*, i8** %_objFilename.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1
  %8 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i64 0, i64 %idxprom4
  store i8 %7, i8* %arrayidx5, align 1
  %9 = load i8*, i8** %_objFilename.addr, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr inbounds i8, i8* %9, i64 %idxprom6
  %11 = load i8*, i8** %lastSlash, align 8
  %cmp = icmp eq i8* %arrayidx7, %11
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.cond
  br label %for.end

if.end9:                                          ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %12 = load i32, i32* %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then8
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %13 = load i8*, i8** %_materialName.addr, align 8
  %14 = load i8*, i8** %_materialName.addr, align 8
  %call10 = call i64 @strLength(i8* %14, i64 256)
  call void @strConcat(i8* %arraydecay, i64 256, i8* %13, i64 %call10)
  br label %if.end13

if.else:                                          ; preds = %if.end
  %arraydecay11 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %15 = load i8*, i8** %_materialName.addr, align 8
  %16 = load i8*, i8** %_materialName.addr, align 8
  %call12 = call i64 @strLength(i8* %16, i64 256)
  call void @strCopy(i8* %arraydecay11, i64 256, i8* %15, i64 %call12)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %for.end
  %arraydecay14 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %call15 = call zeroext i1 @fileOpen(%struct.File* %file, i8* %arraydecay14)
  br i1 %call15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end13
  %arraydecay17 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.25, i32 0, i32 0), i8* %arraydecay17)
  store i1 true, i1* %retval, align 1
  br label %return

if.end18:                                         ; preds = %if.end13
  %buffer = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %17 = load i8*, i8** %buffer, align 8
  %18 = bitcast i8* %17 to i32*
  store i32* %18, i32** %bom32, align 8
  %19 = load i32*, i32** %bom32, align 8
  %20 = load i32, i32* %19, align 4
  %cmp19 = icmp eq i32 %20, 65279
  br i1 %cmp19, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %21 = load i32*, i32** %bom32, align 8
  %22 = load i32, i32* %21, align 4
  %cmp20 = icmp eq i32 %22, -131072
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %lor.lhs.false, %if.end18
  %arraydecay22 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i8* %arraydecay22)
  store i1 false, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %lor.lhs.false
  %buffer24 = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %23 = load i8*, i8** %buffer24, align 8
  %24 = bitcast i8* %23 to i16*
  store i16* %24, i16** %bom16, align 8
  %25 = load i16*, i16** %bom16, align 8
  %26 = load i16, i16* %25, align 2
  %conv = zext i16 %26 to i32
  %cmp25 = icmp eq i32 %conv, 65534
  br i1 %cmp25, label %if.then31, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %if.end23
  %27 = load i16*, i16** %bom16, align 8
  %28 = load i16, i16* %27, align 2
  %conv28 = zext i16 %28 to i32
  %cmp29 = icmp eq i32 %conv28, 65279
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %lor.lhs.false27, %if.end23
  %arraydecay32 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i8* %arraydecay32)
  store i1 false, i1* %retval, align 1
  br label %return

if.end33:                                         ; preds = %lor.lhs.false27
  call void @initLexer(%struct.Lexer* %lexer)
  call void @materialInit(%struct.objzMaterial* %mat)
  store i8 0, i8* %result, align 1
  br label %for.cond34

for.cond34:                                       ; preds = %if.end140, %if.end33
  %call35 = call i8* @fileReadLine(%struct.File* %file)
  store i8* %call35, i8** %line, align 8
  %29 = load i8*, i8** %line, align 8
  %tobool36 = icmp ne i8* %29, null
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %for.cond34
  br label %for.end141

if.end38:                                         ; preds = %for.cond34
  %30 = load i8*, i8** %line, align 8
  call void @lexerSetLine(%struct.Lexer* %lexer, i8* %30)
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay39 = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call40 = call i32 @strcasecmp(i8* %arraydecay39, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %cmp41 = icmp eq i32 %call40, 0
  br i1 %cmp41, label %if.then43, label %if.else65

if.then43:                                        ; preds = %if.end38
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text44 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [256 x i8], [256 x i8]* %text44, i64 0, i64 0
  %31 = load i8, i8* %arrayidx45, align 4
  %conv46 = sext i8 %31 to i32
  %cmp47 = icmp eq i32 %conv46, 0
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.then43
  %line50 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %32 = load i32, i32* %line50, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %33 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.27, i32 0, i32 0), i32 %32, i32 %33)
  br label %cleanup

if.end51:                                         ; preds = %if.then43
  %name = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arrayidx52 = getelementptr inbounds [64 x i8], [64 x i8]* %name, i64 0, i64 0
  %34 = load i8, i8* %arrayidx52, align 4
  %conv53 = sext i8 %34 to i32
  %cmp54 = icmp ne i32 %conv53, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end51
  %35 = load %struct.Array*, %struct.Array** %_materials.addr, align 8
  %36 = bitcast %struct.objzMaterial* %mat to i8*
  call void @arrayAppend(%struct.Array* %35, i8* %36)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end51
  call void @materialInit(%struct.objzMaterial* %mat)
  %name58 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arraydecay59 = getelementptr inbounds [64 x i8], [64 x i8]* %name58, i32 0, i32 0
  %text60 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay61 = getelementptr inbounds [256 x i8], [256 x i8]* %text60, i32 0, i32 0
  %text62 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [256 x i8], [256 x i8]* %text62, i32 0, i32 0
  %call64 = call i64 @strLength(i8* %arraydecay63, i64 256)
  call void @strCopy(i8* %arraydecay59, i64 64, i8* %arraydecay61, i64 %call64)
  br label %if.end140

if.else65:                                        ; preds = %if.end38
  store i64 0, i64* %i66, align 8
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc137, %if.else65
  %37 = load i64, i64* %i66, align 8
  %cmp68 = icmp ult i64 %37, 14
  br i1 %cmp68, label %for.body, label %for.end139

for.body:                                         ; preds = %for.cond67
  %38 = load i64, i64* %i66, align 8
  %arrayidx70 = getelementptr inbounds [14 x %struct.MaterialProperty], [14 x %struct.MaterialProperty]* @s_materialProperties, i64 0, i64 %38
  store %struct.MaterialProperty* %arrayidx70, %struct.MaterialProperty** %prop, align 8
  %39 = bitcast %struct.objzMaterial* %mat to i8*
  %40 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %offset = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %40, i32 0, i32 2
  %41 = load i64, i64* %offset, align 8
  %arrayidx71 = getelementptr inbounds i8, i8* %39, i64 %41
  store i8* %arrayidx71, i8** %dest, align 8
  %text72 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay73 = getelementptr inbounds [256 x i8], [256 x i8]* %text72, i32 0, i32 0
  %42 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %name74 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %42, i32 0, i32 0
  %43 = load i8*, i8** %name74, align 8
  %call75 = call i32 @strcasecmp(i8* %arraydecay73, i8* %43)
  %cmp76 = icmp eq i32 %call75, 0
  br i1 %cmp76, label %if.then78, label %if.end136

if.then78:                                        ; preds = %for.body
  %44 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %type = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %44, i32 0, i32 1
  %45 = load i32, i32* %type, align 8
  %cmp79 = icmp eq i32 %45, 0
  br i1 %cmp79, label %if.then81, label %if.else125

if.then81:                                        ; preds = %if.then78
  store i32 0, i32* %j, align 4
  br label %for.cond82

for.cond82:                                       ; preds = %for.inc122, %if.then81
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %argToken, i1 zeroext false)
  %text83 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arrayidx84 = getelementptr inbounds [256 x i8], [256 x i8]* %text83, i64 0, i64 0
  %46 = load i8, i8* %arrayidx84, align 4
  %conv85 = sext i8 %46 to i32
  %cmp86 = icmp eq i32 %conv85, 0
  br i1 %cmp86, label %if.then88, label %if.end96

if.then88:                                        ; preds = %for.cond82
  %47 = load i32, i32* %j, align 4
  %cmp89 = icmp eq i32 %47, 0
  br i1 %cmp89, label %if.then91, label %if.end95

if.then91:                                        ; preds = %if.then88
  %line92 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %48 = load i32, i32* %line92, align 4
  %column93 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %49 = load i32, i32* %column93, align 4
  %50 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %name94 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %50, i32 0, i32 0
  %51 = load i8*, i8** %name94, align 8
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28, i32 0, i32 0), i32 %48, i32 %49, i8* %51)
  br label %cleanup

if.end95:                                         ; preds = %if.then88
  br label %for.end124

if.end96:                                         ; preds = %for.cond82
  store i8 0, i8* %match, align 1
  store i64 0, i64* %k, align 8
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc111, %if.end96
  %52 = load i64, i64* %k, align 8
  %cmp98 = icmp ult i64 %52, 12
  br i1 %cmp98, label %for.body100, label %for.end113

for.body100:                                      ; preds = %for.cond97
  %53 = load i64, i64* %k, align 8
  %arrayidx101 = getelementptr inbounds [12 x %struct.MaterialMapArg], [12 x %struct.MaterialMapArg]* @s_materialMapArgs, i64 0, i64 %53
  store %struct.MaterialMapArg* %arrayidx101, %struct.MaterialMapArg** %arg, align 8
  %text102 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay103 = getelementptr inbounds [256 x i8], [256 x i8]* %text102, i32 0, i32 0
  %54 = load %struct.MaterialMapArg*, %struct.MaterialMapArg** %arg, align 8
  %name104 = getelementptr inbounds %struct.MaterialMapArg, %struct.MaterialMapArg* %54, i32 0, i32 0
  %55 = load i8*, i8** %name104, align 8
  %call105 = call i32 @strcasecmp(i8* %arraydecay103, i8* %55)
  %cmp106 = icmp eq i32 %call105, 0
  br i1 %cmp106, label %if.then108, label %if.end110

if.then108:                                       ; preds = %for.body100
  store i8 1, i8* %match, align 1
  %56 = load %struct.MaterialMapArg*, %struct.MaterialMapArg** %arg, align 8
  %n = getelementptr inbounds %struct.MaterialMapArg, %struct.MaterialMapArg* %56, i32 0, i32 1
  %57 = load i32, i32* %n, align 8
  %call109 = call zeroext i1 @skipTokens(%struct.Lexer* %lexer, i32 %57)
  br label %for.end113

if.end110:                                        ; preds = %for.body100
  br label %for.inc111

for.inc111:                                       ; preds = %if.end110
  %58 = load i64, i64* %k, align 8
  %inc112 = add i64 %58, 1
  store i64 %inc112, i64* %k, align 8
  br label %for.cond97

for.end113:                                       ; preds = %if.then108, %for.cond97
  %59 = load i8, i8* %match, align 1
  %tobool114 = trunc i8 %59 to i1
  br i1 %tobool114, label %if.end121, label %if.then115

if.then115:                                       ; preds = %for.end113
  %60 = load i8*, i8** %dest, align 8
  %text116 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay117 = getelementptr inbounds [256 x i8], [256 x i8]* %text116, i32 0, i32 0
  %text118 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay119 = getelementptr inbounds [256 x i8], [256 x i8]* %text118, i32 0, i32 0
  %call120 = call i64 @strLength(i8* %arraydecay119, i64 256)
  call void @strCopy(i8* %60, i64 64, i8* %arraydecay117, i64 %call120)
  br label %if.end121

if.end121:                                        ; preds = %if.then115, %for.end113
  br label %for.inc122

for.inc122:                                       ; preds = %if.end121
  %61 = load i32, i32* %j, align 4
  %inc123 = add nsw i32 %61, 1
  store i32 %inc123, i32* %j, align 4
  br label %for.cond82

for.end124:                                       ; preds = %if.end95
  br label %if.end135

if.else125:                                       ; preds = %if.then78
  %62 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %type126 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %62, i32 0, i32 1
  %63 = load i32, i32* %type126, align 8
  %cmp127 = icmp eq i32 %63, 1
  br i1 %cmp127, label %if.then129, label %if.end134

if.then129:                                       ; preds = %if.else125
  %64 = load i8*, i8** %dest, align 8
  %65 = bitcast i8* %64 to float*
  %66 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8
  %n130 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %66, i32 0, i32 3
  %67 = load i32, i32* %n130, align 8
  %call131 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %65, i32 %67)
  br i1 %call131, label %if.end133, label %if.then132

if.then132:                                       ; preds = %if.then129
  br label %cleanup

if.end133:                                        ; preds = %if.then129
  br label %if.end134

if.end134:                                        ; preds = %if.end133, %if.else125
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %for.end124
  br label %for.end139

if.end136:                                        ; preds = %for.body
  br label %for.inc137

for.inc137:                                       ; preds = %if.end136
  %68 = load i64, i64* %i66, align 8
  %inc138 = add i64 %68, 1
  store i64 %inc138, i64* %i66, align 8
  br label %for.cond67

for.end139:                                       ; preds = %if.end135, %for.cond67
  br label %if.end140

if.end140:                                        ; preds = %for.end139, %if.end57
  br label %for.cond34

for.end141:                                       ; preds = %if.then37
  %name142 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arrayidx143 = getelementptr inbounds [64 x i8], [64 x i8]* %name142, i64 0, i64 0
  %69 = load i8, i8* %arrayidx143, align 4
  %conv144 = sext i8 %69 to i32
  %cmp145 = icmp ne i32 %conv144, 0
  br i1 %cmp145, label %if.then147, label %if.end148

if.then147:                                       ; preds = %for.end141
  %70 = load %struct.Array*, %struct.Array** %_materials.addr, align 8
  %71 = bitcast %struct.objzMaterial* %mat to i8*
  call void @arrayAppend(%struct.Array* %70, i8* %71)
  br label %if.end148

if.end148:                                        ; preds = %if.then147, %for.end141
  store i8 1, i8* %result, align 1
  br label %cleanup

cleanup:                                          ; preds = %if.end148, %if.then132, %if.then91, %if.then49
  call void @fileClose(%struct.File* %file)
  %72 = load i8, i8* %result, align 1
  %tobool149 = trunc i8 %72 to i1
  store i1 %tobool149, i1* %retval, align 1
  br label %return

return:                                           ; preds = %cleanup, %if.then31, %if.then21, %if.then16
  %73 = load i1, i1* %retval, align 1
  ret i1 %73
}

declare i32 @atoi(i8*) #1

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @parseFloats(%struct.Lexer* %_lexer, float* %_result, i32 %n) #0 {
entry:
  %retval = alloca i1, align 1
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_result.addr = alloca float*, align 8
  %n.addr = alloca i32, align 4
  %token = alloca %struct.Token, align 4
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store float* %_result, float** %_result.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  call void @tokenize(%struct.Lexer* %2, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %line = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %3 = load i32, i32* %line, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %4 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56, i32 0, i32 0), i32 %3, i32 %4)
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  %text2 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %text2, i32 0, i32 0
  %call4 = call double @atof(i8* %arraydecay3)
  %conv = fptrunc double %call4 to float
  %5 = load float*, float** %_result.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds float, float* %5, i64 %idxprom
  store float %conv, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %8 = load i1, i1* %retval, align 1
  ret i1 %8
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @arrayDestroy(%struct.Array* %_array) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8
  %call = call i8* @objz_realloc(i8* %1, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 182)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i8* @chunkedArrayElement(%struct.ChunkedArray* %_array, i32 %_index) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_index.addr = alloca i32, align 4
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i32 %_index, i32* %_index.addr, align 4
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks1 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 0
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %chunks1, i32 0, i32 3
  %3 = load i32, i32* %elementSize, align 8
  %4 = load i32, i32* %_index.addr, align 4
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 1
  %6 = load i32, i32* %elementsPerChunk, align 8
  %div = udiv i32 %4, %6
  %mul = mul i32 %3, %div
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %idxprom
  %7 = bitcast i8* %arrayidx to i8**
  store i8** %7, i8*** %chunk, align 8
  %8 = load i8**, i8*** %chunk, align 8
  %9 = load i8*, i8** %8, align 8
  %10 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementSize2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %10, i32 0, i32 2
  %11 = load i64, i64* %elementSize2, align 8
  %12 = load i32, i32* %_index.addr, align 4
  %13 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %elementsPerChunk3 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %13, i32 0, i32 1
  %14 = load i32, i32* %elementsPerChunk3, align 8
  %rem = urem i32 %12, %14
  %conv = zext i32 %rem to i64
  %mul4 = mul i64 %11, %conv
  %arrayidx5 = getelementptr inbounds i8, i8* %9, i64 %mul4
  ret i8* %arrayidx5
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @vec3Normalize(%struct.vec3* %_out, %struct.vec3* %_in) #0 {
entry:
  %_out.addr = alloca %struct.vec3*, align 8
  %_in.addr = alloca %struct.vec3*, align 8
  %len = alloca float, align 4
  store %struct.vec3* %_out, %struct.vec3** %_out.addr, align 8
  store %struct.vec3* %_in, %struct.vec3** %_in.addr, align 8
  %0 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %0, i32 0, i32 0
  %1 = load float, float* %x, align 4
  %2 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x1 = getelementptr inbounds %struct.vec3, %struct.vec3* %2, i32 0, i32 0
  %3 = load float, float* %x1, align 4
  %mul = fmul float %1, %3
  %4 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %4, i32 0, i32 1
  %5 = load float, float* %y, align 4
  %6 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y2 = getelementptr inbounds %struct.vec3, %struct.vec3* %6, i32 0, i32 1
  %7 = load float, float* %y2, align 4
  %mul3 = fmul float %5, %7
  %add = fadd float %mul, %mul3
  %8 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %8, i32 0, i32 2
  %9 = load float, float* %z, align 4
  %10 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z4 = getelementptr inbounds %struct.vec3, %struct.vec3* %10, i32 0, i32 2
  %11 = load float, float* %z4, align 4
  %mul5 = fmul float %9, %11
  %add6 = fadd float %add, %mul5
  store float %add6, float* %len, align 4
  %12 = load float, float* %len, align 4
  %cmp = fcmp ogt float %12, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %13 = load float, float* %len, align 4
  %call = call float @sqrtf(float %13) #4
  %div = fdiv float 1.000000e+00, %call
  store float %div, float* %len, align 4
  %14 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x7 = getelementptr inbounds %struct.vec3, %struct.vec3* %14, i32 0, i32 0
  %15 = load float, float* %x7, align 4
  %16 = load float, float* %len, align 4
  %mul8 = fmul float %15, %16
  %17 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %x9 = getelementptr inbounds %struct.vec3, %struct.vec3* %17, i32 0, i32 0
  store float %mul8, float* %x9, align 4
  %18 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y10 = getelementptr inbounds %struct.vec3, %struct.vec3* %18, i32 0, i32 1
  %19 = load float, float* %y10, align 4
  %20 = load float, float* %len, align 4
  %mul11 = fmul float %19, %20
  %21 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %y12 = getelementptr inbounds %struct.vec3, %struct.vec3* %21, i32 0, i32 1
  store float %mul11, float* %y12, align 4
  %22 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z13 = getelementptr inbounds %struct.vec3, %struct.vec3* %22, i32 0, i32 2
  %23 = load float, float* %z13, align 4
  %24 = load float, float* %len, align 4
  %mul14 = fmul float %23, %24
  %25 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %z15 = getelementptr inbounds %struct.vec3, %struct.vec3* %25, i32 0, i32 2
  store float %mul14, float* %z15, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %26 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %x16 = getelementptr inbounds %struct.vec3, %struct.vec3* %26, i32 0, i32 0
  %27 = load float, float* %x16, align 4
  %28 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %x17 = getelementptr inbounds %struct.vec3, %struct.vec3* %28, i32 0, i32 0
  store float %27, float* %x17, align 4
  %29 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %y18 = getelementptr inbounds %struct.vec3, %struct.vec3* %29, i32 0, i32 1
  %30 = load float, float* %y18, align 4
  %31 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %y19 = getelementptr inbounds %struct.vec3, %struct.vec3* %31, i32 0, i32 1
  store float %30, float* %y19, align 4
  %32 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8
  %z20 = getelementptr inbounds %struct.vec3, %struct.vec3* %32, i32 0, i32 2
  %33 = load float, float* %z20, align 4
  %34 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8
  %z21 = getelementptr inbounds %struct.vec3, %struct.vec3* %34, i32 0, i32 2
  store float %33, float* %z21, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @vertexHashMapInit(%struct.VertexHashMap* %_map, i32 %_initialCapacity) #0 {
entry:
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  %_initialCapacity.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4
  %0 = load i32, i32* %_initialCapacity.addr, align 4
  %conv = uitofp i32 %0 to float
  %mul = fmul float %conv, 0x3FF4CCCCC0000000
  %conv1 = fptoui float %mul to i32
  %1 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %1, i32 0, i32 1
  store i32 %conv1, i32* %numSlots, align 8
  %2 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots2 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots2, align 8
  %conv3 = zext i32 %3 to i64
  %mul4 = mul i64 4, %conv3
  %call = call i8* @objz_realloc(i8* null, i64 %mul4, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 549)
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %5, i32 0, i32 0
  store i32* %4, i32** %slots, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots5 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %7, i32 0, i32 1
  %8 = load i32, i32* %numSlots5, align 8
  %cmp = icmp ult i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots7 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %9, i32 0, i32 0
  %10 = load i32*, i32** %slots7, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom = zext i32 %11 to i64
  %arrayidx = getelementptr inbounds i32, i32* %10, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %13, i32 0, i32 2
  %14 = load i32, i32* %_initialCapacity.addr, align 4
  call void @arrayInit(%struct.Array* %vertices, i64 20, i32 %14)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @normalHashMapInit(%struct.NormalHashMap* %_map, i32 %_initialCapacity, %struct.ChunkedArray* %_normals) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %_initialCapacity.addr = alloca i32, align 4
  %_normals.addr = alloca %struct.ChunkedArray*, align 8
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4
  store %struct.ChunkedArray* %_normals, %struct.ChunkedArray** %_normals.addr, align 8
  %0 = load i32, i32* %_initialCapacity.addr, align 4
  %conv = uitofp i32 %0 to float
  %mul = fmul float %conv, 0x3FF4CCCCC0000000
  %conv1 = fptoui float %mul to i32
  %1 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %1, i32 0, i32 1
  store i32 %conv1, i32* %numSlots, align 8
  %2 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots2 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots2, align 8
  %conv3 = zext i32 %3 to i64
  %mul4 = mul i64 4, %conv3
  %call = call i8* @objz_realloc(i8* null, i64 %mul4, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 607)
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %5, i32 0, i32 0
  store i32* %4, i32** %slots, align 8
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_normals.addr, align 8
  %7 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %7, i32 0, i32 3
  store %struct.ChunkedArray* %6, %struct.ChunkedArray** %normals, align 8
  %8 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %8, i32 0, i32 2
  %9 = load i32, i32* %_initialCapacity.addr, align 4
  call void @arrayInit(%struct.Array* %hashedNormals, i64 8, i32 %9)
  %10 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  call void @normalHashMapClear(%struct.NormalHashMap* %10)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @normalHashMapClear(%struct.NormalHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %i = alloca i32, align 4
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %1, i32 0, i32 1
  %2 = load i32, i32* %numSlots, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %3, i32 0, i32 0
  %4 = load i32*, i32** %slots, align 8
  %5 = load i32, i32* %i, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %7, i32 0, i32 2
  %length = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals, i32 0, i32 1
  store i32 0, i32* %length, align 8
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i32 @normalHashMapInsert(%struct.NormalHashMap* %_map, %struct.vec3* %_normal) #0 {
entry:
  %retval = alloca i32, align 4
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %_normal.addr = alloca %struct.vec3*, align 8
  %hashData = alloca [3 x i32], align 4
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca %struct.HashedNormal*, align 8
  %n18 = alloca %struct.HashedNormal, align 4
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  store %struct.vec3* %_normal, %struct.vec3** %_normal.addr, align 8
  %0 = bitcast [3 x i32]* %hashData to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 12, i32 4, i1 false)
  %1 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %1, i32 0, i32 0
  %2 = load float, float* %x, align 4
  %mul = fmul float %2, 5.000000e-01
  %add = fadd float %mul, 1.275000e+02
  %conv = fptoui float %add to i32
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 0
  store i32 %conv, i32* %arrayidx, align 4
  %3 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %3, i32 0, i32 1
  %4 = load float, float* %y, align 4
  %mul1 = fmul float %4, 5.000000e-01
  %add2 = fadd float %mul1, 1.275000e+02
  %conv3 = fptoui float %add2 to i32
  %arrayidx4 = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 1
  store i32 %conv3, i32* %arrayidx4, align 4
  %5 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %5, i32 0, i32 2
  %6 = load float, float* %z, align 4
  %mul5 = fmul float %6, 5.000000e-01
  %add6 = fadd float %mul5, 1.275000e+02
  %conv7 = fptoui float %add6 to i32
  %arrayidx8 = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 2
  store i32 %conv7, i32* %arrayidx8, align 4
  %arraydecay = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i32 0, i32 0
  %7 = bitcast i32* %arraydecay to i8*
  %call = call i32 @sdbmHash(i8* %7, i32 12)
  %8 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %8, i32 0, i32 1
  %9 = load i32, i32* %numSlots, align 8
  %rem = urem i32 %call, %9
  store i32 %rem, i32* %hash, align 4
  %10 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %10, i32 0, i32 0
  %11 = load i32*, i32** %slots, align 8
  %12 = load i32, i32* %hash, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx9 = getelementptr inbounds i32, i32* %11, i64 %idxprom
  %13 = load i32, i32* %arrayidx9, align 4
  store i32 %13, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %14 = load i32, i32* %i, align 4
  %cmp = icmp ne i32 %14, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %15, i32 0, i32 2
  %data = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals11 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %17, i32 0, i32 2
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals11, i32 0, i32 3
  %18 = load i32, i32* %elementSize, align 8
  %19 = load i32, i32* %i, align 4
  %mul12 = mul i32 %18, %19
  %idxprom13 = zext i32 %mul12 to i64
  %arrayidx14 = getelementptr inbounds i8, i8* %16, i64 %idxprom13
  %20 = bitcast i8* %arrayidx14 to %struct.HashedNormal*
  store %struct.HashedNormal* %20, %struct.HashedNormal** %n, align 8
  %21 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %21, i32 0, i32 3
  %22 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals, align 8
  %23 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8
  %normalIndex = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %23, i32 0, i32 0
  %24 = load i32, i32* %normalIndex, align 4
  %call15 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %22, i32 %24)
  %25 = bitcast i8* %call15 to %struct.vec3*
  %26 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %call16 = call zeroext i1 @vec3Equal(%struct.vec3* %25, %struct.vec3* %26, float 0x3E80000000000000)
  br i1 %call16, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %27 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8
  %normalIndex17 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %27, i32 0, i32 0
  %28 = load i32, i32* %normalIndex17, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %while.body
  %29 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8
  %hashNext = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %29, i32 0, i32 1
  %30 = load i32, i32* %hashNext, align 4
  store i32 %30, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %31 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals19 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %31, i32 0, i32 3
  %32 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals19, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %32, i32 0, i32 3
  %33 = load i32, i32* %length, align 8
  %normalIndex20 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 0
  store i32 %33, i32* %normalIndex20, align 4
  %34 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots21 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %34, i32 0, i32 0
  %35 = load i32*, i32** %slots21, align 8
  %36 = load i32, i32* %hash, align 4
  %idxprom22 = zext i32 %36 to i64
  %arrayidx23 = getelementptr inbounds i32, i32* %35, i64 %idxprom22
  %37 = load i32, i32* %arrayidx23, align 4
  %hashNext24 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 1
  store i32 %37, i32* %hashNext24, align 4
  %38 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals25 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %38, i32 0, i32 2
  %length26 = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals25, i32 0, i32 1
  %39 = load i32, i32* %length26, align 8
  %40 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots27 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %40, i32 0, i32 0
  %41 = load i32*, i32** %slots27, align 8
  %42 = load i32, i32* %hash, align 4
  %idxprom28 = zext i32 %42 to i64
  %arrayidx29 = getelementptr inbounds i32, i32* %41, i64 %idxprom28
  store i32 %39, i32* %arrayidx29, align 4
  %43 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals30 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %43, i32 0, i32 2
  %44 = bitcast %struct.HashedNormal* %n18 to i8*
  call void @arrayAppend(%struct.Array* %hashedNormals30, i8* %44)
  %45 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %normals31 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %45, i32 0, i32 3
  %46 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals31, align 8
  %47 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8
  %48 = bitcast %struct.vec3* %47 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %46, i8* %48)
  %normalIndex32 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 0
  %49 = load i32, i32* %normalIndex32, align 4
  store i32 %49, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %50 = load i32, i32* %retval, align 4
  ret i32 %50
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { <2 x float>, float } @calculateSmoothNormal(i32 %_pos, %struct.ChunkedArray* %_faces, %struct.Array* %_faceNormals, i16 zeroext %_smoothingGroup) #0 {
entry:
  %retval = alloca %struct.vec3, align 4
  %_pos.addr = alloca i32, align 4
  %_faces.addr = alloca %struct.ChunkedArray*, align 8
  %_faceNormals.addr = alloca %struct.Array*, align 8
  %_smoothingGroup.addr = alloca i16, align 2
  %normal = alloca %struct.vec3, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %face = alloca %struct.Face*, align 8
  %j = alloca i32, align 4
  %s = alloca float, align 4
  %tmp = alloca { <2 x float>, float }, align 8
  store i32 %_pos, i32* %_pos.addr, align 4
  store %struct.ChunkedArray* %_faces, %struct.ChunkedArray** %_faces.addr, align 8
  store %struct.Array* %_faceNormals, %struct.Array** %_faceNormals.addr, align 8
  store i16 %_smoothingGroup, i16* %_smoothingGroup.addr, align 2
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  store float 0.000000e+00, float* %x, align 4
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  store float 0.000000e+00, float* %y, align 4
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  store float 0.000000e+00, float* %z, align 4
  store i32 0, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc36, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %1, i32 0, i32 3
  %2 = load i32, i32* %length, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end38

for.body:                                         ; preds = %for.cond
  %3 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8
  %4 = load i32, i32* %i, align 4
  %call = call i8* @chunkedArrayElement(%struct.ChunkedArray* %3, i32 %4)
  %5 = bitcast i8* %call to %struct.Face*
  store %struct.Face* %5, %struct.Face** %face, align 8
  %6 = load %struct.Face*, %struct.Face** %face, align 8
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %6, i32 0, i32 1
  %7 = load i16, i16* %smoothingGroup, align 2
  %conv = zext i16 %7 to i32
  %8 = load i16, i16* %_smoothingGroup.addr, align 2
  %conv1 = zext i16 %8 to i32
  %cmp2 = icmp ne i32 %conv, %conv1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc36

if.end:                                           ; preds = %for.body
  store i32 0, i32* %j, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %if.end
  %9 = load i32, i32* %j, align 4
  %cmp5 = icmp slt i32 %9, 3
  br i1 %cmp5, label %for.body7, label %for.end

for.body7:                                        ; preds = %for.cond4
  %10 = load %struct.Face*, %struct.Face** %face, align 8
  %indices = getelementptr inbounds %struct.Face, %struct.Face* %10, i32 0, i32 2
  %11 = load i32, i32* %j, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices, i64 0, i64 %idxprom
  %v = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx, i32 0, i32 0
  %12 = load i32, i32* %v, align 4
  %13 = load i32, i32* %_pos.addr, align 4
  %cmp8 = icmp eq i32 %12, %13
  br i1 %cmp8, label %if.then10, label %if.end34

if.then10:                                        ; preds = %for.body7
  %x11 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  %14 = load float, float* %x11, align 4
  %15 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %data = getelementptr inbounds %struct.Array, %struct.Array* %15, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %17, i32 0, i32 3
  %18 = load i32, i32* %elementSize, align 8
  %19 = load i32, i32* %i, align 4
  %mul = mul i32 %18, %19
  %idxprom12 = zext i32 %mul to i64
  %arrayidx13 = getelementptr inbounds i8, i8* %16, i64 %idxprom12
  %20 = bitcast i8* %arrayidx13 to %struct.vec3*
  %x14 = getelementptr inbounds %struct.vec3, %struct.vec3* %20, i32 0, i32 0
  %21 = load float, float* %x14, align 4
  %add = fadd float %14, %21
  %x15 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  store float %add, float* %x15, align 4
  %y16 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  %22 = load float, float* %y16, align 4
  %23 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %data17 = getelementptr inbounds %struct.Array, %struct.Array* %23, i32 0, i32 0
  %24 = load i8*, i8** %data17, align 8
  %25 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %elementSize18 = getelementptr inbounds %struct.Array, %struct.Array* %25, i32 0, i32 3
  %26 = load i32, i32* %elementSize18, align 8
  %27 = load i32, i32* %i, align 4
  %mul19 = mul i32 %26, %27
  %idxprom20 = zext i32 %mul19 to i64
  %arrayidx21 = getelementptr inbounds i8, i8* %24, i64 %idxprom20
  %28 = bitcast i8* %arrayidx21 to %struct.vec3*
  %y22 = getelementptr inbounds %struct.vec3, %struct.vec3* %28, i32 0, i32 1
  %29 = load float, float* %y22, align 4
  %add23 = fadd float %22, %29
  %y24 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  store float %add23, float* %y24, align 4
  %z25 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  %30 = load float, float* %z25, align 4
  %31 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %data26 = getelementptr inbounds %struct.Array, %struct.Array* %31, i32 0, i32 0
  %32 = load i8*, i8** %data26, align 8
  %33 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8
  %elementSize27 = getelementptr inbounds %struct.Array, %struct.Array* %33, i32 0, i32 3
  %34 = load i32, i32* %elementSize27, align 8
  %35 = load i32, i32* %i, align 4
  %mul28 = mul i32 %34, %35
  %idxprom29 = zext i32 %mul28 to i64
  %arrayidx30 = getelementptr inbounds i8, i8* %32, i64 %idxprom29
  %36 = bitcast i8* %arrayidx30 to %struct.vec3*
  %z31 = getelementptr inbounds %struct.vec3, %struct.vec3* %36, i32 0, i32 2
  %37 = load float, float* %z31, align 4
  %add32 = fadd float %30, %37
  %z33 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  store float %add32, float* %z33, align 4
  %38 = load i32, i32* %n, align 4
  %inc = add nsw i32 %38, 1
  store i32 %inc, i32* %n, align 4
  br label %for.end

if.end34:                                         ; preds = %for.body7
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %39 = load i32, i32* %j, align 4
  %inc35 = add nsw i32 %39, 1
  store i32 %inc35, i32* %j, align 4
  br label %for.cond4

for.end:                                          ; preds = %if.then10, %for.cond4
  br label %for.inc36

for.inc36:                                        ; preds = %for.end, %if.then
  %40 = load i32, i32* %i, align 4
  %inc37 = add i32 %40, 1
  store i32 %inc37, i32* %i, align 4
  br label %for.cond

for.end38:                                        ; preds = %for.cond
  %41 = load i32, i32* %n, align 4
  %conv39 = sitofp i32 %41 to float
  %div = fdiv float 1.000000e+00, %conv39
  store float %div, float* %s, align 4
  %x40 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  %42 = load float, float* %x40, align 4
  %43 = load float, float* %s, align 4
  %mul41 = fmul float %42, %43
  %x42 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 0
  store float %mul41, float* %x42, align 4
  %y43 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  %44 = load float, float* %y43, align 4
  %45 = load float, float* %s, align 4
  %mul44 = fmul float %44, %45
  %y45 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 1
  store float %mul44, float* %y45, align 4
  %z46 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  %46 = load float, float* %z46, align 4
  %47 = load float, float* %s, align 4
  %mul47 = fmul float %46, %47
  %z48 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal, i32 0, i32 2
  store float %mul47, float* %z48, align 4
  call void @vec3Normalize(%struct.vec3* %normal, %struct.vec3* %normal)
  %48 = bitcast %struct.vec3* %retval to i8*
  %49 = bitcast %struct.vec3* %normal to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %48, i8* %49, i64 12, i32 4, i1 false)
  %50 = bitcast { <2 x float>, float }* %tmp to i8*
  %51 = bitcast %struct.vec3* %retval to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %50, i8* %51, i64 12, i32 4, i1 false)
  %52 = load { <2 x float>, float }, { <2 x float>, float }* %tmp, align 8
  ret { <2 x float>, float } %52
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i32 @vertexHashMapInsert(%struct.VertexHashMap* %_map, i32 %_object, i32 %_pos, i32 %_texcoord, i32 %_normal) #0 {
entry:
  %retval = alloca i32, align 4
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  %_object.addr = alloca i32, align 4
  %_pos.addr = alloca i32, align 4
  %_texcoord.addr = alloca i32, align 4
  %_normal.addr = alloca i32, align 4
  %hashData = alloca [4 x i32], align 16
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  %v = alloca %struct.HashedVertex*, align 8
  %v20 = alloca %struct.HashedVertex, align 4
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8
  store i32 %_object, i32* %_object.addr, align 4
  store i32 %_pos, i32* %_pos.addr, align 4
  store i32 %_texcoord, i32* %_texcoord.addr, align 4
  store i32 %_normal, i32* %_normal.addr, align 4
  %0 = bitcast [4 x i32]* %hashData to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 16, i32 16, i1 false)
  %1 = load i32, i32* %_object.addr, align 4
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 0
  store i32 %1, i32* %arrayidx, align 16
  %2 = load i32, i32* %_pos.addr, align 4
  %arrayidx1 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 1
  store i32 %2, i32* %arrayidx1, align 4
  %3 = load i32, i32* %_texcoord.addr, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %_texcoord.addr, align 4
  %arrayidx2 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 2
  store i32 %4, i32* %arrayidx2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, i32* %_normal.addr, align 4
  %cmp3 = icmp ne i32 %5, -1
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %6 = load i32, i32* %_normal.addr, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 3
  store i32 %6, i32* %arrayidx5, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i32 0, i32 0
  %7 = bitcast i32* %arraydecay to i8*
  %call = call i32 @sdbmHash(i8* %7, i32 16)
  %8 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %numSlots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %8, i32 0, i32 1
  %9 = load i32, i32* %numSlots, align 8
  %rem = urem i32 %call, %9
  store i32 %rem, i32* %hash, align 4
  %10 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %10, i32 0, i32 0
  %11 = load i32*, i32** %slots, align 8
  %12 = load i32, i32* %hash, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx7 = getelementptr inbounds i32, i32* %11, i64 %idxprom
  %13 = load i32, i32* %arrayidx7, align 4
  store i32 %13, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.end6
  %14 = load i32, i32* %i, align 4
  %cmp8 = icmp ne i32 %14, -1
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %15, i32 0, i32 2
  %data = getelementptr inbounds %struct.Array, %struct.Array* %vertices, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices9 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %17, i32 0, i32 2
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %vertices9, i32 0, i32 3
  %18 = load i32, i32* %elementSize, align 8
  %19 = load i32, i32* %i, align 4
  %mul = mul i32 %18, %19
  %idxprom10 = zext i32 %mul to i64
  %arrayidx11 = getelementptr inbounds i8, i8* %16, i64 %idxprom10
  %20 = bitcast i8* %arrayidx11 to %struct.HashedVertex*
  store %struct.HashedVertex* %20, %struct.HashedVertex** %v, align 8
  %21 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %object = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %21, i32 0, i32 0
  %22 = load i32, i32* %object, align 4
  %23 = load i32, i32* %_object.addr, align 4
  %cmp12 = icmp eq i32 %22, %23
  br i1 %cmp12, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %while.body
  %24 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %pos = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %24, i32 0, i32 1
  %25 = load i32, i32* %pos, align 4
  %26 = load i32, i32* %_pos.addr, align 4
  %cmp13 = icmp eq i32 %25, %26
  br i1 %cmp13, label %land.lhs.true14, label %if.end19

land.lhs.true14:                                  ; preds = %land.lhs.true
  %27 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %texcoord = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %27, i32 0, i32 2
  %28 = load i32, i32* %texcoord, align 4
  %29 = load i32, i32* %_texcoord.addr, align 4
  %cmp15 = icmp eq i32 %28, %29
  br i1 %cmp15, label %land.lhs.true16, label %if.end19

land.lhs.true16:                                  ; preds = %land.lhs.true14
  %30 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %normal = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %30, i32 0, i32 3
  %31 = load i32, i32* %normal, align 4
  %32 = load i32, i32* %_normal.addr, align 4
  %cmp17 = icmp eq i32 %31, %32
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true16
  %33 = load i32, i32* %i, align 4
  store i32 %33, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %land.lhs.true16, %land.lhs.true14, %land.lhs.true, %while.body
  %34 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8
  %hashNext = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %34, i32 0, i32 4
  %35 = load i32, i32* %hashNext, align 4
  store i32 %35, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i32, i32* %_object.addr, align 4
  %object21 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 0
  store i32 %36, i32* %object21, align 4
  %37 = load i32, i32* %_pos.addr, align 4
  %pos22 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 1
  store i32 %37, i32* %pos22, align 4
  %38 = load i32, i32* %_texcoord.addr, align 4
  %texcoord23 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 2
  store i32 %38, i32* %texcoord23, align 4
  %39 = load i32, i32* %_normal.addr, align 4
  %normal24 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 3
  store i32 %39, i32* %normal24, align 4
  %40 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots25 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %40, i32 0, i32 0
  %41 = load i32*, i32** %slots25, align 8
  %42 = load i32, i32* %hash, align 4
  %idxprom26 = zext i32 %42 to i64
  %arrayidx27 = getelementptr inbounds i32, i32* %41, i64 %idxprom26
  %43 = load i32, i32* %arrayidx27, align 4
  %hashNext28 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 4
  store i32 %43, i32* %hashNext28, align 4
  %44 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices29 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %44, i32 0, i32 2
  %length = getelementptr inbounds %struct.Array, %struct.Array* %vertices29, i32 0, i32 1
  %45 = load i32, i32* %length, align 8
  %46 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots30 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %46, i32 0, i32 0
  %47 = load i32*, i32** %slots30, align 8
  %48 = load i32, i32* %hash, align 4
  %idxprom31 = zext i32 %48 to i64
  %arrayidx32 = getelementptr inbounds i32, i32* %47, i64 %idxprom31
  store i32 %45, i32* %arrayidx32, align 4
  %49 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices33 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %49, i32 0, i32 2
  %50 = bitcast %struct.HashedVertex* %v20 to i8*
  call void @arrayAppend(%struct.Array* %vertices33, i8* %50)
  %51 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots34 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %51, i32 0, i32 0
  %52 = load i32*, i32** %slots34, align 8
  %53 = load i32, i32* %hash, align 4
  %idxprom35 = zext i32 %53 to i64
  %arrayidx36 = getelementptr inbounds i32, i32* %52, i64 %idxprom35
  %54 = load i32, i32* %arrayidx36, align 4
  store i32 %54, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then18
  %55 = load i32, i32* %retval, align 4
  ret i32 %55
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @normalHashMapDestroy(%struct.NormalHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8
  %0 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %0, i32 0, i32 0
  %1 = load i32*, i32** %slots, align 8
  %2 = bitcast i32* %1 to i8*
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 614)
  %3 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %3, i32 0, i32 2
  call void @arrayDestroy(%struct.Array* %hashedNormals)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal void @chunkedArrayDestroy(%struct.ChunkedArray* %_array) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %i = alloca i32, align 4
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %1, i32 0, i32 0
  %length = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 1
  %2 = load i32, i32* %length, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks1 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %3, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks1, i32 0, i32 0
  %4 = load i8*, i8** %data, align 8
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 0
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %chunks2, i32 0, i32 3
  %6 = load i32, i32* %elementSize, align 8
  %7 = load i32, i32* %i, align 4
  %mul = mul i32 %6, %7
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %8 = bitcast i8* %arrayidx to i8**
  store i8** %8, i8*** %chunk, align 8
  %9 = load i8**, i8*** %chunk, align 8
  %10 = load i8*, i8** %9, align 8
  %call = call i8* @objz_realloc(i8* %10, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 218)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8
  %chunks3 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %12, i32 0, i32 0
  call void @arrayDestroy(%struct.Array* %chunks3)
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #3

; Function Attrs: nounwind readnone
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1) #4

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #3

; Function Attrs: noinline nounwind ssp uwtable
define internal void @vertexHashMapDestroy(%struct.VertexHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8
  %0 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %0, i32 0, i32 0
  %1 = load i32*, i32** %slots, align 8
  %2 = bitcast i32* %1 to i8*
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 556)
  %3 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %3, i32 0, i32 2
  call void @arrayDestroy(%struct.Array* %vertices)
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define void @objz_destroy(%struct.objzModel* %_model) #0 {
entry:
  %_model.addr = alloca %struct.objzModel*, align 8
  store %struct.objzModel* %_model, %struct.objzModel** %_model.addr, align 8
  %0 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %tobool = icmp ne %struct.objzModel* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %indices = getelementptr inbounds %struct.objzModel, %struct.objzModel* %1, i32 0, i32 1
  %2 = load i8*, i8** %indices, align 8
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1243)
  %3 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %materials = getelementptr inbounds %struct.objzModel, %struct.objzModel* %3, i32 0, i32 3
  %4 = load %struct.objzMaterial*, %struct.objzMaterial** %materials, align 8
  %5 = bitcast %struct.objzMaterial* %4 to i8*
  %call1 = call i8* @objz_realloc(i8* %5, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1244)
  %6 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %meshes = getelementptr inbounds %struct.objzModel, %struct.objzModel* %6, i32 0, i32 5
  %7 = load %struct.objzMesh*, %struct.objzMesh** %meshes, align 8
  %8 = bitcast %struct.objzMesh* %7 to i8*
  %call2 = call i8* @objz_realloc(i8* %8, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1245)
  %9 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %objects = getelementptr inbounds %struct.objzModel, %struct.objzModel* %9, i32 0, i32 7
  %10 = load %struct.objzObject*, %struct.objzObject** %objects, align 8
  %11 = bitcast %struct.objzObject* %10 to i8*
  %call3 = call i8* @objz_realloc(i8* %11, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1246)
  %12 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %vertices = getelementptr inbounds %struct.objzModel, %struct.objzModel* %12, i32 0, i32 9
  %13 = load i8*, i8** %vertices, align 8
  %call4 = call i8* @objz_realloc(i8* %13, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1247)
  %14 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8
  %15 = bitcast %struct.objzModel* %14 to i8*
  %call5 = call i8* @objz_realloc(i8* %15, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1248)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define i8* @objz_getError() #0 {
entry:
  %retval = alloca i8*, align 8
  %0 = load i8, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i8*, i8** %retval, align 8
  ret i8* %1
}

; Function Attrs: allocsize(1)
declare i8* @realloc(i8*, i64) #5

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: noreturn
declare void @abort() #6

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

declare i32 @__vsnprintf_chk(i8*, i64, i32, i64, i8*, %struct.__va_list_tag*) #1

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: noinline nounwind ssp uwtable
define internal void @skipWhitespace(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end3, %entry
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call = call zeroext i1 @isEol(%struct.Lexer* %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %call1 = call zeroext i1 @isWhitespace(%struct.Lexer* %1)
  br i1 %call1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %for.end

if.end3:                                          ; preds = %if.end
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 0
  %3 = load i8*, i8** %buf, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %buf, align 8
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 2
  %5 = load i32, i32* %column, align 4
  %inc = add i32 %5, 1
  store i32 %inc, i32* %column, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then2, %if.then
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @isWhitespace(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  %1 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf2 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %3, i32 0, i32 0
  %4 = load i8*, i8** %buf2, align 8
  %arrayidx3 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i8, i8* %arrayidx3, align 1
  %conv4 = sext i8 %5 to i32
  %cmp5 = icmp eq i32 %conv4, 9
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %6 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  %buf7 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %6, i32 0, i32 0
  %7 = load i8*, i8** %buf7, align 8
  %arrayidx8 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = load i8, i8* %arrayidx8, align 1
  %conv9 = sext i8 %8 to i32
  %cmp10 = icmp eq i32 %conv9, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %9 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp10, %lor.rhs ]
  ret i1 %9
}

declare i8* @strstr(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare float @fabsf(float) #8

; Function Attrs: noinline nounwind ssp uwtable
define internal i32 @pnpoly(i32 %nvert, float* %vertx, float* %verty, float %testx, float %testy) #0 {
entry:
  %nvert.addr = alloca i32, align 4
  %vertx.addr = alloca float*, align 8
  %verty.addr = alloca float*, align 8
  %testx.addr = alloca float, align 4
  %testy.addr = alloca float, align 4
  %c = alloca i8, align 1
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store i32 %nvert, i32* %nvert.addr, align 4
  store float* %vertx, float** %vertx.addr, align 8
  store float* %verty, float** %verty.addr, align 8
  store float %testx, float* %testx.addr, align 4
  store float %testy, float* %testy.addr, align 4
  store i8 0, i8* %c, align 1
  store i32 0, i32* %i, align 4
  %0 = load i32, i32* %nvert.addr, align 4
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* %nvert.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load float*, float** %verty.addr, align 8
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds float, float* %3, i64 %idxprom
  %5 = load float, float* %arrayidx, align 4
  %6 = load float, float* %testy.addr, align 4
  %cmp1 = fcmp ogt float %5, %6
  %conv = zext i1 %cmp1 to i32
  %7 = load float*, float** %verty.addr, align 8
  %8 = load i32, i32* %j, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr inbounds float, float* %7, i64 %idxprom2
  %9 = load float, float* %arrayidx3, align 4
  %10 = load float, float* %testy.addr, align 4
  %cmp4 = fcmp ogt float %9, %10
  %conv5 = zext i1 %cmp4 to i32
  %cmp6 = icmp ne i32 %conv, %conv5
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %11 = load float, float* %testx.addr, align 4
  %12 = load float*, float** %vertx.addr, align 8
  %13 = load i32, i32* %j, align 4
  %idxprom8 = sext i32 %13 to i64
  %arrayidx9 = getelementptr inbounds float, float* %12, i64 %idxprom8
  %14 = load float, float* %arrayidx9, align 4
  %15 = load float*, float** %vertx.addr, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom10 = sext i32 %16 to i64
  %arrayidx11 = getelementptr inbounds float, float* %15, i64 %idxprom10
  %17 = load float, float* %arrayidx11, align 4
  %sub12 = fsub float %14, %17
  %18 = load float, float* %testy.addr, align 4
  %19 = load float*, float** %verty.addr, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr inbounds float, float* %19, i64 %idxprom13
  %21 = load float, float* %arrayidx14, align 4
  %sub15 = fsub float %18, %21
  %mul = fmul float %sub12, %sub15
  %22 = load float*, float** %verty.addr, align 8
  %23 = load i32, i32* %j, align 4
  %idxprom16 = sext i32 %23 to i64
  %arrayidx17 = getelementptr inbounds float, float* %22, i64 %idxprom16
  %24 = load float, float* %arrayidx17, align 4
  %25 = load float*, float** %verty.addr, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom18 = sext i32 %26 to i64
  %arrayidx19 = getelementptr inbounds float, float* %25, i64 %idxprom18
  %27 = load float, float* %arrayidx19, align 4
  %sub20 = fsub float %24, %27
  %div = fdiv float %mul, %sub20
  %28 = load float*, float** %vertx.addr, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom21 = sext i32 %29 to i64
  %arrayidx22 = getelementptr inbounds float, float* %28, i64 %idxprom21
  %30 = load float, float* %arrayidx22, align 4
  %add = fadd float %div, %30
  %cmp23 = fcmp olt float %11, %add
  br i1 %cmp23, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %31 = load i8, i8* %c, align 1
  %tobool = trunc i8 %31 to i1
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %c, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %32 = load i32, i32* %i, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, i32* %i, align 4
  store i32 %32, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %33 = load i8, i8* %c, align 1
  %tobool25 = trunc i8 %33 to i1
  %conv26 = zext i1 %tobool25 to i32
  ret i32 %conv26
}

declare i8* @strrchr(i8*, i32) #1

; Function Attrs: noinline nounwind ssp uwtable
define internal void @materialInit(%struct.objzMaterial* %_mat) #0 {
entry:
  %_mat.addr = alloca %struct.objzMaterial*, align 8
  store %struct.objzMaterial* %_mat, %struct.objzMaterial** %_mat.addr, align 8
  %0 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %1 = bitcast %struct.objzMaterial* %0 to i8*
  %2 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %3 = bitcast %struct.objzMaterial* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 568, i64 %4) #7
  %5 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %diffuse = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %5, i32 0, i32 2
  %arrayidx = getelementptr inbounds [3 x float], [3 x float]* %diffuse, i64 0, i64 2
  store float 1.000000e+00, float* %arrayidx, align 4
  %6 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %diffuse1 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %6, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [3 x float], [3 x float]* %diffuse1, i64 0, i64 1
  store float 1.000000e+00, float* %arrayidx2, align 4
  %7 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %diffuse3 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %7, i32 0, i32 2
  %arrayidx4 = getelementptr inbounds [3 x float], [3 x float]* %diffuse3, i64 0, i64 0
  store float 1.000000e+00, float* %arrayidx4, align 4
  %8 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8
  %opacity = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %8, i32 0, i32 6
  store float 1.000000e+00, float* %opacity, align 4
  ret void
}

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @skipTokens(%struct.Lexer* %_lexer, i32 %_n) #0 {
entry:
  %retval = alloca i1, align 1
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_n.addr = alloca i32, align 4
  %token = alloca %struct.Token, align 4
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8
  store i32 %_n, i32* %_n.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %_n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8
  call void @tokenize(%struct.Lexer* %2, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %line = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %3 = load i32, i32* %line, align 4
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %4 = load i32, i32* %column, align 4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.55, i32 0, i32 0), i32 %3, i32 %4)
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %6 = load i1, i1* %retval, align 1
  ret i1 %6
}

declare double @atof(i8*) #1

; Function Attrs: nounwind readnone
declare float @sqrtf(float) #8

; Function Attrs: noinline nounwind ssp uwtable
define internal i32 @sdbmHash(i8* %_data, i32 %_size) #0 {
entry:
  %_data.addr = alloca i8*, align 8
  %_size.addr = alloca i32, align 4
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %_data, i8** %_data.addr, align 8
  store i32 %_size, i32* %_size.addr, align 4
  store i32 0, i32* %hash, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %_size.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %_data.addr, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %4 to i32
  %5 = load i32, i32* %hash, align 4
  %shl = shl i32 %5, 6
  %add = add i32 %conv, %shl
  %6 = load i32, i32* %hash, align 4
  %shl1 = shl i32 %6, 16
  %add2 = add i32 %add, %shl1
  %7 = load i32, i32* %hash, align 4
  %sub = sub i32 %add2, %7
  store i32 %sub, i32* %hash, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load i32, i32* %hash, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind ssp uwtable
define internal zeroext i1 @vec3Equal(%struct.vec3* %_a, %struct.vec3* %_b, float %epsilon) #0 {
entry:
  %_a.addr = alloca %struct.vec3*, align 8
  %_b.addr = alloca %struct.vec3*, align 8
  %epsilon.addr = alloca float, align 4
  store %struct.vec3* %_a, %struct.vec3** %_a.addr, align 8
  store %struct.vec3* %_b, %struct.vec3** %_b.addr, align 8
  store float %epsilon, float* %epsilon.addr, align 4
  %0 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %0, i32 0, i32 0
  %1 = load float, float* %x, align 4
  %2 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8
  %x1 = getelementptr inbounds %struct.vec3, %struct.vec3* %2, i32 0, i32 0
  %3 = load float, float* %x1, align 4
  %sub = fsub float %1, %3
  %call = call float @fabsf(float %sub) #4
  %4 = load float, float* %epsilon.addr, align 4
  %cmp = fcmp ole float %call, %4
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %5, i32 0, i32 1
  %6 = load float, float* %y, align 4
  %7 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8
  %y2 = getelementptr inbounds %struct.vec3, %struct.vec3* %7, i32 0, i32 1
  %8 = load float, float* %y2, align 4
  %sub3 = fsub float %6, %8
  %call4 = call float @fabsf(float %sub3) #4
  %9 = load float, float* %epsilon.addr, align 4
  %cmp5 = fcmp ole float %call4, %9
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %10 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %10, i32 0, i32 2
  %11 = load float, float* %z, align 4
  %12 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8
  %z6 = getelementptr inbounds %struct.vec3, %struct.vec3* %12, i32 0, i32 2
  %13 = load float, float* %z6, align 4
  %sub7 = fsub float %11, %13
  %call8 = call float @fabsf(float %sub7) #4
  %14 = load float, float* %epsilon.addr, align 4
  %cmp9 = fcmp ole float %call8, %14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %15 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp9, %land.rhs ]
  ret i1 %15
}

attributes #0 = { noinline nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { allocsize(1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { allocsize(1) }
attributes #10 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"PIC Level", i32 2}
!1 = !{!"clang version 4.0.1 (https://github.com/llvm-mirror/clang.git 3c8961bedc65c9a15cbe67a2ef385a0938f7cfef) (https://github.com/llvm-mirror/llvm.git c8fccc53ed66d505898f8850bcc690c977a7c9a7)"}
