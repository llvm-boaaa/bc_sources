; ModuleID = 'tigr.c'
source_filename = "tigr.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.TigrFont = type { %struct.Tigr*, i32, %struct.TigrGlyph* }
%struct.Tigr = type { i32, i32, %struct.TPixel*, i8* }
%struct.TPixel = type { i8, i8, i8, i8 }
%struct.TigrGlyph = type { i32, i32, i32, i32, i32 }
%struct.objc_object = type { %struct.objc_class* }
%struct.objc_class = type { %struct.objc_class*, %struct.objc_class*, i8*, i64, i64, i64, %struct.objc_ivar_list*, %struct.objc_method_list**, %struct.objc_cache*, %struct.objc_protocol_list* }
%struct.objc_ivar_list = type { i32, i32, [1 x %struct.objc_ivar] }
%struct.objc_ivar = type { i8*, i8*, i32, i32 }
%struct.objc_method_list = type { %struct.objc_method_list*, i32, i32, [1 x %struct.objc_method] }
%struct.objc_method = type { %struct.objc_selector*, i8*, void ()* }
%struct.objc_selector = type opaque
%struct.objc_cache = type { i32, i32, [1 x %struct.objc_method*] }
%struct.objc_protocol_list = type { %struct.objc_protocol_list*, i64, [1 x %struct.objc_object*] }
%struct.CGPoint = type { double, double }
%struct.mach_timebase_info = type { i32, i32 }
%struct.PNG = type { i8*, i8* }
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.Save = type { i32, i32, i32, i32, i32, %struct.__sFILE*, [256 x i32] }
%struct.TigrInternal = type { i32, i32, %struct.GLStuff, i8*, %struct.Tigr*, i32, i8, float, i32, i32, float, float, i32, i32, [4 x i32], i32, [256 x i8], [256 x i8], i32 }
%struct.GLStuff = type { [2 x i32], i32, i32, i32, i32, i32, i32 }
%struct.State = type { i32, i32, i8*, i8*, i8*, i8*, [37 x i32], [288 x i32], [32 x i32], [19 x i32], i32, i32, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.__CFString = type opaque
%struct.__CFAllocator = type opaque
%struct.__CFURL = type opaque
%struct.CGSize = type { double, double }
%struct.CGRect = type { %struct.CGPoint, %struct.CGSize }
%struct.anon = type { %union.anon }
%union.anon = type { %struct.anon.0 }
%struct.anon.0 = type { i8 }

@.str = private unnamed_addr constant [3 x i8] c"wb\00", align 1
@.str.1 = private unnamed_addr constant [5 x i8] c"IEND\00", align 1
@.str.2 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@tigr_font = constant [3850 x i8] c"\89PNG\0D\0A\1A\0A\00\00\00\0DIHDR\00\00\00\FD\00\00\00\5C\08\03\00\00\00\92\ABC\85\00\00\03\00PLTE_S\87\00\00\00TTT\FF\FF\FA1*B\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00JD\B7Z\00\00\0B\C5IDATx\9C\ED\5C\8B\82\E4&\0ED\C0\FF\7F\F3\8D\91J/\C0\8D{zv\93\9Bt2\C6\C6\BC\0A\09P!\BC\A5\FF\E6_\E9\85\7F\BD5\BA\FE\AE\A04\BA\FE\FFz\F5u-\EE\D1R\16I\8EX\17\A4[N,I\9B\14(\CF\1A\7F\DD]\E5\8D\08\8D\CF\CF.\BD/]ZE\C5\15\FD\09\F4\D2\08\BA\FE\1B\8F\E4R\D6\CE\89\A5\8B\10,\D0\7F%#\A0 .\80\9A\8F\E76\8Fg\FA*\17\F1\D7\93O\E7\C2\8E\AA+\AA\A3P\F4;\E8\E9\CAk2`\D8}\5C\EBH1j \15\BBK\B4C\DF\18\8D\CAv\14\F0U\1A\A3\E3\B0H\AFs\EF\8E\8A\0A\09.\C4\A7P\14\90\9B\C5\0A2$\84\22\DFA_\BE\F2\0E\99^\9D\C0\B2\BD\1AA\15\FD\CA\08\19\90\A0\1F\C0\AA\B6\A1\14\7F;\FAD{s\88E4\82\A5\86\BC_5\A0\D7\91\9E,\1D\B5f!\F7\DA\F8\BB\C0\97\A1!\A30\16\02gy\0B\BDH\0D\9AO\18\AE\5CM\E3\10\E2\09\B2\BF\FA\8B\C5e\CD)&\1D\D5p\19%#\FE\AB\C1\E4\C7{\D6t\A4\D3gB<7\02\CA\DE\FC0\E0,O\D1\93\0D\A1\A4\F9W\B9,\12<{\F4\97bp\B5+\CD\87\D2\D4\80\DE\BA\B1x\D4Y\D3\91N\9F\ED}\F7\CA\CE\9D-\1D\CAU|C\F6N\F3\1B\97\DB\08\22\11\A1\1A\FAR\04\09\1A\DA]\81\B9\F5:\EB\D5\B2F\95\C3\90n\1A\F7Pv\9E\F3\A5\19#\FC\8C\E6\8F\FE\F4\9D!\B2\87\86V'\E9\B2B/\89mn\F0\9A.\F1\AA\03~|\CB\E4\E2\F3k\C8s\D3\95\CF\CD\F9\B5\94\F7e\EF4\9F'?\95\A7>^\1A\86\01-3O^\EF\9D0F\8A*\89GR\12%E\88\F8+yx\D6\F4\B5\F8\FC.}\D7\8E\0F\0Dx\1B}.h\F7h)\FB\9C\A8Gm\E8\DB\02\BE\1Bv\ED\F8\8C\FE=\CD\FF\0C\FA\A8\0D?\88>\97\9E\AA\FA;\E8W\B7\FFd\F4\BF\F9\C7\F3\84.\C3\D1\D4J\CFy\CA\B6\F7X\88\5C|Z\C0\8A,\5Cy=\BF\AD0\B3\9D\C5\CAW\E6\1B\DF\94f\0B\8F\9AD\A6.\9D\D73\825\B3#\15\1A\82\84x2\82*I-c\D2\05+\A27{\FFeE>D\C1\E7\E8\9D\D5Xm\D9\A5.v\9B\A1\1Fv\18\AC\99\A9\F0\5C\A9\CA\B0\94\E9\BD\19\B2\05:\11\96\ED\96\95gUa\92\A0\D8\CC\0DV\D2\1A=\F9\AA\1A\CC}\901R\03\F3\02\EB\D6\E4\CE\FC\15\B6\9Ck\5Ch\B5\A9\13\0Ck\0A\BD\A0\96vB\DF`\A6\A3\1C\95\F9\0B\F4f\DD(/\B8C_H\AA2\FB\C9 \F4b\E8\AF\D5\D0\D6dA_\CC\92\8DaBO0\5C\116\9F~-\FB\80\1E\5C.\0E\19\DF\DD\A1@\92\F1\BFGo\F4I\E8g\13\F3\D4:^\E8\80\DA\D4%j\FE\D0\9B\DD\B0J\95&\CD\0F \16\E8\A7^\DCi:\A1\AD\B1@\0AJ\B5\D4\91\D6t\83\C0\F7\931\0C\9E\EA6\E8\A9\B1\01\BBV\AC]o\E4^I\8DT\99\9F\A2\D7\A1\91{e\85\DE\F1\06\CDPsJ\E5G]\C8\D0\12}![\D1\E6ag\1B\17\9E\A4D\F2\11E\81\FD\8Ey%\9C\D0\EF\D8L~\0FL\FALZA\A5P\B2\93\BD\ADxE\B6\D7\9A#`\E3\A9\B3el\A4BIH \1B\99\A4D\F2\11\F2\09Y\E1M\97\18?bq\E3Y\8D/p\A0N\EFa\BC\E7\E7P\A0\EC\85\E1\8D\F2\A91\C7\B9\DBRtK\C0,\DD\9F1HW\E1}\02k\E3\F3\02\D7)z\BE\0D\9A\7F\D4\A8\0F\86?W\E0\7F\E8\E7\F0\16\FDo\FE\F9\BD([\CB\5C\17\F9\D7b>\E6\D4\98W\D3\E2\F6\AE\AC\BB\99\0D\B7\92\9E\B2\F9=?\FF\F6S\E8[\F3\93\92.T2\AF&\83\E9\8F\A3\C7j\09\1F\D3\11\FA\B1k\BB\A2\96JU\E3k\C7`\D5Np\B2o\CE\BEV\B3\C7\17\9B\9E]A%T\B3\B4\89\D6/\D4\E0sNF&\B3\AF\D0\0F\B3a\E10\8B\14\96\D0\A7\8B\E8\80\DE\0C\1D3D\17\19\F6\A1\AF\E6\0C\BDc\B3pI\B5\C6\FE\B7+\FA\C6\AD5\F4F]D\A1\A2\E5\B6\C5\86l8\F4f_7\C7\E9^\9A\D0\E4<g\DBj\E2\C67^\98\BF\CB\CB\BE\0E2{m+\BFB\DF&\D2\95\D0\C3]r\80^\93\8Cl5\17\BB\D5\E9KI\85\AAl\AB\81\8B9Z\E6\A5\81\D7E\CD/\B2-\7F\80~\D1\9C)\FA\04\BD\11\9C\BB\81\BAa9\EA\E8\DEp\9Ai !{-K\F4\AF\C7}\D4|\CFo\CCg\0Av\D1\8Cll\D1\EB\0C1\A3\CF\B4\C9\17\84f\08\89\F1\B5\0A\A7\996pb\AB9\1DV\BC\FA\00}\F1N\16\E57\1A\ED|) \1B\CD\91\11Y\F1|T\E4\1E\99\B5\B4f\D5 \17\9A!$f\CDqj`U\96\1D.lx\B9\CC\ABp\84~\B3\82\AE\A3u X\B4\A8\FC\C2\C2\5C\95\A3\E3\BCdk\EAu\ED\A9\18\CBn\06mO\D9>\8B\DE;\1FQ!MQ?\8F>\B6\E3O\A1\F7\CEG\ADp\8A\BAA\AF\9A^V\8C\F6\18}l\C7{\E8\7F\F3/\F4\91\84y,\15\8B\F7a\93\CDb1(\CDO \16,\17c/:\EC\80\B06\16\9B1r\A5\BD`\E1m\84T\BE\16\FF\EB.\8Fk\D8\01z1\B2\AD\E9\F9L\C2\12\BD\98\91|\92\A9\E8I\87\A2S \EB\B4\BDx\8E\DE\CE\8CU\1C\9Aq\B5l\D0K\0A9s\F0\12\FD0\F2)\A0\9F\1ARf/\DE8\C8 \87\D9D\DE\14\D0\17\00V-\F0G> M,\E2+\F4b\AB\B2\1C\AF\1E\08\B5\B0\C9gT\EB\FAM\14\E9\15\FA\91zx\BB\BA\A2\5Ci>\9Ci\EA\AD\E3\9E\AE\C6\E8q\C2\A9K\A3\C6AG\E5 \E3\7Fw\E4\83W\EF\8EE\DC\99-n\DC\14'\C7\02\82E\1D\B6 W#\E5\0F!:\07\DE\11z\12\CF\0C\00\A9(^h>\22e\FEV\86B\15\9A_\A5\D0&dC\BB,h\AA\AA\96\9A-\A4\9B\C3\B3\08D\02f\E6\ABJ^B\F8z\99\8E\F8\1D\C9\DE\CFz\1B\CD\CF[\E5\8A^\A6\191\F0q\A8S5\1F\1C\C4\CF\AB\EBUp\9E\F5\E6F\C8daN\D7\06\872\D0Kub\1E\1F\C9\1E\D338\86LF\18\9D\0D<\D2\8D\00\E9*\A3\D1b\E0\D34\EE\E5(\D9=\FA\05\DA\D5\E4\03\1E\A4\E6>T\1C\E8\B5:n\ED+\F4E\CD\B43\F4Q\F3\C5\FF[\1DC\01\FD\90\B9.\CCz\DFE/\B58\7F-\18S\98\94\E9\1C\BD\9Ai\BD\E1\D0\AC\DA\ED\95'%\EF&\B1\B0`B\D2\E3l\E3-\D8\91\ACxv\F7\01\F4R\8B\F3\EC\04b\A6D\AD\9F\9D\DD\F2\D5ws+u\85\9C\9A\12\C3\9E_\CF\B1\DD\DF}\1F\FD\AA\96Ey\FA\F8\00\BD\E5\DBV\FC\1F\FA\FF'\F4\BF\F9\97;_\A7u[\F4\C3F\9E\BE\C3\D9u\18\01\F21\01\E9\972z\D5$2\1B{{\A2\E9&`$\FAfS\B88!/\DD3\AB\A2g\E0\A7\BB\03\F1\AF\D1\C3\06\E754\A2\17Z\C0\E7\95\F9a\18\01\F2}@:=\EC\93\C0,q\1F\B2\10>l\88\E8\9B\FB\12\C0\8B\A0\83\F5PBJ$]\E2\EE\1E\A1o\8ED4fh\F3\E1\0Cfu8\F6\C4\A7\DD\E4\B8\17\DB J\C1pe\A3\D7#\13\F5\00M6\EB\B8\DE\A2'\D38\81\DF\19h\95r\A6\BB\D7K~D\0F\C3\A6\81X\EB\0E-z\A1\13>\CE\11hl(\8A\B9W\E1\CB\80\DD\01\0E\EC\D0c_V\DE\B2U\CA;\9Bi\EB^w\8BM\F3\A5$\92\0E\D51p\95cL\1Bv\E6\03\F4\F0Qi\D3f_\0E\891gT\96X\F7X\F6\AA\9126D\D1[\13KZP\88U!\DE*\BF\01\1D\F6\AA3zTQm\84\B1\B1\87\A3\86\DAa\DA\DD/\0D\9EI\F6\10\8F\17\85;)\CA\1D\AFlXN\BB\C9\A1\18h$\CF\16\AA\F9Q\F6\B8\A2\9F\DC\06\B4\ED\D2\CA\F9I\BF\E9'UTSn\EEe\D4\AFw\BA\13\F2M\CD\8F^\14\8C\FBB*+\E2)M\99+\E9\10\D7\B9\8F\1A\F6(\12zg.\EBE\D13w\8Cs\BE\A5r#\9B\8F\D9\EE\EE\9E\A1\A7\84\96\A0\C3&{\1CG\13-\0EOE\BE\E7\0B0}\12\8B\8E4\D9\D0\83q\B5\1B\F4\B2\D9!\0AdKH\BEk\ED\99\E6\CB\A6\98\9E\F7\AA\90\22\C13\AB\C7\D1 A\8A2\0C\E2\9D\92X\B4\DB\BF\88\B27\F7M\D8\EEZ\98\89P \1Ee\F3]\93=\B7s\F4q\A5\CCa\DE{\8Fxw\E8W\85\F5\9C\CF4?\A5\EDv\0Aa]\8F;v\1C\EF0\8C\1E\A0\9F\C545\E6\07\D1{7\87V\D8^\A1\DF\DC\1Dln\AD\04\FB\F7\D0/+$\0C\F2\87\E8\E1\EA\B9E\FF\9B\7Fa\5Ca\D0\C7\1D,\F1\8A\F8\1D-\ED\DE\06:\E4\B2v\B3bAL$N\AEb\EB6\CBlI\8E\1A2\89{\93\D12(\CF\A2\D8\EE>Vi)\03\8B(\E7\81\DB\1C\1Ff\CE\E8a\0A\17\F9\00@\BE\04\C6.o\85\1D[\BA{\D3eYt\99\B1ev\D8\90\09\FD&\A3\B5\9C\DC7\E4\C5Ni\B9~8\0D#\FAb\A6\F1>X]\8B3\EA\B1\9Dz\D4\001\AE\8B\F8r\C2I\96\9A\C2\E2\9F\A1mR\C4@\EF\F2\1E\85\EAAP\CB\18\EB\F4:`V3_\B9\ED\C2\11\9E4@6\91\A1;\EB\A3m\AB\109x\EC\8D2\8E\F3\BA\90}\94\14\BF\B6\A2MP6W2\11YW\1E\81 =\A2\95\C9\D8:\0C\C7\8E\80\9E {\A7\A8\C7\A1h\90\93}\DD\04;\F4^\F3\9F\A1\C7l\DA\16_\C0l\BA\0B\FD%V\F7\FB\9A\0F\D9\FB\7FV\80{a\1D\9C\A0\0F\8E\C7\97\A1|S'\BAs\80^\17\8D&Vw@\FFT\F3\0B\F4 \1EA{<\EB!sT\D0\97\A1\B8s\09\92|\95\C1{ q0P\DE\F8sg\0FB=\CAf\B4\A8\EE\83\D5u\FA\1Ch\FA7\06v!\AF7\EC\C6\09\9F\EBl3\C0C\03Kz\E4\AD%\EEj>\09ag8\1B\E0&\D8]\DF\A8x\B5\DE?l\B9\C5|\13\BDg\AF\BF\0F\FD\A2A\FF*\F4\BF\F9W\F6\1C\C1\91\8F\B6c9\1An\CAh\04^\D3\99\D9\F8\E3f\0D\DC\00\E1m3\DA\878\8E?\CC6\C6\AE\A2\5C\92\0B\B0\95[\F4\F7<Cv\FB\ED\94\DBhSS\DB\A5\1E4\C3Q\96\84\FE\19\C7\F1\87\D9\CAs\96c\C6\DEy\1E^\A6\E5\94\9B\EC\D8\C9\F1\A8\D1\B7\0F\8A\C2\F6\D3x~\83\E3\E8\8B._\A0\EB\91\AF\07\E1S\FB\10\7F\E6\B4D[\B4M\87E\C1Vz\93\E3D\F4\E4\ED\B6\E3\10V\9Bc\B8\B7\DC \A3oJ\B7\1E\DA\B9\B0\B3\DA)\C7\F1\E8CD\EF\DF\B0\F3#\C7\D3\E7]8\A3/\8F\1A\AF \D4\CD|\C8q^\A2\7F\C3\CE\7F\9C\E7s\E81M\1Cr\9C{\F4ok\FE\09!\91pFOy\0E:-Jf\FAs\8E\83v+\ABB\04\CF\F9\C6X\1E\84\CA#\DA\091\11vd\87\C2\FE$\C7!\FB\D2+D\F4\FEQ\96s\1B\E2\CF]\DE\A9\F6\B9\9D\1B4\DFG|\00\FD\C2G\F7\0FC\EF\F7 \82g\FA\03\E8\8F\C3\BF\86\DE\FF\EB!\E1\DF:\EC\BF\DD\97\F3?\CA\1B\AA\DF\FC\A4\05\0A\00\00\00\00IEND\AEB`\82", align 16
@tigr_font_size = global i32 3850, align 4
@tigrStockFont = common global %struct.TigrFont zeroinitializer, align 8
@tfont = global %struct.TigrFont* @tigrStockFont, align 8
@cp1252 = internal global [128 x i32] [i32 8364, i32 65533, i32 8218, i32 402, i32 8222, i32 8230, i32 8224, i32 8225, i32 710, i32 8240, i32 352, i32 8249, i32 338, i32 65533, i32 381, i32 65533, i32 65533, i32 8216, i32 8217, i32 8220, i32 8221, i32 8226, i32 8211, i32 8212, i32 732, i32 8482, i32 353, i32 8250, i32 339, i32 65533, i32 382, i32 376, i32 160, i32 161, i32 162, i32 163, i32 164, i32 165, i32 166, i32 167, i32 168, i32 169, i32 170, i32 171, i32 172, i32 173, i32 174, i32 175, i32 176, i32 177, i32 178, i32 179, i32 180, i32 181, i32 182, i32 183, i32 184, i32 185, i32 186, i32 187, i32 188, i32 189, i32 190, i32 191, i32 192, i32 193, i32 194, i32 195, i32 196, i32 197, i32 198, i32 199, i32 200, i32 201, i32 202, i32 203, i32 204, i32 205, i32 206, i32 207, i32 208, i32 209, i32 210, i32 211, i32 212, i32 213, i32 214, i32 215, i32 216, i32 217, i32 218, i32 219, i32 220, i32 221, i32 222, i32 223, i32 224, i32 225, i32 226, i32 227, i32 228, i32 229, i32 230, i32 231, i32 232, i32 233, i32 234, i32 235, i32 236, i32 237, i32 238, i32 239, i32 240, i32 241, i32 242, i32 243, i32 244, i32 245, i32 246, i32 247, i32 248, i32 249, i32 250, i32 251, i32 252, i32 253, i32 254, i32 255], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@tigr_upscale_gl_vs = constant [259 x i8] c"#version 330 core\0D\0A\0D\0Alayout (location = 0) in vec2 pos_in;\0D\0Alayout (location = 1) in vec2 uv_in;\0D\0A\0D\0Aout vec2 uv;\0D\0A\0D\0Auniform mat4 model;\0D\0Auniform mat4 projection;\0D\0A\0D\0Avoid main()\0D\0A{\0D\0A\09uv = uv_in;\0D\0A\09gl_Position = projection * model * vec4(pos_in, 0.0, 1.0);\0D\0A}\0D\0A", align 16
@tigr_upscale_gl_vs_size = global i32 259, align 4
@tigr_upscale_gl_fs = constant [444 x i8] c"#version 330 core\0D\0A\0D\0Ain vec2 uv;\0D\0A\0D\0Aout vec4 color;\0D\0A\0D\0Auniform sampler2D image;\0D\0Auniform vec4 parameters;\0D\0A\0D\0Avoid main()\0D\0A{\0D\0A\09vec2 tex_size = textureSize(image, 0);\0D\0A\09vec2 uv_blur = mix(floor(uv * tex_size) + 0.5, uv * tex_size, parameters.xy) / tex_size;\0D\0A\09vec4 c = texture(image, uv_blur);\0D\0A\09c.rgb *= mix(0.5, 1.0 - fract(uv.y * tex_size.y), parameters.z) * 2.0; //scanline\0D\0A\09c = mix(vec4(0.5), c, parameters.w); //contrast \0D\0A\09color = c;\0D\0A}\0D\0A", align 16
@tigr_upscale_gl_fs_size = global i32 444, align 4
@__func__.tigrInternal = private unnamed_addr constant [13 x i8] c"tigrInternal\00", align 1
@.str.4 = private unnamed_addr constant [7 x i8] c"tigr.c\00", align 1
@.str.5 = private unnamed_addr constant [12 x i8] c"bmp->handle\00", align 1
@terminated = global i8 0, align 1
@.str.6 = private unnamed_addr constant [7 x i8] c"closed\00", align 1
@.str.7 = private unnamed_addr constant [11 x i8] c"tigrHandle\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"delegate\00", align 1
@autoreleasePool = internal global %struct.objc_object* null, align 8
@.str.9 = private unnamed_addr constant [6 x i8] c"drain\00", align 1
@tigrOSXInited = internal global i8 0, align 1
@.str.10 = private unnamed_addr constant [18 x i8] c"NSAutoreleasePool\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"alloc\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@.str.13 = private unnamed_addr constant [14 x i8] c"NSApplication\00", align 1
@.str.14 = private unnamed_addr constant [18 x i8] c"sharedApplication\00", align 1
@NSApp = external global %struct.objc_object*, align 8
@.str.15 = private unnamed_addr constant [21 x i8] c"setActivationPolicy:\00", align 1
@.str.16 = private unnamed_addr constant [9 x i8] c"NSObject\00", align 1
@.str.17 = private unnamed_addr constant [12 x i8] c"AppDelegate\00", align 1
@.str.18 = private unnamed_addr constant [22 x i8] c"NSApplicationDelegate\00", align 1
@__func__.tigrInitOSX = private unnamed_addr constant [12 x i8] c"tigrInitOSX\00", align 1
@.str.19 = private unnamed_addr constant [16 x i8] c"resultAddProtoc\00", align 1
@.str.20 = private unnamed_addr constant [28 x i8] c"applicationShouldTerminate:\00", align 1
@.str.21 = private unnamed_addr constant [5 x i8] c"L@:@\00", align 1
@.str.22 = private unnamed_addr constant [16 x i8] c"resultAddMethod\00", align 1
@.str.23 = private unnamed_addr constant [12 x i8] c"autorelease\00", align 1
@.str.24 = private unnamed_addr constant [13 x i8] c"setDelegate:\00", align 1
@.str.25 = private unnamed_addr constant [16 x i8] c"finishLaunching\00", align 1
@.str.26 = private unnamed_addr constant [7 x i8] c"NSMenu\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"NSMenuItem\00", align 1
@.str.28 = private unnamed_addr constant [9 x i8] c"addItem:\00", align 1
@.str.29 = private unnamed_addr constant [13 x i8] c"setMainMenu:\00", align 1
@.str.30 = private unnamed_addr constant [14 x i8] c"NSProcessInfo\00", align 1
@.str.31 = private unnamed_addr constant [12 x i8] c"processInfo\00", align 1
@.str.32 = private unnamed_addr constant [12 x i8] c"processName\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"NSString\00", align 1
@.str.34 = private unnamed_addr constant [22 x i8] c"stringWithUTF8String:\00", align 1
@.str.35 = private unnamed_addr constant [6 x i8] c"Quit \00", align 1
@.str.36 = private unnamed_addr constant [25 x i8] c"stringByAppendingString:\00", align 1
@.str.37 = private unnamed_addr constant [2 x i8] c"q\00", align 1
@.str.38 = private unnamed_addr constant [36 x i8] c"initWithTitle:action:keyEquivalent:\00", align 1
@.str.39 = private unnamed_addr constant [11 x i8] c"terminate:\00", align 1
@.str.40 = private unnamed_addr constant [12 x i8] c"setSubmenu:\00", align 1
@.str.41 = private unnamed_addr constant [6 x i8] c"Error\00", align 1
@.str.42 = private unnamed_addr constant [12 x i8] c"contentView\00", align 1
@.str.43 = private unnamed_addr constant [6 x i8] c"frame\00", align 1
@.str.44 = private unnamed_addr constant [22 x i8] c"convertRectToBacking:\00", align 1
@.str.45 = private unnamed_addr constant [9 x i8] c"NSWindow\00", align 1
@.str.46 = private unnamed_addr constant [45 x i8] c"initWithContentRect:styleMask:backing:defer:\00", align 1
@.str.47 = private unnamed_addr constant [23 x i8] c"setReleasedWhenClosed:\00", align 1
@.str.48 = private unnamed_addr constant [15 x i8] c"WindowDelegate\00", align 1
@.str.49 = private unnamed_addr constant [17 x i8] c"NSWindowDelegate\00", align 1
@__func__.tigrWindow = private unnamed_addr constant [11 x i8] c"tigrWindow\00", align 1
@.str.50 = private unnamed_addr constant [2 x i8] c"L\00", align 1
@.str.51 = private unnamed_addr constant [14 x i8] c"resultAddIvar\00", align 1
@.str.52 = private unnamed_addr constant [4 x i8] c"\CB\86v\00", align 1
@.str.53 = private unnamed_addr constant [17 x i8] c"windowWillClose:\00", align 1
@.str.54 = private unnamed_addr constant [5 x i8] c"v@:@\00", align 1
@.str.55 = private unnamed_addr constant [20 x i8] c"windowDidBecomeKey:\00", align 1
@.str.56 = private unnamed_addr constant [37 x i8] c"setWantsBestResolutionOpenGLSurface:\00", align 1
@tigrWindow.point = private unnamed_addr constant %struct.CGPoint { double 2.000000e+01, double 2.000000e+01 }, align 8
@.str.57 = private unnamed_addr constant [25 x i8] c"cascadeTopLeftFromPoint:\00", align 1
@.str.58 = private unnamed_addr constant [10 x i8] c"setTitle:\00", align 1
@tigrWindow.glAttributes = private unnamed_addr constant [9 x i32] [i32 8, i32 24, i32 11, i32 8, i32 5, i32 73, i32 99, i32 12800, i32 0], align 16
@.str.59 = private unnamed_addr constant [20 x i8] c"NSOpenGLPixelFormat\00", align 1
@.str.60 = private unnamed_addr constant [20 x i8] c"initWithAttributes:\00", align 1
@.str.61 = private unnamed_addr constant [16 x i8] c"NSOpenGLContext\00", align 1
@.str.62 = private unnamed_addr constant [29 x i8] c"initWithFormat:shareContext:\00", align 1
@.str.63 = private unnamed_addr constant [9 x i8] c"setView:\00", align 1
@.str.64 = private unnamed_addr constant [22 x i8] c"makeKeyAndOrderFront:\00", align 1
@.str.65 = private unnamed_addr constant [28 x i8] c"setAcceptsMouseMovedEvents:\00", align 1
@.str.66 = private unnamed_addr constant [8 x i8] c"NSColor\00", align 1
@.str.67 = private unnamed_addr constant [11 x i8] c"blackColor\00", align 1
@.str.68 = private unnamed_addr constant [20 x i8] c"setBackgroundColor:\00", align 1
@.str.69 = private unnamed_addr constant [27 x i8] c"activateIgnoringOtherApps:\00", align 1
@.str.70 = private unnamed_addr constant [19 x i8] c"makeCurrentContext\00", align 1
@.str.71 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.72 = private unnamed_addr constant [11 x i8] c"sendEvent:\00", align 1
@.str.73 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.74 = private unnamed_addr constant [13 x i8] c"buttonNumber\00", align 1
@.str.75 = private unnamed_addr constant [14 x i8] c"modifierFlags\00", align 1
@.str.76 = private unnamed_addr constant [11 x i8] c"characters\00", align 1
@.str.77 = private unnamed_addr constant [11 x i8] c"UTF8String\00", align 1
@.str.78 = private unnamed_addr constant [8 x i8] c"keyCode\00", align 1
@.str.79 = private unnamed_addr constant [10 x i8] c"keyWindow\00", align 1
@.str.80 = private unnamed_addr constant [7 x i8] c"NSDate\00", align 1
@.str.81 = private unnamed_addr constant [12 x i8] c"distantPast\00", align 1
@.str.82 = private unnamed_addr constant [48 x i8] c"nextEventMatchingMask:untilDate:inMode:dequeue:\00", align 1
@NSDefaultRunLoopMode = external constant %struct.objc_object*, align 8
@.str.83 = private unnamed_addr constant [14 x i8] c"updateWindows\00", align 1
@.str.84 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@.str.85 = private unnamed_addr constant [12 x i8] c"flushBuffer\00", align 1
@.str.86 = private unnamed_addr constant [34 x i8] c"mouseLocationOutsideOfEventStream\00", align 1
@__func__.tigrKeyDown = private unnamed_addr constant [12 x i8] c"tigrKeyDown\00", align 1
@.str.87 = private unnamed_addr constant [10 x i8] c"key < 256\00", align 1
@__func__.tigrKeyHeld = private unnamed_addr constant [12 x i8] c"tigrKeyHeld\00", align 1
@tigrTime.time = internal global i64 0, align 8
@tigrTime.timebaseInfo = internal global %struct.mach_timebase_info zeroinitializer, align 4
@.str.88 = private unnamed_addr constant [35 x i8] c"got gl error %x when was doing %s\0A\00", align 1
@.str.89 = private unnamed_addr constant [27 x i8] c"shader compile error : %s\0A\00", align 1
@.str.90 = private unnamed_addr constant [24 x i8] c"shader link error : %s\0A\00", align 1
@tigrGAPICreate.vertices = private unnamed_addr constant [24 x float] [float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00], align 16
@.str.91 = private unnamed_addr constant [11 x i8] c"projection\00", align 1
@.str.92 = private unnamed_addr constant [6 x i8] c"model\00", align 1
@.str.93 = private unnamed_addr constant [11 x i8] c"parameters\00", align 1
@.str.94 = private unnamed_addr constant [15 x i8] c"initialization\00", align 1
@.str.95 = private unnamed_addr constant [8 x i8] c"destroy\00", align 1
@__func__.tigrGAPIDraw = private unnamed_addr constant [13 x i8] c"tigrGAPIDraw\00", align 1
@.str.96 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@__func__.tigrGAPIPresent = private unnamed_addr constant [16 x i8] c"tigrGAPIPresent\00", align 1
@.str.97 = private unnamed_addr constant [8 x i8] c"present\00", align 1
@.str.98 = private unnamed_addr constant [9 x i8] c"\89PNG\0D\0A\1A\0A\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"IHDR\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"IDAT\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"PLTE\00", align 1
@crctable = internal constant [16 x i32] [i32 0, i32 498536548, i32 997073096, i32 651767980, i32 1994146192, i32 1802195444, i32 1303535960, i32 1342533948, i32 -306674912, i32 -267414716, i32 -690576408, i32 -882789492, i32 -1687895376, i32 -2032938284, i32 -1609899400, i32 -1111625188], align 16
@reverseTable = internal constant [256 x i8] c"\00\80@\C0 \A0`\E0\10\90P\D00\B0p\F0\08\88H\C8(\A8h\E8\18\98X\D88\B8x\F8\04\84D\C4$\A4d\E4\14\94T\D44\B4t\F4\0C\8CL\CC,\ACl\EC\1C\9C\5C\DC<\BC|\FC\02\82B\C2\22\A2b\E2\12\92R\D22\B2r\F2\0A\8AJ\CA*\AAj\EA\1A\9AZ\DA:\BAz\FA\06\86F\C6&\A6f\E6\16\96V\D66\B6v\F6\0E\8EN\CE.\AEn\EE\1E\9E^\DE>\BE~\FE\01\81A\C1!\A1a\E1\11\91Q\D11\B1q\F1\09\89I\C9)\A9i\E9\19\99Y\D99\B9y\F9\05\85E\C5%\A5e\E5\15\95U\D55\B5u\F5\0D\8DM\CD-\ADm\ED\1D\9D]\DD=\BD}\FD\03\83C\C3#\A3c\E3\13\93S\D33\B3s\F3\0B\8BK\CB+\ABk\EB\1B\9B[\DB;\BB{\FB\07\87G\C7'\A7g\E7\17\97W\D77\B7w\F7\0F\8FO\CF/\AFo\EF\1F\9F_\DF?\BF\7F\FF", align 16
@lenBits = internal global [31 x i8] c"\00\00\00\00\00\00\00\00\01\01\01\01\02\02\02\02\03\03\03\03\04\04\04\04\05\05\05\05\00\00\00", align 16
@lenBase = internal global [31 x i32] [i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 13, i32 15, i32 17, i32 19, i32 23, i32 27, i32 31, i32 35, i32 43, i32 51, i32 59, i32 67, i32 83, i32 99, i32 115, i32 131, i32 163, i32 195, i32 227, i32 258, i32 0, i32 0], align 16
@distBits = internal global [32 x i8] c"\00\00\00\00\01\01\02\02\03\03\04\04\05\05\06\06\07\07\08\08\09\09\0A\0A\0B\0B\0C\0C\0D\0D\00\00", align 16
@distBase = internal global [32 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 7, i32 9, i32 13, i32 17, i32 25, i32 33, i32 49, i32 65, i32 97, i32 129, i32 193, i32 257, i32 385, i32 513, i32 769, i32 1025, i32 1537, i32 2049, i32 3073, i32 4097, i32 6145, i32 8193, i32 12289, i32 16385, i32 24577, i32 0, i32 0], align 16
@order = internal global [19 x i8] c"\10\11\12\00\08\07\09\06\0A\05\0B\04\0C\03\0D\02\0E\01\0F", align 16

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.Tigr* @tigrBitmap2(i32 %w, i32 %h, i32 %extra) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %extra.addr = alloca i32, align 4
  %tigr = alloca %struct.Tigr*, align 8
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store i32 %extra, i32* %extra.addr, align 4
  %0 = load i32, i32* %extra.addr, align 4
  %conv = sext i32 %0 to i64
  %add = add i64 24, %conv
  %call = call i8* @calloc(i64 1, i64 %add) #13
  %1 = bitcast i8* %call to %struct.Tigr*
  store %struct.Tigr* %1, %struct.Tigr** %tigr, align 8
  %2 = load i32, i32* %w.addr, align 4
  %3 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8
  %w1 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i32 0, i32 0
  store i32 %2, i32* %w1, align 8
  %4 = load i32, i32* %h.addr, align 4
  %5 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8
  %h2 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %5, i32 0, i32 1
  store i32 %4, i32* %h2, align 4
  %6 = load i32, i32* %w.addr, align 4
  %7 = load i32, i32* %h.addr, align 4
  %mul = mul nsw i32 %6, %7
  %conv3 = sext i32 %mul to i64
  %call4 = call i8* @calloc(i64 %conv3, i64 4) #13
  %8 = bitcast i8* %call4 to %struct.TPixel*
  %9 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %9, i32 0, i32 2
  store %struct.TPixel* %8, %struct.TPixel** %pix, align 8
  %10 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8
  ret %struct.Tigr* %10
}

; Function Attrs: allocsize(0,1)
declare i8* @calloc(i64, i64) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.Tigr* @tigrBitmap(i32 %w, i32 %h) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %0 = load i32, i32* %w.addr, align 4
  %1 = load i32, i32* %h.addr, align 4
  %call = call %struct.Tigr* @tigrBitmap2(i32 %0, i32 %1, i32 0)
  ret %struct.Tigr* %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrResize(%struct.Tigr* %bmp, i32 %w, i32 %h) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %y = alloca i32, align 4
  %cw = alloca i32, align 4
  %ch = alloca i32, align 4
  %newpix = alloca %struct.TPixel*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %0 = load i32, i32* %w.addr, align 4
  %1 = load i32, i32* %h.addr, align 4
  %mul = mul nsw i32 %0, %1
  %conv = sext i32 %mul to i64
  %call = call i8* @calloc(i64 %conv, i64 4) #13
  %2 = bitcast i8* %call to %struct.TPixel*
  store %struct.TPixel* %2, %struct.TPixel** %newpix, align 8
  %3 = load i32, i32* %w.addr, align 4
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w1 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 0
  %5 = load i32, i32* %w1, align 8
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load i32, i32* %w.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w3 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 0
  %8 = load i32, i32* %w3, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %6, %cond.true ], [ %8, %cond.false ]
  store i32 %cond, i32* %cw, align 4
  %9 = load i32, i32* %h.addr, align 4
  %10 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h4 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %10, i32 0, i32 1
  %11 = load i32, i32* %h4, align 4
  %cmp5 = icmp slt i32 %9, %11
  br i1 %cmp5, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %12 = load i32, i32* %h.addr, align 4
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %13 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h9 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %13, i32 0, i32 1
  %14 = load i32, i32* %h9, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true7
  %cond11 = phi i32 [ %12, %cond.true7 ], [ %14, %cond.false8 ]
  store i32 %cond11, i32* %ch, align 4
  store i32 0, i32* %y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end10
  %15 = load i32, i32* %y, align 4
  %16 = load i32, i32* %ch, align 4
  %cmp12 = icmp slt i32 %15, %16
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load %struct.TPixel*, %struct.TPixel** %newpix, align 8
  %18 = load i32, i32* %y, align 4
  %19 = load i32, i32* %w.addr, align 4
  %mul14 = mul nsw i32 %18, %19
  %idx.ext = sext i32 %mul14 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %17, i64 %idx.ext
  %20 = bitcast %struct.TPixel* %add.ptr to i8*
  %21 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %21, i32 0, i32 2
  %22 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %23 = load i32, i32* %y, align 4
  %24 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w15 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %24, i32 0, i32 0
  %25 = load i32, i32* %w15, align 8
  %mul16 = mul nsw i32 %23, %25
  %idx.ext17 = sext i32 %mul16 to i64
  %add.ptr18 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %22, i64 %idx.ext17
  %26 = bitcast %struct.TPixel* %add.ptr18 to i8*
  %27 = load i32, i32* %cw, align 4
  %conv19 = sext i32 %27 to i64
  %mul20 = mul i64 %conv19, 4
  %28 = load %struct.TPixel*, %struct.TPixel** %newpix, align 8
  %29 = load i32, i32* %y, align 4
  %30 = load i32, i32* %w.addr, align 4
  %mul21 = mul nsw i32 %29, %30
  %idx.ext22 = sext i32 %mul21 to i64
  %add.ptr23 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %28, i64 %idx.ext22
  %31 = bitcast %struct.TPixel* %add.ptr23 to i8*
  %32 = call i64 @llvm.objectsize.i64.p0i8(i8* %31, i1 false, i1 true)
  %call24 = call i8* @__memcpy_chk(i8* %20, i8* %26, i64 %mul20, i64 %32) #10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load i32, i32* %y, align 4
  %inc = add nsw i32 %33, 1
  store i32 %inc, i32* %y, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix25 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %34, i32 0, i32 2
  %35 = load %struct.TPixel*, %struct.TPixel** %pix25, align 8
  %36 = bitcast %struct.TPixel* %35 to i8*
  call void @free(i8* %36)
  %37 = load %struct.TPixel*, %struct.TPixel** %newpix, align 8
  %38 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix26 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %38, i32 0, i32 2
  store %struct.TPixel* %37, %struct.TPixel** %pix26, align 8
  %39 = load i32, i32* %w.addr, align 4
  %40 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w27 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %40, i32 0, i32 0
  store i32 %39, i32* %w27, align 8
  %41 = load i32, i32* %h.addr, align 4
  %42 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h28 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %42, i32 0, i32 1
  store i32 %41, i32* %h28, align 4
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #2

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #3

declare void @free(i8*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrCalcScale(i32 %bmpW, i32 %bmpH, i32 %areaW, i32 %areaH) #0 {
entry:
  %bmpW.addr = alloca i32, align 4
  %bmpH.addr = alloca i32, align 4
  %areaW.addr = alloca i32, align 4
  %areaH.addr = alloca i32, align 4
  %scale = alloca i32, align 4
  store i32 %bmpW, i32* %bmpW.addr, align 4
  store i32 %bmpH, i32* %bmpH.addr, align 4
  store i32 %areaW, i32* %areaW.addr, align 4
  store i32 %areaH, i32* %areaH.addr, align 4
  store i32 0, i32* %scale, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %0 = load i32, i32* %scale, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* %scale, align 4
  %1 = load i32, i32* %bmpW.addr, align 4
  %2 = load i32, i32* %scale, align 4
  %mul = mul nsw i32 %1, %2
  %3 = load i32, i32* %areaW.addr, align 4
  %cmp = icmp sgt i32 %mul, %3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %4 = load i32, i32* %bmpH.addr, align 4
  %5 = load i32, i32* %scale, align 4
  %mul1 = mul nsw i32 %4, %5
  %6 = load i32, i32* %areaH.addr, align 4
  %cmp2 = icmp sgt i32 %mul1, %6
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %for.cond
  %7 = load i32, i32* %scale, align 4
  %dec = add nsw i32 %7, -1
  store i32 %dec, i32* %scale, align 4
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false
  br label %for.cond

for.end:                                          ; preds = %if.then
  %8 = load i32, i32* %scale, align 4
  %cmp3 = icmp sgt i32 %8, 1
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %9 = load i32, i32* %scale, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %9, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrEnforceScale(i32 %scale, i32 %flags) #0 {
entry:
  %scale.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %scale, i32* %scale.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i32, i32* %flags.addr, align 4
  %and = and i32 %0, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %scale.addr, align 4
  %cmp = icmp slt i32 %1, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 4, i32* %scale.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, i32* %flags.addr, align 4
  %and1 = and i32 %2, 4
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end6

land.lhs.true3:                                   ; preds = %if.end
  %3 = load i32, i32* %scale.addr, align 4
  %cmp4 = icmp slt i32 %3, 3
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true3
  store i32 3, i32* %scale.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true3, %if.end
  %4 = load i32, i32* %flags.addr, align 4
  %and7 = and i32 %4, 2
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.end12

land.lhs.true9:                                   ; preds = %if.end6
  %5 = load i32, i32* %scale.addr, align 4
  %cmp10 = icmp slt i32 %5, 2
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true9
  store i32 2, i32* %scale.addr, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %land.lhs.true9, %if.end6
  %6 = load i32, i32* %scale.addr, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrPosition(%struct.Tigr* %bmp, i32 %scale, i32 %windowW, i32 %windowH, i32* %out) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %scale.addr = alloca i32, align 4
  %windowW.addr = alloca i32, align 4
  %windowH.addr = alloca i32, align 4
  %out.addr = alloca i32*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %scale, i32* %scale.addr, align 4
  store i32 %windowW, i32* %windowW.addr, align 4
  store i32 %windowH, i32* %windowH.addr, align 4
  store i32* %out, i32** %out.addr, align 8
  %0 = load i32, i32* %windowW.addr, align 4
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 0
  %2 = load i32, i32* %w, align 8
  %3 = load i32, i32* %scale.addr, align 4
  %mul = mul nsw i32 %2, %3
  %sub = sub nsw i32 %0, %mul
  %div = sdiv i32 %sub, 2
  %4 = load i32*, i32** %out.addr, align 8
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 0
  store i32 %div, i32* %arrayidx, align 4
  %5 = load i32, i32* %windowH.addr, align 4
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 1
  %7 = load i32, i32* %h, align 4
  %8 = load i32, i32* %scale.addr, align 4
  %mul1 = mul nsw i32 %7, %8
  %sub2 = sub nsw i32 %5, %mul1
  %div3 = sdiv i32 %sub2, 2
  %9 = load i32*, i32** %out.addr, align 8
  %arrayidx4 = getelementptr inbounds i32, i32* %9, i64 1
  store i32 %div3, i32* %arrayidx4, align 4
  %10 = load i32*, i32** %out.addr, align 8
  %arrayidx5 = getelementptr inbounds i32, i32* %10, i64 0
  %11 = load i32, i32* %arrayidx5, align 4
  %12 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w6 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %12, i32 0, i32 0
  %13 = load i32, i32* %w6, align 8
  %14 = load i32, i32* %scale.addr, align 4
  %mul7 = mul nsw i32 %13, %14
  %add = add nsw i32 %11, %mul7
  %15 = load i32*, i32** %out.addr, align 8
  %arrayidx8 = getelementptr inbounds i32, i32* %15, i64 2
  store i32 %add, i32* %arrayidx8, align 4
  %16 = load i32*, i32** %out.addr, align 8
  %arrayidx9 = getelementptr inbounds i32, i32* %16, i64 1
  %17 = load i32, i32* %arrayidx9, align 4
  %18 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h10 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %18, i32 0, i32 1
  %19 = load i32, i32* %h10, align 4
  %20 = load i32, i32* %scale.addr, align 4
  %mul11 = mul nsw i32 %19, %20
  %add12 = add nsw i32 %17, %mul11
  %21 = load i32*, i32** %out.addr, align 8
  %arrayidx13 = getelementptr inbounds i32, i32* %21, i64 3
  store i32 %add12, i32* %arrayidx13, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrClear(%struct.Tigr* %bmp, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %count = alloca i32, align 4
  %n = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 0
  %2 = load i32, i32* %w, align 8
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i32 0, i32 1
  %4 = load i32, i32* %h, align 4
  %mul = mul nsw i32 %2, %4
  store i32 %mul, i32* %count, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %n, align 4
  %6 = load i32, i32* %count, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 2
  %8 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %9 = load i32, i32* %n, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %8, i64 %idxprom
  %10 = bitcast %struct.TPixel* %arrayidx to i8*
  %11 = bitcast %struct.TPixel* %color to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %10, i8* align 1 %11, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrFill(%struct.Tigr* %bmp, i32 %x, i32 %y, i32 %w, i32 %h, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %td = alloca %struct.TPixel*, align 8
  %dt = alloca i32, align 4
  %i = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %x.addr, align 4
  %3 = load i32, i32* %w.addr, align 4
  %add = add nsw i32 %3, %2
  store i32 %add, i32* %w.addr, align 4
  store i32 0, i32* %x.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32, i32* %y.addr, align 4
  %cmp1 = icmp slt i32 %4, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load i32, i32* %y.addr, align 4
  %6 = load i32, i32* %h.addr, align 4
  %add3 = add nsw i32 %6, %5
  store i32 %add3, i32* %h.addr, align 4
  store i32 0, i32* %y.addr, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %7 = load i32, i32* %x.addr, align 4
  %8 = load i32, i32* %w.addr, align 4
  %add5 = add nsw i32 %7, %8
  %9 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w6 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %9, i32 0, i32 0
  %10 = load i32, i32* %w6, align 8
  %cmp7 = icmp sgt i32 %add5, %10
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end4
  %11 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w9 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %11, i32 0, i32 0
  %12 = load i32, i32* %w9, align 8
  %13 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %12, %13
  store i32 %sub, i32* %w.addr, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end4
  %14 = load i32, i32* %y.addr, align 4
  %15 = load i32, i32* %h.addr, align 4
  %add11 = add nsw i32 %14, %15
  %16 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h12 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %16, i32 0, i32 1
  %17 = load i32, i32* %h12, align 4
  %cmp13 = icmp sgt i32 %add11, %17
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end10
  %18 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h15 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %18, i32 0, i32 1
  %19 = load i32, i32* %h15, align 4
  %20 = load i32, i32* %y.addr, align 4
  %sub16 = sub nsw i32 %19, %20
  store i32 %sub16, i32* %h.addr, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  %21 = load i32, i32* %w.addr, align 4
  %cmp18 = icmp sle i32 %21, 0
  br i1 %cmp18, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end17
  %22 = load i32, i32* %h.addr, align 4
  %cmp19 = icmp sle i32 %22, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false, %if.end17
  br label %do.end

if.end21:                                         ; preds = %lor.lhs.false
  %23 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %23, i32 0, i32 2
  %24 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %25 = load i32, i32* %y.addr, align 4
  %26 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w22 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %26, i32 0, i32 0
  %27 = load i32, i32* %w22, align 8
  %mul = mul nsw i32 %25, %27
  %28 = load i32, i32* %x.addr, align 4
  %add23 = add nsw i32 %mul, %28
  %idxprom = sext i32 %add23 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %24, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %td, align 8
  %29 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w24 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %29, i32 0, i32 0
  %30 = load i32, i32* %w24, align 8
  store i32 %30, i32* %dt, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end21
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %31 = load i32, i32* %i, align 4
  %32 = load i32, i32* %w.addr, align 4
  %cmp25 = icmp slt i32 %31, %32
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %34 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %34 to i64
  %arrayidx27 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %33, i64 %idxprom26
  %35 = bitcast %struct.TPixel* %arrayidx27 to i8*
  %36 = bitcast %struct.TPixel* %color to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %35, i8* align 1 %36, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %37 = load i32, i32* %i, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %38 = load i32, i32* %dt, align 4
  %39 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %idx.ext = sext i32 %38 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %39, i64 %idx.ext
  store %struct.TPixel* %add.ptr, %struct.TPixel** %td, align 8
  br label %do.cond

do.cond:                                          ; preds = %for.end
  %40 = load i32, i32* %h.addr, align 4
  %dec = add nsw i32 %40, -1
  store i32 %dec, i32* %h.addr, align 4
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %if.then20, %do.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrLine(%struct.Tigr* %bmp, i32 %x0, i32 %y0, i32 %x1, i32 %y1, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x0.addr = alloca i32, align 4
  %y0.addr = alloca i32, align 4
  %x1.addr = alloca i32, align 4
  %y1.addr = alloca i32, align 4
  %sx = alloca i32, align 4
  %sy = alloca i32, align 4
  %dx = alloca i32, align 4
  %dy = alloca i32, align 4
  %err = alloca i32, align 4
  %e2 = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x0, i32* %x0.addr, align 4
  store i32 %y0, i32* %y0.addr, align 4
  store i32 %x1, i32* %x1.addr, align 4
  store i32 %y1, i32* %y1.addr, align 4
  %1 = load i32, i32* %x1.addr, align 4
  %2 = load i32, i32* %x0.addr, align 4
  %sub = sub nsw i32 %1, %2
  %call = call i32 @abs(i32 %sub) #14
  store i32 %call, i32* %dx, align 4
  %3 = load i32, i32* %y1.addr, align 4
  %4 = load i32, i32* %y0.addr, align 4
  %sub1 = sub nsw i32 %3, %4
  %call2 = call i32 @abs(i32 %sub1) #14
  store i32 %call2, i32* %dy, align 4
  %5 = load i32, i32* %x0.addr, align 4
  %6 = load i32, i32* %x1.addr, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %sx, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 -1, i32* %sx, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load i32, i32* %y0.addr, align 4
  %8 = load i32, i32* %y1.addr, align 4
  %cmp3 = icmp slt i32 %7, %8
  br i1 %cmp3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  store i32 1, i32* %sy, align 4
  br label %if.end6

if.else5:                                         ; preds = %if.end
  store i32 -1, i32* %sy, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.else5, %if.then4
  %9 = load i32, i32* %dx, align 4
  %10 = load i32, i32* %dy, align 4
  %sub7 = sub nsw i32 %9, %10
  store i32 %sub7, i32* %err, align 4
  %11 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %12 = load i32, i32* %x0.addr, align 4
  %13 = load i32, i32* %y0.addr, align 4
  %14 = bitcast %struct.TPixel* %color to i32*
  %15 = load i32, i32* %14, align 1
  call void @tigrPlot(%struct.Tigr* %11, i32 %12, i32 %13, i32 %15)
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.end6
  %16 = load i32, i32* %x0.addr, align 4
  %17 = load i32, i32* %x1.addr, align 4
  %cmp8 = icmp ne i32 %16, %17
  br i1 %cmp8, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %18 = load i32, i32* %y0.addr, align 4
  %19 = load i32, i32* %y1.addr, align 4
  %cmp9 = icmp ne i32 %18, %19
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond
  %20 = phi i1 [ true, %while.cond ], [ %cmp9, %lor.rhs ]
  br i1 %20, label %while.body, label %while.end

while.body:                                       ; preds = %lor.end
  %21 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %22 = load i32, i32* %x0.addr, align 4
  %23 = load i32, i32* %y0.addr, align 4
  %24 = bitcast %struct.TPixel* %color to i32*
  %25 = load i32, i32* %24, align 1
  call void @tigrPlot(%struct.Tigr* %21, i32 %22, i32 %23, i32 %25)
  %26 = load i32, i32* %err, align 4
  %mul = mul nsw i32 2, %26
  store i32 %mul, i32* %e2, align 4
  %27 = load i32, i32* %e2, align 4
  %28 = load i32, i32* %dy, align 4
  %sub10 = sub nsw i32 0, %28
  %cmp11 = icmp sgt i32 %27, %sub10
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %while.body
  %29 = load i32, i32* %dy, align 4
  %30 = load i32, i32* %err, align 4
  %sub13 = sub nsw i32 %30, %29
  store i32 %sub13, i32* %err, align 4
  %31 = load i32, i32* %sx, align 4
  %32 = load i32, i32* %x0.addr, align 4
  %add = add nsw i32 %32, %31
  store i32 %add, i32* %x0.addr, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %while.body
  %33 = load i32, i32* %e2, align 4
  %34 = load i32, i32* %dx, align 4
  %cmp15 = icmp slt i32 %33, %34
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end14
  %35 = load i32, i32* %dx, align 4
  %36 = load i32, i32* %err, align 4
  %add17 = add nsw i32 %36, %35
  store i32 %add17, i32* %err, align 4
  %37 = load i32, i32* %sy, align 4
  %38 = load i32, i32* %y0.addr, align 4
  %add18 = add nsw i32 %38, %37
  store i32 %add18, i32* %y0.addr, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end14
  br label %while.cond

while.end:                                        ; preds = %lor.end
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @abs(i32) #6

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrPlot(%struct.Tigr* %bmp, i32 %x, i32 %y, i32 %pix.coerce) #0 {
entry:
  %pix = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %xa = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %pix to i32*
  store i32 %pix.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, i32* %y.addr, align 4
  %cmp1 = icmp sge i32 %2, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load i32, i32* %x.addr, align 4
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 0
  %5 = load i32, i32* %w, align 8
  %cmp3 = icmp slt i32 %3, %5
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load i32, i32* %y.addr, align 4
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 1
  %8 = load i32, i32* %h, align 4
  %cmp5 = icmp slt i32 %6, %8
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %a6 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %9 = load i8, i8* %a6, align 1
  %conv = zext i8 %9 to i32
  %a7 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %10 = load i8, i8* %a7, align 1
  %conv8 = zext i8 %10 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  %conv10 = zext i1 %cmp9 to i32
  %add = add nsw i32 %conv, %conv10
  store i32 %add, i32* %xa, align 4
  %11 = load i32, i32* %y.addr, align 4
  %12 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w11 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %12, i32 0, i32 0
  %13 = load i32, i32* %w11, align 8
  %mul = mul nsw i32 %11, %13
  %14 = load i32, i32* %x.addr, align 4
  %add12 = add nsw i32 %mul, %14
  store i32 %add12, i32* %i, align 4
  %15 = load i32, i32* %xa, align 4
  %a13 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %16 = load i8, i8* %a13, align 1
  %conv14 = zext i8 %16 to i32
  %a15 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %17 = load i8, i8* %a15, align 1
  %conv16 = zext i8 %17 to i32
  %cmp17 = icmp sgt i32 %conv16, 0
  %conv18 = zext i1 %cmp17 to i32
  %add19 = add nsw i32 %conv14, %conv18
  %mul20 = mul nsw i32 %15, %add19
  store i32 %mul20, i32* %a, align 4
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 2
  %18 = load i8, i8* %r, align 1
  %conv21 = zext i8 %18 to i32
  %19 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix22 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %19, i32 0, i32 2
  %20 = load %struct.TPixel*, %struct.TPixel** %pix22, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom = sext i32 %21 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %20, i64 %idxprom
  %r23 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx, i32 0, i32 2
  %22 = load i8, i8* %r23, align 1
  %conv24 = zext i8 %22 to i32
  %sub = sub nsw i32 %conv21, %conv24
  %23 = load i32, i32* %a, align 4
  %mul25 = mul nsw i32 %sub, %23
  %shr = ashr i32 %mul25, 16
  %conv26 = trunc i32 %shr to i8
  %conv27 = zext i8 %conv26 to i32
  %24 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix28 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %24, i32 0, i32 2
  %25 = load %struct.TPixel*, %struct.TPixel** %pix28, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom29 = sext i32 %26 to i64
  %arrayidx30 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %25, i64 %idxprom29
  %r31 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx30, i32 0, i32 2
  %27 = load i8, i8* %r31, align 1
  %conv32 = zext i8 %27 to i32
  %add33 = add nsw i32 %conv32, %conv27
  %conv34 = trunc i32 %add33 to i8
  store i8 %conv34, i8* %r31, align 1
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 1
  %28 = load i8, i8* %g, align 1
  %conv35 = zext i8 %28 to i32
  %29 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix36 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %29, i32 0, i32 2
  %30 = load %struct.TPixel*, %struct.TPixel** %pix36, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom37 = sext i32 %31 to i64
  %arrayidx38 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %30, i64 %idxprom37
  %g39 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx38, i32 0, i32 1
  %32 = load i8, i8* %g39, align 1
  %conv40 = zext i8 %32 to i32
  %sub41 = sub nsw i32 %conv35, %conv40
  %33 = load i32, i32* %a, align 4
  %mul42 = mul nsw i32 %sub41, %33
  %shr43 = ashr i32 %mul42, 16
  %conv44 = trunc i32 %shr43 to i8
  %conv45 = zext i8 %conv44 to i32
  %34 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix46 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %34, i32 0, i32 2
  %35 = load %struct.TPixel*, %struct.TPixel** %pix46, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom47 = sext i32 %36 to i64
  %arrayidx48 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %35, i64 %idxprom47
  %g49 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx48, i32 0, i32 1
  %37 = load i8, i8* %g49, align 1
  %conv50 = zext i8 %37 to i32
  %add51 = add nsw i32 %conv50, %conv45
  %conv52 = trunc i32 %add51 to i8
  store i8 %conv52, i8* %g49, align 1
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 0
  %38 = load i8, i8* %b, align 1
  %conv53 = zext i8 %38 to i32
  %39 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix54 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %39, i32 0, i32 2
  %40 = load %struct.TPixel*, %struct.TPixel** %pix54, align 8
  %41 = load i32, i32* %i, align 4
  %idxprom55 = sext i32 %41 to i64
  %arrayidx56 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %40, i64 %idxprom55
  %b57 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx56, i32 0, i32 0
  %42 = load i8, i8* %b57, align 1
  %conv58 = zext i8 %42 to i32
  %sub59 = sub nsw i32 %conv53, %conv58
  %43 = load i32, i32* %a, align 4
  %mul60 = mul nsw i32 %sub59, %43
  %shr61 = ashr i32 %mul60, 16
  %conv62 = trunc i32 %shr61 to i8
  %conv63 = zext i8 %conv62 to i32
  %44 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix64 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %44, i32 0, i32 2
  %45 = load %struct.TPixel*, %struct.TPixel** %pix64, align 8
  %46 = load i32, i32* %i, align 4
  %idxprom65 = sext i32 %46 to i64
  %arrayidx66 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %45, i64 %idxprom65
  %b67 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx66, i32 0, i32 0
  %47 = load i8, i8* %b67, align 1
  %conv68 = zext i8 %47 to i32
  %add69 = add nsw i32 %conv68, %conv63
  %conv70 = trunc i32 %add69 to i8
  store i8 %conv70, i8* %b67, align 1
  %a71 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %48 = load i8, i8* %a71, align 1
  %conv72 = zext i8 %48 to i32
  %49 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix73 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %49, i32 0, i32 2
  %50 = load %struct.TPixel*, %struct.TPixel** %pix73, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom74 = sext i32 %51 to i64
  %arrayidx75 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %50, i64 %idxprom74
  %a76 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx75, i32 0, i32 3
  %52 = load i8, i8* %a76, align 1
  %conv77 = zext i8 %52 to i32
  %sub78 = sub nsw i32 %conv72, %conv77
  %53 = load i32, i32* %a, align 4
  %mul79 = mul nsw i32 %sub78, %53
  %shr80 = ashr i32 %mul79, 16
  %conv81 = trunc i32 %shr80 to i8
  %conv82 = zext i8 %conv81 to i32
  %54 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix83 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %54, i32 0, i32 2
  %55 = load %struct.TPixel*, %struct.TPixel** %pix83, align 8
  %56 = load i32, i32* %i, align 4
  %idxprom84 = sext i32 %56 to i64
  %arrayidx85 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %55, i64 %idxprom84
  %a86 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx85, i32 0, i32 3
  %57 = load i8, i8* %a86, align 1
  %conv87 = zext i8 %57 to i32
  %add88 = add nsw i32 %conv87, %conv82
  %conv89 = trunc i32 %add88 to i8
  store i8 %conv89, i8* %a86, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrRect(%struct.Tigr* %bmp, i32 %x, i32 %y, i32 %w, i32 %h, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %1 = load i32, i32* %w.addr, align 4
  %cmp = icmp sle i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %h.addr, align 4
  %cmp1 = icmp sle i32 %2, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i32, i32* %x.addr, align 4
  %4 = load i32, i32* %w.addr, align 4
  %add = add nsw i32 %3, %4
  %sub = sub nsw i32 %add, 1
  store i32 %sub, i32* %x1, align 4
  %5 = load i32, i32* %y.addr, align 4
  %6 = load i32, i32* %h.addr, align 4
  %add2 = add nsw i32 %5, %6
  %sub3 = sub nsw i32 %add2, 1
  store i32 %sub3, i32* %y1, align 4
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %8 = load i32, i32* %x.addr, align 4
  %9 = load i32, i32* %y.addr, align 4
  %10 = load i32, i32* %x1, align 4
  %11 = load i32, i32* %y.addr, align 4
  %12 = bitcast %struct.TPixel* %color to i32*
  %13 = load i32, i32* %12, align 1
  call void @tigrLine(%struct.Tigr* %7, i32 %8, i32 %9, i32 %10, i32 %11, i32 %13)
  %14 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %15 = load i32, i32* %x1, align 4
  %16 = load i32, i32* %y.addr, align 4
  %17 = load i32, i32* %x1, align 4
  %18 = load i32, i32* %y1, align 4
  %19 = bitcast %struct.TPixel* %color to i32*
  %20 = load i32, i32* %19, align 1
  call void @tigrLine(%struct.Tigr* %14, i32 %15, i32 %16, i32 %17, i32 %18, i32 %20)
  %21 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %22 = load i32, i32* %x1, align 4
  %23 = load i32, i32* %y1, align 4
  %24 = load i32, i32* %x.addr, align 4
  %25 = load i32, i32* %y1, align 4
  %26 = bitcast %struct.TPixel* %color to i32*
  %27 = load i32, i32* %26, align 1
  call void @tigrLine(%struct.Tigr* %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %27)
  %28 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %29 = load i32, i32* %x.addr, align 4
  %30 = load i32, i32* %y1, align 4
  %31 = load i32, i32* %x.addr, align 4
  %32 = load i32, i32* %y.addr, align 4
  %33 = bitcast %struct.TPixel* %color to i32*
  %34 = load i32, i32* %33, align 1
  call void @tigrLine(%struct.Tigr* %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %34)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrGet(%struct.Tigr* %bmp, i32 %x, i32 %y) #0 {
entry:
  %retval = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %empty = alloca %struct.TPixel, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast %struct.TPixel* %empty to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %0, i8 0, i64 4, i1 false)
  %1 = load i32, i32* %x.addr, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, i32* %y.addr, align 4
  %cmp1 = icmp sge i32 %2, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load i32, i32* %x.addr, align 4
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 0
  %5 = load i32, i32* %w, align 8
  %cmp3 = icmp slt i32 %3, %5
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %6 = load i32, i32* %y.addr, align 4
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 1
  %8 = load i32, i32* %h, align 4
  %cmp5 = icmp slt i32 %6, %8
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %9 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %9, i32 0, i32 2
  %10 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %11 = load i32, i32* %y.addr, align 4
  %12 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w6 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %12, i32 0, i32 0
  %13 = load i32, i32* %w6, align 8
  %mul = mul nsw i32 %11, %13
  %14 = load i32, i32* %x.addr, align 4
  %add = add nsw i32 %mul, %14
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %10, i64 %idxprom
  %15 = bitcast %struct.TPixel* %retval to i8*
  %16 = bitcast %struct.TPixel* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %15, i8* align 1 %16, i64 4, i1 false)
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %17 = bitcast %struct.TPixel* %retval to i8*
  %18 = bitcast %struct.TPixel* %empty to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %17, i8* align 1 %18, i64 4, i1 false)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = bitcast %struct.TPixel* %retval to i32*
  %20 = load i32, i32* %19, align 1
  ret i32 %20
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrBlit(%struct.Tigr* %dst, %struct.Tigr* %src, i32 %dx, i32 %dy, i32 %sx, i32 %sy, i32 %w, i32 %h) #0 {
entry:
  %dst.addr = alloca %struct.Tigr*, align 8
  %src.addr = alloca %struct.Tigr*, align 8
  %dx.addr = alloca i32, align 4
  %dy.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %td = alloca %struct.TPixel*, align 8
  %ts = alloca %struct.TPixel*, align 8
  %st = alloca i32, align 4
  %dt = alloca i32, align 4
  store %struct.Tigr* %dst, %struct.Tigr** %dst.addr, align 8
  store %struct.Tigr* %src, %struct.Tigr** %src.addr, align 8
  store i32 %dx, i32* %dx.addr, align 4
  store i32 %dy, i32* %dy.addr, align 4
  store i32 %sx, i32* %sx.addr, align 4
  store i32 %sy, i32* %sy.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %0 = load i32, i32* %dx.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %dx.addr, align 4
  %2 = load i32, i32* %w.addr, align 4
  %add = add nsw i32 %2, %1
  store i32 %add, i32* %w.addr, align 4
  %3 = load i32, i32* %dx.addr, align 4
  %4 = load i32, i32* %sx.addr, align 4
  %sub = sub nsw i32 %4, %3
  store i32 %sub, i32* %sx.addr, align 4
  store i32 0, i32* %dx.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, i32* %dy.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %6 = load i32, i32* %dy.addr, align 4
  %7 = load i32, i32* %h.addr, align 4
  %add3 = add nsw i32 %7, %6
  store i32 %add3, i32* %h.addr, align 4
  %8 = load i32, i32* %dy.addr, align 4
  %9 = load i32, i32* %sy.addr, align 4
  %sub4 = sub nsw i32 %9, %8
  store i32 %sub4, i32* %sy.addr, align 4
  store i32 0, i32* %dy.addr, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %10 = load i32, i32* %sx.addr, align 4
  %cmp6 = icmp slt i32 %10, 0
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %11 = load i32, i32* %sx.addr, align 4
  %12 = load i32, i32* %w.addr, align 4
  %add8 = add nsw i32 %12, %11
  store i32 %add8, i32* %w.addr, align 4
  %13 = load i32, i32* %sx.addr, align 4
  %14 = load i32, i32* %dx.addr, align 4
  %sub9 = sub nsw i32 %14, %13
  store i32 %sub9, i32* %dx.addr, align 4
  store i32 0, i32* %sx.addr, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %15 = load i32, i32* %sy.addr, align 4
  %cmp11 = icmp slt i32 %15, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %16 = load i32, i32* %sy.addr, align 4
  %17 = load i32, i32* %h.addr, align 4
  %add13 = add nsw i32 %17, %16
  store i32 %add13, i32* %h.addr, align 4
  %18 = load i32, i32* %sy.addr, align 4
  %19 = load i32, i32* %dy.addr, align 4
  %sub14 = sub nsw i32 %19, %18
  store i32 %sub14, i32* %dy.addr, align 4
  store i32 0, i32* %sy.addr, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %20 = load i32, i32* %dx.addr, align 4
  %21 = load i32, i32* %w.addr, align 4
  %add16 = add nsw i32 %20, %21
  %22 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w17 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %22, i32 0, i32 0
  %23 = load i32, i32* %w17, align 8
  %cmp18 = icmp sgt i32 %add16, %23
  br i1 %cmp18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end15
  %24 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w20 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %24, i32 0, i32 0
  %25 = load i32, i32* %w20, align 8
  %26 = load i32, i32* %dx.addr, align 4
  %sub21 = sub nsw i32 %25, %26
  store i32 %sub21, i32* %w.addr, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end15
  %27 = load i32, i32* %dy.addr, align 4
  %28 = load i32, i32* %h.addr, align 4
  %add23 = add nsw i32 %27, %28
  %29 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %h24 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %29, i32 0, i32 1
  %30 = load i32, i32* %h24, align 4
  %cmp25 = icmp sgt i32 %add23, %30
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end22
  %31 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %h27 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %31, i32 0, i32 1
  %32 = load i32, i32* %h27, align 4
  %33 = load i32, i32* %dy.addr, align 4
  %sub28 = sub nsw i32 %32, %33
  store i32 %sub28, i32* %h.addr, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end22
  %34 = load i32, i32* %sx.addr, align 4
  %35 = load i32, i32* %w.addr, align 4
  %add30 = add nsw i32 %34, %35
  %36 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w31 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %36, i32 0, i32 0
  %37 = load i32, i32* %w31, align 8
  %cmp32 = icmp sgt i32 %add30, %37
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.end29
  %38 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w34 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %38, i32 0, i32 0
  %39 = load i32, i32* %w34, align 8
  %40 = load i32, i32* %sx.addr, align 4
  %sub35 = sub nsw i32 %39, %40
  store i32 %sub35, i32* %w.addr, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.end29
  %41 = load i32, i32* %sy.addr, align 4
  %42 = load i32, i32* %h.addr, align 4
  %add37 = add nsw i32 %41, %42
  %43 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %h38 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %43, i32 0, i32 1
  %44 = load i32, i32* %h38, align 4
  %cmp39 = icmp sgt i32 %add37, %44
  br i1 %cmp39, label %if.then40, label %if.end43

if.then40:                                        ; preds = %if.end36
  %45 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %h41 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %45, i32 0, i32 1
  %46 = load i32, i32* %h41, align 4
  %47 = load i32, i32* %sy.addr, align 4
  %sub42 = sub nsw i32 %46, %47
  store i32 %sub42, i32* %h.addr, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %if.end36
  %48 = load i32, i32* %w.addr, align 4
  %cmp44 = icmp sle i32 %48, 0
  br i1 %cmp44, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end43
  %49 = load i32, i32* %h.addr, align 4
  %cmp45 = icmp sle i32 %49, 0
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %lor.lhs.false, %if.end43
  br label %do.end

if.end47:                                         ; preds = %lor.lhs.false
  %50 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %50, i32 0, i32 2
  %51 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %52 = load i32, i32* %sy.addr, align 4
  %53 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w48 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %53, i32 0, i32 0
  %54 = load i32, i32* %w48, align 8
  %mul = mul nsw i32 %52, %54
  %55 = load i32, i32* %sx.addr, align 4
  %add49 = add nsw i32 %mul, %55
  %idxprom = sext i32 %add49 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %51, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %ts, align 8
  %56 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %pix50 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %56, i32 0, i32 2
  %57 = load %struct.TPixel*, %struct.TPixel** %pix50, align 8
  %58 = load i32, i32* %dy.addr, align 4
  %59 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w51 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %59, i32 0, i32 0
  %60 = load i32, i32* %w51, align 8
  %mul52 = mul nsw i32 %58, %60
  %61 = load i32, i32* %dx.addr, align 4
  %add53 = add nsw i32 %mul52, %61
  %idxprom54 = sext i32 %add53 to i64
  %arrayidx55 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %57, i64 %idxprom54
  store %struct.TPixel* %arrayidx55, %struct.TPixel** %td, align 8
  %62 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w56 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %62, i32 0, i32 0
  %63 = load i32, i32* %w56, align 8
  store i32 %63, i32* %st, align 4
  %64 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w57 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %64, i32 0, i32 0
  %65 = load i32, i32* %w57, align 8
  store i32 %65, i32* %dt, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end47
  %66 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %67 = bitcast %struct.TPixel* %66 to i8*
  %68 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %69 = bitcast %struct.TPixel* %68 to i8*
  %70 = load i32, i32* %w.addr, align 4
  %conv = sext i32 %70 to i64
  %mul58 = mul i64 %conv, 4
  %71 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %72 = bitcast %struct.TPixel* %71 to i8*
  %73 = call i64 @llvm.objectsize.i64.p0i8(i8* %72, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %67, i8* %69, i64 %mul58, i64 %73) #10
  %74 = load i32, i32* %st, align 4
  %75 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %idx.ext = sext i32 %74 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %75, i64 %idx.ext
  store %struct.TPixel* %add.ptr, %struct.TPixel** %ts, align 8
  %76 = load i32, i32* %dt, align 4
  %77 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %idx.ext59 = sext i32 %76 to i64
  %add.ptr60 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %77, i64 %idx.ext59
  store %struct.TPixel* %add.ptr60, %struct.TPixel** %td, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %78 = load i32, i32* %h.addr, align 4
  %dec = add nsw i32 %78, -1
  store i32 %dec, i32* %h.addr, align 4
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %if.then46, %do.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrBlitTint(%struct.Tigr* %dst, %struct.Tigr* %src, i32 %dx, i32 %dy, i32 %sx, i32 %sy, i32 %w, i32 %h, i32 %tint.coerce) #0 {
entry:
  %tint = alloca %struct.TPixel, align 1
  %dst.addr = alloca %struct.Tigr*, align 8
  %src.addr = alloca %struct.Tigr*, align 8
  %dx.addr = alloca i32, align 4
  %dy.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %td = alloca %struct.TPixel*, align 8
  %ts = alloca %struct.TPixel*, align 8
  %x = alloca i32, align 4
  %st = alloca i32, align 4
  %dt = alloca i32, align 4
  %xr = alloca i32, align 4
  %xg = alloca i32, align 4
  %xb = alloca i32, align 4
  %xa = alloca i32, align 4
  %r83 = alloca i32, align 4
  %g89 = alloca i32, align 4
  %b96 = alloca i32, align 4
  %a103 = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %tint to i32*
  store i32 %tint.coerce, i32* %0, align 1
  store %struct.Tigr* %dst, %struct.Tigr** %dst.addr, align 8
  store %struct.Tigr* %src, %struct.Tigr** %src.addr, align 8
  store i32 %dx, i32* %dx.addr, align 4
  store i32 %dy, i32* %dy.addr, align 4
  store i32 %sx, i32* %sx.addr, align 4
  store i32 %sy, i32* %sy.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %1 = load i32, i32* %dx.addr, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %dx.addr, align 4
  %3 = load i32, i32* %w.addr, align 4
  %add = add nsw i32 %3, %2
  store i32 %add, i32* %w.addr, align 4
  %4 = load i32, i32* %dx.addr, align 4
  %5 = load i32, i32* %sx.addr, align 4
  %sub = sub nsw i32 %5, %4
  store i32 %sub, i32* %sx.addr, align 4
  store i32 0, i32* %dx.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %dy.addr, align 4
  %cmp1 = icmp slt i32 %6, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %7 = load i32, i32* %dy.addr, align 4
  %8 = load i32, i32* %h.addr, align 4
  %add3 = add nsw i32 %8, %7
  store i32 %add3, i32* %h.addr, align 4
  %9 = load i32, i32* %dy.addr, align 4
  %10 = load i32, i32* %sy.addr, align 4
  %sub4 = sub nsw i32 %10, %9
  store i32 %sub4, i32* %sy.addr, align 4
  store i32 0, i32* %dy.addr, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %11 = load i32, i32* %sx.addr, align 4
  %cmp6 = icmp slt i32 %11, 0
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %12 = load i32, i32* %sx.addr, align 4
  %13 = load i32, i32* %w.addr, align 4
  %add8 = add nsw i32 %13, %12
  store i32 %add8, i32* %w.addr, align 4
  %14 = load i32, i32* %sx.addr, align 4
  %15 = load i32, i32* %dx.addr, align 4
  %sub9 = sub nsw i32 %15, %14
  store i32 %sub9, i32* %dx.addr, align 4
  store i32 0, i32* %sx.addr, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %16 = load i32, i32* %sy.addr, align 4
  %cmp11 = icmp slt i32 %16, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %17 = load i32, i32* %sy.addr, align 4
  %18 = load i32, i32* %h.addr, align 4
  %add13 = add nsw i32 %18, %17
  store i32 %add13, i32* %h.addr, align 4
  %19 = load i32, i32* %sy.addr, align 4
  %20 = load i32, i32* %dy.addr, align 4
  %sub14 = sub nsw i32 %20, %19
  store i32 %sub14, i32* %dy.addr, align 4
  store i32 0, i32* %sy.addr, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %21 = load i32, i32* %dx.addr, align 4
  %22 = load i32, i32* %w.addr, align 4
  %add16 = add nsw i32 %21, %22
  %23 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w17 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %23, i32 0, i32 0
  %24 = load i32, i32* %w17, align 8
  %cmp18 = icmp sgt i32 %add16, %24
  br i1 %cmp18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end15
  %25 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w20 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %25, i32 0, i32 0
  %26 = load i32, i32* %w20, align 8
  %27 = load i32, i32* %dx.addr, align 4
  %sub21 = sub nsw i32 %26, %27
  store i32 %sub21, i32* %w.addr, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end15
  %28 = load i32, i32* %dy.addr, align 4
  %29 = load i32, i32* %h.addr, align 4
  %add23 = add nsw i32 %28, %29
  %30 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %h24 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %30, i32 0, i32 1
  %31 = load i32, i32* %h24, align 4
  %cmp25 = icmp sgt i32 %add23, %31
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end22
  %32 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %h27 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %32, i32 0, i32 1
  %33 = load i32, i32* %h27, align 4
  %34 = load i32, i32* %dy.addr, align 4
  %sub28 = sub nsw i32 %33, %34
  store i32 %sub28, i32* %h.addr, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end22
  %35 = load i32, i32* %sx.addr, align 4
  %36 = load i32, i32* %w.addr, align 4
  %add30 = add nsw i32 %35, %36
  %37 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w31 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %37, i32 0, i32 0
  %38 = load i32, i32* %w31, align 8
  %cmp32 = icmp sgt i32 %add30, %38
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.end29
  %39 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w34 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %39, i32 0, i32 0
  %40 = load i32, i32* %w34, align 8
  %41 = load i32, i32* %sx.addr, align 4
  %sub35 = sub nsw i32 %40, %41
  store i32 %sub35, i32* %w.addr, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.end29
  %42 = load i32, i32* %sy.addr, align 4
  %43 = load i32, i32* %h.addr, align 4
  %add37 = add nsw i32 %42, %43
  %44 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %h38 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %44, i32 0, i32 1
  %45 = load i32, i32* %h38, align 4
  %cmp39 = icmp sgt i32 %add37, %45
  br i1 %cmp39, label %if.then40, label %if.end43

if.then40:                                        ; preds = %if.end36
  %46 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %h41 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %46, i32 0, i32 1
  %47 = load i32, i32* %h41, align 4
  %48 = load i32, i32* %sy.addr, align 4
  %sub42 = sub nsw i32 %47, %48
  store i32 %sub42, i32* %h.addr, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %if.end36
  %49 = load i32, i32* %w.addr, align 4
  %cmp44 = icmp sle i32 %49, 0
  br i1 %cmp44, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end43
  %50 = load i32, i32* %h.addr, align 4
  %cmp45 = icmp sle i32 %50, 0
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %lor.lhs.false, %if.end43
  br label %do.end

if.end47:                                         ; preds = %lor.lhs.false
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 2
  %51 = load i8, i8* %r, align 1
  %conv = zext i8 %51 to i32
  %r48 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 2
  %52 = load i8, i8* %r48, align 1
  %conv49 = zext i8 %52 to i32
  %cmp50 = icmp sgt i32 %conv49, 0
  %conv51 = zext i1 %cmp50 to i32
  %add52 = add nsw i32 %conv, %conv51
  store i32 %add52, i32* %xr, align 4
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 1
  %53 = load i8, i8* %g, align 1
  %conv53 = zext i8 %53 to i32
  %g54 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 1
  %54 = load i8, i8* %g54, align 1
  %conv55 = zext i8 %54 to i32
  %cmp56 = icmp sgt i32 %conv55, 0
  %conv57 = zext i1 %cmp56 to i32
  %add58 = add nsw i32 %conv53, %conv57
  store i32 %add58, i32* %xg, align 4
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 0
  %55 = load i8, i8* %b, align 1
  %conv59 = zext i8 %55 to i32
  %b60 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 0
  %56 = load i8, i8* %b60, align 1
  %conv61 = zext i8 %56 to i32
  %cmp62 = icmp sgt i32 %conv61, 0
  %conv63 = zext i1 %cmp62 to i32
  %add64 = add nsw i32 %conv59, %conv63
  store i32 %add64, i32* %xb, align 4
  %a = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 3
  %57 = load i8, i8* %a, align 1
  %conv65 = zext i8 %57 to i32
  %a66 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 3
  %58 = load i8, i8* %a66, align 1
  %conv67 = zext i8 %58 to i32
  %cmp68 = icmp sgt i32 %conv67, 0
  %conv69 = zext i1 %cmp68 to i32
  %add70 = add nsw i32 %conv65, %conv69
  store i32 %add70, i32* %xa, align 4
  %59 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %59, i32 0, i32 2
  %60 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %61 = load i32, i32* %sy.addr, align 4
  %62 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w71 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %62, i32 0, i32 0
  %63 = load i32, i32* %w71, align 8
  %mul = mul nsw i32 %61, %63
  %64 = load i32, i32* %sx.addr, align 4
  %add72 = add nsw i32 %mul, %64
  %idxprom = sext i32 %add72 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %60, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %ts, align 8
  %65 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %pix73 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %65, i32 0, i32 2
  %66 = load %struct.TPixel*, %struct.TPixel** %pix73, align 8
  %67 = load i32, i32* %dy.addr, align 4
  %68 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w74 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %68, i32 0, i32 0
  %69 = load i32, i32* %w74, align 8
  %mul75 = mul nsw i32 %67, %69
  %70 = load i32, i32* %dx.addr, align 4
  %add76 = add nsw i32 %mul75, %70
  %idxprom77 = sext i32 %add76 to i64
  %arrayidx78 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %66, i64 %idxprom77
  store %struct.TPixel* %arrayidx78, %struct.TPixel** %td, align 8
  %71 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %w79 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %71, i32 0, i32 0
  %72 = load i32, i32* %w79, align 8
  store i32 %72, i32* %st, align 4
  %73 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %w80 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %73, i32 0, i32 0
  %74 = load i32, i32* %w80, align 8
  store i32 %74, i32* %dt, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end47
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %75 = load i32, i32* %x, align 4
  %76 = load i32, i32* %w.addr, align 4
  %cmp81 = icmp slt i32 %75, %76
  br i1 %cmp81, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %77 = load i32, i32* %xr, align 4
  %78 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %79 = load i32, i32* %x, align 4
  %idxprom84 = sext i32 %79 to i64
  %arrayidx85 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %78, i64 %idxprom84
  %r86 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx85, i32 0, i32 2
  %80 = load i8, i8* %r86, align 1
  %conv87 = zext i8 %80 to i32
  %mul88 = mul nsw i32 %77, %conv87
  %shr = ashr i32 %mul88, 8
  store i32 %shr, i32* %r83, align 4
  %81 = load i32, i32* %xg, align 4
  %82 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %83 = load i32, i32* %x, align 4
  %idxprom90 = sext i32 %83 to i64
  %arrayidx91 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %82, i64 %idxprom90
  %g92 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx91, i32 0, i32 1
  %84 = load i8, i8* %g92, align 1
  %conv93 = zext i8 %84 to i32
  %mul94 = mul nsw i32 %81, %conv93
  %shr95 = ashr i32 %mul94, 8
  store i32 %shr95, i32* %g89, align 4
  %85 = load i32, i32* %xb, align 4
  %86 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %87 = load i32, i32* %x, align 4
  %idxprom97 = sext i32 %87 to i64
  %arrayidx98 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %86, i64 %idxprom97
  %b99 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx98, i32 0, i32 0
  %88 = load i8, i8* %b99, align 1
  %conv100 = zext i8 %88 to i32
  %mul101 = mul nsw i32 %85, %conv100
  %shr102 = ashr i32 %mul101, 8
  store i32 %shr102, i32* %b96, align 4
  %89 = load i32, i32* %xa, align 4
  %90 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %91 = load i32, i32* %x, align 4
  %idxprom104 = sext i32 %91 to i64
  %arrayidx105 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %90, i64 %idxprom104
  %a106 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx105, i32 0, i32 3
  %92 = load i8, i8* %a106, align 1
  %conv107 = zext i8 %92 to i32
  %93 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %94 = load i32, i32* %x, align 4
  %idxprom108 = sext i32 %94 to i64
  %arrayidx109 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %93, i64 %idxprom108
  %a110 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx109, i32 0, i32 3
  %95 = load i8, i8* %a110, align 1
  %conv111 = zext i8 %95 to i32
  %cmp112 = icmp sgt i32 %conv111, 0
  %conv113 = zext i1 %cmp112 to i32
  %add114 = add nsw i32 %conv107, %conv113
  %mul115 = mul nsw i32 %89, %add114
  store i32 %mul115, i32* %a103, align 4
  %96 = load i32, i32* %r83, align 4
  %97 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %98 = load i32, i32* %x, align 4
  %idxprom116 = sext i32 %98 to i64
  %arrayidx117 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %97, i64 %idxprom116
  %r118 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx117, i32 0, i32 2
  %99 = load i8, i8* %r118, align 1
  %conv119 = zext i8 %99 to i32
  %sub120 = sub i32 %96, %conv119
  %100 = load i32, i32* %a103, align 4
  %mul121 = mul i32 %sub120, %100
  %shr122 = lshr i32 %mul121, 16
  %conv123 = trunc i32 %shr122 to i8
  %conv124 = zext i8 %conv123 to i32
  %101 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %102 = load i32, i32* %x, align 4
  %idxprom125 = sext i32 %102 to i64
  %arrayidx126 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %101, i64 %idxprom125
  %r127 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx126, i32 0, i32 2
  %103 = load i8, i8* %r127, align 1
  %conv128 = zext i8 %103 to i32
  %add129 = add nsw i32 %conv128, %conv124
  %conv130 = trunc i32 %add129 to i8
  store i8 %conv130, i8* %r127, align 1
  %104 = load i32, i32* %g89, align 4
  %105 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %106 = load i32, i32* %x, align 4
  %idxprom131 = sext i32 %106 to i64
  %arrayidx132 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %105, i64 %idxprom131
  %g133 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx132, i32 0, i32 1
  %107 = load i8, i8* %g133, align 1
  %conv134 = zext i8 %107 to i32
  %sub135 = sub i32 %104, %conv134
  %108 = load i32, i32* %a103, align 4
  %mul136 = mul i32 %sub135, %108
  %shr137 = lshr i32 %mul136, 16
  %conv138 = trunc i32 %shr137 to i8
  %conv139 = zext i8 %conv138 to i32
  %109 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %110 = load i32, i32* %x, align 4
  %idxprom140 = sext i32 %110 to i64
  %arrayidx141 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %109, i64 %idxprom140
  %g142 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx141, i32 0, i32 1
  %111 = load i8, i8* %g142, align 1
  %conv143 = zext i8 %111 to i32
  %add144 = add nsw i32 %conv143, %conv139
  %conv145 = trunc i32 %add144 to i8
  store i8 %conv145, i8* %g142, align 1
  %112 = load i32, i32* %b96, align 4
  %113 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %114 = load i32, i32* %x, align 4
  %idxprom146 = sext i32 %114 to i64
  %arrayidx147 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %113, i64 %idxprom146
  %b148 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx147, i32 0, i32 0
  %115 = load i8, i8* %b148, align 1
  %conv149 = zext i8 %115 to i32
  %sub150 = sub i32 %112, %conv149
  %116 = load i32, i32* %a103, align 4
  %mul151 = mul i32 %sub150, %116
  %shr152 = lshr i32 %mul151, 16
  %conv153 = trunc i32 %shr152 to i8
  %conv154 = zext i8 %conv153 to i32
  %117 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %118 = load i32, i32* %x, align 4
  %idxprom155 = sext i32 %118 to i64
  %arrayidx156 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %117, i64 %idxprom155
  %b157 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx156, i32 0, i32 0
  %119 = load i8, i8* %b157, align 1
  %conv158 = zext i8 %119 to i32
  %add159 = add nsw i32 %conv158, %conv154
  %conv160 = trunc i32 %add159 to i8
  store i8 %conv160, i8* %b157, align 1
  %120 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %121 = load i32, i32* %x, align 4
  %idxprom161 = sext i32 %121 to i64
  %arrayidx162 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %120, i64 %idxprom161
  %a163 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx162, i32 0, i32 3
  %122 = load i8, i8* %a163, align 1
  %conv164 = zext i8 %122 to i32
  %123 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %124 = load i32, i32* %x, align 4
  %idxprom165 = sext i32 %124 to i64
  %arrayidx166 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %123, i64 %idxprom165
  %a167 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx166, i32 0, i32 3
  %125 = load i8, i8* %a167, align 1
  %conv168 = zext i8 %125 to i32
  %sub169 = sub nsw i32 %conv164, %conv168
  %126 = load i32, i32* %a103, align 4
  %mul170 = mul i32 %sub169, %126
  %shr171 = lshr i32 %mul170, 16
  %conv172 = trunc i32 %shr171 to i8
  %conv173 = zext i8 %conv172 to i32
  %127 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %128 = load i32, i32* %x, align 4
  %idxprom174 = sext i32 %128 to i64
  %arrayidx175 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %127, i64 %idxprom174
  %a176 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx175, i32 0, i32 3
  %129 = load i8, i8* %a176, align 1
  %conv177 = zext i8 %129 to i32
  %add178 = add nsw i32 %conv177, %conv173
  %conv179 = trunc i32 %add178 to i8
  store i8 %conv179, i8* %a176, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %130 = load i32, i32* %x, align 4
  %inc = add nsw i32 %130, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %131 = load i32, i32* %st, align 4
  %132 = load %struct.TPixel*, %struct.TPixel** %ts, align 8
  %idx.ext = sext i32 %131 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %132, i64 %idx.ext
  store %struct.TPixel* %add.ptr, %struct.TPixel** %ts, align 8
  %133 = load i32, i32* %dt, align 4
  %134 = load %struct.TPixel*, %struct.TPixel** %td, align 8
  %idx.ext180 = sext i32 %133 to i64
  %add.ptr181 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %134, i64 %idx.ext180
  store %struct.TPixel* %add.ptr181, %struct.TPixel** %td, align 8
  br label %do.cond

do.cond:                                          ; preds = %for.end
  %135 = load i32, i32* %h.addr, align 4
  %dec = add nsw i32 %135, -1
  store i32 %dec, i32* %h.addr, align 4
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %if.then46, %do.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrBlitAlpha(%struct.Tigr* %dst, %struct.Tigr* %src, i32 %dx, i32 %dy, i32 %sx, i32 %sy, i32 %w, i32 %h, float %alpha) #0 {
entry:
  %dst.addr = alloca %struct.Tigr*, align 8
  %src.addr = alloca %struct.Tigr*, align 8
  %dx.addr = alloca i32, align 4
  %dy.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %alpha.addr = alloca float, align 4
  %agg.tmp = alloca %struct.TPixel, align 1
  store %struct.Tigr* %dst, %struct.Tigr** %dst.addr, align 8
  store %struct.Tigr* %src, %struct.Tigr** %src.addr, align 8
  store i32 %dx, i32* %dx.addr, align 4
  store i32 %dy, i32* %dy.addr, align 4
  store i32 %sx, i32* %sx.addr, align 4
  store i32 %sy, i32* %sy.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store float %alpha, float* %alpha.addr, align 4
  %0 = load float, float* %alpha.addr, align 4
  %cmp = fcmp olt float %0, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load float, float* %alpha.addr, align 4
  %cmp1 = fcmp ogt float %1, 1.000000e+00
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %2 = load float, float* %alpha.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi float [ 1.000000e+00, %cond.true2 ], [ %2, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi float [ 0.000000e+00, %cond.true ], [ %cond, %cond.end ]
  store float %cond5, float* %alpha.addr, align 4
  %3 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8
  %4 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8
  %5 = load i32, i32* %dx.addr, align 4
  %6 = load i32, i32* %dy.addr, align 4
  %7 = load i32, i32* %sx.addr, align 4
  %8 = load i32, i32* %sy.addr, align 4
  %9 = load i32, i32* %w.addr, align 4
  %10 = load i32, i32* %h.addr, align 4
  %11 = load float, float* %alpha.addr, align 4
  %mul = fmul float %11, 2.550000e+02
  %conv = fptoui float %mul to i8
  %call = call i32 @tigrRGBA(i8 zeroext -1, i8 zeroext -1, i8 zeroext -1, i8 zeroext %conv)
  %12 = bitcast %struct.TPixel* %agg.tmp to i32*
  store i32 %call, i32* %12, align 1
  %13 = bitcast %struct.TPixel* %agg.tmp to i32*
  %14 = load i32, i32* %13, align 1
  call void @tigrBlitTint(%struct.Tigr* %3, %struct.Tigr* %4, i32 %5, i32 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %14)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @tigrRGBA(i8 zeroext %r, i8 zeroext %g, i8 zeroext %b, i8 zeroext %a) #0 {
entry:
  %retval = alloca %struct.TPixel, align 1
  %r.addr = alloca i8, align 1
  %g.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %a.addr = alloca i8, align 1
  store i8 %r, i8* %r.addr, align 1
  store i8 %g, i8* %g.addr, align 1
  store i8 %b, i8* %b.addr, align 1
  store i8 %a, i8* %a.addr, align 1
  %0 = load i8, i8* %r.addr, align 1
  %r1 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 2
  store i8 %0, i8* %r1, align 1
  %1 = load i8, i8* %g.addr, align 1
  %g2 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 1
  store i8 %1, i8* %g2, align 1
  %2 = load i8, i8* %b.addr, align 1
  %b3 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 0
  store i8 %2, i8* %b3, align 1
  %3 = load i8, i8* %a.addr, align 1
  %a4 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 3
  store i8 %3, i8* %a4, align 1
  %4 = bitcast %struct.TPixel* %retval to i32*
  %5 = load i32, i32* %4, align 1
  ret i32 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.Tigr* @tigrLoadImageMem(i8* %data, i32 %length) #0 {
entry:
  %data.addr = alloca i8*, align 8
  %length.addr = alloca i32, align 4
  %png = alloca %struct.PNG, align 8
  store i8* %data, i8** %data.addr, align 8
  store i32 %length, i32* %length.addr, align 4
  %0 = load i8*, i8** %data.addr, align 8
  %p = getelementptr inbounds %struct.PNG, %struct.PNG* %png, i32 0, i32 0
  store i8* %0, i8** %p, align 8
  %1 = load i8*, i8** %data.addr, align 8
  %2 = load i32, i32* %length.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %end = getelementptr inbounds %struct.PNG, %struct.PNG* %png, i32 0, i32 1
  store i8* %add.ptr, i8** %end, align 8
  %call = call %struct.Tigr* @tigrLoadPng(%struct.PNG* %png)
  ret %struct.Tigr* %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal %struct.Tigr* @tigrLoadPng(%struct.PNG* %png) #0 {
entry:
  %retval = alloca %struct.Tigr*, align 8
  %png.addr = alloca %struct.PNG*, align 8
  %ihdr = alloca i8*, align 8
  %idat = alloca i8*, align 8
  %plte = alloca i8*, align 8
  %first = alloca i8*, align 8
  %depth = alloca i32, align 4
  %ctype = alloca i32, align 4
  %bpp = alloca i32, align 4
  %datalen = alloca i32, align 4
  %data = alloca i8*, align 8
  %out = alloca i8*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  %len = alloca i32, align 4
  store %struct.PNG* %png, %struct.PNG** %png.addr, align 8
  store i32 0, i32* %datalen, align 4
  store i8* null, i8** %data, align 8
  store %struct.Tigr* null, %struct.Tigr** %bmp, align 8
  %0 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p = getelementptr inbounds %struct.PNG, %struct.PNG* %0, i32 0, i32 0
  %1 = load i8*, i8** %p, align 8
  %call = call i32 @memcmp(i8* %1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.98, i32 0, i32 0), i64 8)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i32* @__error()
  store i32 22, i32* %call1, align 4
  br label %err

if.end:                                           ; preds = %entry
  %2 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p2 = getelementptr inbounds %struct.PNG, %struct.PNG* %2, i32 0, i32 0
  %3 = load i8*, i8** %p2, align 8
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 8
  store i8* %add.ptr, i8** %p2, align 8
  %4 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p3 = getelementptr inbounds %struct.PNG, %struct.PNG* %4, i32 0, i32 0
  %5 = load i8*, i8** %p3, align 8
  store i8* %5, i8** %first, align 8
  %6 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %call4 = call i8* @find(%struct.PNG* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i32 13)
  store i8* %call4, i8** %ihdr, align 8
  %7 = load i8*, i8** %ihdr, align 8
  %tobool = icmp ne i8* %7, null
  br i1 %tobool, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %call6 = call i32* @__error()
  store i32 22, i32* %call6, align 4
  br label %err

if.end7:                                          ; preds = %if.end
  %8 = load i8*, i8** %ihdr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %8, i64 8
  %9 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %9 to i32
  store i32 %conv, i32* %depth, align 4
  %10 = load i8*, i8** %ihdr, align 8
  %arrayidx8 = getelementptr inbounds i8, i8* %10, i64 9
  %11 = load i8, i8* %arrayidx8, align 1
  %conv9 = zext i8 %11 to i32
  store i32 %conv9, i32* %ctype, align 4
  %12 = load i32, i32* %ctype, align 4
  switch i32 %12, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb10
    i32 3, label %sw.bb11
    i32 4, label %sw.bb12
    i32 6, label %sw.bb13
  ]

sw.bb:                                            ; preds = %if.end7
  store i32 1, i32* %bpp, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end7
  store i32 3, i32* %bpp, align 4
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end7
  store i32 1, i32* %bpp, align 4
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end7
  store i32 2, i32* %bpp, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %if.end7
  store i32 4, i32* %bpp, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end7
  %call14 = call i32* @__error()
  store i32 22, i32* %call14, align 4
  br label %err

sw.epilog:                                        ; preds = %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb
  %13 = load i8*, i8** %ihdr, align 8
  %add.ptr15 = getelementptr inbounds i8, i8* %13, i64 0
  %call16 = call i32 @get32(i8* %add.ptr15)
  %add = add i32 %call16, 1
  %14 = load i8*, i8** %ihdr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %14, i64 4
  %call18 = call i32 @get32(i8* %add.ptr17)
  %call19 = call %struct.Tigr* @tigrBitmap(i32 %add, i32 %call18)
  store %struct.Tigr* %call19, %struct.Tigr** %bmp, align 8
  %15 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %tobool20 = icmp ne %struct.Tigr* %15, null
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %sw.epilog
  %call22 = call i32* @__error()
  store i32 22, i32* %call22, align 4
  br label %err

if.end23:                                         ; preds = %sw.epilog
  %16 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %16, i32 0, i32 0
  %17 = load i32, i32* %w, align 8
  %dec = add nsw i32 %17, -1
  store i32 %dec, i32* %w, align 8
  %18 = load i32, i32* %depth, align 4
  %cmp24 = icmp eq i32 %18, 8
  br i1 %cmp24, label %land.lhs.true, label %if.then40

land.lhs.true:                                    ; preds = %if.end23
  %19 = load i8*, i8** %ihdr, align 8
  %arrayidx26 = getelementptr inbounds i8, i8* %19, i64 10
  %20 = load i8, i8* %arrayidx26, align 1
  %conv27 = zext i8 %20 to i32
  %cmp28 = icmp eq i32 %conv27, 0
  br i1 %cmp28, label %land.lhs.true30, label %if.then40

land.lhs.true30:                                  ; preds = %land.lhs.true
  %21 = load i8*, i8** %ihdr, align 8
  %arrayidx31 = getelementptr inbounds i8, i8* %21, i64 11
  %22 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %22 to i32
  %cmp33 = icmp eq i32 %conv32, 0
  br i1 %cmp33, label %land.lhs.true35, label %if.then40

land.lhs.true35:                                  ; preds = %land.lhs.true30
  %23 = load i8*, i8** %ihdr, align 8
  %arrayidx36 = getelementptr inbounds i8, i8* %23, i64 12
  %24 = load i8, i8* %arrayidx36, align 1
  %conv37 = zext i8 %24 to i32
  %cmp38 = icmp eq i32 %conv37, 0
  br i1 %cmp38, label %if.end42, label %if.then40

if.then40:                                        ; preds = %land.lhs.true35, %land.lhs.true30, %land.lhs.true, %if.end23
  %call41 = call i32* @__error()
  store i32 22, i32* %call41, align 4
  br label %err

if.end42:                                         ; preds = %land.lhs.true35
  %25 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %call43 = call i8* @find(%struct.PNG* %25, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i32 0)
  store i8* %call43, i8** %idat, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end42
  %26 = load i8*, i8** %idat, align 8
  %tobool44 = icmp ne i8* %26, null
  br i1 %tobool44, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load i8*, i8** %idat, align 8
  %add.ptr45 = getelementptr inbounds i8, i8* %27, i64 -8
  %call46 = call i32 @get32(i8* %add.ptr45)
  store i32 %call46, i32* %len, align 4
  %28 = load i8*, i8** %data, align 8
  %29 = load i32, i32* %datalen, align 4
  %30 = load i32, i32* %len, align 4
  %add47 = add i32 %29, %30
  %conv48 = zext i32 %add47 to i64
  %call49 = call i8* @realloc(i8* %28, i64 %conv48) #15
  store i8* %call49, i8** %data, align 8
  %31 = load i8*, i8** %data, align 8
  %tobool50 = icmp ne i8* %31, null
  br i1 %tobool50, label %if.end52, label %if.then51

if.then51:                                        ; preds = %for.body
  br label %for.end

if.end52:                                         ; preds = %for.body
  %32 = load i8*, i8** %data, align 8
  %33 = load i32, i32* %datalen, align 4
  %idx.ext = sext i32 %33 to i64
  %add.ptr53 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %34 = load i8*, i8** %idat, align 8
  %35 = load i32, i32* %len, align 4
  %conv54 = zext i32 %35 to i64
  %36 = load i8*, i8** %data, align 8
  %37 = load i32, i32* %datalen, align 4
  %idx.ext55 = sext i32 %37 to i64
  %add.ptr56 = getelementptr inbounds i8, i8* %36, i64 %idx.ext55
  %38 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr56, i1 false, i1 true)
  %call57 = call i8* @__memcpy_chk(i8* %add.ptr53, i8* %34, i64 %conv54, i64 %38) #10
  %39 = load i32, i32* %len, align 4
  %40 = load i32, i32* %datalen, align 4
  %add58 = add i32 %40, %39
  store i32 %add58, i32* %datalen, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end52
  %41 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %call59 = call i8* @find(%struct.PNG* %41, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i32 0)
  store i8* %call59, i8** %idat, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then51, %for.cond
  %42 = load i8*, i8** %first, align 8
  %43 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p60 = getelementptr inbounds %struct.PNG, %struct.PNG* %43, i32 0, i32 0
  store i8* %42, i8** %p60, align 8
  %44 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %call61 = call i8* @find(%struct.PNG* %44, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.101, i32 0, i32 0), i32 0)
  store i8* %call61, i8** %plte, align 8
  %45 = load i8*, i8** %data, align 8
  %tobool62 = icmp ne i8* %45, null
  br i1 %tobool62, label %land.lhs.true63, label %if.then66

land.lhs.true63:                                  ; preds = %for.end
  %46 = load i32, i32* %datalen, align 4
  %cmp64 = icmp sge i32 %46, 6
  br i1 %cmp64, label %if.end68, label %if.then66

if.then66:                                        ; preds = %land.lhs.true63, %for.end
  %call67 = call i32* @__error()
  store i32 22, i32* %call67, align 4
  br label %err

if.end68:                                         ; preds = %land.lhs.true63
  %47 = load i8*, i8** %data, align 8
  %arrayidx69 = getelementptr inbounds i8, i8* %47, i64 0
  %48 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %48 to i32
  %and = and i32 %conv70, 15
  %cmp71 = icmp eq i32 %and, 8
  br i1 %cmp71, label %land.lhs.true73, label %if.then85

land.lhs.true73:                                  ; preds = %if.end68
  %49 = load i8*, i8** %data, align 8
  %arrayidx74 = getelementptr inbounds i8, i8* %49, i64 0
  %50 = load i8, i8* %arrayidx74, align 1
  %conv75 = zext i8 %50 to i32
  %and76 = and i32 %conv75, 240
  %cmp77 = icmp sle i32 %and76, 112
  br i1 %cmp77, label %land.lhs.true79, label %if.then85

land.lhs.true79:                                  ; preds = %land.lhs.true73
  %51 = load i8*, i8** %data, align 8
  %arrayidx80 = getelementptr inbounds i8, i8* %51, i64 1
  %52 = load i8, i8* %arrayidx80, align 1
  %conv81 = zext i8 %52 to i32
  %and82 = and i32 %conv81, 32
  %cmp83 = icmp eq i32 %and82, 0
  br i1 %cmp83, label %if.end87, label %if.then85

if.then85:                                        ; preds = %land.lhs.true79, %land.lhs.true73, %if.end68
  %call86 = call i32* @__error()
  store i32 22, i32* %call86, align 4
  br label %err

if.end87:                                         ; preds = %land.lhs.true79
  %53 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %53, i32 0, i32 2
  %54 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %55 = bitcast %struct.TPixel* %54 to i8*
  %56 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %call88 = call i32 @outsize(%struct.Tigr* %56, i32 4)
  %idx.ext89 = sext i32 %call88 to i64
  %add.ptr90 = getelementptr inbounds i8, i8* %55, i64 %idx.ext89
  %57 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %58 = load i32, i32* %bpp, align 4
  %call91 = call i32 @outsize(%struct.Tigr* %57, i32 %58)
  %idx.ext92 = sext i32 %call91 to i64
  %idx.neg = sub i64 0, %idx.ext92
  %add.ptr93 = getelementptr inbounds i8, i8* %add.ptr90, i64 %idx.neg
  store i8* %add.ptr93, i8** %out, align 8
  %59 = load i8*, i8** %out, align 8
  %60 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %61 = load i32, i32* %bpp, align 4
  %call94 = call i32 @outsize(%struct.Tigr* %60, i32 %61)
  %62 = load i8*, i8** %data, align 8
  %add.ptr95 = getelementptr inbounds i8, i8* %62, i64 2
  %63 = load i32, i32* %datalen, align 4
  %sub = sub nsw i32 %63, 6
  %call96 = call i32 @tigrInflate(i8* %59, i32 %call94, i8* %add.ptr95, i32 %sub)
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.end87
  %call99 = call i32* @__error()
  store i32 22, i32* %call99, align 4
  br label %err

if.end100:                                        ; preds = %if.end87
  %64 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %w101 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %64, i32 0, i32 0
  %65 = load i32, i32* %w101, align 8
  %66 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %66, i32 0, i32 1
  %67 = load i32, i32* %h, align 4
  %68 = load i32, i32* %bpp, align 4
  %69 = load i8*, i8** %out, align 8
  %call102 = call i32 @unfilter(i32 %65, i32 %67, i32 %68, i8* %69)
  %tobool103 = icmp ne i32 %call102, 0
  br i1 %tobool103, label %if.end106, label %if.then104

if.then104:                                       ; preds = %if.end100
  %call105 = call i32* @__error()
  store i32 22, i32* %call105, align 4
  br label %err

if.end106:                                        ; preds = %if.end100
  %70 = load i32, i32* %ctype, align 4
  %cmp107 = icmp eq i32 %70, 3
  br i1 %cmp107, label %if.then109, label %if.else

if.then109:                                       ; preds = %if.end106
  %71 = load i8*, i8** %plte, align 8
  %tobool110 = icmp ne i8* %71, null
  br i1 %tobool110, label %if.end113, label %if.then111

if.then111:                                       ; preds = %if.then109
  %call112 = call i32* @__error()
  store i32 22, i32* %call112, align 4
  br label %err

if.end113:                                        ; preds = %if.then109
  %72 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %w114 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %72, i32 0, i32 0
  %73 = load i32, i32* %w114, align 8
  %74 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %h115 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %74, i32 0, i32 1
  %75 = load i32, i32* %h115, align 4
  %76 = load i8*, i8** %out, align 8
  %77 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %pix116 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %77, i32 0, i32 2
  %78 = load %struct.TPixel*, %struct.TPixel** %pix116, align 8
  %79 = load i8*, i8** %plte, align 8
  call void @depalette(i32 %73, i32 %75, i8* %76, %struct.TPixel* %78, i8* %79)
  br label %if.end120

if.else:                                          ; preds = %if.end106
  %80 = load i32, i32* %bpp, align 4
  %81 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %w117 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %81, i32 0, i32 0
  %82 = load i32, i32* %w117, align 8
  %83 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %h118 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %83, i32 0, i32 1
  %84 = load i32, i32* %h118, align 4
  %85 = load i8*, i8** %out, align 8
  %86 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %pix119 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %86, i32 0, i32 2
  %87 = load %struct.TPixel*, %struct.TPixel** %pix119, align 8
  call void @convert(i32 %80, i32 %82, i32 %84, i8* %85, %struct.TPixel* %87)
  br label %if.end120

if.end120:                                        ; preds = %if.else, %if.end113
  %88 = load i8*, i8** %data, align 8
  call void @free(i8* %88)
  %89 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  store %struct.Tigr* %89, %struct.Tigr** %retval, align 8
  br label %return

err:                                              ; preds = %if.then111, %if.then104, %if.then98, %if.then85, %if.then66, %if.then40, %if.then21, %sw.default, %if.then5, %if.then
  %90 = load i8*, i8** %data, align 8
  %tobool121 = icmp ne i8* %90, null
  br i1 %tobool121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %err
  %91 = load i8*, i8** %data, align 8
  call void @free(i8* %91)
  br label %if.end123

if.end123:                                        ; preds = %if.then122, %err
  %92 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %tobool124 = icmp ne %struct.Tigr* %92, null
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end123
  %93 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  call void @tigrFree(%struct.Tigr* %93)
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %if.end123
  store %struct.Tigr* null, %struct.Tigr** %retval, align 8
  br label %return

return:                                           ; preds = %if.end126, %if.end120
  %94 = load %struct.Tigr*, %struct.Tigr** %retval, align 8
  ret %struct.Tigr* %94
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.Tigr* @tigrLoadImage(i8* %fileName) #0 {
entry:
  %retval = alloca %struct.Tigr*, align 8
  %fileName.addr = alloca i8*, align 8
  %len = alloca i32, align 4
  %data = alloca i8*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  store i8* %fileName, i8** %fileName.addr, align 8
  %0 = load i8*, i8** %fileName.addr, align 8
  %call = call i8* @tigrReadFile(i8* %0, i32* %len)
  store i8* %call, i8** %data, align 8
  %1 = load i8*, i8** %data, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.Tigr* null, %struct.Tigr** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i8*, i8** %data, align 8
  %3 = load i32, i32* %len, align 4
  %call1 = call %struct.Tigr* @tigrLoadImageMem(i8* %2, i32 %3)
  store %struct.Tigr* %call1, %struct.Tigr** %bmp, align 8
  %4 = load i8*, i8** %data, align 8
  call void @free(i8* %4)
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  store %struct.Tigr* %5, %struct.Tigr** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load %struct.Tigr*, %struct.Tigr** %retval, align 8
  ret %struct.Tigr* %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i8* @tigrReadFile(i8* %fileName, i32* %length) #0 {
entry:
  %retval = alloca i8*, align 8
  %fileName.addr = alloca i8*, align 8
  %length.addr = alloca i32*, align 8
  %file = alloca %struct.__sFILE*, align 8
  %data = alloca i8*, align 8
  %len = alloca i64, align 8
  store i8* %fileName, i8** %fileName.addr, align 8
  store i32* %length, i32** %length.addr, align 8
  %0 = load i32*, i32** %length.addr, align 8
  %tobool = icmp ne i32* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32*, i32** %length.addr, align 8
  store i32 0, i32* %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8*, i8** %fileName.addr, align 8
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %file, align 8
  %3 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %tobool1 = icmp ne %struct.__sFILE* %3, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i8* null, i8** %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call4 = call i32 @fseek(%struct.__sFILE* %4, i64 0, i32 2)
  %5 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call5 = call i64 @ftell(%struct.__sFILE* %5)
  store i64 %call5, i64* %len, align 8
  %6 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call6 = call i32 @fseek(%struct.__sFILE* %6, i64 0, i32 0)
  %7 = load i64, i64* %len, align 8
  %add = add i64 %7, 1
  %call7 = call i8* @malloc(i64 %add) #16
  store i8* %call7, i8** %data, align 8
  %8 = load i8*, i8** %data, align 8
  %tobool8 = icmp ne i8* %8, null
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end3
  %9 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call10 = call i32 @fclose(%struct.__sFILE* %9)
  store i8* null, i8** %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end3
  %10 = load i8*, i8** %data, align 8
  %11 = load i64, i64* %len, align 8
  %12 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call12 = call i64 @fread(i8* %10, i64 1, i64 %11, %struct.__sFILE* %12)
  %13 = load i64, i64* %len, align 8
  %cmp = icmp ne i64 %call12, %13
  br i1 %cmp, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %14 = load i8*, i8** %data, align 8
  call void @free(i8* %14)
  %15 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call14 = call i32 @fclose(%struct.__sFILE* %15)
  store i8* null, i8** %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end11
  %16 = load i8*, i8** %data, align 8
  %17 = load i64, i64* %len, align 8
  %arrayidx = getelementptr inbounds i8, i8* %16, i64 %17
  store i8 0, i8* %arrayidx, align 1
  %18 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8
  %call16 = call i32 @fclose(%struct.__sFILE* %18)
  %19 = load i32*, i32** %length.addr, align 8
  %tobool17 = icmp ne i32* %19, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %20 = load i64, i64* %len, align 8
  %conv = trunc i64 %20 to i32
  %21 = load i32*, i32** %length.addr, align 8
  store i32 %conv, i32* %21, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %22 = load i8*, i8** %data, align 8
  store i8* %22, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then13, %if.then9, %if.then2
  %23 = load i8*, i8** %retval, align 8
  ret i8* %23
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @putbits(%struct.Save* %s, i32 %data, i32 %bitcount) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %data.addr = alloca i32, align 4
  %bitcount.addr = alloca i32, align 4
  %prev = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %data, i32* %data.addr, align 4
  store i32 %bitcount, i32* %bitcount.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load i32, i32* %bitcount.addr, align 4
  %dec = add i32 %0, -1
  store i32 %dec, i32* %bitcount.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %bits = getelementptr inbounds %struct.Save, %struct.Save* %1, i32 0, i32 2
  %2 = load i32, i32* %bits, align 8
  store i32 %2, i32* %prev, align 4
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %bits1 = getelementptr inbounds %struct.Save, %struct.Save* %3, i32 0, i32 2
  %4 = load i32, i32* %bits1, align 8
  %shr = lshr i32 %4, 1
  %5 = load i32, i32* %data.addr, align 4
  %and = and i32 %5, 1
  %shl = shl i32 %and, 7
  %or = or i32 %shr, %shl
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %bits2 = getelementptr inbounds %struct.Save, %struct.Save* %6, i32 0, i32 2
  store i32 %or, i32* %bits2, align 8
  %7 = load i32, i32* %data.addr, align 4
  %shr3 = lshr i32 %7, 1
  store i32 %shr3, i32* %data.addr, align 4
  %8 = load i32, i32* %prev, align 4
  %and4 = and i32 %8, 1
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %bits6 = getelementptr inbounds %struct.Save, %struct.Save* %10, i32 0, i32 2
  %11 = load i32, i32* %bits6, align 8
  call void @put(%struct.Save* %9, i32 %11)
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %bits7 = getelementptr inbounds %struct.Save, %struct.Save* %12, i32 0, i32 2
  store i32 128, i32* %bits7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @put(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  %0 = load i32, i32* %v.addr, align 4
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %out = getelementptr inbounds %struct.Save, %struct.Save* %1, i32 0, i32 5
  %2 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %call = call i32 @fputc(i32 %0, %struct.__sFILE* %2)
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %3, i32 0, i32 0
  %4 = load i32, i32* %crc, align 8
  %shr = lshr i32 %4, 4
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc1 = getelementptr inbounds %struct.Save, %struct.Save* %5, i32 0, i32 0
  %6 = load i32, i32* %crc1, align 8
  %and = and i32 %6, 15
  %7 = load i32, i32* %v.addr, align 4
  %and2 = and i32 %7, 15
  %xor = xor i32 %and, %and2
  %idxprom = zext i32 %xor to i64
  %arrayidx = getelementptr inbounds [16 x i32], [16 x i32]* @crctable, i64 0, i64 %idxprom
  %8 = load i32, i32* %arrayidx, align 4
  %xor3 = xor i32 %shr, %8
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc4 = getelementptr inbounds %struct.Save, %struct.Save* %9, i32 0, i32 0
  store i32 %xor3, i32* %crc4, align 8
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc5 = getelementptr inbounds %struct.Save, %struct.Save* %10, i32 0, i32 0
  %11 = load i32, i32* %crc5, align 8
  %shr6 = lshr i32 %11, 4
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc7 = getelementptr inbounds %struct.Save, %struct.Save* %12, i32 0, i32 0
  %13 = load i32, i32* %crc7, align 8
  %and8 = and i32 %13, 15
  %14 = load i32, i32* %v.addr, align 4
  %shr9 = lshr i32 %14, 4
  %xor10 = xor i32 %and8, %shr9
  %idxprom11 = zext i32 %xor10 to i64
  %arrayidx12 = getelementptr inbounds [16 x i32], [16 x i32]* @crctable, i64 0, i64 %idxprom11
  %15 = load i32, i32* %arrayidx12, align 4
  %xor13 = xor i32 %shr6, %15
  %16 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc14 = getelementptr inbounds %struct.Save, %struct.Save* %16, i32 0, i32 0
  store i32 %xor13, i32* %crc14, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @putbitsr(%struct.Save* %s, i32 %data, i32 %bitcount) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %data.addr = alloca i32, align 4
  %bitcount.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %data, i32* %data.addr, align 4
  store i32 %bitcount, i32* %bitcount.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %bitcount.addr, align 4
  %dec = add i32 %0, -1
  store i32 %dec, i32* %bitcount.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %2 = load i32, i32* %data.addr, align 4
  %3 = load i32, i32* %bitcount.addr, align 4
  %shr = lshr i32 %2, %3
  call void @putbits(%struct.Save* %1, i32 %shr, i32 1)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrSaveImage(i8* %fileName, %struct.Tigr* %bmp) #0 {
entry:
  %retval = alloca i32, align 4
  %fileName.addr = alloca i8*, align 8
  %bmp.addr = alloca %struct.Tigr*, align 8
  %s = alloca %struct.Save, align 8
  %dataPos = alloca i64, align 8
  %dataSize = alloca i64, align 8
  %err = alloca i64, align 8
  %out = alloca %struct.__sFILE*, align 8
  store i8* %fileName, i8** %fileName.addr, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load i8*, i8** %fileName.addr, align 8
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %out, align 8
  %1 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %tobool = icmp ne %struct.__sFILE* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %out1 = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 5
  store %struct.__sFILE* %2, %struct.__sFILE** %out1, align 8
  %adler = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 1
  store i32 1, i32* %adler, align 4
  %bits = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 2
  store i32 128, i32* %bits, align 8
  %prev = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 3
  store i32 65535, i32* %prev, align 4
  %runlen = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 4
  store i32 0, i32* %runlen, align 8
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  call void @savePngHeader(%struct.Save* %s, %struct.Tigr* %3)
  %out2 = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 5
  %4 = load %struct.__sFILE*, %struct.__sFILE** %out2, align 8
  %call3 = call i64 @ftell(%struct.__sFILE* %4)
  store i64 %call3, i64* %dataPos, align 8
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %6 = load i64, i64* %dataPos, align 8
  %call4 = call i64 @savePngData(%struct.Save* %s, %struct.Tigr* %5, i64 %6)
  store i64 %call4, i64* %dataSize, align 8
  call void @begin(%struct.Save* %s, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i32 0, i32 0), i32 0)
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 0
  %7 = load i32, i32* %crc, align 8
  %neg = xor i32 %7, -1
  call void @put32(%struct.Save* %s, i32 %neg)
  %8 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %9 = load i64, i64* %dataPos, align 8
  %call5 = call i32 @fseek(%struct.__sFILE* %8, i64 %9, i32 0)
  %10 = load i64, i64* %dataSize, align 8
  %conv = trunc i64 %10 to i32
  call void @put32(%struct.Save* %s, i32 %conv)
  %11 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %call6 = call i32 @ferror(%struct.__sFILE* %11)
  %conv7 = sext i32 %call6 to i64
  store i64 %conv7, i64* %err, align 8
  %12 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %call8 = call i32 @fclose(%struct.__sFILE* %12)
  %13 = load i64, i64* %err, align 8
  %tobool9 = icmp ne i64 %13, 0
  %lnot = xor i1 %tobool9, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @savePngHeader(%struct.Save* %s, %struct.Tigr* %bmp) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %out = getelementptr inbounds %struct.Save, %struct.Save* %0, i32 0, i32 5
  %1 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %call = call i64 @"\01_fwrite"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.98, i32 0, i32 0), i64 8, i64 1, %struct.__sFILE* %1)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @begin(%struct.Save* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i32 13)
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 0
  %5 = load i32, i32* %w, align 8
  call void @put32(%struct.Save* %3, i32 %5)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 1
  %8 = load i32, i32* %h, align 4
  call void @put32(%struct.Save* %6, i32 %8)
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %9, i32 8)
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %10, i32 6)
  %11 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %11, i32 0)
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %12, i32 0)
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %13, i32 0)
  %14 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %15 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %15, i32 0, i32 0
  %16 = load i32, i32* %crc, align 8
  %neg = xor i32 %16, -1
  call void @put32(%struct.Save* %14, i32 %neg)
  ret void
}

declare i64 @ftell(%struct.__sFILE*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i64 @savePngData(%struct.Save* %s, %struct.Tigr* %bmp, i64 %dataPos) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %bmp.addr = alloca %struct.Tigr*, align 8
  %dataPos.addr = alloca i64, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %dataSize = alloca i64, align 8
  %row = alloca %struct.TPixel*, align 8
  %prev = alloca %struct.TPixel, align 1
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i64 %dataPos, i64* %dataPos.addr, align 8
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @begin(%struct.Save* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i32 0)
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %1, i32 8)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @put(%struct.Save* %2, i32 29)
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @putbits(%struct.Save* %3, i32 3, i32 3)
  store i32 0, i32* %y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc33, %entry
  %4 = load i32, i32* %y, align 4
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %5, i32 0, i32 1
  %6 = load i32, i32* %h, align 4
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end35

for.body:                                         ; preds = %for.cond
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 2
  %8 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %9 = load i32, i32* %y, align 4
  %10 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %10, i32 0, i32 0
  %11 = load i32, i32* %w, align 8
  %mul = mul nsw i32 %9, %11
  %idxprom = sext i32 %mul to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %8, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %row, align 8
  %call = call i32 @tigrRGBA(i8 zeroext 0, i8 zeroext 0, i8 zeroext 0, i8 zeroext 0)
  %12 = bitcast %struct.TPixel* %prev to i32*
  store i32 %call, i32* %12, align 1
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @encodeByte(%struct.Save* %13, i8 zeroext 1)
  store i32 0, i32* %x, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %14 = load i32, i32* %x, align 4
  %15 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w2 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %15, i32 0, i32 0
  %16 = load i32, i32* %w2, align 8
  %cmp3 = icmp slt i32 %14, %16
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %17 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %18 = load %struct.TPixel*, %struct.TPixel** %row, align 8
  %19 = load i32, i32* %x, align 4
  %idxprom5 = sext i32 %19 to i64
  %arrayidx6 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %18, i64 %idxprom5
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx6, i32 0, i32 2
  %20 = load i8, i8* %r, align 1
  %conv = zext i8 %20 to i32
  %r7 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 2
  %21 = load i8, i8* %r7, align 1
  %conv8 = zext i8 %21 to i32
  %sub = sub nsw i32 %conv, %conv8
  %conv9 = trunc i32 %sub to i8
  call void @encodeByte(%struct.Save* %17, i8 zeroext %conv9)
  %22 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %23 = load %struct.TPixel*, %struct.TPixel** %row, align 8
  %24 = load i32, i32* %x, align 4
  %idxprom10 = sext i32 %24 to i64
  %arrayidx11 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %23, i64 %idxprom10
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx11, i32 0, i32 1
  %25 = load i8, i8* %g, align 1
  %conv12 = zext i8 %25 to i32
  %g13 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 1
  %26 = load i8, i8* %g13, align 1
  %conv14 = zext i8 %26 to i32
  %sub15 = sub nsw i32 %conv12, %conv14
  %conv16 = trunc i32 %sub15 to i8
  call void @encodeByte(%struct.Save* %22, i8 zeroext %conv16)
  %27 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %28 = load %struct.TPixel*, %struct.TPixel** %row, align 8
  %29 = load i32, i32* %x, align 4
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %28, i64 %idxprom17
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx18, i32 0, i32 0
  %30 = load i8, i8* %b, align 1
  %conv19 = zext i8 %30 to i32
  %b20 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 0
  %31 = load i8, i8* %b20, align 1
  %conv21 = zext i8 %31 to i32
  %sub22 = sub nsw i32 %conv19, %conv21
  %conv23 = trunc i32 %sub22 to i8
  call void @encodeByte(%struct.Save* %27, i8 zeroext %conv23)
  %32 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %33 = load %struct.TPixel*, %struct.TPixel** %row, align 8
  %34 = load i32, i32* %x, align 4
  %idxprom24 = sext i32 %34 to i64
  %arrayidx25 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %33, i64 %idxprom24
  %a = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx25, i32 0, i32 3
  %35 = load i8, i8* %a, align 1
  %conv26 = zext i8 %35 to i32
  %a27 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 3
  %36 = load i8, i8* %a27, align 1
  %conv28 = zext i8 %36 to i32
  %sub29 = sub nsw i32 %conv26, %conv28
  %conv30 = trunc i32 %sub29 to i8
  call void @encodeByte(%struct.Save* %32, i8 zeroext %conv30)
  %37 = load %struct.TPixel*, %struct.TPixel** %row, align 8
  %38 = load i32, i32* %x, align 4
  %idxprom31 = sext i32 %38 to i64
  %arrayidx32 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %37, i64 %idxprom31
  %39 = bitcast %struct.TPixel* %prev to i8*
  %40 = bitcast %struct.TPixel* %arrayidx32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %39, i8* align 1 %40, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %41 = load i32, i32* %x, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc33

for.inc33:                                        ; preds = %for.end
  %42 = load i32, i32* %y, align 4
  %inc34 = add nsw i32 %42, 1
  store i32 %inc34, i32* %y, align 4
  br label %for.cond

for.end35:                                        ; preds = %for.cond
  %43 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @endrun(%struct.Save* %43)
  %44 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @literal(%struct.Save* %44, i32 256)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end35
  %45 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %bits = getelementptr inbounds %struct.Save, %struct.Save* %45, i32 0, i32 2
  %46 = load i32, i32* %bits, align 8
  %cmp36 = icmp ne i32 %46, 128
  br i1 %cmp36, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %47 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @putbits(%struct.Save* %47, i32 0, i32 1)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %48 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %49 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %adler = getelementptr inbounds %struct.Save, %struct.Save* %49, i32 0, i32 1
  %50 = load i32, i32* %adler, align 4
  call void @put32(%struct.Save* %48, i32 %50)
  %51 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %out = getelementptr inbounds %struct.Save, %struct.Save* %51, i32 0, i32 5
  %52 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8
  %call38 = call i64 @ftell(%struct.__sFILE* %52)
  %53 = load i64, i64* %dataPos.addr, align 8
  %sub39 = sub nsw i64 %call38, %53
  %sub40 = sub nsw i64 %sub39, 8
  store i64 %sub40, i64* %dataSize, align 8
  %54 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %55 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %55, i32 0, i32 0
  %56 = load i32, i32* %crc, align 8
  %neg = xor i32 %56, -1
  call void @put32(%struct.Save* %54, i32 %neg)
  %57 = load i64, i64* %dataSize, align 8
  ret i64 %57
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @begin(%struct.Save* %s, i8* %id, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %id.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i8* %id, i8** %id.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %1 = load i32, i32* %len.addr, align 4
  call void @put32(%struct.Save* %0, i32 %1)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %2, i32 0, i32 0
  store i32 -1, i32* %crc, align 8
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %4 = load i8*, i8** %id.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %5 to i32
  call void @put(%struct.Save* %3, i32 %conv)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %7 = load i8*, i8** %id.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, i8* %7, i64 1
  %8 = load i8, i8* %arrayidx1, align 1
  %conv2 = sext i8 %8 to i32
  call void @put(%struct.Save* %6, i32 %conv2)
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %10 = load i8*, i8** %id.addr, align 8
  %arrayidx3 = getelementptr inbounds i8, i8* %10, i64 2
  %11 = load i8, i8* %arrayidx3, align 1
  %conv4 = sext i8 %11 to i32
  call void @put(%struct.Save* %9, i32 %conv4)
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %13 = load i8*, i8** %id.addr, align 8
  %arrayidx5 = getelementptr inbounds i8, i8* %13, i64 3
  %14 = load i8, i8* %arrayidx5, align 1
  %conv6 = sext i8 %14 to i32
  call void @put(%struct.Save* %12, i32 %conv6)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @put32(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %1 = load i32, i32* %v.addr, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 255
  call void @put(%struct.Save* %0, i32 %and)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %3 = load i32, i32* %v.addr, align 4
  %shr1 = lshr i32 %3, 16
  %and2 = and i32 %shr1, 255
  call void @put(%struct.Save* %2, i32 %and2)
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %5 = load i32, i32* %v.addr, align 4
  %shr3 = lshr i32 %5, 8
  %and4 = and i32 %shr3, 255
  call void @put(%struct.Save* %4, i32 %and4)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %7 = load i32, i32* %v.addr, align 4
  %and5 = and i32 %7, 255
  call void @put(%struct.Save* %6, i32 %and5)
  ret void
}

declare i32 @fseek(%struct.__sFILE*, i64, i32) #4

declare i32 @ferror(%struct.__sFILE*) #4

declare i32 @fclose(%struct.__sFILE*) #4

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #7

declare i64 @fread(i8*, i64, i64, %struct.__sFILE*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define i8* @tigrDecodeUTF8(i8* %text, i32* %cp) #0 {
entry:
  %text.addr = alloca i8*, align 8
  %cp.addr = alloca i32*, align 8
  %c = alloca i8, align 1
  %extra = alloca i32, align 4
  %min = alloca i32, align 4
  store i8* %text, i8** %text.addr, align 8
  store i32* %cp, i32** %cp.addr, align 8
  %0 = load i8*, i8** %text.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 1
  store i8* %incdec.ptr, i8** %text.addr, align 8
  %1 = load i8, i8* %0, align 1
  store i8 %1, i8* %c, align 1
  store i32 0, i32* %extra, align 4
  store i32 0, i32* %min, align 4
  %2 = load i32*, i32** %cp.addr, align 8
  store i32 0, i32* %2, align 4
  %3 = load i8, i8* %c, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv, 240
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i8, i8* %c, align 1
  %conv2 = zext i8 %4 to i32
  %and = and i32 %conv2, 7
  %5 = load i32*, i32** %cp.addr, align 8
  store i32 %and, i32* %5, align 4
  store i32 3, i32* %extra, align 4
  store i32 65536, i32* %min, align 4
  br label %if.end25

if.else:                                          ; preds = %entry
  %6 = load i8, i8* %c, align 1
  %conv3 = zext i8 %6 to i32
  %cmp4 = icmp sge i32 %conv3, 224
  br i1 %cmp4, label %if.then6, label %if.else9

if.then6:                                         ; preds = %if.else
  %7 = load i8, i8* %c, align 1
  %conv7 = zext i8 %7 to i32
  %and8 = and i32 %conv7, 15
  %8 = load i32*, i32** %cp.addr, align 8
  store i32 %and8, i32* %8, align 4
  store i32 2, i32* %extra, align 4
  store i32 2048, i32* %min, align 4
  br label %if.end24

if.else9:                                         ; preds = %if.else
  %9 = load i8, i8* %c, align 1
  %conv10 = zext i8 %9 to i32
  %cmp11 = icmp sge i32 %conv10, 192
  br i1 %cmp11, label %if.then13, label %if.else16

if.then13:                                        ; preds = %if.else9
  %10 = load i8, i8* %c, align 1
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 31
  %11 = load i32*, i32** %cp.addr, align 8
  store i32 %and15, i32* %11, align 4
  store i32 1, i32* %extra, align 4
  store i32 128, i32* %min, align 4
  br label %if.end23

if.else16:                                        ; preds = %if.else9
  %12 = load i8, i8* %c, align 1
  %conv17 = zext i8 %12 to i32
  %cmp18 = icmp sge i32 %conv17, 128
  br i1 %cmp18, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.else16
  %13 = load i32*, i32** %cp.addr, align 8
  store i32 65533, i32* %13, align 4
  br label %if.end

if.else21:                                        ; preds = %if.else16
  %14 = load i8, i8* %c, align 1
  %conv22 = zext i8 %14 to i32
  %15 = load i32*, i32** %cp.addr, align 8
  store i32 %conv22, i32* %15, align 4
  br label %if.end

if.end:                                           ; preds = %if.else21, %if.then20
  br label %if.end23

if.end23:                                         ; preds = %if.end, %if.then13
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then6
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then
  br label %while.cond

while.cond:                                       ; preds = %if.end32, %if.end25
  %16 = load i32, i32* %extra, align 4
  %dec = add nsw i32 %16, -1
  store i32 %dec, i32* %extra, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load i8*, i8** %text.addr, align 8
  %incdec.ptr26 = getelementptr inbounds i8, i8* %17, i32 1
  store i8* %incdec.ptr26, i8** %text.addr, align 8
  %18 = load i8, i8* %17, align 1
  store i8 %18, i8* %c, align 1
  %19 = load i8, i8* %c, align 1
  %conv27 = zext i8 %19 to i32
  %and28 = and i32 %conv27, 192
  %cmp29 = icmp ne i32 %and28, 128
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %while.body
  %20 = load i32*, i32** %cp.addr, align 8
  store i32 65533, i32* %20, align 4
  br label %while.end

if.end32:                                         ; preds = %while.body
  %21 = load i32*, i32** %cp.addr, align 8
  %22 = load i32, i32* %21, align 4
  %shl = shl i32 %22, 6
  %23 = load i8, i8* %c, align 1
  %conv33 = zext i8 %23 to i32
  %and34 = and i32 %conv33, 63
  %or = or i32 %shl, %and34
  %24 = load i32*, i32** %cp.addr, align 8
  store i32 %or, i32* %24, align 4
  br label %while.cond

while.end:                                        ; preds = %if.then31, %while.cond
  %25 = load i32*, i32** %cp.addr, align 8
  %26 = load i32, i32* %25, align 4
  %27 = load i32, i32* %min, align 4
  %cmp35 = icmp slt i32 %26, %27
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %while.end
  %28 = load i32*, i32** %cp.addr, align 8
  store i32 65533, i32* %28, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %while.end
  %29 = load i8*, i8** %text.addr, align 8
  ret i8* %29
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i8* @tigrEncodeUTF8(i8* %text, i32 %cp) #0 {
entry:
  %text.addr = alloca i8*, align 8
  %cp.addr = alloca i32, align 4
  store i8* %text, i8** %text.addr, align 8
  store i32 %cp, i32* %cp.addr, align 4
  %0 = load i32, i32* %cp.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %cp.addr, align 4
  %cmp1 = icmp sgt i32 %1, 1114111
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 65533, i32* %cp.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %2 = load i32, i32* %cp.addr, align 4
  %cmp2 = icmp slt i32 %2, 128
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load i32, i32* %cp.addr, align 4
  %shr = ashr i32 %3, 0
  %and = and i32 %shr, 127
  %or = or i32 0, %and
  %conv = trunc i32 %or to i8
  %4 = load i8*, i8** %text.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr, i8** %text.addr, align 8
  store i8 %conv, i8* %4, align 1
  br label %if.end59

if.else:                                          ; preds = %if.end
  %5 = load i32, i32* %cp.addr, align 4
  %cmp4 = icmp slt i32 %5, 2048
  br i1 %cmp4, label %if.then6, label %if.else17

if.then6:                                         ; preds = %if.else
  %6 = load i32, i32* %cp.addr, align 4
  %shr7 = ashr i32 %6, 6
  %and8 = and i32 %shr7, 31
  %or9 = or i32 192, %and8
  %conv10 = trunc i32 %or9 to i8
  %7 = load i8*, i8** %text.addr, align 8
  %incdec.ptr11 = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr11, i8** %text.addr, align 8
  store i8 %conv10, i8* %7, align 1
  %8 = load i32, i32* %cp.addr, align 4
  %shr12 = ashr i32 %8, 0
  %and13 = and i32 %shr12, 63
  %or14 = or i32 128, %and13
  %conv15 = trunc i32 %or14 to i8
  %9 = load i8*, i8** %text.addr, align 8
  %incdec.ptr16 = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr16, i8** %text.addr, align 8
  store i8 %conv15, i8* %9, align 1
  br label %if.end58

if.else17:                                        ; preds = %if.else
  %10 = load i32, i32* %cp.addr, align 4
  %cmp18 = icmp slt i32 %10, 65536
  br i1 %cmp18, label %if.then20, label %if.else36

if.then20:                                        ; preds = %if.else17
  %11 = load i32, i32* %cp.addr, align 4
  %shr21 = ashr i32 %11, 12
  %and22 = and i32 %shr21, 15
  %or23 = or i32 224, %and22
  %conv24 = trunc i32 %or23 to i8
  %12 = load i8*, i8** %text.addr, align 8
  %incdec.ptr25 = getelementptr inbounds i8, i8* %12, i32 1
  store i8* %incdec.ptr25, i8** %text.addr, align 8
  store i8 %conv24, i8* %12, align 1
  %13 = load i32, i32* %cp.addr, align 4
  %shr26 = ashr i32 %13, 6
  %and27 = and i32 %shr26, 63
  %or28 = or i32 128, %and27
  %conv29 = trunc i32 %or28 to i8
  %14 = load i8*, i8** %text.addr, align 8
  %incdec.ptr30 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr30, i8** %text.addr, align 8
  store i8 %conv29, i8* %14, align 1
  %15 = load i32, i32* %cp.addr, align 4
  %shr31 = ashr i32 %15, 0
  %and32 = and i32 %shr31, 63
  %or33 = or i32 128, %and32
  %conv34 = trunc i32 %or33 to i8
  %16 = load i8*, i8** %text.addr, align 8
  %incdec.ptr35 = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr35, i8** %text.addr, align 8
  store i8 %conv34, i8* %16, align 1
  br label %if.end57

if.else36:                                        ; preds = %if.else17
  %17 = load i32, i32* %cp.addr, align 4
  %shr37 = ashr i32 %17, 18
  %and38 = and i32 %shr37, 7
  %or39 = or i32 240, %and38
  %conv40 = trunc i32 %or39 to i8
  %18 = load i8*, i8** %text.addr, align 8
  %incdec.ptr41 = getelementptr inbounds i8, i8* %18, i32 1
  store i8* %incdec.ptr41, i8** %text.addr, align 8
  store i8 %conv40, i8* %18, align 1
  %19 = load i32, i32* %cp.addr, align 4
  %shr42 = ashr i32 %19, 12
  %and43 = and i32 %shr42, 63
  %or44 = or i32 128, %and43
  %conv45 = trunc i32 %or44 to i8
  %20 = load i8*, i8** %text.addr, align 8
  %incdec.ptr46 = getelementptr inbounds i8, i8* %20, i32 1
  store i8* %incdec.ptr46, i8** %text.addr, align 8
  store i8 %conv45, i8* %20, align 1
  %21 = load i32, i32* %cp.addr, align 4
  %shr47 = ashr i32 %21, 6
  %and48 = and i32 %shr47, 63
  %or49 = or i32 128, %and48
  %conv50 = trunc i32 %or49 to i8
  %22 = load i8*, i8** %text.addr, align 8
  %incdec.ptr51 = getelementptr inbounds i8, i8* %22, i32 1
  store i8* %incdec.ptr51, i8** %text.addr, align 8
  store i8 %conv50, i8* %22, align 1
  %23 = load i32, i32* %cp.addr, align 4
  %shr52 = ashr i32 %23, 0
  %and53 = and i32 %shr52, 63
  %or54 = or i32 128, %and53
  %conv55 = trunc i32 %or54 to i8
  %24 = load i8*, i8** %text.addr, align 8
  %incdec.ptr56 = getelementptr inbounds i8, i8* %24, i32 1
  store i8* %incdec.ptr56, i8** %text.addr, align 8
  store i8 %conv55, i8* %24, align 1
  br label %if.end57

if.end57:                                         ; preds = %if.else36, %if.then20
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.then6
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then3
  %25 = load i8*, i8** %text.addr, align 8
  ret i8* %25
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrSetPostFX(%struct.Tigr* %bmp, i32 %hblur, i32 %vblur, float %scanlines, float %contrast) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %hblur.addr = alloca i32, align 4
  %vblur.addr = alloca i32, align 4
  %scanlines.addr = alloca float, align 4
  %contrast.addr = alloca float, align 4
  %win = alloca %struct.TigrInternal*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %hblur, i32* %hblur.addr, align 4
  store i32 %vblur, i32* %vblur.addr, align 4
  store float %scanlines, float* %scanlines.addr, align 4
  store float %contrast, float* %contrast.addr, align 4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load i32, i32* %hblur.addr, align 4
  %2 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %hblur1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %2, i32 0, i32 8
  store i32 %1, i32* %hblur1, align 4
  %3 = load i32, i32* %vblur.addr, align 4
  %4 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %vblur2 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %4, i32 0, i32 9
  store i32 %3, i32* %vblur2, align 8
  %5 = load float, float* %scanlines.addr, align 4
  %6 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scanlines3 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %6, i32 0, i32 10
  store float %5, float* %scanlines3, align 4
  %7 = load float, float* %contrast.addr, align 4
  %8 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %contrast4 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %8, i32 0, i32 11
  store float %7, float* %contrast4, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.TigrInternal* @tigrInternal(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %0, i32 0, i32 3
  %1 = load i8*, i8** %handle, align 8
  %tobool = icmp ne i8* %1, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool1 = icmp ne i64 %conv, 0
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.tigrInternal, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 2107, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.5, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %2
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %add.ptr = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i64 1
  %4 = bitcast %struct.Tigr* %add.ptr to %struct.TigrInternal*
  ret %struct.TigrInternal* %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrInflate(i8* %out, i32 %outlen, i8* %in, i32 %inlen) #0 {
entry:
  %retval = alloca i32, align 4
  %out.addr = alloca i8*, align 8
  %outlen.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 8
  %inlen.addr = alloca i32, align 4
  %last = alloca i32, align 4
  %s = alloca %struct.State*, align 8
  store i8* %out, i8** %out.addr, align 8
  store i32 %outlen, i32* %outlen.addr, align 4
  store i8* %in, i8** %in.addr, align 8
  store i32 %inlen, i32* %inlen.addr, align 4
  %call = call i8* @calloc(i64 1, i64 1560) #13
  %0 = bitcast i8* %call to %struct.State*
  store %struct.State* %0, %struct.State** %s, align 8
  %1 = load i8*, i8** %in.addr, align 8
  %2 = load %struct.State*, %struct.State** %s, align 8
  %in1 = getelementptr inbounds %struct.State, %struct.State* %2, i32 0, i32 2
  store i8* %1, i8** %in1, align 8
  %3 = load %struct.State*, %struct.State** %s, align 8
  %in2 = getelementptr inbounds %struct.State, %struct.State* %3, i32 0, i32 2
  %4 = load i8*, i8** %in2, align 8
  %5 = load i32, i32* %inlen.addr, align 4
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 2
  %6 = load %struct.State*, %struct.State** %s, align 8
  %inend = getelementptr inbounds %struct.State, %struct.State* %6, i32 0, i32 3
  store i8* %add.ptr3, i8** %inend, align 8
  %7 = load i8*, i8** %out.addr, align 8
  %8 = load %struct.State*, %struct.State** %s, align 8
  %out4 = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 4
  store i8* %7, i8** %out4, align 8
  %9 = load %struct.State*, %struct.State** %s, align 8
  %out5 = getelementptr inbounds %struct.State, %struct.State* %9, i32 0, i32 4
  %10 = load i8*, i8** %out5, align 8
  %11 = load i32, i32* %outlen.addr, align 4
  %idx.ext6 = zext i32 %11 to i64
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 %idx.ext6
  %12 = load %struct.State*, %struct.State** %s, align 8
  %outend = getelementptr inbounds %struct.State, %struct.State* %12, i32 0, i32 5
  store i8* %add.ptr7, i8** %outend, align 8
  %13 = load %struct.State*, %struct.State** %s, align 8
  %bits = getelementptr inbounds %struct.State, %struct.State* %13, i32 0, i32 0
  store i32 0, i32* %bits, align 8
  %14 = load %struct.State*, %struct.State** %s, align 8
  %count = getelementptr inbounds %struct.State, %struct.State* %14, i32 0, i32 1
  store i32 0, i32* %count, align 4
  %15 = load %struct.State*, %struct.State** %s, align 8
  %call8 = call i32 @bits(%struct.State* %15, i32 0)
  %16 = load %struct.State*, %struct.State** %s, align 8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %16, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  %call9 = call i32 @setjmp(i32* %arraydecay) #18
  %cmp = icmp eq i32 %call9, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load %struct.State*, %struct.State** %s, align 8
  %18 = bitcast %struct.State* %17 to i8*
  call void @free(i8* %18)
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %19 = load %struct.State*, %struct.State** %s, align 8
  %call10 = call i32 @bits(%struct.State* %19, i32 1)
  store i32 %call10, i32* %last, align 4
  %20 = load %struct.State*, %struct.State** %s, align 8
  %call11 = call i32 @bits(%struct.State* %20, i32 2)
  switch i32 %call11, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb12
    i32 2, label %sw.bb13
    i32 3, label %sw.bb14
  ]

sw.bb:                                            ; preds = %do.body
  %21 = load %struct.State*, %struct.State** %s, align 8
  call void @stored(%struct.State* %21)
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.body
  %22 = load %struct.State*, %struct.State** %s, align 8
  call void @fixed(%struct.State* %22)
  %23 = load %struct.State*, %struct.State** %s, align 8
  call void @block(%struct.State* %23)
  br label %sw.epilog

sw.bb13:                                          ; preds = %do.body
  %24 = load %struct.State*, %struct.State** %s, align 8
  call void @dynamic(%struct.State* %24)
  %25 = load %struct.State*, %struct.State** %s, align 8
  call void @block(%struct.State* %25)
  br label %sw.epilog

sw.bb14:                                          ; preds = %do.body
  %26 = load %struct.State*, %struct.State** %s, align 8
  %jmp15 = getelementptr inbounds %struct.State, %struct.State* %26, i32 0, i32 6
  %arraydecay16 = getelementptr inbounds [37 x i32], [37 x i32]* %jmp15, i32 0, i32 0
  call void @longjmp(i32* %arraydecay16, i32 1) #19
  unreachable

sw.epilog:                                        ; preds = %do.body, %sw.bb13, %sw.bb12, %sw.bb
  br label %do.cond

do.cond:                                          ; preds = %sw.epilog
  %27 = load i32, i32* %last, align 4
  %tobool = icmp ne i32 %27, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %28 = load %struct.State*, %struct.State** %s, align 8
  %29 = bitcast %struct.State* %28 to i8*
  call void @free(i8* %29)
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %do.end, %if.then
  %30 = load i32, i32* %retval, align 4
  ret i32 %30
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @bits(%struct.State* %s, i32 %n) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %n.addr = alloca i32, align 4
  %v = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.State*, %struct.State** %s.addr, align 8
  %bits = getelementptr inbounds %struct.State, %struct.State* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 8
  %2 = load i32, i32* %n.addr, align 4
  %shl = shl i32 1, %2
  %sub = sub nsw i32 %shl, 1
  %and = and i32 %1, %sub
  store i32 %and, i32* %v, align 4
  %3 = load i32, i32* %n.addr, align 4
  %4 = load %struct.State*, %struct.State** %s.addr, align 8
  %bits1 = getelementptr inbounds %struct.State, %struct.State* %4, i32 0, i32 0
  %5 = load i32, i32* %bits1, align 8
  %shr = lshr i32 %5, %3
  store i32 %shr, i32* %bits1, align 8
  %6 = load i32, i32* %n.addr, align 4
  %7 = load %struct.State*, %struct.State** %s.addr, align 8
  %count = getelementptr inbounds %struct.State, %struct.State* %7, i32 0, i32 1
  %8 = load i32, i32* %count, align 4
  %sub2 = sub i32 %8, %6
  store i32 %sub2, i32* %count, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %9 = load %struct.State*, %struct.State** %s.addr, align 8
  %count3 = getelementptr inbounds %struct.State, %struct.State* %9, i32 0, i32 1
  %10 = load i32, i32* %count3, align 4
  %cmp = icmp ult i32 %10, 16
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load %struct.State*, %struct.State** %s.addr, align 8
  %in = getelementptr inbounds %struct.State, %struct.State* %11, i32 0, i32 2
  %12 = load i8*, i8** %in, align 8
  %13 = load %struct.State*, %struct.State** %s.addr, align 8
  %inend = getelementptr inbounds %struct.State, %struct.State* %13, i32 0, i32 3
  %14 = load i8*, i8** %inend, align 8
  %cmp4 = icmp ne i8* %12, %14
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %15 = load %struct.State*, %struct.State** %s.addr, align 8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %15, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #19
  unreachable

if.end:                                           ; preds = %while.body
  %16 = load %struct.State*, %struct.State** %s.addr, align 8
  %in5 = getelementptr inbounds %struct.State, %struct.State* %16, i32 0, i32 2
  %17 = load i8*, i8** %in5, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %17, i32 1
  store i8* %incdec.ptr, i8** %in5, align 8
  %18 = load i8, i8* %17, align 1
  %conv = zext i8 %18 to i32
  %19 = load %struct.State*, %struct.State** %s.addr, align 8
  %count6 = getelementptr inbounds %struct.State, %struct.State* %19, i32 0, i32 1
  %20 = load i32, i32* %count6, align 4
  %shl7 = shl i32 %conv, %20
  %21 = load %struct.State*, %struct.State** %s.addr, align 8
  %bits8 = getelementptr inbounds %struct.State, %struct.State* %21, i32 0, i32 0
  %22 = load i32, i32* %bits8, align 8
  %or = or i32 %22, %shl7
  store i32 %or, i32* %bits8, align 8
  %23 = load %struct.State*, %struct.State** %s.addr, align 8
  %count9 = getelementptr inbounds %struct.State, %struct.State* %23, i32 0, i32 1
  %24 = load i32, i32* %count9, align 4
  %add = add i32 %24, 8
  store i32 %add, i32* %count9, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %25 = load i32, i32* %v, align 4
  ret i32 %25
}

; Function Attrs: returns_twice
declare i32 @setjmp(i32*) #8

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @stored(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %len = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  %0 = load %struct.State*, %struct.State** %s.addr, align 8
  %1 = load %struct.State*, %struct.State** %s.addr, align 8
  %count = getelementptr inbounds %struct.State, %struct.State* %1, i32 0, i32 1
  %2 = load i32, i32* %count, align 4
  %and = and i32 %2, 7
  %call = call i32 @bits(%struct.State* %0, i32 %and)
  %3 = load %struct.State*, %struct.State** %s.addr, align 8
  %call1 = call i32 @bits(%struct.State* %3, i32 16)
  store i32 %call1, i32* %len, align 4
  %4 = load i32, i32* %len, align 4
  %5 = load %struct.State*, %struct.State** %s.addr, align 8
  %bits = getelementptr inbounds %struct.State, %struct.State* %5, i32 0, i32 0
  %6 = load i32, i32* %bits, align 8
  %xor = xor i32 %4, %6
  %and2 = and i32 %xor, 65535
  %cmp = icmp eq i32 %and2, 65535
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.State*, %struct.State** %s.addr, align 8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %7, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #19
  unreachable

if.end:                                           ; preds = %entry
  %8 = load %struct.State*, %struct.State** %s.addr, align 8
  %in = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 2
  %9 = load i8*, i8** %in, align 8
  %10 = load i32, i32* %len, align 4
  %idx.ext = sext i32 %10 to i64
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 %idx.ext
  %11 = load %struct.State*, %struct.State** %s.addr, align 8
  %inend = getelementptr inbounds %struct.State, %struct.State* %11, i32 0, i32 3
  %12 = load i8*, i8** %inend, align 8
  %cmp3 = icmp ule i8* %add.ptr, %12
  br i1 %cmp3, label %if.end7, label %if.then4

if.then4:                                         ; preds = %if.end
  %13 = load %struct.State*, %struct.State** %s.addr, align 8
  %jmp5 = getelementptr inbounds %struct.State, %struct.State* %13, i32 0, i32 6
  %arraydecay6 = getelementptr inbounds [37 x i32], [37 x i32]* %jmp5, i32 0, i32 0
  call void @longjmp(i32* %arraydecay6, i32 1) #19
  unreachable

if.end7:                                          ; preds = %if.end
  %14 = load %struct.State*, %struct.State** %s.addr, align 8
  %15 = load %struct.State*, %struct.State** %s.addr, align 8
  %in8 = getelementptr inbounds %struct.State, %struct.State* %15, i32 0, i32 2
  %16 = load i8*, i8** %in8, align 8
  %17 = load i32, i32* %len, align 4
  call void @copy(%struct.State* %14, i8* %16, i32 %17)
  %18 = load i32, i32* %len, align 4
  %19 = load %struct.State*, %struct.State** %s.addr, align 8
  %in9 = getelementptr inbounds %struct.State, %struct.State* %19, i32 0, i32 2
  %20 = load i8*, i8** %in9, align 8
  %idx.ext10 = sext i32 %18 to i64
  %add.ptr11 = getelementptr inbounds i8, i8* %20, i64 %idx.ext10
  store i8* %add.ptr11, i8** %in9, align 8
  %21 = load %struct.State*, %struct.State** %s.addr, align 8
  %call12 = call i32 @bits(%struct.State* %21, i32 16)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @fixed(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %n = alloca i32, align 4
  %lens = alloca [320 x i8], align 16
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %n, align 4
  %cmp = icmp sle i32 %0, 143
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %n, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom
  store i8 8, i8* %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %n, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 144, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc6, %for.end
  %3 = load i32, i32* %n, align 4
  %cmp2 = icmp sle i32 %3, 255
  br i1 %cmp2, label %for.body3, label %for.end8

for.body3:                                        ; preds = %for.cond1
  %4 = load i32, i32* %n, align 4
  %idxprom4 = sext i32 %4 to i64
  %arrayidx5 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom4
  store i8 9, i8* %arrayidx5, align 1
  br label %for.inc6

for.inc6:                                         ; preds = %for.body3
  %5 = load i32, i32* %n, align 4
  %inc7 = add nsw i32 %5, 1
  store i32 %inc7, i32* %n, align 4
  br label %for.cond1

for.end8:                                         ; preds = %for.cond1
  store i32 256, i32* %n, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc14, %for.end8
  %6 = load i32, i32* %n, align 4
  %cmp10 = icmp sle i32 %6, 279
  br i1 %cmp10, label %for.body11, label %for.end16

for.body11:                                       ; preds = %for.cond9
  %7 = load i32, i32* %n, align 4
  %idxprom12 = sext i32 %7 to i64
  %arrayidx13 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom12
  store i8 7, i8* %arrayidx13, align 1
  br label %for.inc14

for.inc14:                                        ; preds = %for.body11
  %8 = load i32, i32* %n, align 4
  %inc15 = add nsw i32 %8, 1
  store i32 %inc15, i32* %n, align 4
  br label %for.cond9

for.end16:                                        ; preds = %for.cond9
  store i32 280, i32* %n, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc22, %for.end16
  %9 = load i32, i32* %n, align 4
  %cmp18 = icmp sle i32 %9, 287
  br i1 %cmp18, label %for.body19, label %for.end24

for.body19:                                       ; preds = %for.cond17
  %10 = load i32, i32* %n, align 4
  %idxprom20 = sext i32 %10 to i64
  %arrayidx21 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom20
  store i8 8, i8* %arrayidx21, align 1
  br label %for.inc22

for.inc22:                                        ; preds = %for.body19
  %11 = load i32, i32* %n, align 4
  %inc23 = add nsw i32 %11, 1
  store i32 %inc23, i32* %n, align 4
  br label %for.cond17

for.end24:                                        ; preds = %for.cond17
  store i32 0, i32* %n, align 4
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc30, %for.end24
  %12 = load i32, i32* %n, align 4
  %cmp26 = icmp slt i32 %12, 32
  br i1 %cmp26, label %for.body27, label %for.end32

for.body27:                                       ; preds = %for.cond25
  %13 = load i32, i32* %n, align 4
  %add = add nsw i32 288, %13
  %idxprom28 = sext i32 %add to i64
  %arrayidx29 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom28
  store i8 5, i8* %arrayidx29, align 1
  br label %for.inc30

for.inc30:                                        ; preds = %for.body27
  %14 = load i32, i32* %n, align 4
  %inc31 = add nsw i32 %14, 1
  store i32 %inc31, i32* %n, align 4
  br label %for.cond25

for.end32:                                        ; preds = %for.cond25
  %15 = load %struct.State*, %struct.State** %s.addr, align 8
  %16 = load %struct.State*, %struct.State** %s.addr, align 8
  %litcodes = getelementptr inbounds %struct.State, %struct.State* %16, i32 0, i32 7
  %arraydecay = getelementptr inbounds [288 x i32], [288 x i32]* %litcodes, i32 0, i32 0
  %arraydecay33 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %call = call i32 @build(%struct.State* %15, i32* %arraydecay, i8* %arraydecay33, i32 288)
  %17 = load %struct.State*, %struct.State** %s.addr, align 8
  %tlit = getelementptr inbounds %struct.State, %struct.State* %17, i32 0, i32 10
  store i32 %call, i32* %tlit, align 8
  %18 = load %struct.State*, %struct.State** %s.addr, align 8
  %19 = load %struct.State*, %struct.State** %s.addr, align 8
  %distcodes = getelementptr inbounds %struct.State, %struct.State* %19, i32 0, i32 8
  %arraydecay34 = getelementptr inbounds [32 x i32], [32 x i32]* %distcodes, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay35, i64 288
  %call36 = call i32 @build(%struct.State* %18, i32* %arraydecay34, i8* %add.ptr, i32 32)
  %20 = load %struct.State*, %struct.State** %s.addr, align 8
  %tdist = getelementptr inbounds %struct.State, %struct.State* %20, i32 0, i32 11
  store i32 %call36, i32* %tdist, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @block(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %sym = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end6, %entry
  %0 = load %struct.State*, %struct.State** %s.addr, align 8
  %1 = load %struct.State*, %struct.State** %s.addr, align 8
  %litcodes = getelementptr inbounds %struct.State, %struct.State* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [288 x i32], [288 x i32]* %litcodes, i32 0, i32 0
  %2 = load %struct.State*, %struct.State** %s.addr, align 8
  %tlit = getelementptr inbounds %struct.State, %struct.State* %2, i32 0, i32 10
  %3 = load i32, i32* %tlit, align 8
  %call = call i32 @decode(%struct.State* %0, i32* %arraydecay, i32 %3)
  store i32 %call, i32* %sym, align 4
  %4 = load i32, i32* %sym, align 4
  %cmp = icmp slt i32 %4, 256
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.cond
  %5 = load i32, i32* %sym, align 4
  %conv = trunc i32 %5 to i8
  %6 = load %struct.State*, %struct.State** %s.addr, align 8
  %call1 = call i8* @emit(%struct.State* %6, i32 1)
  store i8 %conv, i8* %call1, align 1
  br label %if.end6

if.else:                                          ; preds = %for.cond
  %7 = load i32, i32* %sym, align 4
  %cmp2 = icmp sgt i32 %7, 256
  br i1 %cmp2, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  %8 = load %struct.State*, %struct.State** %s.addr, align 8
  %9 = load i32, i32* %sym, align 4
  %sub = sub nsw i32 %9, 257
  call void @run(%struct.State* %8, i32 %sub)
  br label %if.end

if.else5:                                         ; preds = %if.else
  br label %for.end

if.end:                                           ; preds = %if.then4
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  br label %for.cond

for.end:                                          ; preds = %if.else5
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @dynamic(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %nlit = alloca i32, align 4
  %ndist = alloca i32, align 4
  %nlen = alloca i32, align 4
  %lenlens = alloca [19 x i8], align 16
  %lens = alloca [320 x i8], align 16
  %sym = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  %0 = bitcast [19 x i8]* %lenlens to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %0, i8 0, i64 19, i1 false)
  %1 = load %struct.State*, %struct.State** %s.addr, align 8
  %call = call i32 @bits(%struct.State* %1, i32 5)
  %add = add nsw i32 257, %call
  store i32 %add, i32* %nlit, align 4
  %2 = load %struct.State*, %struct.State** %s.addr, align 8
  %call1 = call i32 @bits(%struct.State* %2, i32 5)
  %add2 = add nsw i32 1, %call1
  store i32 %add2, i32* %ndist, align 4
  %3 = load %struct.State*, %struct.State** %s.addr, align 8
  %call3 = call i32 @bits(%struct.State* %3, i32 4)
  %add4 = add nsw i32 4, %call3
  store i32 %add4, i32* %nlen, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, i32* %n, align 4
  %5 = load i32, i32* %nlen, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.State*, %struct.State** %s.addr, align 8
  %call5 = call i32 @bits(%struct.State* %6, i32 3)
  %conv = trunc i32 %call5 to i8
  %7 = load i32, i32* %n, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds [19 x i8], [19 x i8]* @order, i64 0, i64 %idxprom
  %8 = load i8, i8* %arrayidx, align 1
  %idxprom6 = sext i8 %8 to i64
  %arrayidx7 = getelementptr inbounds [19 x i8], [19 x i8]* %lenlens, i64 0, i64 %idxprom6
  store i8 %conv, i8* %arrayidx7, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load %struct.State*, %struct.State** %s.addr, align 8
  %11 = load %struct.State*, %struct.State** %s.addr, align 8
  %lencodes = getelementptr inbounds %struct.State, %struct.State* %11, i32 0, i32 9
  %arraydecay = getelementptr inbounds [19 x i32], [19 x i32]* %lencodes, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [19 x i8], [19 x i8]* %lenlens, i32 0, i32 0
  %call9 = call i32 @build(%struct.State* %10, i32* %arraydecay, i8* %arraydecay8, i32 19)
  %12 = load %struct.State*, %struct.State** %s.addr, align 8
  %tlen = getelementptr inbounds %struct.State, %struct.State* %12, i32 0, i32 12
  store i32 %call9, i32* %tlen, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %sw.epilog, %for.end
  %13 = load i32, i32* %n, align 4
  %14 = load i32, i32* %nlit, align 4
  %15 = load i32, i32* %ndist, align 4
  %add11 = add nsw i32 %14, %15
  %cmp12 = icmp slt i32 %13, %add11
  br i1 %cmp12, label %for.body14, label %for.end58

for.body14:                                       ; preds = %for.cond10
  %16 = load %struct.State*, %struct.State** %s.addr, align 8
  %17 = load %struct.State*, %struct.State** %s.addr, align 8
  %lencodes15 = getelementptr inbounds %struct.State, %struct.State* %17, i32 0, i32 9
  %arraydecay16 = getelementptr inbounds [19 x i32], [19 x i32]* %lencodes15, i32 0, i32 0
  %18 = load %struct.State*, %struct.State** %s.addr, align 8
  %tlen17 = getelementptr inbounds %struct.State, %struct.State* %18, i32 0, i32 12
  %19 = load i32, i32* %tlen17, align 8
  %call18 = call i32 @decode(%struct.State* %16, i32* %arraydecay16, i32 %19)
  store i32 %call18, i32* %sym, align 4
  %20 = load i32, i32* %sym, align 4
  switch i32 %20, label %sw.default [
    i32 16, label %sw.bb
    i32 17, label %sw.bb30
    i32 18, label %sw.bb42
  ]

sw.bb:                                            ; preds = %for.body14
  %21 = load %struct.State*, %struct.State** %s.addr, align 8
  %call19 = call i32 @bits(%struct.State* %21, i32 2)
  %add20 = add nsw i32 3, %call19
  store i32 %add20, i32* %i, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc27, %sw.bb
  %22 = load i32, i32* %i, align 4
  %tobool = icmp ne i32 %22, 0
  br i1 %tobool, label %for.body22, label %for.end29

for.body22:                                       ; preds = %for.cond21
  %23 = load i32, i32* %n, align 4
  %sub = sub nsw i32 %23, 1
  %idxprom23 = sext i32 %sub to i64
  %arrayidx24 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom23
  %24 = load i8, i8* %arrayidx24, align 1
  %25 = load i32, i32* %n, align 4
  %idxprom25 = sext i32 %25 to i64
  %arrayidx26 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom25
  store i8 %24, i8* %arrayidx26, align 1
  br label %for.inc27

for.inc27:                                        ; preds = %for.body22
  %26 = load i32, i32* %i, align 4
  %dec = add nsw i32 %26, -1
  store i32 %dec, i32* %i, align 4
  %27 = load i32, i32* %n, align 4
  %inc28 = add nsw i32 %27, 1
  store i32 %inc28, i32* %n, align 4
  br label %for.cond21

for.end29:                                        ; preds = %for.cond21
  br label %sw.epilog

sw.bb30:                                          ; preds = %for.body14
  %28 = load %struct.State*, %struct.State** %s.addr, align 8
  %call31 = call i32 @bits(%struct.State* %28, i32 3)
  %add32 = add nsw i32 3, %call31
  store i32 %add32, i32* %i, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc38, %sw.bb30
  %29 = load i32, i32* %i, align 4
  %tobool34 = icmp ne i32 %29, 0
  br i1 %tobool34, label %for.body35, label %for.end41

for.body35:                                       ; preds = %for.cond33
  %30 = load i32, i32* %n, align 4
  %idxprom36 = sext i32 %30 to i64
  %arrayidx37 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom36
  store i8 0, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body35
  %31 = load i32, i32* %i, align 4
  %dec39 = add nsw i32 %31, -1
  store i32 %dec39, i32* %i, align 4
  %32 = load i32, i32* %n, align 4
  %inc40 = add nsw i32 %32, 1
  store i32 %inc40, i32* %n, align 4
  br label %for.cond33

for.end41:                                        ; preds = %for.cond33
  br label %sw.epilog

sw.bb42:                                          ; preds = %for.body14
  %33 = load %struct.State*, %struct.State** %s.addr, align 8
  %call43 = call i32 @bits(%struct.State* %33, i32 7)
  %add44 = add nsw i32 11, %call43
  store i32 %add44, i32* %i, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc50, %sw.bb42
  %34 = load i32, i32* %i, align 4
  %tobool46 = icmp ne i32 %34, 0
  br i1 %tobool46, label %for.body47, label %for.end53

for.body47:                                       ; preds = %for.cond45
  %35 = load i32, i32* %n, align 4
  %idxprom48 = sext i32 %35 to i64
  %arrayidx49 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom48
  store i8 0, i8* %arrayidx49, align 1
  br label %for.inc50

for.inc50:                                        ; preds = %for.body47
  %36 = load i32, i32* %i, align 4
  %dec51 = add nsw i32 %36, -1
  store i32 %dec51, i32* %i, align 4
  %37 = load i32, i32* %n, align 4
  %inc52 = add nsw i32 %37, 1
  store i32 %inc52, i32* %n, align 4
  br label %for.cond45

for.end53:                                        ; preds = %for.cond45
  br label %sw.epilog

sw.default:                                       ; preds = %for.body14
  %38 = load i32, i32* %sym, align 4
  %conv54 = trunc i32 %38 to i8
  %39 = load i32, i32* %n, align 4
  %inc55 = add nsw i32 %39, 1
  store i32 %inc55, i32* %n, align 4
  %idxprom56 = sext i32 %39 to i64
  %arrayidx57 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom56
  store i8 %conv54, i8* %arrayidx57, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %for.end53, %for.end41, %for.end29
  br label %for.cond10

for.end58:                                        ; preds = %for.cond10
  %40 = load %struct.State*, %struct.State** %s.addr, align 8
  %41 = load %struct.State*, %struct.State** %s.addr, align 8
  %litcodes = getelementptr inbounds %struct.State, %struct.State* %41, i32 0, i32 7
  %arraydecay59 = getelementptr inbounds [288 x i32], [288 x i32]* %litcodes, i32 0, i32 0
  %arraydecay60 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %42 = load i32, i32* %nlit, align 4
  %call61 = call i32 @build(%struct.State* %40, i32* %arraydecay59, i8* %arraydecay60, i32 %42)
  %43 = load %struct.State*, %struct.State** %s.addr, align 8
  %tlit = getelementptr inbounds %struct.State, %struct.State* %43, i32 0, i32 10
  store i32 %call61, i32* %tlit, align 8
  %44 = load %struct.State*, %struct.State** %s.addr, align 8
  %45 = load %struct.State*, %struct.State** %s.addr, align 8
  %distcodes = getelementptr inbounds %struct.State, %struct.State* %45, i32 0, i32 8
  %arraydecay62 = getelementptr inbounds [32 x i32], [32 x i32]* %distcodes, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %46 = load i32, i32* %nlit, align 4
  %idx.ext = sext i32 %46 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay63, i64 %idx.ext
  %47 = load i32, i32* %ndist, align 4
  %call64 = call i32 @build(%struct.State* %44, i32* %arraydecay62, i8* %add.ptr, i32 %47)
  %48 = load %struct.State*, %struct.State** %s.addr, align 8
  %tdist = getelementptr inbounds %struct.State, %struct.State* %48, i32 0, i32 11
  store i32 %call64, i32* %tdist, align 4
  ret void
}

; Function Attrs: noreturn
declare void @longjmp(i32*, i32) #9

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrLoadGlyphs(%struct.TigrFont* %font, i32 %codepage) #0 {
entry:
  %retval = alloca i32, align 4
  %font.addr = alloca %struct.TigrFont*, align 8
  %codepage.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %w = alloca i32, align 4
  %h = alloca i32, align 4
  %rowh = alloca i32, align 4
  %g = alloca %struct.TigrGlyph*, align 8
  %j = alloca i32, align 4
  %g61 = alloca %struct.TigrGlyph, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  store i32 %codepage, i32* %codepage.addr, align 4
  store i32 0, i32* %x, align 4
  store i32 0, i32* %y, align 4
  store i32 1, i32* %rowh, align 4
  %0 = load i32, i32* %codepage.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1252, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %numGlyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %1, i32 0, i32 1
  store i32 96, i32* %numGlyphs, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %2 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %numGlyphs2 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 1
  store i32 224, i32* %numGlyphs2, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %sw.bb1, %sw.bb
  %3 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %numGlyphs3 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %3, i32 0, i32 1
  %4 = load i32, i32* %numGlyphs3, align 8
  %conv = sext i32 %4 to i64
  %call = call i8* @calloc(i64 %conv, i64 20) #13
  %5 = bitcast i8* %call to %struct.TigrGlyph*
  %6 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %6, i32 0, i32 2
  store %struct.TigrGlyph* %5, %struct.TigrGlyph** %glyphs, align 8
  store i32 32, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %7 = load i32, i32* %i, align 4
  %8 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %numGlyphs4 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %8, i32 0, i32 1
  %9 = load i32, i32* %numGlyphs4, align 8
  %add = add nsw i32 %9, 32
  %cmp = icmp slt i32 %7, %add
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %10, i32 0, i32 0
  %11 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8
  call void @scan(%struct.Tigr* %11, i32* %x, i32* %y, i32* %rowh)
  %12 = load i32, i32* %y, align 4
  %13 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %bitmap6 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %13, i32 0, i32 0
  %14 = load %struct.Tigr*, %struct.Tigr** %bitmap6, align 8
  %h7 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %14, i32 0, i32 1
  %15 = load i32, i32* %h7, align 4
  %cmp8 = icmp sge i32 %12, %15
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call10 = call i32* @__error()
  store i32 22, i32* %call10, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  store i32 0, i32* %h, align 4
  store i32 0, i32* %w, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %16 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %bitmap11 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %16, i32 0, i32 0
  %17 = load %struct.Tigr*, %struct.Tigr** %bitmap11, align 8
  %18 = load i32, i32* %x, align 4
  %19 = load i32, i32* %w, align 4
  %add12 = add nsw i32 %18, %19
  %20 = load i32, i32* %y, align 4
  %call13 = call i32 @border(%struct.Tigr* %17, i32 %add12, i32 %20)
  %tobool = icmp ne i32 %call13, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load i32, i32* %w, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %w, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond14

while.cond14:                                     ; preds = %while.body20, %while.end
  %22 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %bitmap15 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %22, i32 0, i32 0
  %23 = load %struct.Tigr*, %struct.Tigr** %bitmap15, align 8
  %24 = load i32, i32* %x, align 4
  %25 = load i32, i32* %y, align 4
  %26 = load i32, i32* %h, align 4
  %add16 = add nsw i32 %25, %26
  %call17 = call i32 @border(%struct.Tigr* %23, i32 %24, i32 %add16)
  %tobool18 = icmp ne i32 %call17, 0
  %lnot19 = xor i1 %tobool18, true
  br i1 %lnot19, label %while.body20, label %while.end22

while.body20:                                     ; preds = %while.cond14
  %27 = load i32, i32* %h, align 4
  %inc21 = add nsw i32 %27, 1
  store i32 %inc21, i32* %h, align 4
  br label %while.cond14

while.end22:                                      ; preds = %while.cond14
  %28 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs23 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %28, i32 0, i32 2
  %29 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs23, align 8
  %30 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %30, 32
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %29, i64 %idxprom
  store %struct.TigrGlyph* %arrayidx, %struct.TigrGlyph** %g, align 8
  %31 = load i32, i32* %i, align 4
  %cmp24 = icmp slt i32 %31, 128
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %while.end22
  %32 = load i32, i32* %i, align 4
  %33 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %code = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %33, i32 0, i32 0
  store i32 %32, i32* %code, align 4
  br label %if.end37

if.else:                                          ; preds = %while.end22
  %34 = load i32, i32* %codepage.addr, align 4
  %cmp27 = icmp eq i32 %34, 1252
  br i1 %cmp27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %if.else
  %35 = load i32, i32* %i, align 4
  %sub30 = sub nsw i32 %35, 128
  %idxprom31 = sext i32 %sub30 to i64
  %arrayidx32 = getelementptr inbounds [128 x i32], [128 x i32]* @cp1252, i64 0, i64 %idxprom31
  %36 = load i32, i32* %arrayidx32, align 4
  %37 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %code33 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %37, i32 0, i32 0
  store i32 %36, i32* %code33, align 4
  br label %if.end36

if.else34:                                        ; preds = %if.else
  %call35 = call i32* @__error()
  store i32 22, i32* %call35, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then26
  %38 = load i32, i32* %x, align 4
  %39 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %x38 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %39, i32 0, i32 1
  store i32 %38, i32* %x38, align 4
  %40 = load i32, i32* %y, align 4
  %41 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %y39 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %41, i32 0, i32 2
  store i32 %40, i32* %y39, align 4
  %42 = load i32, i32* %w, align 4
  %43 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %w40 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %43, i32 0, i32 3
  store i32 %42, i32* %w40, align 4
  %44 = load i32, i32* %h, align 4
  %45 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %h41 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %45, i32 0, i32 4
  store i32 %44, i32* %h41, align 4
  %46 = load i32, i32* %w, align 4
  %47 = load i32, i32* %x, align 4
  %add42 = add nsw i32 %47, %46
  store i32 %add42, i32* %x, align 4
  %48 = load i32, i32* %h, align 4
  %49 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs43 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %49, i32 0, i32 2
  %50 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs43, align 8
  %arrayidx44 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %50, i64 0
  %h45 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx44, i32 0, i32 4
  %51 = load i32, i32* %h45, align 4
  %cmp46 = icmp ne i32 %48, %51
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end37
  %call49 = call i32* @__error()
  store i32 22, i32* %call49, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end50:                                         ; preds = %if.end37
  %52 = load i32, i32* %h, align 4
  %53 = load i32, i32* %rowh, align 4
  %cmp51 = icmp sgt i32 %52, %53
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end50
  %54 = load i32, i32* %h, align 4
  store i32 %54, i32* %rowh, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.end50
  br label %for.inc

for.inc:                                          ; preds = %if.end54
  %55 = load i32, i32* %i, align 4
  %inc55 = add nsw i32 %55, 1
  store i32 %inc55, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %i, align 4
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc88, %for.end
  %56 = load i32, i32* %i, align 4
  %57 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %numGlyphs57 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %57, i32 0, i32 1
  %58 = load i32, i32* %numGlyphs57, align 8
  %cmp58 = icmp slt i32 %56, %58
  br i1 %cmp58, label %for.body60, label %for.end90

for.body60:                                       ; preds = %for.cond56
  %59 = load i32, i32* %i, align 4
  store i32 %59, i32* %j, align 4
  %60 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs62 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %60, i32 0, i32 2
  %61 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs62, align 8
  %62 = load i32, i32* %i, align 4
  %idxprom63 = sext i32 %62 to i64
  %arrayidx64 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %61, i64 %idxprom63
  %63 = bitcast %struct.TigrGlyph* %g61 to i8*
  %64 = bitcast %struct.TigrGlyph* %arrayidx64 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %63, i8* align 4 %64, i64 20, i1 false)
  br label %while.cond65

while.cond65:                                     ; preds = %while.body76, %for.body60
  %65 = load i32, i32* %j, align 4
  %cmp66 = icmp sgt i32 %65, 0
  br i1 %cmp66, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond65
  %66 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs68 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %66, i32 0, i32 2
  %67 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs68, align 8
  %68 = load i32, i32* %j, align 4
  %sub69 = sub nsw i32 %68, 1
  %idxprom70 = sext i32 %sub69 to i64
  %arrayidx71 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %67, i64 %idxprom70
  %code72 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx71, i32 0, i32 0
  %69 = load i32, i32* %code72, align 4
  %code73 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %g61, i32 0, i32 0
  %70 = load i32, i32* %code73, align 4
  %cmp74 = icmp sgt i32 %69, %70
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond65
  %71 = phi i1 [ false, %while.cond65 ], [ %cmp74, %land.rhs ]
  br i1 %71, label %while.body76, label %while.end84

while.body76:                                     ; preds = %land.end
  %72 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs77 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %72, i32 0, i32 2
  %73 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs77, align 8
  %74 = load i32, i32* %j, align 4
  %idxprom78 = sext i32 %74 to i64
  %arrayidx79 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %73, i64 %idxprom78
  %75 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs80 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %75, i32 0, i32 2
  %76 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs80, align 8
  %77 = load i32, i32* %j, align 4
  %sub81 = sub nsw i32 %77, 1
  %idxprom82 = sext i32 %sub81 to i64
  %arrayidx83 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %76, i64 %idxprom82
  %78 = bitcast %struct.TigrGlyph* %arrayidx79 to i8*
  %79 = bitcast %struct.TigrGlyph* %arrayidx83 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %78, i8* align 4 %79, i64 20, i1 false)
  %80 = load i32, i32* %j, align 4
  %dec = add nsw i32 %80, -1
  store i32 %dec, i32* %j, align 4
  br label %while.cond65

while.end84:                                      ; preds = %land.end
  %81 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs85 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %81, i32 0, i32 2
  %82 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs85, align 8
  %83 = load i32, i32* %j, align 4
  %idxprom86 = sext i32 %83 to i64
  %arrayidx87 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %82, i64 %idxprom86
  %84 = bitcast %struct.TigrGlyph* %arrayidx87 to i8*
  %85 = bitcast %struct.TigrGlyph* %g61 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %84, i8* align 4 %85, i64 20, i1 false)
  br label %for.inc88

for.inc88:                                        ; preds = %while.end84
  %86 = load i32, i32* %i, align 4
  %inc89 = add nsw i32 %86, 1
  store i32 %inc89, i32* %i, align 4
  br label %for.cond56

for.end90:                                        ; preds = %for.cond56
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end90, %if.then48, %if.else34, %if.then
  %87 = load i32, i32* %retval, align 4
  ret i32 %87
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @scan(%struct.Tigr* %bmp, i32* %x, i32* %y, i32* %rowh) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32*, align 8
  %y.addr = alloca i32*, align 8
  %rowh.addr = alloca i32*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32* %x, i32** %x.addr, align 8
  store i32* %y, i32** %y.addr, align 8
  store i32* %rowh, i32** %rowh.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end3, %entry
  %0 = load i32*, i32** %y.addr, align 8
  %1 = load i32, i32* %0, align 4
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %2, i32 0, i32 1
  %3 = load i32, i32* %h, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i32*, i32** %x.addr, align 8
  %5 = load i32, i32* %4, align 4
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 0
  %7 = load i32, i32* %w, align 8
  %cmp1 = icmp sge i32 %5, %7
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %8 = load i32*, i32** %x.addr, align 8
  store i32 0, i32* %8, align 4
  %9 = load i32*, i32** %rowh.addr, align 8
  %10 = load i32, i32* %9, align 4
  %11 = load i32*, i32** %y.addr, align 8
  %12 = load i32, i32* %11, align 4
  %add = add nsw i32 %12, %10
  store i32 %add, i32* %11, align 4
  %13 = load i32*, i32** %rowh.addr, align 8
  store i32 1, i32* %13, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %14 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %15 = load i32*, i32** %x.addr, align 8
  %16 = load i32, i32* %15, align 4
  %17 = load i32*, i32** %y.addr, align 8
  %18 = load i32, i32* %17, align 4
  %call = call i32 @border(%struct.Tigr* %14, i32 %16, i32 %18)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %while.end

if.end3:                                          ; preds = %if.end
  %19 = load i32*, i32** %x.addr, align 8
  %20 = load i32, i32* %19, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, i32* %19, align 4
  br label %while.cond

while.end:                                        ; preds = %if.then2, %while.cond
  ret void
}

declare i32* @__error() #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @border(%struct.Tigr* %bmp, i32 %x, i32 %y) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %top = alloca %struct.TPixel, align 1
  %c = alloca %struct.TPixel, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call i32 @tigrGet(%struct.Tigr* %0, i32 0, i32 0)
  %1 = bitcast %struct.TPixel* %top to i32*
  store i32 %call, i32* %1, align 1
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %3 = load i32, i32* %x.addr, align 4
  %4 = load i32, i32* %y.addr, align 4
  %call1 = call i32 @tigrGet(%struct.Tigr* %2, i32 %3, i32 %4)
  %5 = bitcast %struct.TPixel* %c to i32*
  store i32 %call1, i32* %5, align 1
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %c, i32 0, i32 2
  %6 = load i8, i8* %r, align 1
  %conv = zext i8 %6 to i32
  %r2 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %top, i32 0, i32 2
  %7 = load i8, i8* %r2, align 1
  %conv3 = zext i8 %7 to i32
  %cmp = icmp eq i32 %conv, %conv3
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %c, i32 0, i32 1
  %8 = load i8, i8* %g, align 1
  %conv5 = zext i8 %8 to i32
  %g6 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %top, i32 0, i32 1
  %9 = load i8, i8* %g6, align 1
  %conv7 = zext i8 %9 to i32
  %cmp8 = icmp eq i32 %conv5, %conv7
  br i1 %cmp8, label %land.lhs.true10, label %lor.lhs.false

land.lhs.true10:                                  ; preds = %land.lhs.true
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %c, i32 0, i32 0
  %10 = load i8, i8* %b, align 1
  %conv11 = zext i8 %10 to i32
  %b12 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %top, i32 0, i32 0
  %11 = load i8, i8* %b12, align 1
  %conv13 = zext i8 %11 to i32
  %cmp14 = icmp eq i32 %conv11, %conv13
  br i1 %cmp14, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true10, %land.lhs.true, %entry
  %12 = load i32, i32* %x.addr, align 4
  %13 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %13, i32 0, i32 0
  %14 = load i32, i32* %w, align 8
  %cmp16 = icmp sge i32 %12, %14
  br i1 %cmp16, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %15 = load i32, i32* %y.addr, align 4
  %16 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %16, i32 0, i32 1
  %17 = load i32, i32* %h, align 4
  %cmp18 = icmp sge i32 %15, %17
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %land.lhs.true10
  %18 = phi i1 [ true, %lor.lhs.false ], [ true, %land.lhs.true10 ], [ %cmp18, %lor.rhs ]
  %lor.ext = zext i1 %18 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.TigrFont* @tigrLoadFont(%struct.Tigr* %bitmap, i32 %codepage) #0 {
entry:
  %retval = alloca %struct.TigrFont*, align 8
  %bitmap.addr = alloca %struct.Tigr*, align 8
  %codepage.addr = alloca i32, align 4
  %font = alloca %struct.TigrFont*, align 8
  store %struct.Tigr* %bitmap, %struct.Tigr** %bitmap.addr, align 8
  store i32 %codepage, i32* %codepage.addr, align 4
  %call = call i8* @calloc(i64 1, i64 24) #13
  %0 = bitcast i8* %call to %struct.TigrFont*
  store %struct.TigrFont* %0, %struct.TigrFont** %font, align 8
  %1 = load %struct.Tigr*, %struct.Tigr** %bitmap.addr, align 8
  %2 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8
  %bitmap1 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 0
  store %struct.Tigr* %1, %struct.Tigr** %bitmap1, align 8
  %3 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8
  %4 = load i32, i32* %codepage.addr, align 4
  %call2 = call i32 @tigrLoadGlyphs(%struct.TigrFont* %3, i32 %4)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8
  call void @tigrFreeFont(%struct.TigrFont* %5)
  store %struct.TigrFont* null, %struct.TigrFont** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8
  store %struct.TigrFont* %6, %struct.TigrFont** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load %struct.TigrFont*, %struct.TigrFont** %retval, align 8
  ret %struct.TigrFont* %7
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrFreeFont(%struct.TigrFont* %font) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %0, i32 0, i32 0
  %1 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8
  call void @tigrFree(%struct.Tigr* %1)
  %2 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 2
  %3 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs, align 8
  %4 = bitcast %struct.TigrGlyph* %3 to i8*
  call void @free(i8* %4)
  %5 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %6 = bitcast %struct.TigrFont* %5 to i8*
  call void @free(i8* %6)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrFree(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %window = alloca %struct.objc_object*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %0, i32 0, i32 3
  %1 = load i8*, i8** %handle, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %2)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %glContext = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %3, i32 0, i32 3
  %4 = load i8*, i8** %glContext, align 8
  %5 = bitcast i8* %4 to %struct.objc_object*
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %5, %struct.objc_selector* %call1)
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  call void @tigrGAPIEnd(%struct.Tigr* %6)
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  call void @tigrGAPIDestroy(%struct.Tigr* %7)
  %8 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgets = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %8, i32 0, i32 4
  %9 = load %struct.Tigr*, %struct.Tigr** %widgets, align 8
  call void @tigrFree(%struct.Tigr* %9)
  %10 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle2 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %10, i32 0, i32 3
  %11 = load i8*, i8** %handle2, align 8
  %12 = bitcast i8* %11 to %struct.objc_object*
  store %struct.objc_object* %12, %struct.objc_object** %window, align 8
  %13 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call3 = call zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %13)
  br i1 %call3, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %14 = load i8, i8* @terminated, align 1
  %tobool4 = trunc i8 %14 to i1
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %15 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call6 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.71, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %15, %struct.objc_selector* %call6)
  br label %if.end

if.end:                                           ; preds = %if.then5, %land.lhs.true, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %16 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %16, i32 0, i32 2
  %17 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %18 = bitcast %struct.TPixel* %17 to i8*
  call void @free(i8* %18)
  %19 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %20 = bitcast %struct.Tigr* %19 to i8*
  call void @free(i8* %20)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrSetupFont(%struct.TigrFont* %font) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %1 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8
  %cmp = icmp eq %struct.TigrFont* %0, %1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 0
  %3 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8
  %tobool = icmp ne %struct.Tigr* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = load i32, i32* @tigr_font_size, align 4
  %call = call %struct.Tigr* @tigrLoadImageMem(i8* getelementptr inbounds ([3850 x i8], [3850 x i8]* @tigr_font, i32 0, i32 0), i32 %4)
  %5 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8
  %bitmap1 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %5, i32 0, i32 0
  store %struct.Tigr* %call, %struct.Tigr** %bitmap1, align 8
  %6 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8
  %call2 = call i32 @tigrLoadGlyphs(%struct.TigrFont* %6, i32 1252)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrPrint(%struct.Tigr* %dest, %struct.TigrFont* %font, i32 %x, i32 %y, i32 %color.coerce, i8* %text, ...) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %dest.addr = alloca %struct.Tigr*, align 8
  %font.addr = alloca %struct.TigrFont*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %text.addr = alloca i8*, align 8
  %tmp = alloca [1024 x i8], align 16
  %g = alloca %struct.TigrGlyph*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %p = alloca i8*, align 8
  %start = alloca i32, align 4
  %c = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %dest, %struct.Tigr** %dest.addr, align 8
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i8* %text, i8** %text.addr, align 8
  %1 = load i32, i32* %x.addr, align 4
  store i32 %1, i32* %start, align 4
  %2 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  call void @tigrSetupFont(%struct.TigrFont* %2)
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %3 = load i8*, i8** %text.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %3, %struct.__va_list_tag* %arraydecay3)
  %arrayidx = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i64 0, i64 1023
  store i8 0, i8* %arrayidx, align 1
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %arraydecay6 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  store i8* %arraydecay6, i8** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.then9, %if.then, %entry
  %4 = load i8*, i8** %p, align 8
  %5 = load i8, i8* %4, align 1
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load i8*, i8** %p, align 8
  %call7 = call i8* @tigrDecodeUTF8(i8* %6, i32* %c)
  store i8* %call7, i8** %p, align 8
  %7 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %7, 13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond

if.end:                                           ; preds = %while.body
  %8 = load i32, i32* %c, align 4
  %cmp8 = icmp eq i32 %8, 10
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %9 = load i32, i32* %start, align 4
  store i32 %9, i32* %x.addr, align 4
  %10 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %call10 = call i32 @tigrTextHeight(%struct.TigrFont* %10, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %11 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %11, %call10
  store i32 %add, i32* %y.addr, align 4
  br label %while.cond

if.end11:                                         ; preds = %if.end
  %12 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %13 = load i32, i32* %c, align 4
  %call12 = call %struct.TigrGlyph* @get(%struct.TigrFont* %12, i32 %13)
  store %struct.TigrGlyph* %call12, %struct.TigrGlyph** %g, align 8
  %14 = load %struct.Tigr*, %struct.Tigr** %dest.addr, align 8
  %15 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %15, i32 0, i32 0
  %16 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8
  %17 = load i32, i32* %x.addr, align 4
  %18 = load i32, i32* %y.addr, align 4
  %19 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %x13 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %19, i32 0, i32 1
  %20 = load i32, i32* %x13, align 4
  %21 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %y14 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %21, i32 0, i32 2
  %22 = load i32, i32* %y14, align 4
  %23 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %w = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %23, i32 0, i32 3
  %24 = load i32, i32* %w, align 4
  %25 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %h = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %25, i32 0, i32 4
  %26 = load i32, i32* %h, align 4
  %27 = bitcast %struct.TPixel* %color to i32*
  %28 = load i32, i32* %27, align 1
  call void @tigrBlitTint(%struct.Tigr* %14, %struct.Tigr* %16, i32 %17, i32 %18, i32 %20, i32 %22, i32 %24, i32 %26, i32 %28)
  %29 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8
  %w15 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %29, i32 0, i32 3
  %30 = load i32, i32* %w15, align 4
  %31 = load i32, i32* %x.addr, align 4
  %add16 = add nsw i32 %31, %30
  store i32 %add16, i32* %x.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #10

declare i32 @__vsnprintf_chk(i8*, i64, i32, i64, i8*, %struct.__va_list_tag*) #4

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #10

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrTextHeight(%struct.TigrFont* %font, i8* %text) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  %text.addr = alloca i8*, align 8
  %rowh = alloca i32, align 4
  %h = alloca i32, align 4
  %c = alloca i32, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  store i8* %text, i8** %text.addr, align 8
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  call void @tigrSetupFont(%struct.TigrFont* %0)
  %1 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %call = call %struct.TigrGlyph* @get(%struct.TigrFont* %1, i32 0)
  %h1 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %call, i32 0, i32 4
  %2 = load i32, i32* %h1, align 4
  store i32 %2, i32* %rowh, align 4
  store i32 %2, i32* %h, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %3 = load i8*, i8** %text.addr, align 8
  %4 = load i8, i8* %3, align 1
  %tobool = icmp ne i8 %4, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i8*, i8** %text.addr, align 8
  %call2 = call i8* @tigrDecodeUTF8(i8* %5, i32* %c)
  store i8* %call2, i8** %text.addr, align 8
  %6 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %6, 10
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %7 = load i8*, i8** %text.addr, align 8
  %8 = load i8, i8* %7, align 1
  %conv = sext i8 %8 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load i32, i32* %rowh, align 4
  %10 = load i32, i32* %h, align 4
  %add = add nsw i32 %10, %9
  store i32 %add, i32* %h, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %11 = load i32, i32* %h, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal %struct.TigrGlyph* @get(%struct.TigrFont* %font, i32 %code) #0 {
entry:
  %retval = alloca %struct.TigrGlyph*, align 8
  %font.addr = alloca %struct.TigrFont*, align 8
  %code.addr = alloca i32, align 4
  %lo = alloca i32, align 4
  %hi = alloca i32, align 4
  %guess = alloca i32, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  store i32 %code, i32* %code.addr, align 4
  store i32 0, i32* %lo, align 4
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %numGlyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %0, i32 0, i32 1
  %1 = load i32, i32* %numGlyphs, align 8
  store i32 %1, i32* %hi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load i32, i32* %lo, align 4
  %3 = load i32, i32* %hi, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i32, i32* %lo, align 4
  %5 = load i32, i32* %hi, align 4
  %add = add i32 %4, %5
  %div = udiv i32 %add, 2
  store i32 %div, i32* %guess, align 4
  %6 = load i32, i32* %code.addr, align 4
  %7 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %7, i32 0, i32 2
  %8 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs, align 8
  %9 = load i32, i32* %guess, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %8, i64 %idxprom
  %code1 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx, i32 0, i32 0
  %10 = load i32, i32* %code1, align 4
  %cmp2 = icmp slt i32 %6, %10
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %11 = load i32, i32* %guess, align 4
  store i32 %11, i32* %hi, align 4
  br label %if.end

if.else:                                          ; preds = %while.body
  %12 = load i32, i32* %guess, align 4
  %add3 = add i32 %12, 1
  store i32 %add3, i32* %lo, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %13 = load i32, i32* %lo, align 4
  %cmp4 = icmp eq i32 %13, 0
  br i1 %cmp4, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %14 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs5 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %14, i32 0, i32 2
  %15 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs5, align 8
  %16 = load i32, i32* %lo, align 4
  %sub = sub i32 %16, 1
  %idxprom6 = zext i32 %sub to i64
  %arrayidx7 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %15, i64 %idxprom6
  %code8 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx7, i32 0, i32 0
  %17 = load i32, i32* %code8, align 4
  %18 = load i32, i32* %code.addr, align 4
  %cmp9 = icmp ne i32 %17, %18
  br i1 %cmp9, label %if.then10, label %if.else13

if.then10:                                        ; preds = %lor.lhs.false, %while.end
  %19 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs11 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %19, i32 0, i32 2
  %20 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs11, align 8
  %arrayidx12 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %20, i64 31
  store %struct.TigrGlyph* %arrayidx12, %struct.TigrGlyph** %retval, align 8
  br label %return

if.else13:                                        ; preds = %lor.lhs.false
  %21 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %glyphs14 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %21, i32 0, i32 2
  %22 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs14, align 8
  %23 = load i32, i32* %lo, align 4
  %sub15 = sub i32 %23, 1
  %idxprom16 = zext i32 %sub15 to i64
  %arrayidx17 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %22, i64 %idxprom16
  store %struct.TigrGlyph* %arrayidx17, %struct.TigrGlyph** %retval, align 8
  br label %return

return:                                           ; preds = %if.else13, %if.then10
  %24 = load %struct.TigrGlyph*, %struct.TigrGlyph** %retval, align 8
  ret %struct.TigrGlyph* %24
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrTextWidth(%struct.TigrFont* %font, i8* %text) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  %text.addr = alloca i8*, align 8
  %x = alloca i32, align 4
  %w = alloca i32, align 4
  %c = alloca i32, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8
  store i8* %text, i8** %text.addr, align 8
  store i32 0, i32* %x, align 4
  store i32 0, i32* %w, align 4
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  call void @tigrSetupFont(%struct.TigrFont* %0)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load i8*, i8** %text.addr, align 8
  %2 = load i8, i8* %1, align 1
  %tobool = icmp ne i8 %2, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %text.addr, align 8
  %call = call i8* @tigrDecodeUTF8(i8* %3, i32* %c)
  store i8* %call, i8** %text.addr, align 8
  %4 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %4, 10
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %5 = load i32, i32* %c, align 4
  %cmp1 = icmp eq i32 %5, 13
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body
  store i32 0, i32* %x, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %6 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8
  %7 = load i32, i32* %c, align 4
  %call2 = call %struct.TigrGlyph* @get(%struct.TigrFont* %6, i32 %7)
  %w3 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %call2, i32 0, i32 3
  %8 = load i32, i32* %w3, align 4
  %9 = load i32, i32* %x, align 4
  %add = add nsw i32 %9, %8
  store i32 %add, i32* %x, align 4
  %10 = load i32, i32* %x, align 4
  %11 = load i32, i32* %w, align 4
  %cmp4 = icmp sgt i32 %10, %11
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %12 = load i32, i32* %x, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %13 = load i32, i32* %w, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %12, %cond.true ], [ %13, %cond.false ]
  store i32 %cond, i32* %w, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %14 = load i32, i32* %w, align 4
  ret i32 %14
}

; Function Attrs: cold noreturn
declare void @__assert_rtn(i8*, i8*, i32, i8*) #11

; Function Attrs: noinline nounwind optnone ssp uwtable
define i64 @applicationShouldTerminate(%struct.objc_object* %self, %struct.objc_selector* %_sel, %struct.objc_object* %sender) #0 {
entry:
  %self.addr = alloca %struct.objc_object*, align 8
  %_sel.addr = alloca %struct.objc_selector*, align 8
  %sender.addr = alloca %struct.objc_object*, align 8
  store %struct.objc_object* %self, %struct.objc_object** %self.addr, align 8
  store %struct.objc_selector* %_sel, %struct.objc_selector** %_sel.addr, align 8
  store %struct.objc_object* %sender, %struct.objc_object** %sender.addr, align 8
  store i8 1, i8* @terminated, align 1
  ret i64 0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @windowWillClose(%struct.objc_object* %self, %struct.objc_selector* %_sel, %struct.objc_object* %notification) #0 {
entry:
  %self.addr = alloca %struct.objc_object*, align 8
  %_sel.addr = alloca %struct.objc_selector*, align 8
  %notification.addr = alloca %struct.objc_object*, align 8
  %value = alloca i64, align 8
  store %struct.objc_object* %self, %struct.objc_object** %self.addr, align 8
  store %struct.objc_selector* %_sel, %struct.objc_selector** %_sel.addr, align 8
  store %struct.objc_object* %notification, %struct.objc_object** %notification.addr, align 8
  store i64 1, i64* %value, align 8
  %0 = load %struct.objc_object*, %struct.objc_object** %self.addr, align 8
  %1 = load i64, i64* %value, align 8
  %2 = inttoptr i64 %1 to i8*
  %call = call %struct.objc_ivar* @object_setInstanceVariable(%struct.objc_object* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  ret void
}

declare %struct.objc_ivar* @object_setInstanceVariable(%struct.objc_object*, i8*, i8*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @windowDidBecomeKey(%struct.objc_object* %self, %struct.objc_selector* %_sel, %struct.objc_object* %notification) #0 {
entry:
  %self.addr = alloca %struct.objc_object*, align 8
  %_sel.addr = alloca %struct.objc_selector*, align 8
  %notification.addr = alloca %struct.objc_object*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  store %struct.objc_object* %self, %struct.objc_object** %self.addr, align 8
  store %struct.objc_selector* %_sel, %struct.objc_selector** %_sel.addr, align 8
  store %struct.objc_object* %notification, %struct.objc_object** %notification.addr, align 8
  store %struct.Tigr* null, %struct.Tigr** %bmp, align 8
  %0 = load %struct.objc_object*, %struct.objc_object** %self.addr, align 8
  %1 = bitcast %struct.Tigr** %bmp to i8**
  %call = call %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i8** %1)
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %tobool = icmp ne %struct.Tigr* %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %call1 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %3)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.TigrInternal* [ %call1, %cond.true ], [ null, %cond.false ]
  store %struct.TigrInternal* %cond, %struct.TigrInternal** %win, align 8
  %4 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %tobool2 = icmp ne %struct.TigrInternal* %4, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %5 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %5, i32 0, i32 16
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i32 0, i32 0
  %6 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys3 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %6, i32 0, i32 16
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %keys3, i32 0, i32 0
  %7 = call i64 @llvm.objectsize.i64.p0i8(i8* %arraydecay4, i1 false, i1 true)
  %call5 = call i8* @__memset_chk(i8* %arraydecay, i32 0, i64 256, i64 %7) #10
  %8 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %prev = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %8, i32 0, i32 17
  %arraydecay6 = getelementptr inbounds [256 x i8], [256 x i8]* %prev, i32 0, i32 0
  %9 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %prev7 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %9, i32 0, i32 17
  %arraydecay8 = getelementptr inbounds [256 x i8], [256 x i8]* %prev7, i32 0, i32 0
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %arraydecay8, i1 false, i1 true)
  %call9 = call i8* @__memset_chk(i8* %arraydecay6, i32 0, i64 256, i64 %10) #10
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %11, i32 0, i32 15
  store i32 0, i32* %lastChar, align 4
  %12 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %12, i32 0, i32 18
  store i32 0, i32* %mouseButtons, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

declare %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object*, i8*, i8**) #4

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %window) #0 {
entry:
  %retval = alloca i1, align 1
  %window.addr = alloca %struct.objc_object*, align 8
  %wdg = alloca %struct.objc_object*, align 8
  %value = alloca i64, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8
  %0 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %0, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %wdg, align 8
  %1 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  %tobool = icmp ne %struct.objc_object* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, i64* %value, align 8
  %2 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  %3 = bitcast i64* %value to i8**
  %call2 = call %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object* %2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i8** %3)
  %4 = load i64, i64* %value, align 8
  %tobool3 = icmp ne i64 %4, 0
  %5 = zext i1 %tobool3 to i64
  %cond = select i1 %tobool3, i32 1, i32 0
  %tobool4 = icmp ne i32 %cond, 0
  store i1 %tobool4, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, i1* %retval, align 1
  ret i1 %6
}

declare void @objc_msgSend() #4

declare %struct.objc_selector* @sel_registerName(i8*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_tigrCleanupOSX() #0 {
entry:
  %0 = load %struct.objc_object*, %struct.objc_object** @autoreleasePool, align 8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %0, %struct.objc_selector* %call)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrInitOSX() #0 {
entry:
  %poolAlloc = alloca %struct.objc_object*, align 8
  %appDelegateClass = alloca %struct.objc_class*, align 8
  %resultAddProtoc = alloca i8, align 1
  %resultAddMethod = alloca i8, align 1
  %dgAlloc = alloca %struct.objc_object*, align 8
  %dg = alloca %struct.objc_object*, align 8
  %menubarAlloc = alloca %struct.objc_object*, align 8
  %menubar = alloca %struct.objc_object*, align 8
  %appMenuItemAlloc = alloca %struct.objc_object*, align 8
  %appMenuItem = alloca %struct.objc_object*, align 8
  %appMenuAlloc = alloca %struct.objc_object*, align 8
  %appMenu = alloca %struct.objc_object*, align 8
  %processInfo = alloca %struct.objc_object*, align 8
  %appName = alloca %struct.objc_object*, align 8
  %quitTitlePrefixString = alloca %struct.objc_object*, align 8
  %quitTitle = alloca %struct.objc_object*, align 8
  %quitMenuItemKey = alloca %struct.objc_object*, align 8
  %quitMenuItemAlloc = alloca %struct.objc_object*, align 8
  %quitMenuItem = alloca %struct.objc_object*, align 8
  %0 = load i8, i8* @tigrOSXInited, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.10, i32 0, i32 0))
  %1 = bitcast %struct.objc_class* %call to %struct.objc_object*
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call2 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %1, %struct.objc_selector* %call1)
  store %struct.objc_object* %call2, %struct.objc_object** %poolAlloc, align 8
  %2 = load %struct.objc_object*, %struct.objc_object** %poolAlloc, align 8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call4 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %2, %struct.objc_selector* %call3)
  store %struct.objc_object* %call4, %struct.objc_object** @autoreleasePool, align 8
  %call5 = call i32 @atexit(void ()* @_tigrCleanupOSX)
  %call6 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.13, i32 0, i32 0))
  %3 = bitcast %struct.objc_class* %call6 to %struct.objc_object*
  %call7 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.14, i32 0, i32 0))
  %call8 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %3, %struct.objc_selector* %call7)
  %4 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call9 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.15, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i64)*)(%struct.objc_object* %4, %struct.objc_selector* %call9, i64 0)
  %call10 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.16, i32 0, i32 0))
  %call11 = call %struct.objc_class* @objc_allocateClassPair(%struct.objc_class* %call10, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.17, i32 0, i32 0), i64 0)
  store %struct.objc_class* %call11, %struct.objc_class** %appDelegateClass, align 8
  %5 = load %struct.objc_class*, %struct.objc_class** %appDelegateClass, align 8
  %call12 = call %struct.objc_object* @objc_getProtocol(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.18, i32 0, i32 0))
  %call13 = call signext i8 @class_addProtocol(%struct.objc_class* %5, %struct.objc_object* %call12)
  %tobool14 = icmp ne i8 %call13, 0
  %frombool = zext i1 %tobool14 to i8
  store i8 %frombool, i8* %resultAddProtoc, align 1
  %6 = load i8, i8* %resultAddProtoc, align 1
  %tobool15 = trunc i8 %6 to i1
  %lnot = xor i1 %tobool15, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool16 = icmp ne i64 %conv, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrInitOSX, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 2906, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.19, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %7
  %8 = load %struct.objc_class*, %struct.objc_class** %appDelegateClass, align 8
  %call17 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.20, i32 0, i32 0))
  %call18 = call signext i8 @class_addMethod(%struct.objc_class* %8, %struct.objc_selector* %call17, void ()* bitcast (i64 (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)* @applicationShouldTerminate to void ()*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21, i32 0, i32 0))
  %tobool19 = icmp ne i8 %call18, 0
  %frombool20 = zext i1 %tobool19 to i8
  store i8 %frombool20, i8* %resultAddMethod, align 1
  %9 = load i8, i8* %resultAddMethod, align 1
  %tobool21 = trunc i8 %9 to i1
  %lnot22 = xor i1 %tobool21, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.end
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrInitOSX, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 2908, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end28

cond.false27:                                     ; preds = %cond.end
  br label %cond.end28

cond.end28:                                       ; preds = %cond.false27, %10
  %11 = load %struct.objc_class*, %struct.objc_class** %appDelegateClass, align 8
  %12 = bitcast %struct.objc_class* %11 to %struct.objc_object*
  %call29 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call30 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %12, %struct.objc_selector* %call29)
  store %struct.objc_object* %call30, %struct.objc_object** %dgAlloc, align 8
  %13 = load %struct.objc_object*, %struct.objc_object** %dgAlloc, align 8
  %call31 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call32 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %13, %struct.objc_selector* %call31)
  store %struct.objc_object* %call32, %struct.objc_object** %dg, align 8
  %14 = load %struct.objc_object*, %struct.objc_object** %dg, align 8
  %call33 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %14, %struct.objc_selector* %call33)
  %15 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call34 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.24, i32 0, i32 0))
  %16 = load %struct.objc_object*, %struct.objc_object** %dg, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %15, %struct.objc_selector* %call34, %struct.objc_object* %16)
  %17 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call35 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.25, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %17, %struct.objc_selector* %call35)
  %call36 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %18 = bitcast %struct.objc_class* %call36 to %struct.objc_object*
  %call37 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call38 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %18, %struct.objc_selector* %call37)
  store %struct.objc_object* %call38, %struct.objc_object** %menubarAlloc, align 8
  %19 = load %struct.objc_object*, %struct.objc_object** %menubarAlloc, align 8
  %call39 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call40 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %19, %struct.objc_selector* %call39)
  store %struct.objc_object* %call40, %struct.objc_object** %menubar, align 8
  %20 = load %struct.objc_object*, %struct.objc_object** %menubar, align 8
  %call41 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %20, %struct.objc_selector* %call41)
  %call42 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0))
  %21 = bitcast %struct.objc_class* %call42 to %struct.objc_object*
  %call43 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call44 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %21, %struct.objc_selector* %call43)
  store %struct.objc_object* %call44, %struct.objc_object** %appMenuItemAlloc, align 8
  %22 = load %struct.objc_object*, %struct.objc_object** %appMenuItemAlloc, align 8
  %call45 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call46 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %22, %struct.objc_selector* %call45)
  store %struct.objc_object* %call46, %struct.objc_object** %appMenuItem, align 8
  %23 = load %struct.objc_object*, %struct.objc_object** %appMenuItem, align 8
  %call47 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %23, %struct.objc_selector* %call47)
  %24 = load %struct.objc_object*, %struct.objc_object** %menubar, align 8
  %call48 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28, i32 0, i32 0))
  %25 = load %struct.objc_object*, %struct.objc_object** %appMenuItem, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %24, %struct.objc_selector* %call48, %struct.objc_object* %25)
  %26 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call49 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.29, i32 0, i32 0))
  %27 = load %struct.objc_object*, %struct.objc_object** %menubar, align 8
  %call50 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %26, %struct.objc_selector* %call49, %struct.objc_object* %27)
  %call51 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %28 = bitcast %struct.objc_class* %call51 to %struct.objc_object*
  %call52 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call53 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %28, %struct.objc_selector* %call52)
  store %struct.objc_object* %call53, %struct.objc_object** %appMenuAlloc, align 8
  %29 = load %struct.objc_object*, %struct.objc_object** %appMenuAlloc, align 8
  %call54 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call55 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %29, %struct.objc_selector* %call54)
  store %struct.objc_object* %call55, %struct.objc_object** %appMenu, align 8
  %30 = load %struct.objc_object*, %struct.objc_object** %appMenu, align 8
  %call56 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %30, %struct.objc_selector* %call56)
  %call57 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.30, i32 0, i32 0))
  %31 = bitcast %struct.objc_class* %call57 to %struct.objc_object*
  %call58 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.31, i32 0, i32 0))
  %call59 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %31, %struct.objc_selector* %call58)
  store %struct.objc_object* %call59, %struct.objc_object** %processInfo, align 8
  %32 = load %struct.objc_object*, %struct.objc_object** %processInfo, align 8
  %call60 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.32, i32 0, i32 0))
  %call61 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %32, %struct.objc_selector* %call60)
  store %struct.objc_object* %call61, %struct.objc_object** %appName, align 8
  %call62 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0))
  %33 = bitcast %struct.objc_class* %call62 to %struct.objc_object*
  %call63 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34, i32 0, i32 0))
  %call64 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i8*)*)(%struct.objc_object* %33, %struct.objc_selector* %call63, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.35, i32 0, i32 0))
  store %struct.objc_object* %call64, %struct.objc_object** %quitTitlePrefixString, align 8
  %34 = load %struct.objc_object*, %struct.objc_object** %quitTitlePrefixString, align 8
  %call65 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36, i32 0, i32 0))
  %35 = load %struct.objc_object*, %struct.objc_object** %appName, align 8
  %call66 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %34, %struct.objc_selector* %call65, %struct.objc_object* %35)
  store %struct.objc_object* %call66, %struct.objc_object** %quitTitle, align 8
  %call67 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0))
  %36 = bitcast %struct.objc_class* %call67 to %struct.objc_object*
  %call68 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34, i32 0, i32 0))
  %call69 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i8*)*)(%struct.objc_object* %36, %struct.objc_selector* %call68, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.37, i32 0, i32 0))
  store %struct.objc_object* %call69, %struct.objc_object** %quitMenuItemKey, align 8
  %call70 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0))
  %37 = bitcast %struct.objc_class* %call70 to %struct.objc_object*
  %call71 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call72 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %37, %struct.objc_selector* %call71)
  store %struct.objc_object* %call72, %struct.objc_object** %quitMenuItemAlloc, align 8
  %38 = load %struct.objc_object*, %struct.objc_object** %quitMenuItemAlloc, align 8
  %call73 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.38, i32 0, i32 0))
  %39 = load %struct.objc_object*, %struct.objc_object** %quitTitle, align 8
  %call74 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.39, i32 0, i32 0))
  %40 = load %struct.objc_object*, %struct.objc_object** %quitMenuItemKey, align 8
  %call75 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %38, %struct.objc_selector* %call73, %struct.objc_object* %39, %struct.objc_selector* %call74, %struct.objc_object* %40)
  store %struct.objc_object* %call75, %struct.objc_object** %quitMenuItem, align 8
  %41 = load %struct.objc_object*, %struct.objc_object** %quitMenuItem, align 8
  %call76 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %41, %struct.objc_selector* %call76)
  %42 = load %struct.objc_object*, %struct.objc_object** %appMenu, align 8
  %call77 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28, i32 0, i32 0))
  %43 = load %struct.objc_object*, %struct.objc_object** %quitMenuItem, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %42, %struct.objc_selector* %call77, %struct.objc_object* %43)
  %44 = load %struct.objc_object*, %struct.objc_object** %appMenuItem, align 8
  %call78 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.40, i32 0, i32 0))
  %45 = load %struct.objc_object*, %struct.objc_object** %appMenu, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %44, %struct.objc_selector* %call78, %struct.objc_object* %45)
  store i8 1, i8* @tigrOSXInited, align 1
  br label %return

return:                                           ; preds = %cond.end28, %if.then
  ret void
}

declare %struct.objc_class* @objc_getClass(i8*) #4

declare i32 @atexit(void ()*) #4

declare %struct.objc_class* @objc_allocateClassPair(%struct.objc_class*, i8*, i64) #4

declare signext i8 @class_addProtocol(%struct.objc_class*, %struct.objc_object*) #4

declare %struct.objc_object* @objc_getProtocol(i8*) #4

declare signext i8 @class_addMethod(%struct.objc_class*, %struct.objc_selector*, void ()*, i8*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrError(%struct.Tigr* %bmp, i8* %message, ...) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %message.addr = alloca i8*, align 8
  %tmp = alloca [1024 x i8], align 16
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %header = alloca %struct.__CFString*, align 8
  %msg = alloca %struct.__CFString*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i8* %message, i8** %message.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %0 = load i8*, i8** %message.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %0, %struct.__va_list_tag* %arraydecay3)
  %arrayidx = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i64 0, i64 1023
  store i8 0, i8* %arrayidx, align 1
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %call6 = call %struct.__CFString* @CFStringCreateWithCString(%struct.__CFAllocator* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.41, i32 0, i32 0), i32 134217984)
  store %struct.__CFString* %call6, %struct.__CFString** %header, align 8
  %arraydecay7 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %call8 = call %struct.__CFString* @CFStringCreateWithCString(%struct.__CFAllocator* null, i8* %arraydecay7, i32 134217984)
  store %struct.__CFString* %call8, %struct.__CFString** %msg, align 8
  %1 = load %struct.__CFString*, %struct.__CFString** %header, align 8
  %2 = load %struct.__CFString*, %struct.__CFString** %msg, align 8
  %call9 = call i32 @CFUserNotificationDisplayNotice(double 0.000000e+00, i64 0, %struct.__CFURL* null, %struct.__CFURL* null, %struct.__CFURL* null, %struct.__CFString* %1, %struct.__CFString* %2, %struct.__CFString* null)
  %3 = load %struct.__CFString*, %struct.__CFString** %header, align 8
  %4 = bitcast %struct.__CFString* %3 to i8*
  call void @CFRelease(i8* %4)
  %5 = load %struct.__CFString*, %struct.__CFString** %msg, align 8
  %6 = bitcast %struct.__CFString* %5 to i8*
  call void @CFRelease(i8* %6)
  call void @exit(i32 1) #19
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare %struct.__CFString* @CFStringCreateWithCString(%struct.__CFAllocator*, i8*, i32) #4

declare i32 @CFUserNotificationDisplayNotice(double, i64, %struct.__CFURL*, %struct.__CFURL*, %struct.__CFURL*, %struct.__CFString*, %struct.__CFString*, %struct.__CFString*) #4

declare void @CFRelease(i8*) #4

; Function Attrs: noreturn
declare void @exit(i32) #9

; Function Attrs: noinline nounwind optnone ssp uwtable
define { double, double } @_tigrCocoaWindowSize(%struct.objc_object* %window) #0 {
entry:
  %retval = alloca %struct.CGSize, align 8
  %window.addr = alloca %struct.objc_object*, align 8
  %contentView = alloca %struct.objc_object*, align 8
  %rect = alloca %struct.CGRect, align 8
  %tmp = alloca %struct.CGRect, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8
  %0 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %0, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %contentView, align 8
  %1 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8
  %call2 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.43, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*)*)(%struct.CGRect* sret %rect, %struct.objc_object* %1, %struct.objc_selector* %call2)
  %2 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.44, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*, %struct.CGRect*)*)(%struct.CGRect* sret %tmp, %struct.objc_object* %2, %struct.objc_selector* %call3, %struct.CGRect* byval align 8 %rect)
  %3 = bitcast %struct.CGRect* %rect to i8*
  %4 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 32, i1 false)
  %size = getelementptr inbounds %struct.CGRect, %struct.CGRect* %rect, i32 0, i32 1
  %5 = bitcast %struct.CGSize* %retval to i8*
  %6 = bitcast %struct.CGSize* %size to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %6, i64 16, i1 false)
  %7 = bitcast %struct.CGSize* %retval to { double, double }*
  %8 = load { double, double }, { double, double }* %7, align 8
  ret { double, double } %8
}

declare void @objc_msgSend_stret() #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.TigrInternal* @_tigrInternalCocoa(%struct.objc_object* %window) #0 {
entry:
  %retval = alloca %struct.TigrInternal*, align 8
  %window.addr = alloca %struct.objc_object*, align 8
  %wdg = alloca %struct.objc_object*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8
  %0 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8
  %tobool = icmp ne %struct.objc_object* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.TigrInternal* null, %struct.TigrInternal** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %1, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %wdg, align 8
  %2 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  %tobool2 = icmp ne %struct.objc_object* %2, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store %struct.TigrInternal* null, %struct.TigrInternal** %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  store %struct.Tigr* null, %struct.Tigr** %bmp, align 8
  %3 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  %4 = bitcast %struct.Tigr** %bmp to i8**
  %call5 = call %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object* %3, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i8** %4)
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %tobool6 = icmp ne %struct.Tigr* %5, null
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %call7 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %6)
  br label %cond.end

cond.false:                                       ; preds = %if.end4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.TigrInternal* [ %call7, %cond.true ], [ null, %cond.false ]
  store %struct.TigrInternal* %cond, %struct.TigrInternal** %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then3, %if.then
  %7 = load %struct.TigrInternal*, %struct.TigrInternal** %retval, align 8
  ret %struct.TigrInternal* %7
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.Tigr* @tigrWindow(i32 %w, i32 %h, i8* %title, i32 %flags) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %title.addr = alloca i8*, align 8
  %flags.addr = alloca i32, align 4
  %scale = alloca i32, align 4
  %bmp = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %mainMonitor = alloca %struct.CGRect, align 8
  %maxW = alloca i32, align 4
  %maxH = alloca i32, align 4
  %rect = alloca %struct.CGRect, align 8
  %windowAlloc = alloca %struct.objc_object*, align 8
  %window = alloca %struct.objc_object*, align 8
  %WindowDelegateClass = alloca %struct.objc_class*, align 8
  %resultAddProtoc = alloca i8, align 1
  %resultAddIvar = alloca i8, align 1
  %resultAddMethod = alloca i8, align 1
  %wdgAlloc = alloca %struct.objc_object*, align 8
  %wdg = alloca %struct.objc_object*, align 8
  %contentView = alloca %struct.objc_object*, align 8
  %point = alloca %struct.CGPoint, align 8
  %titleString = alloca %struct.objc_object*, align 8
  %glAttributes = alloca [9 x i32], align 16
  %pixelFormatAlloc = alloca %struct.objc_object*, align 8
  %pixelFormat = alloca %struct.objc_object*, align 8
  %openGLContextAlloc = alloca %struct.objc_object*, align 8
  %openGLContext = alloca %struct.objc_object*, align 8
  %blackColor = alloca %struct.objc_object*, align 8
  %windowSize = alloca %struct.CGSize, align 8
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store i8* %title, i8** %title.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  call void @tigrInitOSX()
  %0 = load i32, i32* %flags.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %scale, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %call = call i32 @CGMainDisplayID()
  call void @CGDisplayBounds(%struct.CGRect* sret %mainMonitor, i32 %call)
  %call1 = call double @CGRectGetHeight(%struct.CGRect* byval align 8 %mainMonitor)
  %mul = fmul double %call1, 3.000000e+00
  %div = fdiv double %mul, 4.000000e+00
  %conv = fptosi double %div to i32
  store i32 %conv, i32* %maxW, align 4
  %call2 = call double @CGRectGetWidth(%struct.CGRect* byval align 8 %mainMonitor)
  %mul3 = fmul double %call2, 3.000000e+00
  %div4 = fdiv double %mul3, 4.000000e+00
  %conv5 = fptosi double %div4 to i32
  store i32 %conv5, i32* %maxH, align 4
  %1 = load i32, i32* %w.addr, align 4
  %2 = load i32, i32* %h.addr, align 4
  %3 = load i32, i32* %maxW, align 4
  %4 = load i32, i32* %maxH, align 4
  %call6 = call i32 @tigrCalcScale(i32 %1, i32 %2, i32 %3, i32 %4)
  store i32 %call6, i32* %scale, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i32, i32* %scale, align 4
  %6 = load i32, i32* %flags.addr, align 4
  %call7 = call i32 @tigrEnforceScale(i32 %5, i32 %6)
  store i32 %call7, i32* %scale, align 4
  %origin = getelementptr inbounds %struct.CGRect, %struct.CGRect* %rect, i32 0, i32 0
  %x = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 0
  store double 0.000000e+00, double* %x, align 8
  %y = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 1
  store double 0.000000e+00, double* %y, align 8
  %size = getelementptr inbounds %struct.CGRect, %struct.CGRect* %rect, i32 0, i32 1
  %width = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size, i32 0, i32 0
  %7 = load i32, i32* %w.addr, align 4
  %8 = load i32, i32* %scale, align 4
  %mul8 = mul nsw i32 %7, %8
  %conv9 = sitofp i32 %mul8 to double
  store double %conv9, double* %width, align 8
  %height = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size, i32 0, i32 1
  %9 = load i32, i32* %h.addr, align 4
  %10 = load i32, i32* %scale, align 4
  %mul10 = mul nsw i32 %9, %10
  %conv11 = sitofp i32 %mul10 to double
  store double %conv11, double* %height, align 8
  %call12 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.45, i32 0, i32 0))
  %11 = bitcast %struct.objc_class* %call12 to %struct.objc_object*
  %call13 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call14 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %11, %struct.objc_selector* %call13)
  store %struct.objc_object* %call14, %struct.objc_object** %windowAlloc, align 8
  %12 = load %struct.objc_object*, %struct.objc_object** %windowAlloc, align 8
  %call15 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.46, i32 0, i32 0))
  %call16 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.CGRect*, i64, i64, i8)*)(%struct.objc_object* %12, %struct.objc_selector* %call15, %struct.CGRect* byval align 8 %rect, i64 15, i64 2, i8 signext 0)
  store %struct.objc_object* %call16, %struct.objc_object** %window, align 8
  %13 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call17 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %13, %struct.objc_selector* %call17)
  %14 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call18 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.47, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %14, %struct.objc_selector* %call18, i8 signext 0)
  %call19 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.16, i32 0, i32 0))
  %call20 = call %struct.objc_class* @objc_allocateClassPair(%struct.objc_class* %call19, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.48, i32 0, i32 0), i64 0)
  store %struct.objc_class* %call20, %struct.objc_class** %WindowDelegateClass, align 8
  %15 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8
  %call21 = call %struct.objc_object* @objc_getProtocol(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.49, i32 0, i32 0))
  %call22 = call signext i8 @class_addProtocol(%struct.objc_class* %15, %struct.objc_object* %call21)
  %tobool23 = icmp ne i8 %call22, 0
  %frombool = zext i1 %tobool23 to i8
  store i8 %frombool, i8* %resultAddProtoc, align 1
  %16 = load i8, i8* %resultAddProtoc, align 1
  %tobool24 = trunc i8 %16 to i1
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %conv25 = sext i32 %lnot.ext to i64
  %tobool26 = icmp ne i64 %conv25, 0
  br i1 %tobool26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3035, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.19, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %17
  %18 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8
  %19 = call double @llvm.log2.f64(double 8.000000e+00)
  %20 = call double @llvm.rint.f64(double %19)
  %conv27 = fptoui double %20 to i8
  %call28 = call signext i8 @class_addIvar(%struct.objc_class* %18, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i64 8, i8 zeroext %conv27, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.50, i32 0, i32 0))
  %tobool29 = icmp ne i8 %call28, 0
  %frombool30 = zext i1 %tobool29 to i8
  store i8 %frombool30, i8* %resultAddIvar, align 1
  %21 = load i8, i8* %resultAddIvar, align 1
  %tobool31 = trunc i8 %21 to i1
  %lnot32 = xor i1 %tobool31, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %tobool35 = icmp ne i64 %conv34, 0
  br i1 %tobool35, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.end
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3037, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.51, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end38

cond.false37:                                     ; preds = %cond.end
  br label %cond.end38

cond.end38:                                       ; preds = %cond.false37, %22
  %23 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8
  %24 = call double @llvm.log2.f64(double 8.000000e+00)
  %25 = call double @llvm.rint.f64(double %24)
  %conv39 = fptoui double %25 to i8
  %call40 = call signext i8 @class_addIvar(%struct.objc_class* %23, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i64 8, i8 zeroext %conv39, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.52, i32 0, i32 0))
  %tobool41 = icmp ne i8 %call40, 0
  %frombool42 = zext i1 %tobool41 to i8
  store i8 %frombool42, i8* %resultAddIvar, align 1
  %26 = load i8, i8* %resultAddIvar, align 1
  %tobool43 = trunc i8 %26 to i1
  %lnot44 = xor i1 %tobool43, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %tobool47 = icmp ne i64 %conv46, 0
  br i1 %tobool47, label %cond.true48, label %cond.false49

cond.true48:                                      ; preds = %cond.end38
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3039, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.51, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end50

cond.false49:                                     ; preds = %cond.end38
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false49, %27
  %28 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8
  %call51 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.53, i32 0, i32 0))
  %call52 = call signext i8 @class_addMethod(%struct.objc_class* %28, %struct.objc_selector* %call51, void ()* bitcast (void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)* @windowWillClose to void ()*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.54, i32 0, i32 0))
  %tobool53 = icmp ne i8 %call52, 0
  %frombool54 = zext i1 %tobool53 to i8
  store i8 %frombool54, i8* %resultAddMethod, align 1
  %29 = load i8, i8* %resultAddMethod, align 1
  %tobool55 = trunc i8 %29 to i1
  %lnot56 = xor i1 %tobool55, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %conv58 = sext i32 %lnot.ext57 to i64
  %tobool59 = icmp ne i64 %conv58, 0
  br i1 %tobool59, label %cond.true60, label %cond.false61

cond.true60:                                      ; preds = %cond.end50
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3041, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end62

cond.false61:                                     ; preds = %cond.end50
  br label %cond.end62

cond.end62:                                       ; preds = %cond.false61, %30
  %31 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8
  %call63 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.55, i32 0, i32 0))
  %call64 = call signext i8 @class_addMethod(%struct.objc_class* %31, %struct.objc_selector* %call63, void ()* bitcast (void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)* @windowDidBecomeKey to void ()*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.54, i32 0, i32 0))
  %tobool65 = icmp ne i8 %call64, 0
  %frombool66 = zext i1 %tobool65 to i8
  store i8 %frombool66, i8* %resultAddMethod, align 1
  %32 = load i8, i8* %resultAddMethod, align 1
  %tobool67 = trunc i8 %32 to i1
  %lnot68 = xor i1 %tobool67, true
  %lnot.ext69 = zext i1 %lnot68 to i32
  %conv70 = sext i32 %lnot.ext69 to i64
  %tobool71 = icmp ne i64 %conv70, 0
  br i1 %tobool71, label %cond.true72, label %cond.false73

cond.true72:                                      ; preds = %cond.end62
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3043, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end74

cond.false73:                                     ; preds = %cond.end62
  br label %cond.end74

cond.end74:                                       ; preds = %cond.false73, %33
  %34 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8
  %35 = bitcast %struct.objc_class* %34 to %struct.objc_object*
  %call75 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call76 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %35, %struct.objc_selector* %call75)
  store %struct.objc_object* %call76, %struct.objc_object** %wdgAlloc, align 8
  %36 = load %struct.objc_object*, %struct.objc_object** %wdgAlloc, align 8
  %call77 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call78 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %36, %struct.objc_selector* %call77)
  store %struct.objc_object* %call78, %struct.objc_object** %wdg, align 8
  %37 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  %call79 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %37, %struct.objc_selector* %call79)
  %38 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call80 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.24, i32 0, i32 0))
  %39 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %38, %struct.objc_selector* %call80, %struct.objc_object* %39)
  %40 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call81 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0))
  %call82 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %40, %struct.objc_selector* %call81)
  store %struct.objc_object* %call82, %struct.objc_object** %contentView, align 8
  %41 = load i32, i32* %flags.addr, align 4
  %and83 = and i32 %41, 16
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %if.end87

if.then85:                                        ; preds = %cond.end74
  %42 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8
  %call86 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.56, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %42, %struct.objc_selector* %call86, i8 signext 1)
  br label %if.end87

if.end87:                                         ; preds = %if.then85, %cond.end74
  %43 = bitcast %struct.CGPoint* %point to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 bitcast (%struct.CGPoint* @tigrWindow.point to i8*), i64 16, i1 false)
  %44 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call88 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.57, i32 0, i32 0))
  %45 = bitcast %struct.CGPoint* %point to { double, double }*
  %46 = getelementptr inbounds { double, double }, { double, double }* %45, i32 0, i32 0
  %47 = load double, double* %46, align 8
  %48 = getelementptr inbounds { double, double }, { double, double }* %45, i32 0, i32 1
  %49 = load double, double* %48, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, double, double)*)(%struct.objc_object* %44, %struct.objc_selector* %call88, double %47, double %49)
  %call89 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0))
  %50 = bitcast %struct.objc_class* %call89 to %struct.objc_object*
  %call90 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34, i32 0, i32 0))
  %51 = load i8*, i8** %title.addr, align 8
  %call91 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i8*)*)(%struct.objc_object* %50, %struct.objc_selector* %call90, i8* %51)
  store %struct.objc_object* %call91, %struct.objc_object** %titleString, align 8
  %52 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call92 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.58, i32 0, i32 0))
  %53 = load %struct.objc_object*, %struct.objc_object** %titleString, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %52, %struct.objc_selector* %call92, %struct.objc_object* %53)
  %54 = bitcast [9 x i32]* %glAttributes to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %54, i8* align 16 bitcast ([9 x i32]* @tigrWindow.glAttributes to i8*), i64 36, i1 false)
  %call93 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.59, i32 0, i32 0))
  %55 = bitcast %struct.objc_class* %call93 to %struct.objc_object*
  %call94 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call95 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %55, %struct.objc_selector* %call94)
  store %struct.objc_object* %call95, %struct.objc_object** %pixelFormatAlloc, align 8
  %56 = load %struct.objc_object*, %struct.objc_object** %pixelFormatAlloc, align 8
  %call96 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.60, i32 0, i32 0))
  %arraydecay = getelementptr inbounds [9 x i32], [9 x i32]* %glAttributes, i32 0, i32 0
  %call97 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i32*)*)(%struct.objc_object* %56, %struct.objc_selector* %call96, i32* %arraydecay)
  store %struct.objc_object* %call97, %struct.objc_object** %pixelFormat, align 8
  %57 = load %struct.objc_object*, %struct.objc_object** %pixelFormat, align 8
  %call98 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %57, %struct.objc_selector* %call98)
  %call99 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.61, i32 0, i32 0))
  %58 = bitcast %struct.objc_class* %call99 to %struct.objc_object*
  %call100 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call101 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %58, %struct.objc_selector* %call100)
  store %struct.objc_object* %call101, %struct.objc_object** %openGLContextAlloc, align 8
  %59 = load %struct.objc_object*, %struct.objc_object** %openGLContextAlloc, align 8
  %call102 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.62, i32 0, i32 0))
  %60 = load %struct.objc_object*, %struct.objc_object** %pixelFormat, align 8
  %call103 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*, %struct.objc_object*)*)(%struct.objc_object* %59, %struct.objc_selector* %call102, %struct.objc_object* %60, %struct.objc_object* null)
  store %struct.objc_object* %call103, %struct.objc_object** %openGLContext, align 8
  %61 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %call104 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %61, %struct.objc_selector* %call104)
  %62 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %call105 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.63, i32 0, i32 0))
  %63 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %62, %struct.objc_selector* %call105, %struct.objc_object* %63)
  %64 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call106 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.64, i32 0, i32 0))
  %65 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %64, %struct.objc_selector* %call106, %struct.objc_object* %65)
  %66 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call107 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.65, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %66, %struct.objc_selector* %call107, i8 signext 1)
  %call108 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.66, i32 0, i32 0))
  %67 = bitcast %struct.objc_class* %call108 to %struct.objc_object*
  %call109 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.67, i32 0, i32 0))
  %call110 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %67, %struct.objc_selector* %call109)
  store %struct.objc_object* %call110, %struct.objc_object** %blackColor, align 8
  %68 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call111 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.68, i32 0, i32 0))
  %69 = load %struct.objc_object*, %struct.objc_object** %blackColor, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %68, %struct.objc_selector* %call111, %struct.objc_object* %69)
  %70 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call112 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.69, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %70, %struct.objc_selector* %call112, i8 signext 1)
  %71 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call113 = call { double, double } @_tigrCocoaWindowSize(%struct.objc_object* %71)
  %72 = bitcast %struct.CGSize* %windowSize to { double, double }*
  %73 = getelementptr inbounds { double, double }, { double, double }* %72, i32 0, i32 0
  %74 = extractvalue { double, double } %call113, 0
  store double %74, double* %73, align 8
  %75 = getelementptr inbounds { double, double }, { double, double }* %72, i32 0, i32 1
  %76 = extractvalue { double, double } %call113, 1
  store double %76, double* %75, align 8
  %width114 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %77 = load double, double* %width114, align 8
  %78 = load i32, i32* %scale, align 4
  %conv115 = sitofp i32 %78 to double
  %div116 = fdiv double %77, %conv115
  %conv117 = fptosi double %div116 to i32
  %height118 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %79 = load double, double* %height118, align 8
  %80 = load i32, i32* %scale, align 4
  %conv119 = sitofp i32 %80 to double
  %div120 = fdiv double %79, %conv119
  %conv121 = fptosi double %div120 to i32
  %call122 = call %struct.Tigr* @tigrBitmap2(i32 %conv117, i32 %conv121, i32 632)
  store %struct.Tigr* %call122, %struct.Tigr** %bmp, align 8
  %81 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %82 = bitcast %struct.objc_object* %81 to i8*
  %83 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %83, i32 0, i32 3
  store i8* %82, i8** %handle, align 8
  %84 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8
  %85 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %86 = bitcast %struct.Tigr* %85 to i8*
  %call123 = call %struct.objc_ivar* @object_setInstanceVariable(%struct.objc_object* %84, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i8* %86)
  %87 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %call124 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %87)
  store %struct.TigrInternal* %call124, %struct.TigrInternal** %win, align 8
  %88 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %89 = bitcast %struct.objc_object* %88 to i8*
  %90 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %glContext = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %90, i32 0, i32 3
  store i8* %89, i8** %glContext, align 8
  %91 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %shown = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %91, i32 0, i32 0
  store i32 0, i32* %shown, align 8
  %92 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %closed = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %92, i32 0, i32 1
  store i32 0, i32* %closed, align 4
  %93 = load i32, i32* %scale, align 4
  %94 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale125 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %94, i32 0, i32 13
  store i32 %93, i32* %scale125, align 8
  %95 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %95, i32 0, i32 15
  store i32 0, i32* %lastChar, align 4
  %96 = load i32, i32* %flags.addr, align 4
  %97 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %flags126 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %97, i32 0, i32 12
  store i32 %96, i32* %flags126, align 4
  %98 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %vblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %98, i32 0, i32 9
  store i32 0, i32* %vblur, align 8
  %99 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %hblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %99, i32 0, i32 8
  store i32 0, i32* %hblur, align 4
  %100 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scanlines = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %100, i32 0, i32 10
  store float 0.000000e+00, float* %scanlines, align 4
  %101 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %contrast = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %101, i32 0, i32 11
  store float 1.000000e+00, float* %contrast, align 8
  %102 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgetsWanted = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %102, i32 0, i32 5
  store i32 0, i32* %widgetsWanted, align 8
  %103 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgetAlpha = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %103, i32 0, i32 6
  store i8 0, i8* %widgetAlpha, align 4
  %104 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgetsScale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %104, i32 0, i32 7
  store float 0.000000e+00, float* %widgetsScale, align 8
  %call127 = call %struct.Tigr* @tigrBitmap(i32 40, i32 14)
  %105 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgets = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %105, i32 0, i32 4
  store %struct.Tigr* %call127, %struct.Tigr** %widgets, align 8
  %106 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %gl = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %106, i32 0, i32 2
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %gl, i32 0, i32 6
  store i32 0, i32* %gl_legacy, align 4
  %107 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %107, i32 0, i32 18
  store i32 0, i32* %mouseButtons, align 8
  %108 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %109 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale128 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %109, i32 0, i32 13
  %110 = load i32, i32* %scale128, align 8
  %111 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %w129 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %111, i32 0, i32 0
  %112 = load i32, i32* %w129, align 8
  %113 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %h130 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %113, i32 0, i32 1
  %114 = load i32, i32* %h130, align 4
  %115 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %115, i32 0, i32 14
  %arraydecay131 = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i32 0, i32 0
  call void @tigrPosition(%struct.Tigr* %108, i32 %110, i32 %112, i32 %114, i32* %arraydecay131)
  %116 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %call132 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %116, %struct.objc_selector* %call132)
  %117 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  call void @tigrGAPICreate(%struct.Tigr* %117)
  %118 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  call void @tigrGAPIBegin(%struct.Tigr* %118)
  %119 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %120 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %w133 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %120, i32 0, i32 0
  %121 = load i32, i32* %w133, align 8
  %122 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  %h134 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %122, i32 0, i32 1
  %123 = load i32, i32* %h134, align 4
  call void @tigrGAPIResize(%struct.Tigr* %119, i32 %121, i32 %123)
  %124 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8
  ret %struct.Tigr* %124
}

declare void @CGDisplayBounds(%struct.CGRect* sret, i32) #4

declare i32 @CGMainDisplayID() #4

declare double @CGRectGetHeight(%struct.CGRect* byval align 8) #4

declare double @CGRectGetWidth(%struct.CGRect* byval align 8) #4

declare signext i8 @class_addIvar(%struct.objc_class*, i8*, i64, i8 zeroext, i8*) #4

; Function Attrs: nounwind readnone speculatable
declare double @llvm.log2.f64(double) #3

; Function Attrs: nounwind readnone speculatable
declare double @llvm.rint.f64(double) #3

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPICreate(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %vs = alloca i32, align 4
  %fs = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %gl = alloca %struct.GLStuff*, align 8
  %VBO = alloca i32, align 4
  %vertices = alloca [24 x float], align 16
  %vs_source = alloca i8*, align 8
  %fs_source = alloca i8*, align 8
  %i = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %gl1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %1, i32 0, i32 2
  store %struct.GLStuff* %gl1, %struct.GLStuff** %gl, align 8
  %2 = bitcast [24 x float]* %vertices to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %2, i8* align 16 bitcast ([24 x float]* @tigrGAPICreate.vertices to i8*), i64 96, i1 false)
  %3 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %3, i32 0, i32 6
  %4 = load i32, i32* %gl_legacy, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %vao = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %5, i32 0, i32 1
  call void @glGenVertexArrays(i32 1, i32* %vao)
  call void @glGenBuffers(i32 1, i32* %VBO)
  %6 = load i32, i32* %VBO, align 4
  call void @glBindBuffer(i32 34962, i32 %6)
  %arraydecay = getelementptr inbounds [24 x float], [24 x float]* %vertices, i32 0, i32 0
  %7 = bitcast float* %arraydecay to i8*
  call void @glBufferData(i32 34962, i64 96, i8* %7, i32 35044)
  %8 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %vao2 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %8, i32 0, i32 1
  %9 = load i32, i32* %vao2, align 4
  call void @glBindVertexArray(i32 %9)
  call void @glEnableVertexAttribArray(i32 0)
  call void @glEnableVertexAttribArray(i32 1)
  call void @glVertexAttribPointer(i32 0, i32 2, i32 5126, i8 zeroext 0, i32 16, i8* null)
  call void @glVertexAttribPointer(i32 1, i32 2, i32 5126, i8 zeroext 0, i32 16, i8* null)
  %call3 = call i32 @glCreateShader(i32 35633)
  store i32 %call3, i32* %vs, align 4
  store i8* getelementptr inbounds ([259 x i8], [259 x i8]* @tigr_upscale_gl_vs, i32 0, i32 0), i8** %vs_source, align 8
  %10 = load i32, i32* %vs, align 4
  call void @glShaderSource(i32 %10, i32 1, i8** %vs_source, i32* @tigr_upscale_gl_vs_size)
  %11 = load i32, i32* %vs, align 4
  call void @glCompileShader(i32 %11)
  %12 = load i32, i32* %vs, align 4
  call void @tigrCheckShaderErrors(i32 %12)
  %call4 = call i32 @glCreateShader(i32 35632)
  store i32 %call4, i32* %fs, align 4
  store i8* getelementptr inbounds ([444 x i8], [444 x i8]* @tigr_upscale_gl_fs, i32 0, i32 0), i8** %fs_source, align 8
  %13 = load i32, i32* %fs, align 4
  call void @glShaderSource(i32 %13, i32 1, i8** %fs_source, i32* @tigr_upscale_gl_fs_size)
  %14 = load i32, i32* %fs, align 4
  call void @glCompileShader(i32 %14)
  %15 = load i32, i32* %fs, align 4
  call void @tigrCheckShaderErrors(i32 %15)
  %call5 = call i32 @glCreateProgram()
  %16 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %16, i32 0, i32 2
  store i32 %call5, i32* %program, align 4
  %17 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program6 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %17, i32 0, i32 2
  %18 = load i32, i32* %program6, align 4
  %19 = load i32, i32* %vs, align 4
  call void @glAttachShader(i32 %18, i32 %19)
  %20 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program7 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %20, i32 0, i32 2
  %21 = load i32, i32* %program7, align 4
  %22 = load i32, i32* %fs, align 4
  call void @glAttachShader(i32 %21, i32 %22)
  %23 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program8 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %23, i32 0, i32 2
  %24 = load i32, i32* %program8, align 4
  call void @glLinkProgram(i32 %24)
  %25 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program9 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %25, i32 0, i32 2
  %26 = load i32, i32* %program9, align 4
  call void @tigrCheckProgramErrors(i32 %26)
  %27 = load i32, i32* %vs, align 4
  call void @glDeleteShader(i32 %27)
  %28 = load i32, i32* %fs, align 4
  call void @glDeleteShader(i32 %28)
  %29 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program10 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %29, i32 0, i32 2
  %30 = load i32, i32* %program10, align 4
  %call11 = call i32 @glGetUniformLocation(i32 %30, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.91, i32 0, i32 0))
  %31 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_projection = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %31, i32 0, i32 3
  store i32 %call11, i32* %uniform_projection, align 4
  %32 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program12 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %32, i32 0, i32 2
  %33 = load i32, i32* %program12, align 4
  %call13 = call i32 @glGetUniformLocation(i32 %33, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.92, i32 0, i32 0))
  %34 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_model = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %34, i32 0, i32 4
  store i32 %call13, i32* %uniform_model, align 4
  %35 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program14 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %35, i32 0, i32 2
  %36 = load i32, i32* %program14, align 4
  %call15 = call i32 @glGetUniformLocation(i32 %36, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.93, i32 0, i32 0))
  %37 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_parameters = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %37, i32 0, i32 5
  store i32 %call15, i32* %uniform_parameters, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %38 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy16 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %38, i32 0, i32 6
  %39 = load i32, i32* %gl_legacy16, align 4
  %tobool17 = icmp ne i32 %39, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  call void @glEnable(i32 3553)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end
  %40 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %tex = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %40, i32 0, i32 0
  %arraydecay20 = getelementptr inbounds [2 x i32], [2 x i32]* %tex, i32 0, i32 0
  call void @glGenTextures(i32 2, i32* %arraydecay20)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %41 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %41, 2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %42 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %tex21 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %42, i32 0, i32 0
  %43 = load i32, i32* %i, align 4
  %idxprom = sext i32 %43 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %tex21, i64 0, i64 %idxprom
  %44 = load i32, i32* %arrayidx, align 4
  call void @glBindTexture(i32 3553, i32 %44)
  %45 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy22 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %45, i32 0, i32 6
  %46 = load i32, i32* %gl_legacy22, align 4
  %tobool23 = icmp ne i32 %46, 0
  %47 = zext i1 %tobool23 to i64
  %cond = select i1 %tobool23, i32 9728, i32 9729
  call void @glTexParameteri(i32 3553, i32 10241, i32 %cond)
  %48 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy24 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %48, i32 0, i32 6
  %49 = load i32, i32* %gl_legacy24, align 4
  %tobool25 = icmp ne i32 %49, 0
  %50 = zext i1 %tobool25 to i64
  %cond26 = select i1 %tobool25, i32 9728, i32 9729
  call void @glTexParameteri(i32 3553, i32 10240, i32 %cond26)
  call void @glPixelStorei(i32 3314, i32 0)
  call void @glPixelStorei(i32 3317, i32 1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %51 = load i32, i32* %i, align 4
  %inc = add nsw i32 %51, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @tigrCheckGLError(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.94, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPIBegin(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPIResize(%struct.Tigr* %bmp, i32 %width, i32 %height) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %width, i32* %width.addr, align 4
  store i32 %height, i32* %height.addr, align 4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %1 = load i32, i32* %width.addr, align 4
  %2 = load i32, i32* %height.addr, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPIEnd(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPIDestroy(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %gl = alloca %struct.GLStuff*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %gl1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %1, i32 0, i32 2
  store %struct.GLStuff* %gl1, %struct.GLStuff** %gl, align 8
  %2 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %2, i32 0, i32 6
  %3 = load i32, i32* %gl_legacy, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %tex = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %tex, i32 0, i32 0
  call void @glDeleteTextures(i32 2, i32* %arraydecay)
  %5 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %5, i32 0, i32 2
  %6 = load i32, i32* %program, align 4
  call void @glDeleteProgram(i32 %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @tigrCheckGLError(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.95, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i8 @_tigrKeyFromOSX(i16 zeroext %key) #0 {
entry:
  %retval = alloca i8, align 1
  %key.addr = alloca i16, align 2
  store i16 %key, i16* %key.addr, align 2
  %0 = load i16, i16* %key.addr, align 2
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 12, label %sw.bb
    i32 13, label %sw.bb1
    i32 14, label %sw.bb2
    i32 15, label %sw.bb3
    i32 17, label %sw.bb4
    i32 16, label %sw.bb5
    i32 32, label %sw.bb6
    i32 34, label %sw.bb7
    i32 31, label %sw.bb8
    i32 35, label %sw.bb9
    i32 0, label %sw.bb10
    i32 1, label %sw.bb11
    i32 2, label %sw.bb12
    i32 3, label %sw.bb13
    i32 5, label %sw.bb14
    i32 4, label %sw.bb15
    i32 38, label %sw.bb16
    i32 40, label %sw.bb17
    i32 37, label %sw.bb18
    i32 6, label %sw.bb19
    i32 7, label %sw.bb20
    i32 8, label %sw.bb21
    i32 9, label %sw.bb22
    i32 11, label %sw.bb23
    i32 45, label %sw.bb24
    i32 46, label %sw.bb25
    i32 29, label %sw.bb26
    i32 18, label %sw.bb27
    i32 19, label %sw.bb28
    i32 20, label %sw.bb29
    i32 21, label %sw.bb30
    i32 23, label %sw.bb31
    i32 22, label %sw.bb32
    i32 26, label %sw.bb33
    i32 28, label %sw.bb34
    i32 25, label %sw.bb35
    i32 82, label %sw.bb36
    i32 83, label %sw.bb37
    i32 84, label %sw.bb38
    i32 85, label %sw.bb39
    i32 86, label %sw.bb40
    i32 87, label %sw.bb41
    i32 88, label %sw.bb42
    i32 89, label %sw.bb43
    i32 91, label %sw.bb44
    i32 92, label %sw.bb45
    i32 67, label %sw.bb46
    i32 69, label %sw.bb47
    i32 76, label %sw.bb48
    i32 78, label %sw.bb49
    i32 65, label %sw.bb50
    i32 75, label %sw.bb51
    i32 122, label %sw.bb52
    i32 120, label %sw.bb53
    i32 99, label %sw.bb54
    i32 118, label %sw.bb55
    i32 96, label %sw.bb56
    i32 97, label %sw.bb57
    i32 98, label %sw.bb58
    i32 100, label %sw.bb59
    i32 101, label %sw.bb60
    i32 109, label %sw.bb61
    i32 103, label %sw.bb62
    i32 111, label %sw.bb63
    i32 56, label %sw.bb64
    i32 59, label %sw.bb65
    i32 58, label %sw.bb66
    i32 57, label %sw.bb67
    i32 55, label %sw.bb68
    i32 54, label %sw.bb69
    i32 60, label %sw.bb70
    i32 62, label %sw.bb71
    i32 61, label %sw.bb72
    i32 51, label %sw.bb73
    i32 48, label %sw.bb74
    i32 36, label %sw.bb75
    i32 53, label %sw.bb76
    i32 49, label %sw.bb77
    i32 116, label %sw.bb78
    i32 121, label %sw.bb79
    i32 119, label %sw.bb80
    i32 115, label %sw.bb81
    i32 123, label %sw.bb82
    i32 126, label %sw.bb83
    i32 124, label %sw.bb84
    i32 125, label %sw.bb85
    i32 114, label %sw.bb86
    i32 117, label %sw.bb87
    i32 107, label %sw.bb88
    i32 113, label %sw.bb89
    i32 71, label %sw.bb90
    i32 41, label %sw.bb91
    i32 24, label %sw.bb92
    i32 43, label %sw.bb93
    i32 27, label %sw.bb94
    i32 44, label %sw.bb95
    i32 42, label %sw.bb96
    i32 50, label %sw.bb97
    i32 39, label %sw.bb98
    i32 33, label %sw.bb99
    i32 30, label %sw.bb100
    i32 47, label %sw.bb101
  ]

sw.bb:                                            ; preds = %entry
  store i8 81, i8* %retval, align 1
  br label %return

sw.bb1:                                           ; preds = %entry
  store i8 87, i8* %retval, align 1
  br label %return

sw.bb2:                                           ; preds = %entry
  store i8 69, i8* %retval, align 1
  br label %return

sw.bb3:                                           ; preds = %entry
  store i8 82, i8* %retval, align 1
  br label %return

sw.bb4:                                           ; preds = %entry
  store i8 84, i8* %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry
  store i8 89, i8* %retval, align 1
  br label %return

sw.bb6:                                           ; preds = %entry
  store i8 85, i8* %retval, align 1
  br label %return

sw.bb7:                                           ; preds = %entry
  store i8 73, i8* %retval, align 1
  br label %return

sw.bb8:                                           ; preds = %entry
  store i8 79, i8* %retval, align 1
  br label %return

sw.bb9:                                           ; preds = %entry
  store i8 80, i8* %retval, align 1
  br label %return

sw.bb10:                                          ; preds = %entry
  store i8 65, i8* %retval, align 1
  br label %return

sw.bb11:                                          ; preds = %entry
  store i8 83, i8* %retval, align 1
  br label %return

sw.bb12:                                          ; preds = %entry
  store i8 68, i8* %retval, align 1
  br label %return

sw.bb13:                                          ; preds = %entry
  store i8 70, i8* %retval, align 1
  br label %return

sw.bb14:                                          ; preds = %entry
  store i8 71, i8* %retval, align 1
  br label %return

sw.bb15:                                          ; preds = %entry
  store i8 72, i8* %retval, align 1
  br label %return

sw.bb16:                                          ; preds = %entry
  store i8 74, i8* %retval, align 1
  br label %return

sw.bb17:                                          ; preds = %entry
  store i8 75, i8* %retval, align 1
  br label %return

sw.bb18:                                          ; preds = %entry
  store i8 76, i8* %retval, align 1
  br label %return

sw.bb19:                                          ; preds = %entry
  store i8 90, i8* %retval, align 1
  br label %return

sw.bb20:                                          ; preds = %entry
  store i8 88, i8* %retval, align 1
  br label %return

sw.bb21:                                          ; preds = %entry
  store i8 67, i8* %retval, align 1
  br label %return

sw.bb22:                                          ; preds = %entry
  store i8 86, i8* %retval, align 1
  br label %return

sw.bb23:                                          ; preds = %entry
  store i8 66, i8* %retval, align 1
  br label %return

sw.bb24:                                          ; preds = %entry
  store i8 78, i8* %retval, align 1
  br label %return

sw.bb25:                                          ; preds = %entry
  store i8 77, i8* %retval, align 1
  br label %return

sw.bb26:                                          ; preds = %entry
  store i8 48, i8* %retval, align 1
  br label %return

sw.bb27:                                          ; preds = %entry
  store i8 49, i8* %retval, align 1
  br label %return

sw.bb28:                                          ; preds = %entry
  store i8 50, i8* %retval, align 1
  br label %return

sw.bb29:                                          ; preds = %entry
  store i8 51, i8* %retval, align 1
  br label %return

sw.bb30:                                          ; preds = %entry
  store i8 52, i8* %retval, align 1
  br label %return

sw.bb31:                                          ; preds = %entry
  store i8 53, i8* %retval, align 1
  br label %return

sw.bb32:                                          ; preds = %entry
  store i8 54, i8* %retval, align 1
  br label %return

sw.bb33:                                          ; preds = %entry
  store i8 55, i8* %retval, align 1
  br label %return

sw.bb34:                                          ; preds = %entry
  store i8 56, i8* %retval, align 1
  br label %return

sw.bb35:                                          ; preds = %entry
  store i8 57, i8* %retval, align 1
  br label %return

sw.bb36:                                          ; preds = %entry
  store i8 -128, i8* %retval, align 1
  br label %return

sw.bb37:                                          ; preds = %entry
  store i8 -127, i8* %retval, align 1
  br label %return

sw.bb38:                                          ; preds = %entry
  store i8 -126, i8* %retval, align 1
  br label %return

sw.bb39:                                          ; preds = %entry
  store i8 -125, i8* %retval, align 1
  br label %return

sw.bb40:                                          ; preds = %entry
  store i8 -124, i8* %retval, align 1
  br label %return

sw.bb41:                                          ; preds = %entry
  store i8 -123, i8* %retval, align 1
  br label %return

sw.bb42:                                          ; preds = %entry
  store i8 -122, i8* %retval, align 1
  br label %return

sw.bb43:                                          ; preds = %entry
  store i8 -121, i8* %retval, align 1
  br label %return

sw.bb44:                                          ; preds = %entry
  store i8 -120, i8* %retval, align 1
  br label %return

sw.bb45:                                          ; preds = %entry
  store i8 -119, i8* %retval, align 1
  br label %return

sw.bb46:                                          ; preds = %entry
  store i8 -118, i8* %retval, align 1
  br label %return

sw.bb47:                                          ; preds = %entry
  store i8 -117, i8* %retval, align 1
  br label %return

sw.bb48:                                          ; preds = %entry
  store i8 -116, i8* %retval, align 1
  br label %return

sw.bb49:                                          ; preds = %entry
  store i8 -115, i8* %retval, align 1
  br label %return

sw.bb50:                                          ; preds = %entry
  store i8 -114, i8* %retval, align 1
  br label %return

sw.bb51:                                          ; preds = %entry
  store i8 -113, i8* %retval, align 1
  br label %return

sw.bb52:                                          ; preds = %entry
  store i8 -112, i8* %retval, align 1
  br label %return

sw.bb53:                                          ; preds = %entry
  store i8 -111, i8* %retval, align 1
  br label %return

sw.bb54:                                          ; preds = %entry
  store i8 -110, i8* %retval, align 1
  br label %return

sw.bb55:                                          ; preds = %entry
  store i8 -109, i8* %retval, align 1
  br label %return

sw.bb56:                                          ; preds = %entry
  store i8 -108, i8* %retval, align 1
  br label %return

sw.bb57:                                          ; preds = %entry
  store i8 -107, i8* %retval, align 1
  br label %return

sw.bb58:                                          ; preds = %entry
  store i8 -106, i8* %retval, align 1
  br label %return

sw.bb59:                                          ; preds = %entry
  store i8 -105, i8* %retval, align 1
  br label %return

sw.bb60:                                          ; preds = %entry
  store i8 -104, i8* %retval, align 1
  br label %return

sw.bb61:                                          ; preds = %entry
  store i8 -103, i8* %retval, align 1
  br label %return

sw.bb62:                                          ; preds = %entry
  store i8 -102, i8* %retval, align 1
  br label %return

sw.bb63:                                          ; preds = %entry
  store i8 -101, i8* %retval, align 1
  br label %return

sw.bb64:                                          ; preds = %entry
  store i8 -76, i8* %retval, align 1
  br label %return

sw.bb65:                                          ; preds = %entry
  store i8 -74, i8* %retval, align 1
  br label %return

sw.bb66:                                          ; preds = %entry
  store i8 -72, i8* %retval, align 1
  br label %return

sw.bb67:                                          ; preds = %entry
  store i8 -93, i8* %retval, align 1
  br label %return

sw.bb68:                                          ; preds = %entry
  store i8 -80, i8* %retval, align 1
  br label %return

sw.bb69:                                          ; preds = %entry
  store i8 -79, i8* %retval, align 1
  br label %return

sw.bb70:                                          ; preds = %entry
  store i8 -75, i8* %retval, align 1
  br label %return

sw.bb71:                                          ; preds = %entry
  store i8 -73, i8* %retval, align 1
  br label %return

sw.bb72:                                          ; preds = %entry
  store i8 -71, i8* %retval, align 1
  br label %return

sw.bb73:                                          ; preds = %entry
  store i8 -100, i8* %retval, align 1
  br label %return

sw.bb74:                                          ; preds = %entry
  store i8 -99, i8* %retval, align 1
  br label %return

sw.bb75:                                          ; preds = %entry
  store i8 -98, i8* %retval, align 1
  br label %return

sw.bb76:                                          ; preds = %entry
  store i8 -92, i8* %retval, align 1
  br label %return

sw.bb77:                                          ; preds = %entry
  store i8 -91, i8* %retval, align 1
  br label %return

sw.bb78:                                          ; preds = %entry
  store i8 -90, i8* %retval, align 1
  br label %return

sw.bb79:                                          ; preds = %entry
  store i8 -89, i8* %retval, align 1
  br label %return

sw.bb80:                                          ; preds = %entry
  store i8 -88, i8* %retval, align 1
  br label %return

sw.bb81:                                          ; preds = %entry
  store i8 -87, i8* %retval, align 1
  br label %return

sw.bb82:                                          ; preds = %entry
  store i8 -86, i8* %retval, align 1
  br label %return

sw.bb83:                                          ; preds = %entry
  store i8 -85, i8* %retval, align 1
  br label %return

sw.bb84:                                          ; preds = %entry
  store i8 -84, i8* %retval, align 1
  br label %return

sw.bb85:                                          ; preds = %entry
  store i8 -83, i8* %retval, align 1
  br label %return

sw.bb86:                                          ; preds = %entry
  store i8 -82, i8* %retval, align 1
  br label %return

sw.bb87:                                          ; preds = %entry
  store i8 -81, i8* %retval, align 1
  br label %return

sw.bb88:                                          ; preds = %entry
  store i8 -77, i8* %retval, align 1
  br label %return

sw.bb89:                                          ; preds = %entry
  store i8 -94, i8* %retval, align 1
  br label %return

sw.bb90:                                          ; preds = %entry
  store i8 -78, i8* %retval, align 1
  br label %return

sw.bb91:                                          ; preds = %entry
  store i8 -70, i8* %retval, align 1
  br label %return

sw.bb92:                                          ; preds = %entry
  store i8 -69, i8* %retval, align 1
  br label %return

sw.bb93:                                          ; preds = %entry
  store i8 -68, i8* %retval, align 1
  br label %return

sw.bb94:                                          ; preds = %entry
  store i8 -67, i8* %retval, align 1
  br label %return

sw.bb95:                                          ; preds = %entry
  store i8 -65, i8* %retval, align 1
  br label %return

sw.bb96:                                          ; preds = %entry
  store i8 -62, i8* %retval, align 1
  br label %return

sw.bb97:                                          ; preds = %entry
  store i8 -64, i8* %retval, align 1
  br label %return

sw.bb98:                                          ; preds = %entry
  store i8 -60, i8* %retval, align 1
  br label %return

sw.bb99:                                          ; preds = %entry
  store i8 -63, i8* %retval, align 1
  br label %return

sw.bb100:                                         ; preds = %entry
  store i8 -61, i8* %retval, align 1
  br label %return

sw.bb101:                                         ; preds = %entry
  store i8 -66, i8* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i8 0, i8* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb101, %sw.bb100, %sw.bb99, %sw.bb98, %sw.bb97, %sw.bb96, %sw.bb95, %sw.bb94, %sw.bb93, %sw.bb92, %sw.bb91, %sw.bb90, %sw.bb89, %sw.bb88, %sw.bb87, %sw.bb86, %sw.bb85, %sw.bb84, %sw.bb83, %sw.bb82, %sw.bb81, %sw.bb80, %sw.bb79, %sw.bb78, %sw.bb77, %sw.bb76, %sw.bb75, %sw.bb74, %sw.bb73, %sw.bb72, %sw.bb71, %sw.bb70, %sw.bb69, %sw.bb68, %sw.bb67, %sw.bb66, %sw.bb65, %sw.bb64, %sw.bb63, %sw.bb62, %sw.bb61, %sw.bb60, %sw.bb59, %sw.bb58, %sw.bb57, %sw.bb56, %sw.bb55, %sw.bb54, %sw.bb53, %sw.bb52, %sw.bb51, %sw.bb50, %sw.bb49, %sw.bb48, %sw.bb47, %sw.bb46, %sw.bb45, %sw.bb44, %sw.bb43, %sw.bb42, %sw.bb41, %sw.bb40, %sw.bb39, %sw.bb38, %sw.bb37, %sw.bb36, %sw.bb35, %sw.bb34, %sw.bb33, %sw.bb32, %sw.bb31, %sw.bb30, %sw.bb29, %sw.bb28, %sw.bb27, %sw.bb26, %sw.bb25, %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb21, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load i8, i8* %retval, align 1
  ret i8 %1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_tigrOnCocoaEvent(%struct.objc_object* %event, %struct.objc_object* %window) #0 {
entry:
  %event.addr = alloca %struct.objc_object*, align 8
  %window.addr = alloca %struct.objc_object*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %eventType = alloca i64, align 8
  %number = alloca i64, align 8
  %number23 = alloca i64, align 8
  %modifiers = alloca i64, align 8
  %keys = alloca %struct.anon, align 1
  %inputText = alloca %struct.objc_object*, align 8
  %inputTextUTF8 = alloca i8*, align 8
  %keyCode = alloca i16, align 2
  %keyCode72 = alloca i16, align 2
  store %struct.objc_object* %event, %struct.objc_object** %event.addr, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8
  %0 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %tobool = icmp ne %struct.objc_object* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8
  %call = call %struct.TigrInternal* @_tigrInternalCocoa(%struct.objc_object* %1)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %2 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %tobool1 = icmp ne %struct.TigrInternal* %2, null
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %3 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.72, i32 0, i32 0))
  %4 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %3, %struct.objc_selector* %call3, %struct.objc_object* %4)
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call5 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.73, i32 0, i32 0))
  %call6 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %5, %struct.objc_selector* %call5)
  store i64 %call6, i64* %eventType, align 8
  %6 = load i64, i64* %eventType, align 8
  switch i64 %6, label %sw.default [
    i64 1, label %sw.bb
    i64 2, label %sw.bb7
    i64 3, label %sw.bb9
    i64 4, label %sw.bb12
    i64 25, label %sw.bb15
    i64 26, label %sw.bb22
    i64 12, label %sw.bb31
    i64 10, label %sw.bb60
    i64 11, label %sw.bb71
  ]

sw.bb:                                            ; preds = %if.end4
  %7 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %7, i32 0, i32 18
  %8 = load i32, i32* %mouseButtons, align 8
  %or = or i32 %8, 1
  store i32 %or, i32* %mouseButtons, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %if.end4
  %9 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons8 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %9, i32 0, i32 18
  %10 = load i32, i32* %mouseButtons8, align 8
  %and = and i32 %10, -2
  store i32 %and, i32* %mouseButtons8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %if.end4
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons10 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %11, i32 0, i32 18
  %12 = load i32, i32* %mouseButtons10, align 8
  %or11 = or i32 %12, 2
  store i32 %or11, i32* %mouseButtons10, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end4
  %13 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons13 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %13, i32 0, i32 18
  %14 = load i32, i32* %mouseButtons13, align 8
  %and14 = and i32 %14, -3
  store i32 %and14, i32* %mouseButtons13, align 8
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end4
  %15 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call16 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0))
  %call17 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %15, %struct.objc_selector* %call16)
  store i64 %call17, i64* %number, align 8
  %16 = load i64, i64* %number, align 8
  %cmp = icmp eq i64 %16, 2
  br i1 %cmp, label %if.then18, label %if.end21

if.then18:                                        ; preds = %sw.bb15
  %17 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons19 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %17, i32 0, i32 18
  %18 = load i32, i32* %mouseButtons19, align 8
  %or20 = or i32 %18, 4
  store i32 %or20, i32* %mouseButtons19, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %sw.bb15
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end4
  %19 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call24 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0))
  %call25 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %19, %struct.objc_selector* %call24)
  store i64 %call25, i64* %number23, align 8
  %20 = load i64, i64* %number23, align 8
  %cmp26 = icmp eq i64 %20, 2
  br i1 %cmp26, label %if.then27, label %if.end30

if.then27:                                        ; preds = %sw.bb22
  %21 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons28 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %21, i32 0, i32 18
  %22 = load i32, i32* %mouseButtons28, align 8
  %and29 = and i32 %22, -5
  store i32 %and29, i32* %mouseButtons28, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %sw.bb22
  br label %sw.epilog

sw.bb31:                                          ; preds = %if.end4
  %23 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call32 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.75, i32 0, i32 0))
  %call33 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %23, %struct.objc_selector* %call32)
  store i64 %call33, i64* %modifiers, align 8
  %24 = load i64, i64* %modifiers, align 8
  %and34 = and i64 %24, 4294901760
  %shr = lshr i64 %and34, 16
  %conv = trunc i64 %shr to i8
  %25 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %mask = bitcast %union.anon* %25 to i8*
  store i8 %conv, i8* %mask, align 1
  %26 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %27 = bitcast %union.anon* %26 to %struct.anon.0*
  %28 = bitcast %struct.anon.0* %27 to i8*
  %bf.load = load i8, i8* %28, align 1
  %bf.clear = and i8 %bf.load, 1
  %29 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys35 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %29, i32 0, i32 16
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %keys35, i64 0, i64 160
  store i8 %bf.clear, i8* %arrayidx, align 8
  %30 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %31 = bitcast %union.anon* %30 to %struct.anon.0*
  %32 = bitcast %struct.anon.0* %31 to i8*
  %bf.load36 = load i8, i8* %32, align 1
  %bf.lshr = lshr i8 %bf.load36, 1
  %bf.clear37 = and i8 %bf.lshr, 1
  %33 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys38 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %33, i32 0, i32 16
  %arrayidx39 = getelementptr inbounds [256 x i8], [256 x i8]* %keys38, i64 0, i64 159
  store i8 %bf.clear37, i8* %arrayidx39, align 1
  %34 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %35 = bitcast %union.anon* %34 to %struct.anon.0*
  %36 = bitcast %struct.anon.0* %35 to i8*
  %bf.load40 = load i8, i8* %36, align 1
  %bf.lshr41 = lshr i8 %bf.load40, 2
  %bf.clear42 = and i8 %bf.lshr41, 1
  %37 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys43 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %37, i32 0, i32 16
  %arrayidx44 = getelementptr inbounds [256 x i8], [256 x i8]* %keys43, i64 0, i64 160
  store i8 %bf.clear42, i8* %arrayidx44, align 8
  %38 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %39 = bitcast %union.anon* %38 to %struct.anon.0*
  %40 = bitcast %struct.anon.0* %39 to i8*
  %bf.load45 = load i8, i8* %40, align 1
  %bf.lshr46 = lshr i8 %bf.load45, 3
  %bf.clear47 = and i8 %bf.lshr46, 1
  %41 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys48 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %41, i32 0, i32 16
  %arrayidx49 = getelementptr inbounds [256 x i8], [256 x i8]* %keys48, i64 0, i64 161
  store i8 %bf.clear47, i8* %arrayidx49, align 1
  %42 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %43 = bitcast %union.anon* %42 to %struct.anon.0*
  %44 = bitcast %struct.anon.0* %43 to i8*
  %bf.load50 = load i8, i8* %44, align 1
  %bf.lshr51 = lshr i8 %bf.load50, 4
  %bf.clear52 = and i8 %bf.lshr51, 1
  %45 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys53 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %45, i32 0, i32 16
  %arrayidx54 = getelementptr inbounds [256 x i8], [256 x i8]* %keys53, i64 0, i64 176
  store i8 %bf.clear52, i8* %arrayidx54, align 8
  %46 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %47 = bitcast %union.anon* %46 to %struct.anon.0*
  %48 = bitcast %struct.anon.0* %47 to i8*
  %bf.load55 = load i8, i8* %48, align 1
  %bf.lshr56 = lshr i8 %bf.load55, 4
  %bf.clear57 = and i8 %bf.lshr56, 1
  %49 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys58 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %49, i32 0, i32 16
  %arrayidx59 = getelementptr inbounds [256 x i8], [256 x i8]* %keys58, i64 0, i64 177
  store i8 %bf.clear57, i8* %arrayidx59, align 1
  br label %sw.epilog

sw.bb60:                                          ; preds = %if.end4
  %50 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call61 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.76, i32 0, i32 0))
  %call62 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %50, %struct.objc_selector* %call61)
  store %struct.objc_object* %call62, %struct.objc_object** %inputText, align 8
  %51 = load %struct.objc_object*, %struct.objc_object** %inputText, align 8
  %call63 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.77, i32 0, i32 0))
  %call64 = call i8* bitcast (void ()* @objc_msgSend to i8* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %51, %struct.objc_selector* %call63)
  store i8* %call64, i8** %inputTextUTF8, align 8
  %52 = load i8*, i8** %inputTextUTF8, align 8
  %53 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %53, i32 0, i32 15
  %call65 = call i8* @tigrDecodeUTF8(i8* %52, i32* %lastChar)
  %54 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call66 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.78, i32 0, i32 0))
  %call67 = call zeroext i16 bitcast (void ()* @objc_msgSend to i16 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %54, %struct.objc_selector* %call66)
  store i16 %call67, i16* %keyCode, align 2
  %55 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys68 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %55, i32 0, i32 16
  %56 = load i16, i16* %keyCode, align 2
  %call69 = call zeroext i8 @_tigrKeyFromOSX(i16 zeroext %56)
  %idxprom = zext i8 %call69 to i64
  %arrayidx70 = getelementptr inbounds [256 x i8], [256 x i8]* %keys68, i64 0, i64 %idxprom
  store i8 1, i8* %arrayidx70, align 1
  br label %sw.epilog

sw.bb71:                                          ; preds = %if.end4
  %57 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  %call73 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.78, i32 0, i32 0))
  %call74 = call zeroext i16 bitcast (void ()* @objc_msgSend to i16 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %57, %struct.objc_selector* %call73)
  store i16 %call74, i16* %keyCode72, align 2
  %58 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys75 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %58, i32 0, i32 16
  %59 = load i16, i16* %keyCode72, align 2
  %call76 = call zeroext i8 @_tigrKeyFromOSX(i16 zeroext %59)
  %idxprom77 = zext i8 %call76 to i64
  %arrayidx78 = getelementptr inbounds [256 x i8], [256 x i8]* %keys75, i64 0, i64 %idxprom77
  store i8 0, i8* %arrayidx78, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb71, %sw.bb60, %sw.bb31, %if.end30, %if.end21, %sw.bb12, %sw.bb9, %sw.bb7, %sw.bb
  %60 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call79 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.72, i32 0, i32 0))
  %61 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %60, %struct.objc_selector* %call79, %struct.objc_object* %61)
  br label %return

return:                                           ; preds = %sw.epilog, %if.then2, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrUpdate(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %openGLContext = alloca %struct.objc_object*, align 8
  %window = alloca %struct.objc_object*, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  %distantPast = alloca %struct.objc_object*, align 8
  %event = alloca %struct.objc_object*, align 8
  %windowSize = alloca %struct.CGSize, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 3
  %2 = load i8*, i8** %handle, align 8
  %3 = bitcast i8* %2 to %struct.objc_object*
  store %struct.objc_object* %3, %struct.objc_object** %window, align 8
  %4 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %glContext = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %4, i32 0, i32 3
  %5 = load i8*, i8** %glContext, align 8
  %6 = bitcast i8* %5 to %struct.objc_object*
  store %struct.objc_object* %6, %struct.objc_object** %openGLContext, align 8
  %7 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call2 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %7, %struct.objc_selector* %call1)
  store %struct.objc_object* %call2, %struct.objc_object** %keyWindow, align 8
  %8 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8
  %9 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %cmp = icmp eq %struct.objc_object* %8, %9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %prev = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %10, i32 0, i32 17
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %prev, i32 0, i32 0
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %11, i32 0, i32 16
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i32 0, i32 0
  %12 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %prev4 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %12, i32 0, i32 17
  %arraydecay5 = getelementptr inbounds [256 x i8], [256 x i8]* %prev4, i32 0, i32 0
  %13 = call i64 @llvm.objectsize.i64.p0i8(i8* %arraydecay5, i1 false, i1 true)
  %call6 = call i8* @__memcpy_chk(i8* %arraydecay, i8* %arraydecay3, i64 256, i64 %13) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call7 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.80, i32 0, i32 0))
  %14 = bitcast %struct.objc_class* %call7 to %struct.objc_object*
  %call8 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.81, i32 0, i32 0))
  %call9 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %14, %struct.objc_selector* %call8)
  store %struct.objc_object* %call9, %struct.objc_object** %distantPast, align 8
  %15 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call10 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.82, i32 0, i32 0))
  %16 = load %struct.objc_object*, %struct.objc_object** %distantPast, align 8
  %17 = load %struct.objc_object*, %struct.objc_object** @NSDefaultRunLoopMode, align 8
  %call11 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i64, %struct.objc_object*, %struct.objc_object*, i8)*)(%struct.objc_object* %15, %struct.objc_selector* %call10, i64 -1, %struct.objc_object* %16, %struct.objc_object* %17, i8 signext 1)
  store %struct.objc_object* %call11, %struct.objc_object** %event, align 8
  %18 = load %struct.objc_object*, %struct.objc_object** %event, align 8
  %19 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8
  call void @_tigrOnCocoaEvent(%struct.objc_object* %18, %struct.objc_object* %19)
  %20 = load i8, i8* @terminated, align 1
  %tobool = trunc i8 %20 to i1
  br i1 %tobool, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %21 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call12 = call zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %21)
  br i1 %call12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false, %if.end
  br label %return

if.end14:                                         ; preds = %lor.lhs.false
  %22 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call15 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.83, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %22, %struct.objc_selector* %call15)
  %23 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %call16 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.84, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %23, %struct.objc_selector* %call16)
  %24 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %call17 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %24, %struct.objc_selector* %call17)
  %25 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call18 = call { double, double } @_tigrCocoaWindowSize(%struct.objc_object* %25)
  %26 = bitcast %struct.CGSize* %windowSize to { double, double }*
  %27 = getelementptr inbounds { double, double }, { double, double }* %26, i32 0, i32 0
  %28 = extractvalue { double, double } %call18, 0
  store double %28, double* %27, align 8
  %29 = getelementptr inbounds { double, double }, { double, double }* %26, i32 0, i32 1
  %30 = extractvalue { double, double } %call18, 1
  store double %30, double* %29, align 8
  %31 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %flags = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %31, i32 0, i32 12
  %32 = load i32, i32* %flags, align 4
  %and = and i32 %32, 1
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end14
  %33 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %width = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %34 = load double, double* %width, align 8
  %35 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %35, i32 0, i32 13
  %36 = load i32, i32* %scale, align 8
  %conv = sitofp i32 %36 to double
  %div = fdiv double %34, %conv
  %conv21 = fptosi double %div to i32
  %height = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %37 = load double, double* %height, align 8
  %38 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale22 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %38, i32 0, i32 13
  %39 = load i32, i32* %scale22, align 8
  %conv23 = sitofp i32 %39 to double
  %div24 = fdiv double %37, %conv23
  %conv25 = fptosi double %div24 to i32
  call void @tigrResize(%struct.Tigr* %33, i32 %conv21, i32 %conv25)
  br label %if.end34

if.else:                                          ; preds = %if.end14
  %40 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %40, i32 0, i32 0
  %41 = load i32, i32* %w, align 8
  %42 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %42, i32 0, i32 1
  %43 = load i32, i32* %h, align 4
  %width26 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %44 = load double, double* %width26, align 8
  %conv27 = fptosi double %44 to i32
  %height28 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %45 = load double, double* %height28, align 8
  %conv29 = fptosi double %45 to i32
  %call30 = call i32 @tigrCalcScale(i32 %41, i32 %43, i32 %conv27, i32 %conv29)
  %46 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %flags31 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %46, i32 0, i32 12
  %47 = load i32, i32* %flags31, align 4
  %call32 = call i32 @tigrEnforceScale(i32 %call30, i32 %47)
  %48 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale33 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %48, i32 0, i32 13
  store i32 %call32, i32* %scale33, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then20
  %49 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %50 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale35 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %50, i32 0, i32 13
  %51 = load i32, i32* %scale35, align 8
  %width36 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %52 = load double, double* %width36, align 8
  %conv37 = fptosi double %52 to i32
  %height38 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %53 = load double, double* %height38, align 8
  %conv39 = fptosi double %53 to i32
  %54 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %54, i32 0, i32 14
  %arraydecay40 = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i32 0, i32 0
  call void @tigrPosition(%struct.Tigr* %49, i32 %51, i32 %conv37, i32 %conv39, i32* %arraydecay40)
  %55 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %width41 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %56 = load double, double* %width41, align 8
  %conv42 = fptosi double %56 to i32
  %height43 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %57 = load double, double* %height43, align 8
  %conv44 = fptosi double %57 to i32
  call void @tigrGAPIResize(%struct.Tigr* %55, i32 %conv42, i32 %conv44)
  %58 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %width45 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %59 = load double, double* %width45, align 8
  %conv46 = fptosi double %59 to i32
  %height47 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %60 = load double, double* %height47, align 8
  %conv48 = fptosi double %60 to i32
  call void @tigrGAPIPresent(%struct.Tigr* %58, i32 %conv46, i32 %conv48)
  %61 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8
  %call49 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.85, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %61, %struct.objc_selector* %call49)
  br label %return

return:                                           ; preds = %if.end34, %if.then13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPIPresent(%struct.Tigr* %bmp, i32 %w, i32 %h) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %gl = alloca %struct.GLStuff*, align 8
  %projection = alloca [16 x float], align 16
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %gl1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %1, i32 0, i32 2
  store %struct.GLStuff* %gl1, %struct.GLStuff** %gl, align 8
  %2 = load i32, i32* %w.addr, align 4
  %3 = load i32, i32* %h.addr, align 4
  call void @glViewport(i32 0, i32 0, i32 %2, i32 %3)
  call void @glClearColor(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00)
  call void @glClear(i32 16384)
  %4 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %4, i32 0, i32 6
  %5 = load i32, i32* %gl_legacy, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %arrayinit.begin = getelementptr inbounds [16 x float], [16 x float]* %projection, i64 0, i64 0
  %6 = load i32, i32* %w.addr, align 4
  %conv = sitofp i32 %6 to float
  %div = fdiv float 2.000000e+00, %conv
  store float %div, float* %arrayinit.begin, align 4
  %arrayinit.element = getelementptr inbounds float, float* %arrayinit.begin, i64 1
  store float 0.000000e+00, float* %arrayinit.element, align 4
  %arrayinit.element2 = getelementptr inbounds float, float* %arrayinit.element, i64 1
  store float 0.000000e+00, float* %arrayinit.element2, align 4
  %arrayinit.element3 = getelementptr inbounds float, float* %arrayinit.element2, i64 1
  store float 0.000000e+00, float* %arrayinit.element3, align 4
  %arrayinit.element4 = getelementptr inbounds float, float* %arrayinit.element3, i64 1
  store float 0.000000e+00, float* %arrayinit.element4, align 4
  %arrayinit.element5 = getelementptr inbounds float, float* %arrayinit.element4, i64 1
  %7 = load i32, i32* %h.addr, align 4
  %conv6 = sitofp i32 %7 to float
  %div7 = fdiv float -2.000000e+00, %conv6
  store float %div7, float* %arrayinit.element5, align 4
  %arrayinit.element8 = getelementptr inbounds float, float* %arrayinit.element5, i64 1
  store float 0.000000e+00, float* %arrayinit.element8, align 4
  %arrayinit.element9 = getelementptr inbounds float, float* %arrayinit.element8, i64 1
  store float 0.000000e+00, float* %arrayinit.element9, align 4
  %arrayinit.element10 = getelementptr inbounds float, float* %arrayinit.element9, i64 1
  store float 0.000000e+00, float* %arrayinit.element10, align 4
  %arrayinit.element11 = getelementptr inbounds float, float* %arrayinit.element10, i64 1
  store float 0.000000e+00, float* %arrayinit.element11, align 4
  %arrayinit.element12 = getelementptr inbounds float, float* %arrayinit.element11, i64 1
  store float 1.000000e+00, float* %arrayinit.element12, align 4
  %arrayinit.element13 = getelementptr inbounds float, float* %arrayinit.element12, i64 1
  store float 0.000000e+00, float* %arrayinit.element13, align 4
  %arrayinit.element14 = getelementptr inbounds float, float* %arrayinit.element13, i64 1
  store float -1.000000e+00, float* %arrayinit.element14, align 4
  %arrayinit.element15 = getelementptr inbounds float, float* %arrayinit.element14, i64 1
  store float 1.000000e+00, float* %arrayinit.element15, align 4
  %arrayinit.element16 = getelementptr inbounds float, float* %arrayinit.element15, i64 1
  store float 0.000000e+00, float* %arrayinit.element16, align 4
  %arrayinit.element17 = getelementptr inbounds float, float* %arrayinit.element16, i64 1
  store float 1.000000e+00, float* %arrayinit.element17, align 4
  call void @glActiveTexture(i32 33984)
  %8 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %vao = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %8, i32 0, i32 1
  %9 = load i32, i32* %vao, align 4
  call void @glBindVertexArray(i32 %9)
  %10 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %program = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %10, i32 0, i32 2
  %11 = load i32, i32* %program, align 4
  call void @glUseProgram(i32 %11)
  %12 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_projection = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %12, i32 0, i32 3
  %13 = load i32, i32* %uniform_projection, align 4
  %arraydecay = getelementptr inbounds [16 x float], [16 x float]* %projection, i32 0, i32 0
  call void @glUniformMatrix4fv(i32 %13, i32 1, i8 zeroext 0, float* %arraydecay)
  %14 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_parameters = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %14, i32 0, i32 5
  %15 = load i32, i32* %uniform_parameters, align 4
  %16 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %hblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %16, i32 0, i32 8
  %17 = load i32, i32* %hblur, align 4
  %tobool18 = icmp ne i32 %17, 0
  %18 = zext i1 %tobool18 to i64
  %cond = select i1 %tobool18, float 1.000000e+00, float 0.000000e+00
  %19 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %vblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %19, i32 0, i32 9
  %20 = load i32, i32* %vblur, align 8
  %tobool19 = icmp ne i32 %20, 0
  %21 = zext i1 %tobool19 to i64
  %cond20 = select i1 %tobool19, float 1.000000e+00, float 0.000000e+00
  %22 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scanlines = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %22, i32 0, i32 10
  %23 = load float, float* %scanlines, align 4
  %24 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %contrast = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %24, i32 0, i32 11
  %25 = load float, float* %contrast, align 8
  call void @glUniform4f(i32 %15, float %cond, float %cond20, float %23, float %25)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.tigrGAPIPresent, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3983, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.96, i32 0, i32 0)) #17
  unreachable

if.end:                                           ; preds = %if.then
  call void @glDisable(i32 3042)
  %26 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy21 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %26, i32 0, i32 6
  %27 = load i32, i32* %gl_legacy21, align 4
  %28 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_model = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %28, i32 0, i32 4
  %29 = load i32, i32* %uniform_model, align 4
  %30 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %tex = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %30, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %tex, i64 0, i64 0
  %31 = load i32, i32* %arrayidx, align 4
  %32 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %33 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %33, i32 0, i32 14
  %arrayidx22 = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i64 0, i64 0
  %34 = load i32, i32* %arrayidx22, align 4
  %35 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos23 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %35, i32 0, i32 14
  %arrayidx24 = getelementptr inbounds [4 x i32], [4 x i32]* %pos23, i64 0, i64 1
  %36 = load i32, i32* %arrayidx24, align 4
  %37 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos25 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %37, i32 0, i32 14
  %arrayidx26 = getelementptr inbounds [4 x i32], [4 x i32]* %pos25, i64 0, i64 2
  %38 = load i32, i32* %arrayidx26, align 4
  %39 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos27 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %39, i32 0, i32 14
  %arrayidx28 = getelementptr inbounds [4 x i32], [4 x i32]* %pos27, i64 0, i64 3
  %40 = load i32, i32* %arrayidx28, align 4
  call void @tigrGAPIDraw(i32 %27, i32 %29, i32 %31, %struct.Tigr* %32, i32 %34, i32 %36, i32 %38, i32 %40)
  %41 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgetsScale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %41, i32 0, i32 7
  %42 = load float, float* %widgetsScale, align 8
  %cmp = fcmp ogt float %42, 0.000000e+00
  br i1 %cmp, label %if.then30, label %if.end47

if.then30:                                        ; preds = %if.end
  call void @glEnable(i32 3042)
  call void @glBlendFunc(i32 770, i32 771)
  %43 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %gl_legacy31 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %43, i32 0, i32 6
  %44 = load i32, i32* %gl_legacy31, align 4
  %45 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %uniform_model32 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %45, i32 0, i32 4
  %46 = load i32, i32* %uniform_model32, align 4
  %47 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8
  %tex33 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %47, i32 0, i32 0
  %arrayidx34 = getelementptr inbounds [2 x i32], [2 x i32]* %tex33, i64 0, i64 1
  %48 = load i32, i32* %arrayidx34, align 4
  %49 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgets = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %49, i32 0, i32 4
  %50 = load %struct.Tigr*, %struct.Tigr** %widgets, align 8
  %51 = load i32, i32* %w.addr, align 4
  %conv35 = sitofp i32 %51 to float
  %52 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgets36 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %52, i32 0, i32 4
  %53 = load %struct.Tigr*, %struct.Tigr** %widgets36, align 8
  %w37 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %53, i32 0, i32 0
  %54 = load i32, i32* %w37, align 8
  %conv38 = sitofp i32 %54 to float
  %55 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgetsScale39 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %55, i32 0, i32 7
  %56 = load float, float* %widgetsScale39, align 8
  %mul = fmul float %conv38, %56
  %sub = fsub float %conv35, %mul
  %conv40 = fptosi float %sub to i32
  %57 = load i32, i32* %w.addr, align 4
  %58 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgets41 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %58, i32 0, i32 4
  %59 = load %struct.Tigr*, %struct.Tigr** %widgets41, align 8
  %h42 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %59, i32 0, i32 1
  %60 = load i32, i32* %h42, align 4
  %conv43 = sitofp i32 %60 to float
  %61 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %widgetsScale44 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %61, i32 0, i32 7
  %62 = load float, float* %widgetsScale44, align 8
  %mul45 = fmul float %conv43, %62
  %conv46 = fptosi float %mul45 to i32
  call void @tigrGAPIDraw(i32 %44, i32 %46, i32 %48, %struct.Tigr* %50, i32 %conv40, i32 0, i32 %57, i32 %conv46)
  br label %if.end47

if.end47:                                         ; preds = %if.then30, %if.end
  call void @tigrCheckGLError(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.97, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrClosed(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load i8, i8* @terminated, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 3
  %2 = load i8*, i8** %handle, align 8
  %3 = bitcast i8* %2 to %struct.objc_object*
  %call = call zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %3)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %call, %lor.rhs ]
  %5 = zext i1 %4 to i64
  %cond = select i1 %4, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrMouse(%struct.Tigr* %bmp, i32* %x, i32* %y, i32* %buttons) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32*, align 8
  %y.addr = alloca i32*, align 8
  %buttons.addr = alloca i32*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %window = alloca %struct.objc_object*, align 8
  %windowContentView = alloca %struct.objc_object*, align 8
  %adjustFrame = alloca %struct.CGRect, align 8
  %p = alloca %struct.CGPoint, align 8
  %r = alloca %struct.CGRect, align 8
  %tmp = alloca %struct.CGRect, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32* %x, i32** %x.addr, align 8
  store i32* %y, i32** %y.addr, align 8
  store i32* %buttons, i32** %buttons.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 3
  %2 = load i8*, i8** %handle, align 8
  %3 = bitcast i8* %2 to %struct.objc_object*
  store %struct.objc_object* %3, %struct.objc_object** %window, align 8
  %4 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0))
  %call2 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %4, %struct.objc_selector* %call1)
  store %struct.objc_object* %call2, %struct.objc_object** %windowContentView, align 8
  %5 = load %struct.objc_object*, %struct.objc_object** %windowContentView, align 8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.43, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*)*)(%struct.CGRect* sret %adjustFrame, %struct.objc_object* %5, %struct.objc_selector* %call3)
  %6 = load %struct.objc_object*, %struct.objc_object** %window, align 8
  %call4 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.86, i32 0, i32 0))
  %call5 = call { double, double } bitcast (void ()* @objc_msgSend to { double, double } (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %6, %struct.objc_selector* %call4)
  %7 = bitcast %struct.CGPoint* %p to { double, double }*
  %8 = getelementptr inbounds { double, double }, { double, double }* %7, i32 0, i32 0
  %9 = extractvalue { double, double } %call5, 0
  store double %9, double* %8, align 8
  %10 = getelementptr inbounds { double, double }, { double, double }* %7, i32 0, i32 1
  %11 = extractvalue { double, double } %call5, 1
  store double %11, double* %10, align 8
  %x6 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %12 = load double, double* %x6, align 8
  %cmp = fcmp olt double %12, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %x7 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  store double 0.000000e+00, double* %x7, align 8
  br label %if.end14

if.else:                                          ; preds = %entry
  %x8 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %13 = load double, double* %x8, align 8
  %size = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %width = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size, i32 0, i32 0
  %14 = load double, double* %width, align 8
  %cmp9 = fcmp ogt double %13, %14
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %size11 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %width12 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size11, i32 0, i32 0
  %15 = load double, double* %width12, align 8
  %x13 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  store double %15, double* %x13, align 8
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %y15 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %16 = load double, double* %y15, align 8
  %cmp16 = fcmp olt double %16, 0.000000e+00
  br i1 %cmp16, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.end14
  %y18 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  store double 0.000000e+00, double* %y18, align 8
  br label %if.end28

if.else19:                                        ; preds = %if.end14
  %y20 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %17 = load double, double* %y20, align 8
  %size21 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %height = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size21, i32 0, i32 1
  %18 = load double, double* %height, align 8
  %cmp22 = fcmp ogt double %17, %18
  br i1 %cmp22, label %if.then23, label %if.end27

if.then23:                                        ; preds = %if.else19
  %size24 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %height25 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size24, i32 0, i32 1
  %19 = load double, double* %height25, align 8
  %y26 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  store double %19, double* %y26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %if.else19
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then17
  %origin = getelementptr inbounds %struct.CGRect, %struct.CGRect* %r, i32 0, i32 0
  %x29 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 0
  %x30 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %20 = load double, double* %x30, align 8
  store double %20, double* %x29, align 8
  %y31 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 1
  %y32 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %21 = load double, double* %y32, align 8
  store double %21, double* %y31, align 8
  %size33 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %r, i32 0, i32 1
  %width34 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size33, i32 0, i32 0
  store double 0.000000e+00, double* %width34, align 8
  %height35 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size33, i32 0, i32 1
  store double 0.000000e+00, double* %height35, align 8
  %22 = load %struct.objc_object*, %struct.objc_object** %windowContentView, align 8
  %call36 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.44, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*, %struct.CGRect*)*)(%struct.CGRect* sret %tmp, %struct.objc_object* %22, %struct.objc_selector* %call36, %struct.CGRect* byval align 8 %r)
  %23 = bitcast %struct.CGRect* %r to i8*
  %24 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %24, i64 32, i1 false)
  %origin37 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %r, i32 0, i32 0
  %25 = bitcast %struct.CGPoint* %p to i8*
  %26 = bitcast %struct.CGPoint* %origin37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %26, i64 16, i1 false)
  %x38 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %27 = load double, double* %x38, align 8
  %28 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %28, i32 0, i32 14
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i64 0, i64 0
  %29 = load i32, i32* %arrayidx, align 4
  %conv = sitofp i32 %29 to double
  %sub = fsub double %27, %conv
  %30 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %30, i32 0, i32 13
  %31 = load i32, i32* %scale, align 8
  %conv39 = sitofp i32 %31 to double
  %div = fdiv double %sub, %conv39
  %x40 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  store double %div, double* %x40, align 8
  %size41 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %height42 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size41, i32 0, i32 1
  %32 = load double, double* %height42, align 8
  %y43 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %33 = load double, double* %y43, align 8
  %sub44 = fsub double %32, %33
  %34 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %pos45 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %34, i32 0, i32 14
  %arrayidx46 = getelementptr inbounds [4 x i32], [4 x i32]* %pos45, i64 0, i64 1
  %35 = load i32, i32* %arrayidx46, align 4
  %conv47 = sitofp i32 %35 to double
  %sub48 = fsub double %sub44, %conv47
  %36 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %scale49 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %36, i32 0, i32 13
  %37 = load i32, i32* %scale49, align 8
  %conv50 = sitofp i32 %37 to double
  %div51 = fdiv double %sub48, %conv50
  %y52 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  store double %div51, double* %y52, align 8
  %38 = load i32*, i32** %x.addr, align 8
  %tobool = icmp ne i32* %38, null
  br i1 %tobool, label %if.then53, label %if.end56

if.then53:                                        ; preds = %if.end28
  %x54 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %39 = load double, double* %x54, align 8
  %conv55 = fptosi double %39 to i32
  %40 = load i32*, i32** %x.addr, align 8
  store i32 %conv55, i32* %40, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then53, %if.end28
  %41 = load i32*, i32** %y.addr, align 8
  %tobool57 = icmp ne i32* %41, null
  br i1 %tobool57, label %if.then58, label %if.end61

if.then58:                                        ; preds = %if.end56
  %y59 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %42 = load double, double* %y59, align 8
  %conv60 = fptosi double %42 to i32
  %43 = load i32*, i32** %y.addr, align 8
  store i32 %conv60, i32* %43, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.then58, %if.end56
  %44 = load i32*, i32** %buttons.addr, align 8
  %tobool62 = icmp ne i32* %44, null
  br i1 %tobool62, label %if.then63, label %if.end69

if.then63:                                        ; preds = %if.end61
  %45 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call64 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call65 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %45, %struct.objc_selector* %call64)
  store %struct.objc_object* %call65, %struct.objc_object** %keyWindow, align 8
  %46 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8
  %47 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle66 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %47, i32 0, i32 3
  %48 = load i8*, i8** %handle66, align 8
  %49 = bitcast i8* %48 to %struct.objc_object*
  %cmp67 = icmp ne %struct.objc_object* %46, %49
  br i1 %cmp67, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then63
  br label %cond.end

cond.false:                                       ; preds = %if.then63
  %50 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %50, i32 0, i32 18
  %51 = load i32, i32* %mouseButtons, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %51, %cond.false ]
  %52 = load i32*, i32** %buttons.addr, align 8
  store i32 %cond, i32* %52, align 4
  br label %if.end69

if.end69:                                         ; preds = %cond.end, %if.end61
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrKeyDown(%struct.Tigr* %bmp, i32 %key) #0 {
entry:
  %retval = alloca i32, align 4
  %bmp.addr = alloca %struct.Tigr*, align 8
  %key.addr = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %key, i32* %key.addr, align 4
  %0 = load i32, i32* %key.addr, align 4
  %cmp = icmp slt i32 %0, 256
  %lnot = xor i1 %cmp, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrKeyDown, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3581, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.87, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %1
  %2 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %2, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %keyWindow, align 8
  %3 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 3
  %5 = load i8*, i8** %handle, align 8
  %6 = bitcast i8* %5 to %struct.objc_object*
  %cmp2 = icmp ne %struct.objc_object* %3, %6
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call4 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %7)
  store %struct.TigrInternal* %call4, %struct.TigrInternal** %win, align 8
  %8 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %8, i32 0, i32 16
  %9 = load i32, i32* %key.addr, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i64 0, i64 %idxprom
  %10 = load i8, i8* %arrayidx, align 1
  %conv5 = sext i8 %10 to i32
  %tobool6 = icmp ne i32 %conv5, 0
  br i1 %tobool6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %prev = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %11, i32 0, i32 17
  %12 = load i32, i32* %key.addr, align 4
  %idxprom7 = sext i32 %12 to i64
  %arrayidx8 = getelementptr inbounds [256 x i8], [256 x i8]* %prev, i64 0, i64 %idxprom7
  %13 = load i8, i8* %arrayidx8, align 1
  %tobool9 = icmp ne i8 %13, 0
  %lnot10 = xor i1 %tobool9, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %14 = phi i1 [ false, %if.end ], [ %lnot10, %land.rhs ]
  %land.ext = zext i1 %14 to i32
  store i32 %land.ext, i32* %retval, align 4
  br label %return

return:                                           ; preds = %land.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrKeyHeld(%struct.Tigr* %bmp, i32 %key) #0 {
entry:
  %retval = alloca i32, align 4
  %bmp.addr = alloca %struct.Tigr*, align 8
  %key.addr = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %key, i32* %key.addr, align 4
  %0 = load i32, i32* %key.addr, align 4
  %cmp = icmp slt i32 %0, 256
  %lnot = xor i1 %cmp, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrKeyHeld, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3592, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.87, i32 0, i32 0)) #17
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %1
  %2 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %2, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %keyWindow, align 8
  %3 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 3
  %5 = load i8*, i8** %handle, align 8
  %6 = bitcast i8* %5 to %struct.objc_object*
  %cmp2 = icmp ne %struct.objc_object* %3, %6
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call4 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %7)
  store %struct.TigrInternal* %call4, %struct.TigrInternal** %win, align 8
  %8 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %8, i32 0, i32 16
  %9 = load i32, i32* %key.addr, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i64 0, i64 %idxprom
  %10 = load i8, i8* %arrayidx, align 1
  %conv5 = sext i8 %10 to i32
  store i32 %conv5, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @tigrReadChar(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %c = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %0)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8
  %1 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %1, i32 0, i32 15
  %2 = load i32, i32* %lastChar, align 4
  store i32 %2, i32* %c, align 4
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8
  %lastChar1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %3, i32 0, i32 15
  store i32 0, i32* %lastChar1, align 4
  %4 = load i32, i32* %c, align 4
  ret i32 %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define float @tigrTime() #0 {
entry:
  %retval = alloca float, align 4
  %current_time = alloca i64, align 8
  %elapsed = alloca double, align 8
  %0 = load i32, i32* getelementptr inbounds (%struct.mach_timebase_info, %struct.mach_timebase_info* @tigrTime.timebaseInfo, i32 0, i32 1), align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @mach_timebase_info(%struct.mach_timebase_info* @tigrTime.timebaseInfo)
  %call1 = call i64 @mach_absolute_time()
  store i64 %call1, i64* @tigrTime.time, align 8
  store float 0.000000e+00, float* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i64 @mach_absolute_time()
  store i64 %call2, i64* %current_time, align 8
  %1 = load i64, i64* %current_time, align 8
  %2 = load i64, i64* @tigrTime.time, align 8
  %sub = sub i64 %1, %2
  %conv = uitofp i64 %sub to double
  %3 = load i32, i32* getelementptr inbounds (%struct.mach_timebase_info, %struct.mach_timebase_info* @tigrTime.timebaseInfo, i32 0, i32 0), align 4
  %conv3 = uitofp i32 %3 to double
  %mul = fmul double %conv, %conv3
  %4 = load i32, i32* getelementptr inbounds (%struct.mach_timebase_info, %struct.mach_timebase_info* @tigrTime.timebaseInfo, i32 0, i32 1), align 4
  %conv4 = uitofp i32 %4 to double
  %mul5 = fmul double %conv4, 1.000000e+09
  %div = fdiv double %mul, %mul5
  store double %div, double* %elapsed, align 8
  %5 = load i64, i64* %current_time, align 8
  store i64 %5, i64* @tigrTime.time, align 8
  %6 = load double, double* %elapsed, align 8
  %conv6 = fptrunc double %6 to float
  store float %conv6, float* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load float, float* %retval, align 4
  ret float %7
}

declare i32 @mach_timebase_info(%struct.mach_timebase_info*) #4

declare i64 @mach_absolute_time() #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrCheckGLError(i8* %state) #0 {
entry:
  %state.addr = alloca i8*, align 8
  %err = alloca i32, align 4
  store i8* %state, i8** %state.addr, align 8
  %call = call i32 @glGetError()
  store i32 %call, i32* %err, align 4
  %0 = load i32, i32* %err, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %err, align 4
  %2 = load i8*, i8** %state.addr, align 8
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.88, i32 0, i32 0), i32 %1, i8* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @glGetError() #4

declare i32 @printf(i8*, ...) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrCheckShaderErrors(i32 %object) #0 {
entry:
  %object.addr = alloca i32, align 4
  %success = alloca i32, align 4
  %info = alloca [2048 x i8], align 16
  store i32 %object, i32* %object.addr, align 4
  %0 = load i32, i32* %object.addr, align 4
  call void @glGetShaderiv(i32 %0, i32 35713, i32* %success)
  %1 = load i32, i32* %success, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %object.addr, align 4
  %arraydecay = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  call void @glGetShaderInfoLog(i32 %2, i32 2048, i32* null, i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.89, i32 0, i32 0), i8* %arraydecay1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @glGetShaderiv(i32, i32, i32*) #4

declare void @glGetShaderInfoLog(i32, i32, i32*, i8*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrCheckProgramErrors(i32 %object) #0 {
entry:
  %object.addr = alloca i32, align 4
  %success = alloca i32, align 4
  %info = alloca [2048 x i8], align 16
  store i32 %object, i32* %object.addr, align 4
  %0 = load i32, i32* %object.addr, align 4
  call void @glGetProgramiv(i32 %0, i32 35714, i32* %success)
  %1 = load i32, i32* %success, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %object.addr, align 4
  %arraydecay = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  call void @glGetProgramInfoLog(i32 %2, i32 2048, i32* null, i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.90, i32 0, i32 0), i8* %arraydecay1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @glGetProgramiv(i32, i32, i32*) #4

declare void @glGetProgramInfoLog(i32, i32, i32*, i8*) #4

declare void @glGenVertexArrays(i32, i32*) #4

declare void @glGenBuffers(i32, i32*) #4

declare void @glBindBuffer(i32, i32) #4

declare void @glBufferData(i32, i64, i8*, i32) #4

declare void @glBindVertexArray(i32) #4

declare void @glEnableVertexAttribArray(i32) #4

declare void @glVertexAttribPointer(i32, i32, i32, i8 zeroext, i32, i8*) #4

declare i32 @glCreateShader(i32) #4

declare void @glShaderSource(i32, i32, i8**, i32*) #4

declare void @glCompileShader(i32) #4

declare i32 @glCreateProgram() #4

declare void @glAttachShader(i32, i32) #4

declare void @glLinkProgram(i32) #4

declare void @glDeleteShader(i32) #4

declare i32 @glGetUniformLocation(i32, i8*) #4

declare void @glEnable(i32) #4

declare void @glGenTextures(i32, i32*) #4

declare void @glBindTexture(i32, i32) #4

declare void @glTexParameteri(i32, i32, i32) #4

declare void @glPixelStorei(i32, i32) #4

declare void @glDeleteTextures(i32, i32*) #4

declare void @glDeleteProgram(i32) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @tigrGAPIDraw(i32 %legacy, i32 %uniform_model, i32 %tex, %struct.Tigr* %bmp, i32 %x1, i32 %y1, i32 %x2, i32 %y2) #0 {
entry:
  %legacy.addr = alloca i32, align 4
  %uniform_model.addr = alloca i32, align 4
  %tex.addr = alloca i32, align 4
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x1.addr = alloca i32, align 4
  %y1.addr = alloca i32, align 4
  %x2.addr = alloca i32, align 4
  %y2.addr = alloca i32, align 4
  %sx = alloca float, align 4
  %sy = alloca float, align 4
  %tx = alloca float, align 4
  %ty = alloca float, align 4
  %model = alloca [16 x float], align 16
  store i32 %legacy, i32* %legacy.addr, align 4
  store i32 %uniform_model, i32* %uniform_model.addr, align 4
  store i32 %tex, i32* %tex.addr, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %x1, i32* %x1.addr, align 4
  store i32 %y1, i32* %y1.addr, align 4
  store i32 %x2, i32* %x2.addr, align 4
  store i32 %y2, i32* %y2.addr, align 4
  %0 = load i32, i32* %tex.addr, align 4
  call void @glBindTexture(i32 3553, i32 %0)
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 0
  %2 = load i32, i32* %w, align 8
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i32 0, i32 1
  %4 = load i32, i32* %h, align 4
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %5, i32 0, i32 2
  %6 = load %struct.TPixel*, %struct.TPixel** %pix, align 8
  %7 = bitcast %struct.TPixel* %6 to i8*
  call void @glTexImage2D(i32 3553, i32 0, i32 32856, i32 %2, i32 %4, i32 0, i32 32993, i32 5121, i8* %7)
  %8 = load i32, i32* %legacy.addr, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %x2.addr, align 4
  %10 = load i32, i32* %x1.addr, align 4
  %sub = sub nsw i32 %9, %10
  %conv = sitofp i32 %sub to float
  store float %conv, float* %sx, align 4
  %11 = load i32, i32* %y2.addr, align 4
  %12 = load i32, i32* %y1.addr, align 4
  %sub1 = sub nsw i32 %11, %12
  %conv2 = sitofp i32 %sub1 to float
  store float %conv2, float* %sy, align 4
  %13 = load i32, i32* %x1.addr, align 4
  %conv3 = sitofp i32 %13 to float
  store float %conv3, float* %tx, align 4
  %14 = load i32, i32* %y1.addr, align 4
  %conv4 = sitofp i32 %14 to float
  store float %conv4, float* %ty, align 4
  %arrayinit.begin = getelementptr inbounds [16 x float], [16 x float]* %model, i64 0, i64 0
  %15 = load float, float* %sx, align 4
  store float %15, float* %arrayinit.begin, align 4
  %arrayinit.element = getelementptr inbounds float, float* %arrayinit.begin, i64 1
  store float 0.000000e+00, float* %arrayinit.element, align 4
  %arrayinit.element5 = getelementptr inbounds float, float* %arrayinit.element, i64 1
  store float 0.000000e+00, float* %arrayinit.element5, align 4
  %arrayinit.element6 = getelementptr inbounds float, float* %arrayinit.element5, i64 1
  store float 0.000000e+00, float* %arrayinit.element6, align 4
  %arrayinit.element7 = getelementptr inbounds float, float* %arrayinit.element6, i64 1
  store float 0.000000e+00, float* %arrayinit.element7, align 4
  %arrayinit.element8 = getelementptr inbounds float, float* %arrayinit.element7, i64 1
  %16 = load float, float* %sy, align 4
  store float %16, float* %arrayinit.element8, align 4
  %arrayinit.element9 = getelementptr inbounds float, float* %arrayinit.element8, i64 1
  store float 0.000000e+00, float* %arrayinit.element9, align 4
  %arrayinit.element10 = getelementptr inbounds float, float* %arrayinit.element9, i64 1
  store float 0.000000e+00, float* %arrayinit.element10, align 4
  %arrayinit.element11 = getelementptr inbounds float, float* %arrayinit.element10, i64 1
  store float 0.000000e+00, float* %arrayinit.element11, align 4
  %arrayinit.element12 = getelementptr inbounds float, float* %arrayinit.element11, i64 1
  store float 0.000000e+00, float* %arrayinit.element12, align 4
  %arrayinit.element13 = getelementptr inbounds float, float* %arrayinit.element12, i64 1
  store float 1.000000e+00, float* %arrayinit.element13, align 4
  %arrayinit.element14 = getelementptr inbounds float, float* %arrayinit.element13, i64 1
  store float 0.000000e+00, float* %arrayinit.element14, align 4
  %arrayinit.element15 = getelementptr inbounds float, float* %arrayinit.element14, i64 1
  %17 = load float, float* %tx, align 4
  store float %17, float* %arrayinit.element15, align 4
  %arrayinit.element16 = getelementptr inbounds float, float* %arrayinit.element15, i64 1
  %18 = load float, float* %ty, align 4
  store float %18, float* %arrayinit.element16, align 4
  %arrayinit.element17 = getelementptr inbounds float, float* %arrayinit.element16, i64 1
  store float 0.000000e+00, float* %arrayinit.element17, align 4
  %arrayinit.element18 = getelementptr inbounds float, float* %arrayinit.element17, i64 1
  store float 1.000000e+00, float* %arrayinit.element18, align 4
  %19 = load i32, i32* %uniform_model.addr, align 4
  %arraydecay = getelementptr inbounds [16 x float], [16 x float]* %model, i32 0, i32 0
  call void @glUniformMatrix4fv(i32 %19, i32 1, i8 zeroext 0, float* %arraydecay)
  call void @glDrawArrays(i32 4, i32 0, i32 6)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.tigrGAPIDraw, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3942, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.96, i32 0, i32 0)) #17
  unreachable

if.end:                                           ; preds = %if.then
  ret void
}

declare void @glTexImage2D(i32, i32, i32, i32, i32, i32, i32, i32, i8*) #4

declare void @glUniformMatrix4fv(i32, i32, i8 zeroext, float*) #4

declare void @glDrawArrays(i32, i32, i32) #4

declare void @glViewport(i32, i32, i32, i32) #4

declare void @glClearColor(float, float, float, float) #4

declare void @glClear(i32) #4

declare void @glActiveTexture(i32) #4

declare void @glUseProgram(i32) #4

declare void @glUniform4f(i32, float, float, float, float) #4

declare void @glDisable(i32) #4

declare void @glBlendFunc(i32, i32) #4

declare i32 @memcmp(i8*, i8*, i64) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @find(%struct.PNG* %png, i8* %chunk, i32 %minlen) #0 {
entry:
  %retval = alloca i8*, align 8
  %png.addr = alloca %struct.PNG*, align 8
  %chunk.addr = alloca i8*, align 8
  %minlen.addr = alloca i32, align 4
  %start = alloca i8*, align 8
  %len = alloca i32, align 4
  store %struct.PNG* %png, %struct.PNG** %png.addr, align 8
  store i8* %chunk, i8** %chunk.addr, align 8
  store i32 %minlen, i32* %minlen.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p = getelementptr inbounds %struct.PNG, %struct.PNG* %0, i32 0, i32 0
  %1 = load i8*, i8** %p, align 8
  %2 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %end = getelementptr inbounds %struct.PNG, %struct.PNG* %2, i32 0, i32 1
  %3 = load i8*, i8** %end, align 8
  %cmp = icmp ult i8* %1, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p1 = getelementptr inbounds %struct.PNG, %struct.PNG* %4, i32 0, i32 0
  %5 = load i8*, i8** %p1, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %call = call i32 @get32(i8* %add.ptr)
  store i32 %call, i32* %len, align 4
  %6 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p2 = getelementptr inbounds %struct.PNG, %struct.PNG* %6, i32 0, i32 0
  %7 = load i8*, i8** %p2, align 8
  store i8* %7, i8** %start, align 8
  %8 = load i32, i32* %len, align 4
  %add = add i32 %8, 12
  %9 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p3 = getelementptr inbounds %struct.PNG, %struct.PNG* %9, i32 0, i32 0
  %10 = load i8*, i8** %p3, align 8
  %idx.ext = zext i32 %add to i64
  %add.ptr4 = getelementptr inbounds i8, i8* %10, i64 %idx.ext
  store i8* %add.ptr4, i8** %p3, align 8
  %11 = load i8*, i8** %start, align 8
  %add.ptr5 = getelementptr inbounds i8, i8* %11, i64 4
  %12 = load i8*, i8** %chunk.addr, align 8
  %call6 = call i32 @memcmp(i8* %add.ptr5, i8* %12, i64 4)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %13 = load i32, i32* %len, align 4
  %14 = load i32, i32* %minlen.addr, align 4
  %cmp8 = icmp uge i32 %13, %14
  br i1 %cmp8, label %land.lhs.true9, label %if.end

land.lhs.true9:                                   ; preds = %land.lhs.true
  %15 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %p10 = getelementptr inbounds %struct.PNG, %struct.PNG* %15, i32 0, i32 0
  %16 = load i8*, i8** %p10, align 8
  %17 = load %struct.PNG*, %struct.PNG** %png.addr, align 8
  %end11 = getelementptr inbounds %struct.PNG, %struct.PNG* %17, i32 0, i32 1
  %18 = load i8*, i8** %end11, align 8
  %cmp12 = icmp ule i8* %16, %18
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true9
  %19 = load i8*, i8** %start, align 8
  %add.ptr13 = getelementptr inbounds i8, i8* %19, i64 8
  store i8* %add.ptr13, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true9, %land.lhs.true, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %20 = load i8*, i8** %retval, align 8
  ret i8* %20
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @get32(i8* %v) #0 {
entry:
  %v.addr = alloca i8*, align 8
  store i8* %v, i8** %v.addr, align 8
  %0 = load i8*, i8** %v.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 24
  %2 = load i8*, i8** %v.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 1
  %3 = load i8, i8* %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %shl3 = shl i32 %conv2, 16
  %or = or i32 %shl, %shl3
  %4 = load i8*, i8** %v.addr, align 8
  %arrayidx4 = getelementptr inbounds i8, i8* %4, i64 2
  %5 = load i8, i8* %arrayidx4, align 1
  %conv5 = zext i8 %5 to i32
  %shl6 = shl i32 %conv5, 8
  %or7 = or i32 %or, %shl6
  %6 = load i8*, i8** %v.addr, align 8
  %arrayidx8 = getelementptr inbounds i8, i8* %6, i64 3
  %7 = load i8, i8* %arrayidx8, align 1
  %conv9 = zext i8 %7 to i32
  %or10 = or i32 %or7, %conv9
  ret i32 %or10
}

; Function Attrs: allocsize(1)
declare i8* @realloc(i8*, i64) #12

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @outsize(%struct.Tigr* %bmp, i32 %bpp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %bpp.addr = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8
  store i32 %bpp, i32* %bpp.addr, align 4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %0, i32 0, i32 0
  %1 = load i32, i32* %w, align 8
  %add = add nsw i32 %1, 1
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %2, i32 0, i32 1
  %3 = load i32, i32* %h, align 4
  %mul = mul nsw i32 %add, %3
  %4 = load i32, i32* %bpp.addr, align 4
  %mul1 = mul nsw i32 %mul, %4
  ret i32 %mul1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @unfilter(i32 %w, i32 %h, i32 %bpp, i8* %raw) #0 {
entry:
  %retval = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %bpp.addr = alloca i32, align 4
  %raw.addr = alloca i8*, align 8
  %len = alloca i32, align 4
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %prev = alloca i8*, align 8
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store i32 %bpp, i32* %bpp.addr, align 4
  store i8* %raw, i8** %raw.addr, align 8
  %0 = load i32, i32* %w.addr, align 4
  %1 = load i32, i32* %bpp.addr, align 4
  %mul = mul nsw i32 %0, %1
  store i32 %mul, i32* %len, align 4
  %2 = load i8*, i8** %raw.addr, align 8
  store i8* %2, i8** %prev, align 8
  store i32 0, i32* %y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc128, %entry
  %3 = load i32, i32* %y, align 4
  %4 = load i32, i32* %h.addr, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end130

for.body:                                         ; preds = %for.cond
  %5 = load i8*, i8** %raw.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %5, i32 1
  store i8* %incdec.ptr, i8** %raw.addr, align 8
  %6 = load i8, i8* %5, align 1
  %conv = zext i8 %6 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb23
    i32 3, label %sw.bb54
    i32 4, label %sw.bb91
  ]

sw.bb:                                            ; preds = %for.body
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.body
  store i32 0, i32* %x, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %sw.bb1
  %7 = load i32, i32* %x, align 4
  %8 = load i32, i32* %bpp.addr, align 4
  %cmp3 = icmp slt i32 %7, %8
  br i1 %cmp3, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond2
  %9 = load i8*, i8** %raw.addr, align 8
  %10 = load i32, i32* %x, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds i8, i8* %9, i64 %idxprom
  %11 = load i8, i8* %arrayidx, align 1
  %conv6 = zext i8 %11 to i32
  %add = add nsw i32 %conv6, 0
  %conv7 = trunc i32 %add to i8
  store i8 %conv7, i8* %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body5
  %12 = load i32, i32* %x, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond2

for.end:                                          ; preds = %for.cond2
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc20, %for.end
  %13 = load i32, i32* %x, align 4
  %14 = load i32, i32* %len, align 4
  %cmp9 = icmp slt i32 %13, %14
  br i1 %cmp9, label %for.body11, label %for.end22

for.body11:                                       ; preds = %for.cond8
  %15 = load i8*, i8** %raw.addr, align 8
  %16 = load i32, i32* %x, align 4
  %17 = load i32, i32* %bpp.addr, align 4
  %sub = sub nsw i32 %16, %17
  %idxprom12 = sext i32 %sub to i64
  %arrayidx13 = getelementptr inbounds i8, i8* %15, i64 %idxprom12
  %18 = load i8, i8* %arrayidx13, align 1
  %conv14 = zext i8 %18 to i32
  %19 = load i8*, i8** %raw.addr, align 8
  %20 = load i32, i32* %x, align 4
  %idxprom15 = sext i32 %20 to i64
  %arrayidx16 = getelementptr inbounds i8, i8* %19, i64 %idxprom15
  %21 = load i8, i8* %arrayidx16, align 1
  %conv17 = zext i8 %21 to i32
  %add18 = add nsw i32 %conv17, %conv14
  %conv19 = trunc i32 %add18 to i8
  store i8 %conv19, i8* %arrayidx16, align 1
  br label %for.inc20

for.inc20:                                        ; preds = %for.body11
  %22 = load i32, i32* %x, align 4
  %inc21 = add nsw i32 %22, 1
  store i32 %inc21, i32* %x, align 4
  br label %for.cond8

for.end22:                                        ; preds = %for.cond8
  br label %sw.epilog

sw.bb23:                                          ; preds = %for.body
  store i32 0, i32* %x, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc36, %sw.bb23
  %23 = load i32, i32* %x, align 4
  %24 = load i32, i32* %bpp.addr, align 4
  %cmp25 = icmp slt i32 %23, %24
  br i1 %cmp25, label %for.body27, label %for.end38

for.body27:                                       ; preds = %for.cond24
  %25 = load i8*, i8** %prev, align 8
  %26 = load i32, i32* %x, align 4
  %idxprom28 = sext i32 %26 to i64
  %arrayidx29 = getelementptr inbounds i8, i8* %25, i64 %idxprom28
  %27 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %27 to i32
  %28 = load i8*, i8** %raw.addr, align 8
  %29 = load i32, i32* %x, align 4
  %idxprom31 = sext i32 %29 to i64
  %arrayidx32 = getelementptr inbounds i8, i8* %28, i64 %idxprom31
  %30 = load i8, i8* %arrayidx32, align 1
  %conv33 = zext i8 %30 to i32
  %add34 = add nsw i32 %conv33, %conv30
  %conv35 = trunc i32 %add34 to i8
  store i8 %conv35, i8* %arrayidx32, align 1
  br label %for.inc36

for.inc36:                                        ; preds = %for.body27
  %31 = load i32, i32* %x, align 4
  %inc37 = add nsw i32 %31, 1
  store i32 %inc37, i32* %x, align 4
  br label %for.cond24

for.end38:                                        ; preds = %for.cond24
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc51, %for.end38
  %32 = load i32, i32* %x, align 4
  %33 = load i32, i32* %len, align 4
  %cmp40 = icmp slt i32 %32, %33
  br i1 %cmp40, label %for.body42, label %for.end53

for.body42:                                       ; preds = %for.cond39
  %34 = load i8*, i8** %prev, align 8
  %35 = load i32, i32* %x, align 4
  %idxprom43 = sext i32 %35 to i64
  %arrayidx44 = getelementptr inbounds i8, i8* %34, i64 %idxprom43
  %36 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %36 to i32
  %37 = load i8*, i8** %raw.addr, align 8
  %38 = load i32, i32* %x, align 4
  %idxprom46 = sext i32 %38 to i64
  %arrayidx47 = getelementptr inbounds i8, i8* %37, i64 %idxprom46
  %39 = load i8, i8* %arrayidx47, align 1
  %conv48 = zext i8 %39 to i32
  %add49 = add nsw i32 %conv48, %conv45
  %conv50 = trunc i32 %add49 to i8
  store i8 %conv50, i8* %arrayidx47, align 1
  br label %for.inc51

for.inc51:                                        ; preds = %for.body42
  %40 = load i32, i32* %x, align 4
  %inc52 = add nsw i32 %40, 1
  store i32 %inc52, i32* %x, align 4
  br label %for.cond39

for.end53:                                        ; preds = %for.cond39
  br label %sw.epilog

sw.bb54:                                          ; preds = %for.body
  store i32 0, i32* %x, align 4
  br label %for.cond55

for.cond55:                                       ; preds = %for.inc67, %sw.bb54
  %41 = load i32, i32* %x, align 4
  %42 = load i32, i32* %bpp.addr, align 4
  %cmp56 = icmp slt i32 %41, %42
  br i1 %cmp56, label %for.body58, label %for.end69

for.body58:                                       ; preds = %for.cond55
  %43 = load i8*, i8** %prev, align 8
  %44 = load i32, i32* %x, align 4
  %idxprom59 = sext i32 %44 to i64
  %arrayidx60 = getelementptr inbounds i8, i8* %43, i64 %idxprom59
  %45 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %45 to i32
  %div = sdiv i32 %conv61, 2
  %46 = load i8*, i8** %raw.addr, align 8
  %47 = load i32, i32* %x, align 4
  %idxprom62 = sext i32 %47 to i64
  %arrayidx63 = getelementptr inbounds i8, i8* %46, i64 %idxprom62
  %48 = load i8, i8* %arrayidx63, align 1
  %conv64 = zext i8 %48 to i32
  %add65 = add nsw i32 %conv64, %div
  %conv66 = trunc i32 %add65 to i8
  store i8 %conv66, i8* %arrayidx63, align 1
  br label %for.inc67

for.inc67:                                        ; preds = %for.body58
  %49 = load i32, i32* %x, align 4
  %inc68 = add nsw i32 %49, 1
  store i32 %inc68, i32* %x, align 4
  br label %for.cond55

for.end69:                                        ; preds = %for.cond55
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc88, %for.end69
  %50 = load i32, i32* %x, align 4
  %51 = load i32, i32* %len, align 4
  %cmp71 = icmp slt i32 %50, %51
  br i1 %cmp71, label %for.body73, label %for.end90

for.body73:                                       ; preds = %for.cond70
  %52 = load i8*, i8** %raw.addr, align 8
  %53 = load i32, i32* %x, align 4
  %54 = load i32, i32* %bpp.addr, align 4
  %sub74 = sub nsw i32 %53, %54
  %idxprom75 = sext i32 %sub74 to i64
  %arrayidx76 = getelementptr inbounds i8, i8* %52, i64 %idxprom75
  %55 = load i8, i8* %arrayidx76, align 1
  %conv77 = zext i8 %55 to i32
  %56 = load i8*, i8** %prev, align 8
  %57 = load i32, i32* %x, align 4
  %idxprom78 = sext i32 %57 to i64
  %arrayidx79 = getelementptr inbounds i8, i8* %56, i64 %idxprom78
  %58 = load i8, i8* %arrayidx79, align 1
  %conv80 = zext i8 %58 to i32
  %add81 = add nsw i32 %conv77, %conv80
  %div82 = sdiv i32 %add81, 2
  %59 = load i8*, i8** %raw.addr, align 8
  %60 = load i32, i32* %x, align 4
  %idxprom83 = sext i32 %60 to i64
  %arrayidx84 = getelementptr inbounds i8, i8* %59, i64 %idxprom83
  %61 = load i8, i8* %arrayidx84, align 1
  %conv85 = zext i8 %61 to i32
  %add86 = add nsw i32 %conv85, %div82
  %conv87 = trunc i32 %add86 to i8
  store i8 %conv87, i8* %arrayidx84, align 1
  br label %for.inc88

for.inc88:                                        ; preds = %for.body73
  %62 = load i32, i32* %x, align 4
  %inc89 = add nsw i32 %62, 1
  store i32 %inc89, i32* %x, align 4
  br label %for.cond70

for.end90:                                        ; preds = %for.cond70
  br label %sw.epilog

sw.bb91:                                          ; preds = %for.body
  store i32 0, i32* %x, align 4
  br label %for.cond92

for.cond92:                                       ; preds = %for.inc104, %sw.bb91
  %63 = load i32, i32* %x, align 4
  %64 = load i32, i32* %bpp.addr, align 4
  %cmp93 = icmp slt i32 %63, %64
  br i1 %cmp93, label %for.body95, label %for.end106

for.body95:                                       ; preds = %for.cond92
  %65 = load i8*, i8** %prev, align 8
  %66 = load i32, i32* %x, align 4
  %idxprom96 = sext i32 %66 to i64
  %arrayidx97 = getelementptr inbounds i8, i8* %65, i64 %idxprom96
  %67 = load i8, i8* %arrayidx97, align 1
  %conv98 = zext i8 %67 to i32
  %68 = load i8*, i8** %raw.addr, align 8
  %69 = load i32, i32* %x, align 4
  %idxprom99 = sext i32 %69 to i64
  %arrayidx100 = getelementptr inbounds i8, i8* %68, i64 %idxprom99
  %70 = load i8, i8* %arrayidx100, align 1
  %conv101 = zext i8 %70 to i32
  %add102 = add nsw i32 %conv101, %conv98
  %conv103 = trunc i32 %add102 to i8
  store i8 %conv103, i8* %arrayidx100, align 1
  br label %for.inc104

for.inc104:                                       ; preds = %for.body95
  %71 = load i32, i32* %x, align 4
  %inc105 = add nsw i32 %71, 1
  store i32 %inc105, i32* %x, align 4
  br label %for.cond92

for.end106:                                       ; preds = %for.cond92
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc125, %for.end106
  %72 = load i32, i32* %x, align 4
  %73 = load i32, i32* %len, align 4
  %cmp108 = icmp slt i32 %72, %73
  br i1 %cmp108, label %for.body110, label %for.end127

for.body110:                                      ; preds = %for.cond107
  %74 = load i8*, i8** %raw.addr, align 8
  %75 = load i32, i32* %x, align 4
  %76 = load i32, i32* %bpp.addr, align 4
  %sub111 = sub nsw i32 %75, %76
  %idxprom112 = sext i32 %sub111 to i64
  %arrayidx113 = getelementptr inbounds i8, i8* %74, i64 %idxprom112
  %77 = load i8, i8* %arrayidx113, align 1
  %78 = load i8*, i8** %prev, align 8
  %79 = load i32, i32* %x, align 4
  %idxprom114 = sext i32 %79 to i64
  %arrayidx115 = getelementptr inbounds i8, i8* %78, i64 %idxprom114
  %80 = load i8, i8* %arrayidx115, align 1
  %81 = load i8*, i8** %prev, align 8
  %82 = load i32, i32* %x, align 4
  %83 = load i32, i32* %bpp.addr, align 4
  %sub116 = sub nsw i32 %82, %83
  %idxprom117 = sext i32 %sub116 to i64
  %arrayidx118 = getelementptr inbounds i8, i8* %81, i64 %idxprom117
  %84 = load i8, i8* %arrayidx118, align 1
  %call = call zeroext i8 @paeth(i8 zeroext %77, i8 zeroext %80, i8 zeroext %84)
  %conv119 = zext i8 %call to i32
  %85 = load i8*, i8** %raw.addr, align 8
  %86 = load i32, i32* %x, align 4
  %idxprom120 = sext i32 %86 to i64
  %arrayidx121 = getelementptr inbounds i8, i8* %85, i64 %idxprom120
  %87 = load i8, i8* %arrayidx121, align 1
  %conv122 = zext i8 %87 to i32
  %add123 = add nsw i32 %conv122, %conv119
  %conv124 = trunc i32 %add123 to i8
  store i8 %conv124, i8* %arrayidx121, align 1
  br label %for.inc125

for.inc125:                                       ; preds = %for.body110
  %88 = load i32, i32* %x, align 4
  %inc126 = add nsw i32 %88, 1
  store i32 %inc126, i32* %x, align 4
  br label %for.cond107

for.end127:                                       ; preds = %for.cond107
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  store i32 0, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %for.end127, %for.end90, %for.end53, %for.end22, %sw.bb
  br label %for.inc128

for.inc128:                                       ; preds = %sw.epilog
  %89 = load i32, i32* %y, align 4
  %inc129 = add nsw i32 %89, 1
  store i32 %inc129, i32* %y, align 4
  %90 = load i8*, i8** %raw.addr, align 8
  store i8* %90, i8** %prev, align 8
  %91 = load i32, i32* %len, align 4
  %92 = load i8*, i8** %raw.addr, align 8
  %idx.ext = sext i32 %91 to i64
  %add.ptr = getelementptr inbounds i8, i8* %92, i64 %idx.ext
  store i8* %add.ptr, i8** %raw.addr, align 8
  br label %for.cond

for.end130:                                       ; preds = %for.cond
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end130, %sw.default
  %93 = load i32, i32* %retval, align 4
  ret i32 %93
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @depalette(i32 %w, i32 %h, i8* %src, %struct.TPixel* %dest, i8* %plte) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %src.addr = alloca i8*, align 8
  %dest.addr = alloca %struct.TPixel*, align 8
  %plte.addr = alloca i8*, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %c = alloca i32, align 4
  %tmp = alloca %struct.TPixel, align 1
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store i8* %src, i8** %src.addr, align 8
  store %struct.TPixel* %dest, %struct.TPixel** %dest.addr, align 8
  store i8* %plte, i8** %plte.addr, align 8
  store i32 0, i32* %y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %y, align 4
  %1 = load i32, i32* %h.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %src.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %2, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %3 = load i32, i32* %x, align 4
  %4 = load i32, i32* %w.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %5 = load i8*, i8** %src.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 0
  %6 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %6 to i32
  store i32 %conv, i32* %c, align 4
  %7 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8
  %incdec.ptr4 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %7, i32 1
  store %struct.TPixel* %incdec.ptr4, %struct.TPixel** %dest.addr, align 8
  %8 = load i8*, i8** %plte.addr, align 8
  %9 = load i32, i32* %c, align 4
  %mul = mul nsw i32 %9, 3
  %add = add nsw i32 %mul, 0
  %idxprom = sext i32 %add to i64
  %arrayidx5 = getelementptr inbounds i8, i8* %8, i64 %idxprom
  %10 = load i8, i8* %arrayidx5, align 1
  %11 = load i8*, i8** %plte.addr, align 8
  %12 = load i32, i32* %c, align 4
  %mul6 = mul nsw i32 %12, 3
  %add7 = add nsw i32 %mul6, 1
  %idxprom8 = sext i32 %add7 to i64
  %arrayidx9 = getelementptr inbounds i8, i8* %11, i64 %idxprom8
  %13 = load i8, i8* %arrayidx9, align 1
  %14 = load i8*, i8** %plte.addr, align 8
  %15 = load i32, i32* %c, align 4
  %mul10 = mul nsw i32 %15, 3
  %add11 = add nsw i32 %mul10, 2
  %idxprom12 = sext i32 %add11 to i64
  %arrayidx13 = getelementptr inbounds i8, i8* %14, i64 %idxprom12
  %16 = load i8, i8* %arrayidx13, align 1
  %17 = load i32, i32* %c, align 4
  %tobool = icmp ne i32 %17, 0
  %18 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 255, i32 0
  %conv14 = trunc i32 %cond to i8
  %call = call i32 @tigrRGBA(i8 zeroext %10, i8 zeroext %13, i8 zeroext %16, i8 zeroext %conv14)
  %19 = bitcast %struct.TPixel* %tmp to i32*
  store i32 %call, i32* %19, align 1
  %20 = bitcast %struct.TPixel* %7 to i8*
  %21 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %20, i8* align 1 %21, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %22 = load i32, i32* %x, align 4
  %inc = add nsw i32 %22, 1
  store i32 %inc, i32* %x, align 4
  %23 = load i8*, i8** %src.addr, align 8
  %incdec.ptr15 = getelementptr inbounds i8, i8* %23, i32 1
  store i8* %incdec.ptr15, i8** %src.addr, align 8
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %24 = load i32, i32* %y, align 4
  %inc17 = add nsw i32 %24, 1
  store i32 %inc17, i32* %y, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @convert(i32 %bpp, i32 %w, i32 %h, i8* %src, %struct.TPixel* %dest) #0 {
entry:
  %bpp.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %src.addr = alloca i8*, align 8
  %dest.addr = alloca %struct.TPixel*, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %tmp = alloca %struct.TPixel, align 1
  %tmp9 = alloca %struct.TPixel, align 1
  %tmp17 = alloca %struct.TPixel, align 1
  %tmp24 = alloca %struct.TPixel, align 1
  store i32 %bpp, i32* %bpp.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store i8* %src, i8** %src.addr, align 8
  store %struct.TPixel* %dest, %struct.TPixel** %dest.addr, align 8
  store i32 0, i32* %y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc30, %entry
  %0 = load i32, i32* %y, align 4
  %1 = load i32, i32* %h.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end32

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %src.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %2, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %3 = load i32, i32* %x, align 4
  %4 = load i32, i32* %w.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %5 = load i32, i32* %bpp.addr, align 4
  switch i32 %5, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb7
    i32 3, label %sw.bb15
    i32 4, label %sw.bb22
  ]

sw.bb:                                            ; preds = %for.body3
  %6 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8
  %incdec.ptr4 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %6, i32 1
  store %struct.TPixel* %incdec.ptr4, %struct.TPixel** %dest.addr, align 8
  %7 = load i8*, i8** %src.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %7, i64 0
  %8 = load i8, i8* %arrayidx, align 1
  %9 = load i8*, i8** %src.addr, align 8
  %arrayidx5 = getelementptr inbounds i8, i8* %9, i64 0
  %10 = load i8, i8* %arrayidx5, align 1
  %11 = load i8*, i8** %src.addr, align 8
  %arrayidx6 = getelementptr inbounds i8, i8* %11, i64 0
  %12 = load i8, i8* %arrayidx6, align 1
  %call = call i32 @tigrRGB(i8 zeroext %8, i8 zeroext %10, i8 zeroext %12)
  %13 = bitcast %struct.TPixel* %tmp to i32*
  store i32 %call, i32* %13, align 1
  %14 = bitcast %struct.TPixel* %6 to i8*
  %15 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %14, i8* align 1 %15, i64 4, i1 false)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body3
  %16 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8
  %incdec.ptr8 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %16, i32 1
  store %struct.TPixel* %incdec.ptr8, %struct.TPixel** %dest.addr, align 8
  %17 = load i8*, i8** %src.addr, align 8
  %arrayidx10 = getelementptr inbounds i8, i8* %17, i64 0
  %18 = load i8, i8* %arrayidx10, align 1
  %19 = load i8*, i8** %src.addr, align 8
  %arrayidx11 = getelementptr inbounds i8, i8* %19, i64 0
  %20 = load i8, i8* %arrayidx11, align 1
  %21 = load i8*, i8** %src.addr, align 8
  %arrayidx12 = getelementptr inbounds i8, i8* %21, i64 0
  %22 = load i8, i8* %arrayidx12, align 1
  %23 = load i8*, i8** %src.addr, align 8
  %arrayidx13 = getelementptr inbounds i8, i8* %23, i64 1
  %24 = load i8, i8* %arrayidx13, align 1
  %call14 = call i32 @tigrRGBA(i8 zeroext %18, i8 zeroext %20, i8 zeroext %22, i8 zeroext %24)
  %25 = bitcast %struct.TPixel* %tmp9 to i32*
  store i32 %call14, i32* %25, align 1
  %26 = bitcast %struct.TPixel* %16 to i8*
  %27 = bitcast %struct.TPixel* %tmp9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %26, i8* align 1 %27, i64 4, i1 false)
  br label %sw.epilog

sw.bb15:                                          ; preds = %for.body3
  %28 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8
  %incdec.ptr16 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %28, i32 1
  store %struct.TPixel* %incdec.ptr16, %struct.TPixel** %dest.addr, align 8
  %29 = load i8*, i8** %src.addr, align 8
  %arrayidx18 = getelementptr inbounds i8, i8* %29, i64 0
  %30 = load i8, i8* %arrayidx18, align 1
  %31 = load i8*, i8** %src.addr, align 8
  %arrayidx19 = getelementptr inbounds i8, i8* %31, i64 1
  %32 = load i8, i8* %arrayidx19, align 1
  %33 = load i8*, i8** %src.addr, align 8
  %arrayidx20 = getelementptr inbounds i8, i8* %33, i64 2
  %34 = load i8, i8* %arrayidx20, align 1
  %call21 = call i32 @tigrRGB(i8 zeroext %30, i8 zeroext %32, i8 zeroext %34)
  %35 = bitcast %struct.TPixel* %tmp17 to i32*
  store i32 %call21, i32* %35, align 1
  %36 = bitcast %struct.TPixel* %28 to i8*
  %37 = bitcast %struct.TPixel* %tmp17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %36, i8* align 1 %37, i64 4, i1 false)
  br label %sw.epilog

sw.bb22:                                          ; preds = %for.body3
  %38 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8
  %incdec.ptr23 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %38, i32 1
  store %struct.TPixel* %incdec.ptr23, %struct.TPixel** %dest.addr, align 8
  %39 = load i8*, i8** %src.addr, align 8
  %arrayidx25 = getelementptr inbounds i8, i8* %39, i64 0
  %40 = load i8, i8* %arrayidx25, align 1
  %41 = load i8*, i8** %src.addr, align 8
  %arrayidx26 = getelementptr inbounds i8, i8* %41, i64 1
  %42 = load i8, i8* %arrayidx26, align 1
  %43 = load i8*, i8** %src.addr, align 8
  %arrayidx27 = getelementptr inbounds i8, i8* %43, i64 2
  %44 = load i8, i8* %arrayidx27, align 1
  %45 = load i8*, i8** %src.addr, align 8
  %arrayidx28 = getelementptr inbounds i8, i8* %45, i64 3
  %46 = load i8, i8* %arrayidx28, align 1
  %call29 = call i32 @tigrRGBA(i8 zeroext %40, i8 zeroext %42, i8 zeroext %44, i8 zeroext %46)
  %47 = bitcast %struct.TPixel* %tmp24 to i32*
  store i32 %call29, i32* %47, align 1
  %48 = bitcast %struct.TPixel* %38 to i8*
  %49 = bitcast %struct.TPixel* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %48, i8* align 1 %49, i64 4, i1 false)
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body3, %sw.bb22, %sw.bb15, %sw.bb7, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %50 = load i32, i32* %x, align 4
  %inc = add nsw i32 %50, 1
  store i32 %inc, i32* %x, align 4
  %51 = load i32, i32* %bpp.addr, align 4
  %52 = load i8*, i8** %src.addr, align 8
  %idx.ext = sext i32 %51 to i64
  %add.ptr = getelementptr inbounds i8, i8* %52, i64 %idx.ext
  store i8* %add.ptr, i8** %src.addr, align 8
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc30

for.inc30:                                        ; preds = %for.end
  %53 = load i32, i32* %y, align 4
  %inc31 = add nsw i32 %53, 1
  store i32 %inc31, i32* %y, align 4
  br label %for.cond

for.end32:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i8 @paeth(i8 zeroext %a, i8 zeroext %b, i8 zeroext %c) #0 {
entry:
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %c.addr = alloca i8, align 1
  %p = alloca i32, align 4
  %pa = alloca i32, align 4
  %pb = alloca i32, align 4
  %pc = alloca i32, align 4
  store i8 %a, i8* %a.addr, align 1
  store i8 %b, i8* %b.addr, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %a.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %b.addr, align 1
  %conv1 = zext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i8, i8* %c.addr, align 1
  %conv2 = zext i8 %2 to i32
  %sub = sub nsw i32 %add, %conv2
  store i32 %sub, i32* %p, align 4
  %3 = load i32, i32* %p, align 4
  %4 = load i8, i8* %a.addr, align 1
  %conv3 = zext i8 %4 to i32
  %sub4 = sub nsw i32 %3, %conv3
  %call = call i32 @abs(i32 %sub4) #14
  store i32 %call, i32* %pa, align 4
  %5 = load i32, i32* %p, align 4
  %6 = load i8, i8* %b.addr, align 1
  %conv5 = zext i8 %6 to i32
  %sub6 = sub nsw i32 %5, %conv5
  %call7 = call i32 @abs(i32 %sub6) #14
  store i32 %call7, i32* %pb, align 4
  %7 = load i32, i32* %p, align 4
  %8 = load i8, i8* %c.addr, align 1
  %conv8 = zext i8 %8 to i32
  %sub9 = sub nsw i32 %7, %conv8
  %call10 = call i32 @abs(i32 %sub9) #14
  store i32 %call10, i32* %pc, align 4
  %9 = load i32, i32* %pa, align 4
  %10 = load i32, i32* %pb, align 4
  %cmp = icmp sle i32 %9, %10
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %11 = load i32, i32* %pa, align 4
  %12 = load i32, i32* %pc, align 4
  %cmp12 = icmp sle i32 %11, %12
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %13 = load i8, i8* %a.addr, align 1
  %conv14 = zext i8 %13 to i32
  br label %cond.end21

cond.false:                                       ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %pb, align 4
  %15 = load i32, i32* %pc, align 4
  %cmp15 = icmp sle i32 %14, %15
  br i1 %cmp15, label %cond.true17, label %cond.false19

cond.true17:                                      ; preds = %cond.false
  %16 = load i8, i8* %b.addr, align 1
  %conv18 = zext i8 %16 to i32
  br label %cond.end

cond.false19:                                     ; preds = %cond.false
  %17 = load i8, i8* %c.addr, align 1
  %conv20 = zext i8 %17 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false19, %cond.true17
  %cond = phi i32 [ %conv18, %cond.true17 ], [ %conv20, %cond.false19 ]
  br label %cond.end21

cond.end21:                                       ; preds = %cond.end, %cond.true
  %cond22 = phi i32 [ %conv14, %cond.true ], [ %cond, %cond.end ]
  %conv23 = trunc i32 %cond22 to i8
  ret i8 %conv23
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @tigrRGB(i8 zeroext %r, i8 zeroext %g, i8 zeroext %b) #0 {
entry:
  %retval = alloca %struct.TPixel, align 1
  %r.addr = alloca i8, align 1
  %g.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  store i8 %r, i8* %r.addr, align 1
  store i8 %g, i8* %g.addr, align 1
  store i8 %b, i8* %b.addr, align 1
  %0 = load i8, i8* %r.addr, align 1
  %r1 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 2
  store i8 %0, i8* %r1, align 1
  %1 = load i8, i8* %g.addr, align 1
  %g2 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 1
  store i8 %1, i8* %g2, align 1
  %2 = load i8, i8* %b.addr, align 1
  %b3 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 0
  store i8 %2, i8* %b3, align 1
  %a = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 3
  store i8 -1, i8* %a, align 1
  %3 = bitcast %struct.TPixel* %retval to i32*
  %4 = load i32, i32* %3, align 1
  ret i32 %4
}

declare i32 @fputc(i32, %struct.__sFILE*) #4

declare i64 @"\01_fwrite"(i8*, i64, i64, %struct.__sFILE*) #4

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @encodeByte(%struct.Save* %s, i8 zeroext %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i8, align 1
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i8 %v, i8* %v.addr, align 1
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %1 = load i8, i8* %v.addr, align 1
  %conv = zext i8 %1 to i32
  call void @updateAdler(%struct.Save* %0, i32 %conv)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %prev = getelementptr inbounds %struct.Save, %struct.Save* %2, i32 0, i32 3
  %3 = load i32, i32* %prev, align 4
  %4 = load i8, i8* %v.addr, align 1
  %conv1 = zext i8 %4 to i32
  %cmp = icmp eq i32 %3, %conv1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen = getelementptr inbounds %struct.Save, %struct.Save* %5, i32 0, i32 4
  %6 = load i32, i32* %runlen, align 8
  %cmp3 = icmp ult i32 %6, 115
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen5 = getelementptr inbounds %struct.Save, %struct.Save* %7, i32 0, i32 4
  %8 = load i32, i32* %runlen5, align 8
  %inc = add i32 %8, 1
  store i32 %inc, i32* %runlen5, align 8
  br label %if.end11

if.else:                                          ; preds = %land.lhs.true, %entry
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen6 = getelementptr inbounds %struct.Save, %struct.Save* %9, i32 0, i32 4
  %10 = load i32, i32* %runlen6, align 8
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.else
  %11 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @endrun(%struct.Save* %11)
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.else
  %12 = load i8, i8* %v.addr, align 1
  %conv8 = zext i8 %12 to i32
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %prev9 = getelementptr inbounds %struct.Save, %struct.Save* %13, i32 0, i32 3
  store i32 %conv8, i32* %prev9, align 4
  %14 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen10 = getelementptr inbounds %struct.Save, %struct.Save* %14, i32 0, i32 4
  store i32 1, i32* %runlen10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @endrun(%struct.Save* %s) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen = getelementptr inbounds %struct.Save, %struct.Save* %0, i32 0, i32 4
  %1 = load i32, i32* %runlen, align 8
  %dec = add i32 %1, -1
  store i32 %dec, i32* %runlen, align 8
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %prev = getelementptr inbounds %struct.Save, %struct.Save* %3, i32 0, i32 3
  %4 = load i32, i32* %prev, align 4
  call void @literal(%struct.Save* %2, i32 %4)
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen1 = getelementptr inbounds %struct.Save, %struct.Save* %5, i32 0, i32 4
  %6 = load i32, i32* %runlen1, align 8
  %cmp = icmp uge i32 %6, 67
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %8 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen2 = getelementptr inbounds %struct.Save, %struct.Save* %8, i32 0, i32 4
  %9 = load i32, i32* %runlen2, align 8
  %sub = sub i32 %9, 67
  call void @encodelen(%struct.Save* %7, i32 277, i32 4, i32 %sub)
  br label %if.end33

if.else:                                          ; preds = %entry
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen3 = getelementptr inbounds %struct.Save, %struct.Save* %10, i32 0, i32 4
  %11 = load i32, i32* %runlen3, align 8
  %cmp4 = icmp uge i32 %11, 35
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen6 = getelementptr inbounds %struct.Save, %struct.Save* %13, i32 0, i32 4
  %14 = load i32, i32* %runlen6, align 8
  %sub7 = sub i32 %14, 35
  call void @encodelen(%struct.Save* %12, i32 273, i32 3, i32 %sub7)
  br label %if.end32

if.else8:                                         ; preds = %if.else
  %15 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen9 = getelementptr inbounds %struct.Save, %struct.Save* %15, i32 0, i32 4
  %16 = load i32, i32* %runlen9, align 8
  %cmp10 = icmp uge i32 %16, 19
  br i1 %cmp10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.else8
  %17 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %18 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen12 = getelementptr inbounds %struct.Save, %struct.Save* %18, i32 0, i32 4
  %19 = load i32, i32* %runlen12, align 8
  %sub13 = sub i32 %19, 19
  call void @encodelen(%struct.Save* %17, i32 269, i32 2, i32 %sub13)
  br label %if.end31

if.else14:                                        ; preds = %if.else8
  %20 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen15 = getelementptr inbounds %struct.Save, %struct.Save* %20, i32 0, i32 4
  %21 = load i32, i32* %runlen15, align 8
  %cmp16 = icmp uge i32 %21, 11
  br i1 %cmp16, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.else14
  %22 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %23 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen18 = getelementptr inbounds %struct.Save, %struct.Save* %23, i32 0, i32 4
  %24 = load i32, i32* %runlen18, align 8
  %sub19 = sub i32 %24, 11
  call void @encodelen(%struct.Save* %22, i32 265, i32 1, i32 %sub19)
  br label %if.end30

if.else20:                                        ; preds = %if.else14
  %25 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen21 = getelementptr inbounds %struct.Save, %struct.Save* %25, i32 0, i32 4
  %26 = load i32, i32* %runlen21, align 8
  %cmp22 = icmp uge i32 %26, 3
  br i1 %cmp22, label %if.then23, label %if.else26

if.then23:                                        ; preds = %if.else20
  %27 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %28 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen24 = getelementptr inbounds %struct.Save, %struct.Save* %28, i32 0, i32 4
  %29 = load i32, i32* %runlen24, align 8
  %sub25 = sub i32 %29, 3
  call void @encodelen(%struct.Save* %27, i32 257, i32 0, i32 %sub25)
  br label %if.end

if.else26:                                        ; preds = %if.else20
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else26
  %30 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %runlen27 = getelementptr inbounds %struct.Save, %struct.Save* %30, i32 0, i32 4
  %31 = load i32, i32* %runlen27, align 8
  %dec28 = add i32 %31, -1
  store i32 %dec28, i32* %runlen27, align 8
  %tobool = icmp ne i32 %31, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %32 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %33 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %prev29 = getelementptr inbounds %struct.Save, %struct.Save* %33, i32 0, i32 3
  %34 = load i32, i32* %prev29, align 4
  call void @literal(%struct.Save* %32, i32 %34)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end

if.end:                                           ; preds = %while.end, %if.then23
  br label %if.end30

if.end30:                                         ; preds = %if.end, %if.then17
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then11
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then5
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @literal(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  %0 = load i32, i32* %v.addr, align 4
  %cmp = icmp ult i32 %0, 144
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %2 = load i32, i32* %v.addr, align 4
  %add = add i32 48, %2
  %sub = sub i32 %add, 0
  call void @putbitsr(%struct.Save* %1, i32 %sub, i32 8)
  br label %if.end14

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %v.addr, align 4
  %cmp1 = icmp ult i32 %3, 256
  br i1 %cmp1, label %if.then2, label %if.else5

if.then2:                                         ; preds = %if.else
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %5 = load i32, i32* %v.addr, align 4
  %add3 = add i32 400, %5
  %sub4 = sub i32 %add3, 144
  call void @putbitsr(%struct.Save* %4, i32 %sub4, i32 9)
  br label %if.end13

if.else5:                                         ; preds = %if.else
  %6 = load i32, i32* %v.addr, align 4
  %cmp6 = icmp ult i32 %6, 280
  br i1 %cmp6, label %if.then7, label %if.else10

if.then7:                                         ; preds = %if.else5
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %8 = load i32, i32* %v.addr, align 4
  %add8 = add i32 0, %8
  %sub9 = sub i32 %add8, 256
  call void @putbitsr(%struct.Save* %7, i32 %sub9, i32 7)
  br label %if.end

if.else10:                                        ; preds = %if.else5
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %10 = load i32, i32* %v.addr, align 4
  %add11 = add i32 192, %10
  %sub12 = sub i32 %add11, 280
  call void @putbitsr(%struct.Save* %9, i32 %sub12, i32 8)
  br label %if.end

if.end:                                           ; preds = %if.else10, %if.then7
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then2
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @updateAdler(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %adler = getelementptr inbounds %struct.Save, %struct.Save* %0, i32 0, i32 1
  %1 = load i32, i32* %adler, align 4
  %and = and i32 %1, 65535
  store i32 %and, i32* %s1, align 4
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %adler1 = getelementptr inbounds %struct.Save, %struct.Save* %2, i32 0, i32 1
  %3 = load i32, i32* %adler1, align 4
  %shr = lshr i32 %3, 16
  %and2 = and i32 %shr, 65535
  store i32 %and2, i32* %s2, align 4
  %4 = load i32, i32* %s1, align 4
  %5 = load i32, i32* %v.addr, align 4
  %add = add i32 %4, %5
  %rem = urem i32 %add, 65521
  store i32 %rem, i32* %s1, align 4
  %6 = load i32, i32* %s2, align 4
  %7 = load i32, i32* %s1, align 4
  %add3 = add i32 %6, %7
  %rem4 = urem i32 %add3, 65521
  store i32 %rem4, i32* %s2, align 4
  %8 = load i32, i32* %s2, align 4
  %shl = shl i32 %8, 16
  %9 = load i32, i32* %s1, align 4
  %add5 = add i32 %shl, %9
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %adler6 = getelementptr inbounds %struct.Save, %struct.Save* %10, i32 0, i32 1
  store i32 %add5, i32* %adler6, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @encodelen(%struct.Save* %s, i32 %code, i32 %bits, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %code.addr = alloca i32, align 4
  %bits.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8
  store i32 %code, i32* %code.addr, align 4
  store i32 %bits, i32* %bits.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %1 = load i32, i32* %code.addr, align 4
  %2 = load i32, i32* %len.addr, align 4
  %3 = load i32, i32* %bits.addr, align 4
  %shr = lshr i32 %2, %3
  %add = add i32 %1, %shr
  call void @literal(%struct.Save* %0, i32 %add)
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8
  %5 = load i32, i32* %len.addr, align 4
  %6 = load i32, i32* %bits.addr, align 4
  call void @putbits(%struct.Save* %4, i32 %5, i32 %6)
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8
  call void @putbits(%struct.Save* %7, i32 0, i32 5)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @copy(%struct.State* %s, i8* %src, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %src.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  %dest = alloca i8*, align 8
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.State*, %struct.State** %s.addr, align 8
  %1 = load i32, i32* %len.addr, align 4
  %call = call i8* @emit(%struct.State* %0, i32 %1)
  store i8* %call, i8** %dest, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load i32, i32* %len.addr, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %len.addr, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %src.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8
  %4 = load i8, i8* %3, align 1
  %5 = load i8*, i8** %dest, align 8
  %incdec.ptr1 = getelementptr inbounds i8, i8* %5, i32 1
  store i8* %incdec.ptr1, i8** %dest, align 8
  store i8 %4, i8* %5, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i8* @emit(%struct.State* %s, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %len.addr = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %1 = load %struct.State*, %struct.State** %s.addr, align 8
  %out = getelementptr inbounds %struct.State, %struct.State* %1, i32 0, i32 4
  %2 = load i8*, i8** %out, align 8
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  store i8* %add.ptr, i8** %out, align 8
  %3 = load %struct.State*, %struct.State** %s.addr, align 8
  %out1 = getelementptr inbounds %struct.State, %struct.State* %3, i32 0, i32 4
  %4 = load i8*, i8** %out1, align 8
  %5 = load %struct.State*, %struct.State** %s.addr, align 8
  %outend = getelementptr inbounds %struct.State, %struct.State* %5, i32 0, i32 5
  %6 = load i8*, i8** %outend, align 8
  %cmp = icmp ule i8* %4, %6
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.State*, %struct.State** %s.addr, align 8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %7, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #19
  unreachable

if.end:                                           ; preds = %entry
  %8 = load %struct.State*, %struct.State** %s.addr, align 8
  %out2 = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 4
  %9 = load i8*, i8** %out2, align 8
  %10 = load i32, i32* %len.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %idx.neg = sub i64 0, %idx.ext3
  %add.ptr4 = getelementptr inbounds i8, i8* %9, i64 %idx.neg
  ret i8* %add.ptr4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @build(%struct.State* %s, i32* %tree, i8* %lens, i32 %symcount) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %tree.addr = alloca i32*, align 8
  %lens.addr = alloca i8*, align 8
  %symcount.addr = alloca i32, align 4
  %n = alloca i32, align 4
  %codes = alloca [16 x i32], align 16
  %first = alloca [16 x i32], align 16
  %counts = alloca [16 x i32], align 16
  %len = alloca i32, align 4
  %code = alloca i32, align 4
  %slot = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i32* %tree, i32** %tree.addr, align 8
  store i8* %lens, i8** %lens.addr, align 8
  store i32 %symcount, i32* %symcount.addr, align 4
  %0 = bitcast [16 x i32]* %counts to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %0, i8 0, i64 64, i1 false)
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %n, align 4
  %2 = load i32, i32* %symcount.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %lens.addr, align 8
  %4 = load i32, i32* %n, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1
  %idxprom1 = zext i8 %5 to i64
  %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 %idxprom1
  %6 = load i32, i32* %arrayidx2, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, i32* %n, align 4
  %inc3 = add nsw i32 %7, 1
  store i32 %inc3, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arrayidx4 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 0
  store i32 0, i32* %arrayidx4, align 16
  %arrayidx5 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 0
  store i32 0, i32* %arrayidx5, align 16
  %arrayidx6 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 0
  store i32 0, i32* %arrayidx6, align 16
  store i32 1, i32* %n, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc26, %for.end
  %8 = load i32, i32* %n, align 4
  %cmp8 = icmp sle i32 %8, 15
  br i1 %cmp8, label %for.body9, label %for.end28

for.body9:                                        ; preds = %for.cond7
  %9 = load i32, i32* %n, align 4
  %sub = sub nsw i32 %9, 1
  %idxprom10 = sext i32 %sub to i64
  %arrayidx11 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 %idxprom10
  %10 = load i32, i32* %arrayidx11, align 4
  %11 = load i32, i32* %n, align 4
  %sub12 = sub nsw i32 %11, 1
  %idxprom13 = sext i32 %sub12 to i64
  %arrayidx14 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 %idxprom13
  %12 = load i32, i32* %arrayidx14, align 4
  %add = add nsw i32 %10, %12
  %shl = shl i32 %add, 1
  %13 = load i32, i32* %n, align 4
  %idxprom15 = sext i32 %13 to i64
  %arrayidx16 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 %idxprom15
  store i32 %shl, i32* %arrayidx16, align 4
  %14 = load i32, i32* %n, align 4
  %sub17 = sub nsw i32 %14, 1
  %idxprom18 = sext i32 %sub17 to i64
  %arrayidx19 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 %idxprom18
  %15 = load i32, i32* %arrayidx19, align 4
  %16 = load i32, i32* %n, align 4
  %sub20 = sub nsw i32 %16, 1
  %idxprom21 = sext i32 %sub20 to i64
  %arrayidx22 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 %idxprom21
  %17 = load i32, i32* %arrayidx22, align 4
  %add23 = add nsw i32 %15, %17
  %18 = load i32, i32* %n, align 4
  %idxprom24 = sext i32 %18 to i64
  %arrayidx25 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 %idxprom24
  store i32 %add23, i32* %arrayidx25, align 4
  br label %for.inc26

for.inc26:                                        ; preds = %for.body9
  %19 = load i32, i32* %n, align 4
  %inc27 = add nsw i32 %19, 1
  store i32 %inc27, i32* %n, align 4
  br label %for.cond7

for.end28:                                        ; preds = %for.cond7
  %arrayidx29 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 15
  %20 = load i32, i32* %arrayidx29, align 4
  %arrayidx30 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 15
  %21 = load i32, i32* %arrayidx30, align 4
  %add31 = add nsw i32 %20, %21
  %22 = load i32, i32* %symcount.addr, align 4
  %cmp32 = icmp sle i32 %add31, %22
  br i1 %cmp32, label %if.end, label %if.then

if.then:                                          ; preds = %for.end28
  %23 = load %struct.State*, %struct.State** %s.addr, align 8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %23, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #19
  unreachable

if.end:                                           ; preds = %for.end28
  store i32 0, i32* %n, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc54, %if.end
  %24 = load i32, i32* %n, align 4
  %25 = load i32, i32* %symcount.addr, align 4
  %cmp34 = icmp slt i32 %24, %25
  br i1 %cmp34, label %for.body35, label %for.end56

for.body35:                                       ; preds = %for.cond33
  %26 = load i8*, i8** %lens.addr, align 8
  %27 = load i32, i32* %n, align 4
  %idxprom36 = sext i32 %27 to i64
  %arrayidx37 = getelementptr inbounds i8, i8* %26, i64 %idxprom36
  %28 = load i8, i8* %arrayidx37, align 1
  %conv = zext i8 %28 to i32
  store i32 %conv, i32* %len, align 4
  %29 = load i32, i32* %len, align 4
  %cmp38 = icmp ne i32 %29, 0
  br i1 %cmp38, label %if.then40, label %if.end53

if.then40:                                        ; preds = %for.body35
  %30 = load i32, i32* %len, align 4
  %idxprom41 = sext i32 %30 to i64
  %arrayidx42 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 %idxprom41
  %31 = load i32, i32* %arrayidx42, align 4
  %inc43 = add nsw i32 %31, 1
  store i32 %inc43, i32* %arrayidx42, align 4
  store i32 %31, i32* %code, align 4
  %32 = load i32, i32* %len, align 4
  %idxprom44 = sext i32 %32 to i64
  %arrayidx45 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 %idxprom44
  %33 = load i32, i32* %arrayidx45, align 4
  %inc46 = add nsw i32 %33, 1
  store i32 %inc46, i32* %arrayidx45, align 4
  store i32 %33, i32* %slot, align 4
  %34 = load i32, i32* %code, align 4
  %35 = load i32, i32* %len, align 4
  %sub47 = sub nsw i32 32, %35
  %shl48 = shl i32 %34, %sub47
  %36 = load i32, i32* %n, align 4
  %shl49 = shl i32 %36, 4
  %or = or i32 %shl48, %shl49
  %37 = load i32, i32* %len, align 4
  %or50 = or i32 %or, %37
  %38 = load i32*, i32** %tree.addr, align 8
  %39 = load i32, i32* %slot, align 4
  %idxprom51 = sext i32 %39 to i64
  %arrayidx52 = getelementptr inbounds i32, i32* %38, i64 %idxprom51
  store i32 %or50, i32* %arrayidx52, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then40, %for.body35
  br label %for.inc54

for.inc54:                                        ; preds = %if.end53
  %40 = load i32, i32* %n, align 4
  %inc55 = add nsw i32 %40, 1
  store i32 %inc55, i32* %n, align 4
  br label %for.cond33

for.end56:                                        ; preds = %for.cond33
  %arrayidx57 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 15
  %41 = load i32, i32* %arrayidx57, align 4
  ret i32 %41
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @decode(%struct.State* %s, i32* %tree, i32 %max) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %tree.addr = alloca i32*, align 8
  %max.addr = alloca i32, align 4
  %lo = alloca i32, align 4
  %hi = alloca i32, align 4
  %key = alloca i32, align 4
  %search = alloca i32, align 4
  %guess = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i32* %tree, i32** %tree.addr, align 8
  store i32 %max, i32* %max.addr, align 4
  store i32 0, i32* %lo, align 4
  %0 = load i32, i32* %max.addr, align 4
  store i32 %0, i32* %hi, align 4
  %1 = load %struct.State*, %struct.State** %s.addr, align 8
  %bits = getelementptr inbounds %struct.State, %struct.State* %1, i32 0, i32 0
  %2 = load i32, i32* %bits, align 8
  %call = call i32 @rev16(i32 %2)
  %shl = shl i32 %call, 16
  %or = or i32 %shl, 65535
  store i32 %or, i32* %search, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %3 = load i32, i32* %lo, align 4
  %4 = load i32, i32* %hi, align 4
  %cmp = icmp ult i32 %3, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i32, i32* %lo, align 4
  %6 = load i32, i32* %hi, align 4
  %add = add i32 %5, %6
  %div = udiv i32 %add, 2
  store i32 %div, i32* %guess, align 4
  %7 = load i32, i32* %search, align 4
  %8 = load i32*, i32** %tree.addr, align 8
  %9 = load i32, i32* %guess, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr inbounds i32, i32* %8, i64 %idxprom
  %10 = load i32, i32* %arrayidx, align 4
  %cmp1 = icmp ult i32 %7, %10
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %11 = load i32, i32* %guess, align 4
  store i32 %11, i32* %hi, align 4
  br label %if.end

if.else:                                          ; preds = %while.body
  %12 = load i32, i32* %guess, align 4
  %add2 = add i32 %12, 1
  store i32 %add2, i32* %lo, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %13 = load i32*, i32** %tree.addr, align 8
  %14 = load i32, i32* %lo, align 4
  %sub = sub i32 %14, 1
  %idxprom3 = zext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds i32, i32* %13, i64 %idxprom3
  %15 = load i32, i32* %arrayidx4, align 4
  store i32 %15, i32* %key, align 4
  %16 = load i32, i32* %search, align 4
  %17 = load i32, i32* %key, align 4
  %xor = xor i32 %16, %17
  %18 = load i32, i32* %key, align 4
  %and = and i32 %18, 15
  %sub5 = sub i32 32, %and
  %shr = lshr i32 %xor, %sub5
  %cmp6 = icmp eq i32 %shr, 0
  br i1 %cmp6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %while.end
  %19 = load %struct.State*, %struct.State** %s.addr, align 8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %19, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #19
  unreachable

if.end8:                                          ; preds = %while.end
  %20 = load %struct.State*, %struct.State** %s.addr, align 8
  %21 = load i32, i32* %key, align 4
  %and9 = and i32 %21, 15
  %call10 = call i32 @bits(%struct.State* %20, i32 %and9)
  %22 = load i32, i32* %key, align 4
  %shr11 = lshr i32 %22, 4
  %and12 = and i32 %shr11, 4095
  ret i32 %and12
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @run(%struct.State* %s, i32 %sym) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %sym.addr = alloca i32, align 4
  %length = alloca i32, align 4
  %dsym = alloca i32, align 4
  %offs = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8
  store i32 %sym, i32* %sym.addr, align 4
  %0 = load %struct.State*, %struct.State** %s.addr, align 8
  %1 = load i32, i32* %sym.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* @lenBits, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %call = call i32 @bits(%struct.State* %0, i32 %conv)
  %3 = load i32, i32* %sym.addr, align 4
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds [31 x i32], [31 x i32]* @lenBase, i64 0, i64 %idxprom1
  %4 = load i32, i32* %arrayidx2, align 4
  %add = add nsw i32 %call, %4
  store i32 %add, i32* %length, align 4
  %5 = load %struct.State*, %struct.State** %s.addr, align 8
  %6 = load %struct.State*, %struct.State** %s.addr, align 8
  %distcodes = getelementptr inbounds %struct.State, %struct.State* %6, i32 0, i32 8
  %arraydecay = getelementptr inbounds [32 x i32], [32 x i32]* %distcodes, i32 0, i32 0
  %7 = load %struct.State*, %struct.State** %s.addr, align 8
  %tdist = getelementptr inbounds %struct.State, %struct.State* %7, i32 0, i32 11
  %8 = load i32, i32* %tdist, align 4
  %call3 = call i32 @decode(%struct.State* %5, i32* %arraydecay, i32 %8)
  store i32 %call3, i32* %dsym, align 4
  %9 = load %struct.State*, %struct.State** %s.addr, align 8
  %10 = load i32, i32* %dsym, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @distBits, i64 0, i64 %idxprom4
  %11 = load i8, i8* %arrayidx5, align 1
  %conv6 = sext i8 %11 to i32
  %call7 = call i32 @bits(%struct.State* %9, i32 %conv6)
  %12 = load i32, i32* %dsym, align 4
  %idxprom8 = sext i32 %12 to i64
  %arrayidx9 = getelementptr inbounds [32 x i32], [32 x i32]* @distBase, i64 0, i64 %idxprom8
  %13 = load i32, i32* %arrayidx9, align 4
  %add10 = add nsw i32 %call7, %13
  store i32 %add10, i32* %offs, align 4
  %14 = load %struct.State*, %struct.State** %s.addr, align 8
  %15 = load %struct.State*, %struct.State** %s.addr, align 8
  %out = getelementptr inbounds %struct.State, %struct.State* %15, i32 0, i32 4
  %16 = load i8*, i8** %out, align 8
  %17 = load i32, i32* %offs, align 4
  %idx.ext = sext i32 %17 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 %idx.neg
  %18 = load i32, i32* %length, align 4
  call void @copy(%struct.State* %14, i8* %add.ptr, i32 %18)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @rev16(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %and = and i32 %0, 255
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* @reverseTable, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 8
  %2 = load i32, i32* %n.addr, align 4
  %shr = lshr i32 %2, 8
  %and1 = and i32 %shr, 255
  %idxprom2 = zext i32 %and1 to i64
  %arrayidx3 = getelementptr inbounds [256 x i8], [256 x i8]* @reverseTable, i64 0, i64 %idxprom2
  %3 = load i8, i8* %arrayidx3, align 1
  %conv4 = zext i8 %3 to i32
  %or = or i32 %shl, %conv4
  ret i32 %or
}

attributes #0 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { allocsize(0,1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone speculatable }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind }
attributes #6 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { returns_twice "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { nounwind }
attributes #11 = { cold noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="true" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #12 = { allocsize(1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #13 = { allocsize(0,1) }
attributes #14 = { nounwind readnone }
attributes #15 = { allocsize(1) }
attributes #16 = { allocsize(0) }
attributes #17 = { cold noreturn }
attributes #18 = { returns_twice }
attributes #19 = { noreturn }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 7.1.0 (https://github.com/llvm-mirror/clang.git 4519e2637fcc4bf6e3049a0a80e6a5e7b97667cb) (https://github.com/llvm-mirror/llvm.git dd3329aeb25d87d4ac6429c0af220f92e1ba5f26)"}
