; ModuleID = 'micropather.cpp'
source_filename = "micropather.cpp"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%class.OpenQueue = type { %"class.micropather::PathNode"*, [23 x i32], %"class.micropather::Graph"* }
%"class.micropather::Graph" = type { i32 (...)** }
%"class.micropather::PathNode" = type <{ i8*, float, float, float, [4 x i8], %"class.micropather::PathNode"*, i32, i32, i32, [4 x i8], [2 x %"class.micropather::PathNode"*], %"class.micropather::PathNode"*, %"class.micropather::PathNode"*, i8, i8, [6 x i8] }>
%"class.micropather::PathNodePool" = type <{ %"class.micropather::PathNode"**, %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::NodeCost"*, i32, i32, %"class.micropather::PathNode", i32, i32, i32, i32, i32, [4 x i8] }>
%"struct.micropather::PathNodePool::Block" = type { %"struct.micropather::PathNodePool::Block"*, [1 x %"class.micropather::PathNode"] }
%"struct.micropather::NodeCost" = type { %"class.micropather::PathNode"*, float }
%"class.micropather::MicroPather" = type { %"class.micropather::PathNodePool", %"class.micropather::MPVector", %"class.micropather::MPVector.0", %"class.micropather::MPVector.1", %"class.micropather::Graph"*, i32, %"class.micropather::PathCache"* }
%"class.micropather::MPVector" = type { i32, i32, %"struct.micropather::StateCost"* }
%"struct.micropather::StateCost" = type { i8*, float }
%"class.micropather::MPVector.0" = type { i32, i32, %"struct.micropather::NodeCost"* }
%"class.micropather::MPVector.1" = type { i32, i32, float* }
%"class.micropather::PathCache" = type { i32, i32, %"struct.micropather::PathCache::Item"*, i32, i32 }
%"struct.micropather::PathCache::Item" = type { i8*, i8*, i8*, float }
%"class.micropather::MPVector.2" = type { i32, i32, i8** }
%"struct.micropather::CacheData" = type { i32, i32, float, i32, i32, float }
%class.ClosedSet = type { %"class.micropather::Graph"* }

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN9OpenQueue4PushEPN11micropather8PathNodeE(%class.OpenQueue* %this, %"class.micropather::PathNode"* %pNode) #0 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  %pNode.addr = alloca %"class.micropather::PathNode"*, align 8
  %iter = alloca %"class.micropather::PathNode"*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  store %"class.micropather::PathNode"* %pNode, %"class.micropather::PathNode"** %pNode.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  %sentinel = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 11
  %1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next, align 8
  store %"class.micropather::PathNode"* %1, %"class.micropather::PathNode"** %iter, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %if.end
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %totalCost = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %2, i32 0, i32 3
  %3 = load float, float* %totalCost, align 8
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %iter, align 8
  %totalCost2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %4, i32 0, i32 3
  %5 = load float, float* %totalCost2, align 8
  %cmp = fcmp olt float %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %iter, align 8
  %7 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  call void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %6, %"class.micropather::PathNode"* %7)
  %8 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %inOpen = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %8, i32 0, i32 13
  store i8 1, i8* %inOpen, align 8
  br label %while.end

if.end:                                           ; preds = %while.body
  %9 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %iter, align 8
  %next3 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %9, i32 0, i32 11
  %10 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next3, align 8
  store %"class.micropather::PathNode"* %10, %"class.micropather::PathNode"** %iter, align 8
  br label %while.body

while.end:                                        ; preds = %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %this, %"class.micropather::PathNode"* %addThis) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNode"*, align 8
  %addThis.addr = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNode"* %this, %"class.micropather::PathNode"** %this.addr, align 8
  store %"class.micropather::PathNode"* %addThis, %"class.micropather::PathNode"** %addThis.addr, align 8
  %this1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %this.addr, align 8
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %addThis.addr, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 11
  store %"class.micropather::PathNode"* %this1, %"class.micropather::PathNode"** %next, align 8
  %prev = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  %1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %prev, align 8
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %addThis.addr, align 8
  %prev2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %2, i32 0, i32 12
  store %"class.micropather::PathNode"* %1, %"class.micropather::PathNode"** %prev2, align 8
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %addThis.addr, align 8
  %prev3 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %prev3, align 8
  %next4 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %4, i32 0, i32 11
  store %"class.micropather::PathNode"* %3, %"class.micropather::PathNode"** %next4, align 8
  %5 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %addThis.addr, align 8
  %prev5 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  store %"class.micropather::PathNode"* %5, %"class.micropather::PathNode"** %prev5, align 8
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define %"class.micropather::PathNode"* @_ZN9OpenQueue3PopEv(%class.OpenQueue* %this) #0 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  %pNode = alloca %"class.micropather::PathNode"*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  %sentinel = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 11
  %1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next, align 8
  store %"class.micropather::PathNode"* %1, %"class.micropather::PathNode"** %pNode, align 8
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  call void @_ZN11micropather8PathNode6UnlinkEv(%"class.micropather::PathNode"* %2)
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %inOpen = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %3, i32 0, i32 13
  store i8 0, i8* %inOpen, align 8
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  ret %"class.micropather::PathNode"* %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8PathNode6UnlinkEv(%"class.micropather::PathNode"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNode"* %this, %"class.micropather::PathNode"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %this.addr, align 8
  %prev = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %prev, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 11
  %1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next, align 8
  %prev2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %1, i32 0, i32 12
  store %"class.micropather::PathNode"* %0, %"class.micropather::PathNode"** %prev2, align 8
  %next3 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 11
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next3, align 8
  %prev4 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %prev4, align 8
  %next5 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %3, i32 0, i32 11
  store %"class.micropather::PathNode"* %2, %"class.micropather::PathNode"** %next5, align 8
  %prev6 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  store %"class.micropather::PathNode"* null, %"class.micropather::PathNode"** %prev6, align 8
  %next7 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 11
  store %"class.micropather::PathNode"* null, %"class.micropather::PathNode"** %next7, align 8
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN9OpenQueue6UpdateEPN11micropather8PathNodeE(%class.OpenQueue* %this, %"class.micropather::PathNode"* %pNode) #0 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  %pNode.addr = alloca %"class.micropather::PathNode"*, align 8
  %it = alloca %"class.micropather::PathNode"*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  store %"class.micropather::PathNode"* %pNode, %"class.micropather::PathNode"** %pNode.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %prev = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 12
  %1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %prev, align 8
  %sentinel = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel, align 8
  %cmp = icmp ne %"class.micropather::PathNode"* %1, %2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %totalCost = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %3, i32 0, i32 3
  %4 = load float, float* %totalCost, align 8
  %5 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %prev2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %5, i32 0, i32 12
  %6 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %prev2, align 8
  %totalCost3 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %6, i32 0, i32 3
  %7 = load float, float* %totalCost3, align 8
  %cmp4 = fcmp olt float %4, %7
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  call void @_ZN11micropather8PathNode6UnlinkEv(%"class.micropather::PathNode"* %8)
  %sentinel5 = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %9 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel5, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %9, i32 0, i32 11
  %10 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next, align 8
  %11 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  call void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %10, %"class.micropather::PathNode"* %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %12 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %totalCost6 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %12, i32 0, i32 3
  %13 = load float, float* %totalCost6, align 8
  %14 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %next7 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %14, i32 0, i32 11
  %15 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next7, align 8
  %totalCost8 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %15, i32 0, i32 3
  %16 = load float, float* %totalCost8, align 8
  %cmp9 = fcmp ogt float %13, %16
  br i1 %cmp9, label %if.then10, label %if.end16

if.then10:                                        ; preds = %if.end
  %17 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %next11 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %17, i32 0, i32 11
  %18 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next11, align 8
  store %"class.micropather::PathNode"* %18, %"class.micropather::PathNode"** %it, align 8
  %19 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  call void @_ZN11micropather8PathNode6UnlinkEv(%"class.micropather::PathNode"* %19)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then10
  %20 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %totalCost12 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %20, i32 0, i32 3
  %21 = load float, float* %totalCost12, align 8
  %22 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %totalCost13 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %22, i32 0, i32 3
  %23 = load float, float* %totalCost13, align 8
  %cmp14 = fcmp ogt float %21, %23
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %24 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %next15 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %24, i32 0, i32 11
  %25 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next15, align 8
  store %"class.micropather::PathNode"* %25, %"class.micropather::PathNode"** %it, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %26 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %27 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  call void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %26, %"class.micropather::PathNode"* %27)
  br label %if.end16

if.end16:                                         ; preds = %while.end, %if.end
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather12PathNodePoolC2Ejj(%"class.micropather::PathNodePool"* %this, i32 %_allocate, i32 %_typicalAdjacent) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %_allocate.addr = alloca i32, align 4
  %_typicalAdjacent.addr = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i32 %_allocate, i32* %_allocate.addr, align 4
  store i32 %_typicalAdjacent, i32* %_typicalAdjacent.addr, align 4
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %firstBlock = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 1
  store %"struct.micropather::PathNodePool::Block"* null, %"struct.micropather::PathNodePool::Block"** %firstBlock, align 8
  %blocks = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  store %"struct.micropather::PathNodePool::Block"* null, %"struct.micropather::PathNodePool::Block"** %blocks, align 8
  %freeMemSentinel = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %allocate = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %0 = load i32, i32* %_allocate.addr, align 4
  store i32 %0, i32* %allocate, align 8
  %nAllocated = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 8
  store i32 0, i32* %nAllocated, align 4
  %nAvailable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 9
  store i32 0, i32* %nAvailable, align 8
  %freeMemSentinel2 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  call void @_ZN11micropather8PathNode12InitSentinelEv(%"class.micropather::PathNode"* %freeMemSentinel2)
  %allocate3 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %1 = load i32, i32* %allocate3, align 8
  %2 = load i32, i32* %_typicalAdjacent.addr, align 4
  %mul = mul i32 %1, %2
  %cacheCap = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 4
  store i32 %mul, i32* %cacheCap, align 8
  %cacheSize = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 5
  store i32 0, i32* %cacheSize, align 4
  %cacheCap4 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 4
  %3 = load i32, i32* %cacheCap4, align 8
  %conv = sext i32 %3 to i64
  %mul5 = mul i64 %conv, 16
  %call = call i8* @malloc(i64 %mul5) #10
  %4 = bitcast i8* %call to %"struct.micropather::NodeCost"*
  %cache = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 3
  store %"struct.micropather::NodeCost"* %4, %"struct.micropather::NodeCost"** %cache, align 8
  %hashShift = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 10
  store i32 3, i32* %hashShift, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call6 = call i32 @_ZNK11micropather12PathNodePool8HashSizeEv(%"class.micropather::PathNodePool"* %this1)
  %allocate7 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %5 = load i32, i32* %allocate7, align 8
  %cmp = icmp ult i32 %call6, %5
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %hashShift8 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 10
  %6 = load i32, i32* %hashShift8, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %hashShift8, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call9 = call i32 @_ZNK11micropather12PathNodePool8HashSizeEv(%"class.micropather::PathNodePool"* %this1)
  %conv10 = zext i32 %call9 to i64
  %call11 = call i8* @calloc(i64 %conv10, i64 8) #11
  %7 = bitcast i8* %call11 to %"class.micropather::PathNode"**
  %hashTable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  store %"class.micropather::PathNode"** %7, %"class.micropather::PathNode"*** %hashTable, align 8
  %call12 = call %"struct.micropather::PathNodePool::Block"* @_ZN11micropather12PathNodePool8NewBlockEv(%"class.micropather::PathNodePool"* %this1)
  %firstBlock13 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 1
  store %"struct.micropather::PathNodePool::Block"* %call12, %"struct.micropather::PathNodePool::Block"** %firstBlock13, align 8
  %blocks14 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  store %"struct.micropather::PathNodePool::Block"* %call12, %"struct.micropather::PathNodePool::Block"** %blocks14, align 8
  %totalCollide = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 11
  store i32 0, i32* %totalCollide, align 8
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8PathNode12InitSentinelEv(%"class.micropather::PathNode"* %this) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNode"* %this, %"class.micropather::PathNode"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %this.addr, align 8
  call void @_ZN11micropather8PathNode5ClearEv(%"class.micropather::PathNode"* %this1)
  call void @_ZN11micropather8PathNode4InitEjPvffPS0_(%"class.micropather::PathNode"* %this1, i32 0, i8* null, float 0x47EFFFFFE0000000, float 0x47EFFFFFE0000000, %"class.micropather::PathNode"* null)
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 11
  store %"class.micropather::PathNode"* %this1, %"class.micropather::PathNode"** %next, align 8
  %prev = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 12
  store %"class.micropather::PathNode"* %this1, %"class.micropather::PathNode"** %prev, align 8
  ret void
}

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #2

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather12PathNodePool8HashSizeEv(%"class.micropather::PathNodePool"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %hashShift = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 10
  %0 = load i32, i32* %hashShift, align 4
  %shl = shl i32 1, %0
  ret i32 %shl
}

; Function Attrs: allocsize(0,1)
declare i8* @calloc(i64, i64) #3

; Function Attrs: noinline optnone ssp uwtable
define %"struct.micropather::PathNodePool::Block"* @_ZN11micropather12PathNodePool8NewBlockEv(%"class.micropather::PathNodePool"* %this) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %block = alloca %"struct.micropather::PathNodePool::Block"*, align 8
  %i = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %allocate = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %0 = load i32, i32* %allocate, align 8
  %sub = sub i32 %0, 1
  %conv = zext i32 %sub to i64
  %mul = mul i64 88, %conv
  %add = add i64 96, %mul
  %call = call i8* @calloc(i64 1, i64 %add) #11
  %1 = bitcast i8* %call to %"struct.micropather::PathNodePool::Block"*
  store %"struct.micropather::PathNodePool::Block"* %1, %"struct.micropather::PathNodePool::Block"** %block, align 8
  %2 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %block, align 8
  %nextBlock = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %2, i32 0, i32 0
  store %"struct.micropather::PathNodePool::Block"* null, %"struct.micropather::PathNodePool::Block"** %nextBlock, align 8
  %allocate2 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %3 = load i32, i32* %allocate2, align 8
  %nAvailable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 9
  %4 = load i32, i32* %nAvailable, align 8
  %add3 = add i32 %4, %3
  store i32 %add3, i32* %nAvailable, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %allocate4 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %6 = load i32, i32* %allocate4, align 8
  %cmp = icmp ult i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %freeMemSentinel = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %7 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %block, align 8
  %pathNode = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %7, i32 0, i32 1
  %8 = load i32, i32* %i, align 4
  %idxprom = zext i32 %8 to i64
  %arrayidx = getelementptr inbounds [1 x %"class.micropather::PathNode"], [1 x %"class.micropather::PathNode"]* %pathNode, i64 0, i64 %idxprom
  call void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %freeMemSentinel, %"class.micropather::PathNode"* %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %block, align 8
  ret %"struct.micropather::PathNodePool::Block"* %10
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather12PathNodePoolC1Ejj(%"class.micropather::PathNodePool"* %this, i32 %_allocate, i32 %_typicalAdjacent) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %_allocate.addr = alloca i32, align 4
  %_typicalAdjacent.addr = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i32 %_allocate, i32* %_allocate.addr, align 4
  store i32 %_typicalAdjacent, i32* %_typicalAdjacent.addr, align 4
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %0 = load i32, i32* %_allocate.addr, align 4
  %1 = load i32, i32* %_typicalAdjacent.addr, align 4
  call void @_ZN11micropather12PathNodePoolC2Ejj(%"class.micropather::PathNodePool"* %this1, i32 %0, i32 %1)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather12PathNodePoolD2Ev(%"class.micropather::PathNodePool"* %this) unnamed_addr #1 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  invoke void @_ZN11micropather12PathNodePool5ClearEv(%"class.micropather::PathNodePool"* %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %firstBlock = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 1
  %0 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %firstBlock, align 8
  %1 = bitcast %"struct.micropather::PathNodePool::Block"* %0 to i8*
  invoke void @free(i8* %1)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %cache = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 3
  %2 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %cache, align 8
  %3 = bitcast %"struct.micropather::NodeCost"* %2 to i8*
  invoke void @free(i8* %3)
          to label %invoke.cont3 unwind label %terminate.lpad

invoke.cont3:                                     ; preds = %invoke.cont2
  %hashTable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %4 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable, align 8
  %5 = bitcast %"class.micropather::PathNode"** %4 to i8*
  invoke void @free(i8* %5)
          to label %invoke.cont4 unwind label %terminate.lpad

invoke.cont4:                                     ; preds = %invoke.cont3
  ret void

terminate.lpad:                                   ; preds = %invoke.cont3, %invoke.cont2, %invoke.cont, %entry
  %6 = landingpad { i8*, i32 }
          catch i8* null
  %7 = extractvalue { i8*, i32 } %6, 0
  call void @__clang_call_terminate(i8* %7) #12
  unreachable
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather12PathNodePool5ClearEv(%"class.micropather::PathNodePool"* %this) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %b = alloca %"struct.micropather::PathNodePool::Block"*, align 8
  %temp = alloca %"struct.micropather::PathNodePool::Block"*, align 8
  %i = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %blocks = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %blocks, align 8
  store %"struct.micropather::PathNodePool::Block"* %0, %"struct.micropather::PathNodePool::Block"** %b, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %tobool = icmp ne %"struct.micropather::PathNodePool::Block"* %1, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %nextBlock = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %2, i32 0, i32 0
  %3 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %nextBlock, align 8
  store %"struct.micropather::PathNodePool::Block"* %3, %"struct.micropather::PathNodePool::Block"** %temp, align 8
  %4 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %firstBlock = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 1
  %5 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %firstBlock, align 8
  %cmp = icmp ne %"struct.micropather::PathNodePool::Block"* %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %7 = bitcast %"struct.micropather::PathNodePool::Block"* %6 to i8*
  call void @free(i8* %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %8 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %temp, align 8
  store %"struct.micropather::PathNodePool::Block"* %8, %"struct.micropather::PathNodePool::Block"** %b, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %firstBlock2 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 1
  %9 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %firstBlock2, align 8
  %blocks3 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  store %"struct.micropather::PathNodePool::Block"* %9, %"struct.micropather::PathNodePool::Block"** %blocks3, align 8
  %nAllocated = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 8
  %10 = load i32, i32* %nAllocated, align 4
  %cmp4 = icmp ugt i32 %10, 0
  br i1 %cmp4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %while.end
  %freeMemSentinel = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %freeMemSentinel6 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %freeMemSentinel6, i32 0, i32 11
  store %"class.micropather::PathNode"* %freeMemSentinel, %"class.micropather::PathNode"** %next, align 8
  %freeMemSentinel7 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %freeMemSentinel8 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %prev = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %freeMemSentinel8, i32 0, i32 12
  store %"class.micropather::PathNode"* %freeMemSentinel7, %"class.micropather::PathNode"** %prev, align 8
  %hashTable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %11 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable, align 8
  %12 = bitcast %"class.micropather::PathNode"** %11 to i8*
  %call = call i32 @_ZNK11micropather12PathNodePool8HashSizeEv(%"class.micropather::PathNodePool"* %this1)
  %conv = zext i32 %call to i64
  %mul = mul i64 8, %conv
  call void @llvm.memset.p0i8.i64(i8* align 8 %12, i8 0, i64 %mul, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then5
  %13 = load i32, i32* %i, align 4
  %allocate = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %14 = load i32, i32* %allocate, align 8
  %cmp9 = icmp ult i32 %13, %14
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %freeMemSentinel10 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %firstBlock11 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 1
  %15 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %firstBlock11, align 8
  %pathNode = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %15, i32 0, i32 1
  %16 = load i32, i32* %i, align 4
  %idxprom = zext i32 %16 to i64
  %arrayidx = getelementptr inbounds [1 x %"class.micropather::PathNode"], [1 x %"class.micropather::PathNode"]* %pathNode, i64 0, i64 %idxprom
  call void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %freeMemSentinel10, %"class.micropather::PathNode"* %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end12

if.end12:                                         ; preds = %for.end, %while.end
  %allocate13 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %18 = load i32, i32* %allocate13, align 8
  %nAvailable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 9
  store i32 %18, i32* %nAvailable, align 8
  %nAllocated14 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 8
  store i32 0, i32* %nAllocated14, align 4
  %cacheSize = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 5
  store i32 0, i32* %cacheSize, align 4
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: noinline noreturn nounwind
define linkonce_odr hidden void @__clang_call_terminate(i8*) #4 {
  %2 = call i8* @__cxa_begin_catch(i8* %0) #13
  call void @_ZSt9terminatev() #12
  unreachable
}

declare i8* @__cxa_begin_catch(i8*)

declare void @_ZSt9terminatev()

declare void @free(i8*) #5

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather12PathNodePoolD1Ev(%"class.micropather::PathNodePool"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  call void @_ZN11micropather12PathNodePoolD2Ev(%"class.micropather::PathNodePool"* %this1) #13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @_ZN11micropather12PathNodePool9PushCacheEPKNS_8NodeCostEiPi(%"class.micropather::PathNodePool"* %this, %"struct.micropather::NodeCost"* %nodes, i32 %nNodes, i32* %start) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %nodes.addr = alloca %"struct.micropather::NodeCost"*, align 8
  %nNodes.addr = alloca i32, align 4
  %start.addr = alloca i32*, align 8
  %i = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store %"struct.micropather::NodeCost"* %nodes, %"struct.micropather::NodeCost"** %nodes.addr, align 8
  store i32 %nNodes, i32* %nNodes.addr, align 4
  store i32* %start, i32** %start.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %0 = load i32*, i32** %start.addr, align 8
  store i32 -1, i32* %0, align 4
  %1 = load i32, i32* %nNodes.addr, align 4
  %cacheSize = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 5
  %2 = load i32, i32* %cacheSize, align 4
  %add = add nsw i32 %1, %2
  %cacheCap = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 4
  %3 = load i32, i32* %cacheCap, align 8
  %cmp = icmp sle i32 %add, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* %nNodes.addr, align 4
  %cmp2 = icmp slt i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %nodes.addr, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %6, i64 %idxprom
  %cache = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 3
  %8 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %cache, align 8
  %9 = load i32, i32* %i, align 4
  %cacheSize3 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 5
  %10 = load i32, i32* %cacheSize3, align 4
  %add4 = add nsw i32 %9, %10
  %idxprom5 = sext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %8, i64 %idxprom5
  %11 = bitcast %"struct.micropather::NodeCost"* %arrayidx6 to i8*
  %12 = bitcast %"struct.micropather::NodeCost"* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %12, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, i32* %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cacheSize7 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 5
  %14 = load i32, i32* %cacheSize7, align 4
  %15 = load i32*, i32** %start.addr, align 8
  store i32 %14, i32* %15, align 4
  %16 = load i32, i32* %nNodes.addr, align 4
  %cacheSize8 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 5
  %17 = load i32, i32* %cacheSize8, align 4
  %add9 = add nsw i32 %17, %16
  store i32 %add9, i32* %cacheSize8, align 4
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %for.end
  %18 = load i1, i1* %retval, align 1
  ret i1 %18
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #6

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather12PathNodePool8GetCacheEiiPNS_8NodeCostE(%"class.micropather::PathNodePool"* %this, i32 %start, i32 %nNodes, %"struct.micropather::NodeCost"* %nodes) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %start.addr = alloca i32, align 4
  %nNodes.addr = alloca i32, align 4
  %nodes.addr = alloca %"struct.micropather::NodeCost"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i32 %start, i32* %start.addr, align 4
  store i32 %nNodes, i32* %nNodes.addr, align 4
  store %"struct.micropather::NodeCost"* %nodes, %"struct.micropather::NodeCost"** %nodes.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %0 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %nodes.addr, align 8
  %1 = bitcast %"struct.micropather::NodeCost"* %0 to i8*
  %cache = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 3
  %2 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %cache, align 8
  %3 = load i32, i32* %start.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %2, i64 %idxprom
  %4 = bitcast %"struct.micropather::NodeCost"* %arrayidx to i8*
  %5 = load i32, i32* %nNodes.addr, align 4
  %conv = sext i32 %5 to i64
  %mul = mul i64 16, %conv
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1, i8* align 8 %4, i64 %mul, i1 false)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #6

; Function Attrs: noinline optnone ssp uwtable
define i32 @_ZN11micropather12PathNodePool4HashEPv(%"class.micropather::PathNodePool"* %this, i8* %voidval) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %voidval.addr = alloca i8*, align 8
  %h = alloca i64, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i8* %voidval, i8** %voidval.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %0 = load i8*, i8** %voidval.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  store i64 %1, i64* %h, align 8
  %2 = load i64, i64* %h, align 8
  %call = call i32 @_ZNK11micropather12PathNodePool8HashMaskEv(%"class.micropather::PathNodePool"* %this1)
  %conv = zext i32 %call to i64
  %rem = urem i64 %2, %conv
  %conv2 = trunc i64 %rem to i32
  ret i32 %conv2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather12PathNodePool8HashMaskEv(%"class.micropather::PathNodePool"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %hashShift = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 10
  %0 = load i32, i32* %hashShift, align 4
  %shl = shl i32 1, %0
  %sub = sub nsw i32 %shl, 1
  ret i32 %sub
}

; Function Attrs: noinline optnone ssp uwtable
define %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool5AllocEv(%"class.micropather::PathNodePool"* %this) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %b = alloca %"struct.micropather::PathNodePool::Block"*, align 8
  %pathNode = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %freeMemSentinel = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %freeMemSentinel, i32 0, i32 11
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next, align 8
  %freeMemSentinel2 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %cmp = icmp eq %"class.micropather::PathNode"* %0, %freeMemSentinel2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %"struct.micropather::PathNodePool::Block"* @_ZN11micropather12PathNodePool8NewBlockEv(%"class.micropather::PathNodePool"* %this1)
  store %"struct.micropather::PathNodePool::Block"* %call, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %blocks = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  %1 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %blocks, align 8
  %2 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %nextBlock = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %2, i32 0, i32 0
  store %"struct.micropather::PathNodePool::Block"* %1, %"struct.micropather::PathNodePool::Block"** %nextBlock, align 8
  %3 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %blocks3 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  store %"struct.micropather::PathNodePool::Block"* %3, %"struct.micropather::PathNodePool::Block"** %blocks3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %freeMemSentinel4 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 6
  %next5 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %freeMemSentinel4, i32 0, i32 11
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next5, align 8
  store %"class.micropather::PathNode"* %4, %"class.micropather::PathNode"** %pathNode, align 8
  %5 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pathNode, align 8
  call void @_ZN11micropather8PathNode6UnlinkEv(%"class.micropather::PathNode"* %5)
  %nAllocated = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 8
  %6 = load i32, i32* %nAllocated, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %nAllocated, align 4
  %nAvailable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 9
  %7 = load i32, i32* %nAvailable, align 8
  %dec = add i32 %7, -1
  store i32 %dec, i32* %nAvailable, align 8
  %8 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pathNode, align 8
  ret %"class.micropather::PathNode"* %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather12PathNodePool11AddPathNodeEjPNS_8PathNodeE(%"class.micropather::PathNodePool"* %this, i32 %key, %"class.micropather::PathNode"* %root) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %key.addr = alloca i32, align 4
  %root.addr = alloca %"class.micropather::PathNode"*, align 8
  %p = alloca %"class.micropather::PathNode"*, align 8
  %dir = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i32 %key, i32* %key.addr, align 4
  store %"class.micropather::PathNode"* %root, %"class.micropather::PathNode"** %root.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %hashTable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %0 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable, align 8
  %1 = load i32, i32* %key.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %0, i64 %idxprom
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx, align 8
  %tobool = icmp ne %"class.micropather::PathNode"* %2, null
  br i1 %tobool, label %if.then, label %if.else16

if.then:                                          ; preds = %entry
  %hashTable2 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %3 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable2, align 8
  %4 = load i32, i32* %key.addr, align 4
  %idxprom3 = zext i32 %4 to i64
  %arrayidx4 = getelementptr inbounds %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %3, i64 %idxprom3
  %5 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx4, align 8
  store %"class.micropather::PathNode"* %5, %"class.micropather::PathNode"** %p, align 8
  br label %while.body

while.body:                                       ; preds = %if.then, %if.end
  %6 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root.addr, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %6, i32 0, i32 0
  %7 = load i8*, i8** %state, align 8
  %8 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %p, align 8
  %state5 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %8, i32 0, i32 0
  %9 = load i8*, i8** %state5, align 8
  %cmp = icmp ult i8* %7, %9
  %10 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 0, i32 1
  store i32 %cond, i32* %dir, align 4
  %11 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %p, align 8
  %child = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %11, i32 0, i32 10
  %12 = load i32, i32* %dir, align 4
  %idxprom6 = sext i32 %12 to i64
  %arrayidx7 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child, i64 0, i64 %idxprom6
  %13 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx7, align 8
  %tobool8 = icmp ne %"class.micropather::PathNode"* %13, null
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %while.body
  %14 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %p, align 8
  %child10 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %14, i32 0, i32 10
  %15 = load i32, i32* %dir, align 4
  %idxprom11 = sext i32 %15 to i64
  %arrayidx12 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child10, i64 0, i64 %idxprom11
  %16 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx12, align 8
  store %"class.micropather::PathNode"* %16, %"class.micropather::PathNode"** %p, align 8
  br label %if.end

if.else:                                          ; preds = %while.body
  %17 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root.addr, align 8
  %18 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %p, align 8
  %child13 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %18, i32 0, i32 10
  %19 = load i32, i32* %dir, align 4
  %idxprom14 = sext i32 %19 to i64
  %arrayidx15 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child13, i64 0, i64 %idxprom14
  store %"class.micropather::PathNode"* %17, %"class.micropather::PathNode"** %arrayidx15, align 8
  br label %while.end

if.end:                                           ; preds = %if.then9
  br label %while.body

while.end:                                        ; preds = %if.else
  br label %if.end20

if.else16:                                        ; preds = %entry
  %20 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root.addr, align 8
  %hashTable17 = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %21 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable17, align 8
  %22 = load i32, i32* %key.addr, align 4
  %idxprom18 = zext i32 %22 to i64
  %arrayidx19 = getelementptr inbounds %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %21, i64 %idxprom18
  store %"class.micropather::PathNode"* %20, %"class.micropather::PathNode"** %arrayidx19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else16, %while.end
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool13FetchPathNodeEPv(%"class.micropather::PathNodePool"* %this, i8* %state) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %state.addr = alloca i8*, align 8
  %key = alloca i32, align 4
  %root = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i8* %state, i8** %state.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %0 = load i8*, i8** %state.addr, align 8
  %call = call i32 @_ZN11micropather12PathNodePool4HashEPv(%"class.micropather::PathNodePool"* %this1, i8* %0)
  store i32 %call, i32* %key, align 4
  %hashTable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %1 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable, align 8
  %2 = load i32, i32* %key, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %1, i64 %idxprom
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx, align 8
  store %"class.micropather::PathNode"* %3, %"class.micropather::PathNode"** %root, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %entry
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %tobool = icmp ne %"class.micropather::PathNode"* %4, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %state2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %5, i32 0, i32 0
  %6 = load i8*, i8** %state2, align 8
  %7 = load i8*, i8** %state.addr, align 8
  %cmp = icmp eq i8* %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %8 = load i8*, i8** %state.addr, align 8
  %9 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %state3 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %9, i32 0, i32 0
  %10 = load i8*, i8** %state3, align 8
  %cmp4 = icmp ult i8* %8, %10
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %11 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %child = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %11, i32 0, i32 10
  %arrayidx5 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child, i64 0, i64 0
  %12 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx5, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %13 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %child6 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %13, i32 0, i32 10
  %arrayidx7 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child6, i64 0, i64 1
  %14 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx7, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %"class.micropather::PathNode"* [ %12, %cond.true ], [ %14, %cond.false ]
  store %"class.micropather::PathNode"* %cond, %"class.micropather::PathNode"** %root, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then, %while.cond
  %15 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  ret %"class.micropather::PathNode"* %15
}

; Function Attrs: noinline optnone ssp uwtable
define %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool11GetPathNodeEjPvffPNS_8PathNodeE(%"class.micropather::PathNodePool"* %this, i32 %frame, i8* %_state, float %_costFromStart, float %_estToGoal, %"class.micropather::PathNode"* %_parent) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %frame.addr = alloca i32, align 4
  %_state.addr = alloca i8*, align 8
  %_costFromStart.addr = alloca float, align 4
  %_estToGoal.addr = alloca float, align 4
  %_parent.addr = alloca %"class.micropather::PathNode"*, align 8
  %key = alloca i32, align 4
  %root = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i32 %frame, i32* %frame.addr, align 4
  store i8* %_state, i8** %_state.addr, align 8
  store float %_costFromStart, float* %_costFromStart.addr, align 4
  store float %_estToGoal, float* %_estToGoal.addr, align 4
  store %"class.micropather::PathNode"* %_parent, %"class.micropather::PathNode"** %_parent.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %0 = load i8*, i8** %_state.addr, align 8
  %call = call i32 @_ZN11micropather12PathNodePool4HashEPv(%"class.micropather::PathNodePool"* %this1, i8* %0)
  store i32 %call, i32* %key, align 4
  %hashTable = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 0
  %1 = load %"class.micropather::PathNode"**, %"class.micropather::PathNode"*** %hashTable, align 8
  %2 = load i32, i32* %key, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %1, i64 %idxprom
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx, align 8
  store %"class.micropather::PathNode"* %3, %"class.micropather::PathNode"** %root, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %entry
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %tobool = icmp ne %"class.micropather::PathNode"* %4, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %5, i32 0, i32 0
  %6 = load i8*, i8** %state, align 8
  %7 = load i8*, i8** %_state.addr, align 8
  %cmp = icmp eq i8* %6, %7
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %while.body
  %8 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %frame2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %8, i32 0, i32 6
  %9 = load i32, i32* %frame2, align 8
  %10 = load i32, i32* %frame.addr, align 4
  %cmp3 = icmp eq i32 %9, %10
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %while.end

if.end:                                           ; preds = %if.then
  %11 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %12 = load i32, i32* %frame.addr, align 4
  %13 = load i8*, i8** %_state.addr, align 8
  %14 = load float, float* %_costFromStart.addr, align 4
  %15 = load float, float* %_estToGoal.addr, align 4
  %16 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %_parent.addr, align 8
  call void @_ZN11micropather8PathNode4InitEjPvffPS0_(%"class.micropather::PathNode"* %11, i32 %12, i8* %13, float %14, float %15, %"class.micropather::PathNode"* %16)
  br label %while.end

if.end5:                                          ; preds = %while.body
  %17 = load i8*, i8** %_state.addr, align 8
  %18 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %state6 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %18, i32 0, i32 0
  %19 = load i8*, i8** %state6, align 8
  %cmp7 = icmp ult i8* %17, %19
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  %20 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %child = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %20, i32 0, i32 10
  %arrayidx8 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child, i64 0, i64 0
  %21 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx8, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  %22 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %child9 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %22, i32 0, i32 10
  %arrayidx10 = getelementptr inbounds [2 x %"class.micropather::PathNode"*], [2 x %"class.micropather::PathNode"*]* %child9, i64 0, i64 1
  %23 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %arrayidx10, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %"class.micropather::PathNode"* [ %21, %cond.true ], [ %23, %cond.false ]
  store %"class.micropather::PathNode"* %cond, %"class.micropather::PathNode"** %root, align 8
  br label %while.cond

while.end:                                        ; preds = %if.end, %if.then4, %while.cond
  %24 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %tobool11 = icmp ne %"class.micropather::PathNode"* %24, null
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %while.end
  %call13 = call %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool5AllocEv(%"class.micropather::PathNodePool"* %this1)
  store %"class.micropather::PathNode"* %call13, %"class.micropather::PathNode"** %root, align 8
  %25 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  call void @_ZN11micropather8PathNode5ClearEv(%"class.micropather::PathNode"* %25)
  %26 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  %27 = load i32, i32* %frame.addr, align 4
  %28 = load i8*, i8** %_state.addr, align 8
  %29 = load float, float* %_costFromStart.addr, align 4
  %30 = load float, float* %_estToGoal.addr, align 4
  %31 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %_parent.addr, align 8
  call void @_ZN11micropather8PathNode4InitEjPvffPS0_(%"class.micropather::PathNode"* %26, i32 %27, i8* %28, float %29, float %30, %"class.micropather::PathNode"* %31)
  %32 = load i32, i32* %key, align 4
  %33 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  call void @_ZN11micropather12PathNodePool11AddPathNodeEjPNS_8PathNodeE(%"class.micropather::PathNodePool"* %this1, i32 %32, %"class.micropather::PathNode"* %33)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %while.end
  %34 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %root, align 8
  ret %"class.micropather::PathNode"* %34
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather8PathNode4InitEjPvffPS0_(%"class.micropather::PathNode"* %this, i32 %_frame, i8* %_state, float %_costFromStart, float %_estToGoal, %"class.micropather::PathNode"* %_parent) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNode"*, align 8
  %_frame.addr = alloca i32, align 4
  %_state.addr = alloca i8*, align 8
  %_costFromStart.addr = alloca float, align 4
  %_estToGoal.addr = alloca float, align 4
  %_parent.addr = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNode"* %this, %"class.micropather::PathNode"** %this.addr, align 8
  store i32 %_frame, i32* %_frame.addr, align 4
  store i8* %_state, i8** %_state.addr, align 8
  store float %_costFromStart, float* %_costFromStart.addr, align 4
  store float %_estToGoal, float* %_estToGoal.addr, align 4
  store %"class.micropather::PathNode"* %_parent, %"class.micropather::PathNode"** %_parent.addr, align 8
  %this1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %this.addr, align 8
  %0 = load i8*, i8** %_state.addr, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 0
  store i8* %0, i8** %state, align 8
  %1 = load float, float* %_costFromStart.addr, align 4
  %costFromStart = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 1
  store float %1, float* %costFromStart, align 8
  %2 = load float, float* %_estToGoal.addr, align 4
  %estToGoal = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 2
  store float %2, float* %estToGoal, align 4
  call void @_ZN11micropather8PathNode13CalcTotalCostEv(%"class.micropather::PathNode"* %this1)
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %_parent.addr, align 8
  %parent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 5
  store %"class.micropather::PathNode"* %3, %"class.micropather::PathNode"** %parent, align 8
  %4 = load i32, i32* %_frame.addr, align 4
  %frame = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 6
  store i32 %4, i32* %frame, align 8
  %inOpen = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 13
  store i8 0, i8* %inOpen, align 8
  %inClosed = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 14
  store i8 0, i8* %inClosed, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather8PathNode5ClearEv(%"class.micropather::PathNode"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNode"* %this, %"class.micropather::PathNode"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %this.addr, align 8
  %0 = bitcast %"class.micropather::PathNode"* %this1 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %0, i8 0, i64 88, i1 false)
  %numAdjacent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 7
  store i32 -1, i32* %numAdjacent, align 4
  %cacheIndex = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 8
  store i32 -1, i32* %cacheIndex, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8PathNode13CalcTotalCostEv(%"class.micropather::PathNode"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::PathNode"* %this, %"class.micropather::PathNode"** %this.addr, align 8
  %this1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %this.addr, align 8
  %costFromStart = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 1
  %0 = load float, float* %costFromStart, align 8
  %cmp = fcmp olt float %0, 0x47EFFFFFE0000000
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %estToGoal = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 2
  %1 = load float, float* %estToGoal, align 4
  %cmp2 = fcmp olt float %1, 0x47EFFFFFE0000000
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %costFromStart3 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 1
  %2 = load float, float* %costFromStart3, align 8
  %estToGoal4 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 2
  %3 = load float, float* %estToGoal4, align 4
  %add = fadd float %2, %3
  %totalCost = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 3
  store float %add, float* %totalCost, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %totalCost5 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %this1, i32 0, i32 3
  store float 0x47EFFFFFE0000000, float* %totalCost5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPatherC2EPNS_5GraphEjjb(%"class.micropather::MicroPather"* %this, %"class.micropather::Graph"* %_graph, i32 %allocate, i32 %typicalAdjacent, i1 zeroext %cache) unnamed_addr #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %_graph.addr = alloca %"class.micropather::Graph"*, align 8
  %allocate.addr = alloca i32, align 4
  %typicalAdjacent.addr = alloca i32, align 4
  %cache.addr = alloca i8, align 1
  %exn.slot = alloca i8*
  %ehselector.slot = alloca i32
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store %"class.micropather::Graph"* %_graph, %"class.micropather::Graph"** %_graph.addr, align 8
  store i32 %allocate, i32* %allocate.addr, align 4
  store i32 %typicalAdjacent, i32* %typicalAdjacent.addr, align 4
  %frombool = zext i1 %cache to i8
  store i8 %frombool, i8* %cache.addr, align 1
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %0 = load i32, i32* %allocate.addr, align 4
  %1 = load i32, i32* %typicalAdjacent.addr, align 4
  call void @_ZN11micropather12PathNodePoolC1Ejj(%"class.micropather::PathNodePool"* %pathNodePool, i32 %0, i32 %1)
  %stateCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  invoke void @_ZN11micropather8MPVectorINS_9StateCostEEC1Ev(%"class.micropather::MPVector"* %stateCostVec)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %nodeCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  invoke void @_ZN11micropather8MPVectorINS_8NodeCostEEC1Ev(%"class.micropather::MPVector.0"* %nodeCostVec)
          to label %invoke.cont3 unwind label %lpad2

invoke.cont3:                                     ; preds = %invoke.cont
  %costVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 3
  invoke void @_ZN11micropather8MPVectorIfEC1Ev(%"class.micropather::MPVector.1"* %costVec)
          to label %invoke.cont5 unwind label %lpad4

invoke.cont5:                                     ; preds = %invoke.cont3
  %graph = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %2 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %_graph.addr, align 8
  store %"class.micropather::Graph"* %2, %"class.micropather::Graph"** %graph, align 8
  %frame = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  store i32 0, i32* %frame, align 8
  %pathCache = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  store %"class.micropather::PathCache"* null, %"class.micropather::PathCache"** %pathCache, align 8
  %3 = load i8, i8* %cache.addr, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont5
  %call = invoke i8* @_Znwm(i64 24) #14
          to label %invoke.cont7 unwind label %lpad6

invoke.cont7:                                     ; preds = %if.then
  %4 = bitcast i8* %call to %"class.micropather::PathCache"*
  %5 = load i32, i32* %allocate.addr, align 4
  %mul = mul i32 %5, 4
  invoke void @_ZN11micropather9PathCacheC1Ei(%"class.micropather::PathCache"* %4, i32 %mul)
          to label %invoke.cont9 unwind label %lpad8

invoke.cont9:                                     ; preds = %invoke.cont7
  %pathCache10 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  store %"class.micropather::PathCache"* %4, %"class.micropather::PathCache"** %pathCache10, align 8
  br label %if.end

lpad:                                             ; preds = %entry
  %6 = landingpad { i8*, i32 }
          cleanup
  %7 = extractvalue { i8*, i32 } %6, 0
  store i8* %7, i8** %exn.slot, align 8
  %8 = extractvalue { i8*, i32 } %6, 1
  store i32 %8, i32* %ehselector.slot, align 4
  br label %ehcleanup13

lpad2:                                            ; preds = %invoke.cont
  %9 = landingpad { i8*, i32 }
          cleanup
  %10 = extractvalue { i8*, i32 } %9, 0
  store i8* %10, i8** %exn.slot, align 8
  %11 = extractvalue { i8*, i32 } %9, 1
  store i32 %11, i32* %ehselector.slot, align 4
  br label %ehcleanup12

lpad4:                                            ; preds = %invoke.cont3
  %12 = landingpad { i8*, i32 }
          cleanup
  %13 = extractvalue { i8*, i32 } %12, 0
  store i8* %13, i8** %exn.slot, align 8
  %14 = extractvalue { i8*, i32 } %12, 1
  store i32 %14, i32* %ehselector.slot, align 4
  br label %ehcleanup11

lpad6:                                            ; preds = %if.then
  %15 = landingpad { i8*, i32 }
          cleanup
  %16 = extractvalue { i8*, i32 } %15, 0
  store i8* %16, i8** %exn.slot, align 8
  %17 = extractvalue { i8*, i32 } %15, 1
  store i32 %17, i32* %ehselector.slot, align 4
  br label %ehcleanup

lpad8:                                            ; preds = %invoke.cont7
  %18 = landingpad { i8*, i32 }
          cleanup
  %19 = extractvalue { i8*, i32 } %18, 0
  store i8* %19, i8** %exn.slot, align 8
  %20 = extractvalue { i8*, i32 } %18, 1
  store i32 %20, i32* %ehselector.slot, align 4
  call void @_ZdlPv(i8* %call) #15
  br label %ehcleanup

if.end:                                           ; preds = %invoke.cont9, %invoke.cont5
  ret void

ehcleanup:                                        ; preds = %lpad8, %lpad6
  call void @_ZN11micropather8MPVectorIfED1Ev(%"class.micropather::MPVector.1"* %costVec) #13
  br label %ehcleanup11

ehcleanup11:                                      ; preds = %ehcleanup, %lpad4
  call void @_ZN11micropather8MPVectorINS_8NodeCostEED1Ev(%"class.micropather::MPVector.0"* %nodeCostVec) #13
  br label %ehcleanup12

ehcleanup12:                                      ; preds = %ehcleanup11, %lpad2
  call void @_ZN11micropather8MPVectorINS_9StateCostEED1Ev(%"class.micropather::MPVector"* %stateCostVec) #13
  br label %ehcleanup13

ehcleanup13:                                      ; preds = %ehcleanup12, %lpad
  call void @_ZN11micropather12PathNodePoolD1Ev(%"class.micropather::PathNodePool"* %pathNodePool) #13
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup13
  %exn = load i8*, i8** %exn.slot, align 8
  %sel = load i32, i32* %ehselector.slot, align 4
  %lpad.val = insertvalue { i8*, i32 } undef, i8* %exn, 0
  %lpad.val14 = insertvalue { i8*, i32 } %lpad.val, i32 %sel, 1
  resume { i8*, i32 } %lpad.val14
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEEC1Ev(%"class.micropather::MPVector"* %this) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  call void @_ZN11micropather8MPVectorINS_9StateCostEEC2Ev(%"class.micropather::MPVector"* %this1)
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEEC1Ev(%"class.micropather::MPVector.0"* %this) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  call void @_ZN11micropather8MPVectorINS_8NodeCostEEC2Ev(%"class.micropather::MPVector.0"* %this1)
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfEC1Ev(%"class.micropather::MPVector.1"* %this) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  call void @_ZN11micropather8MPVectorIfEC2Ev(%"class.micropather::MPVector.1"* %this1)
  ret void
}

; Function Attrs: nobuiltin
declare noalias i8* @_Znwm(i64) #7

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather9PathCacheC1Ei(%"class.micropather::PathCache"* %this, i32 %_allocated) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %_allocated.addr = alloca i32, align 4
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store i32 %_allocated, i32* %_allocated.addr, align 4
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %0 = load i32, i32* %_allocated.addr, align 4
  call void @_ZN11micropather9PathCacheC2Ei(%"class.micropather::PathCache"* %this1, i32 %0)
  ret void
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdlPv(i8*) #8

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfED1Ev(%"class.micropather::MPVector.1"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  call void @_ZN11micropather8MPVectorIfED2Ev(%"class.micropather::MPVector.1"* %this1) #13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEED1Ev(%"class.micropather::MPVector.0"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  call void @_ZN11micropather8MPVectorINS_8NodeCostEED2Ev(%"class.micropather::MPVector.0"* %this1) #13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEED1Ev(%"class.micropather::MPVector"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  call void @_ZN11micropather8MPVectorINS_9StateCostEED2Ev(%"class.micropather::MPVector"* %this1) #13
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPatherC1EPNS_5GraphEjjb(%"class.micropather::MicroPather"* %this, %"class.micropather::Graph"* %_graph, i32 %allocate, i32 %typicalAdjacent, i1 zeroext %cache) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %_graph.addr = alloca %"class.micropather::Graph"*, align 8
  %allocate.addr = alloca i32, align 4
  %typicalAdjacent.addr = alloca i32, align 4
  %cache.addr = alloca i8, align 1
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store %"class.micropather::Graph"* %_graph, %"class.micropather::Graph"** %_graph.addr, align 8
  store i32 %allocate, i32* %allocate.addr, align 4
  store i32 %typicalAdjacent, i32* %typicalAdjacent.addr, align 4
  %frombool = zext i1 %cache to i8
  store i8 %frombool, i8* %cache.addr, align 1
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %0 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %_graph.addr, align 8
  %1 = load i32, i32* %allocate.addr, align 4
  %2 = load i32, i32* %typicalAdjacent.addr, align 4
  %3 = load i8, i8* %cache.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZN11micropather11MicroPatherC2EPNS_5GraphEjjb(%"class.micropather::MicroPather"* %this1, %"class.micropather::Graph"* %0, i32 %1, i32 %2, i1 zeroext %tobool)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather11MicroPatherD2Ev(%"class.micropather::MicroPather"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %pathCache = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %0 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache, align 8
  %isnull = icmp eq %"class.micropather::PathCache"* %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  call void @_ZN11micropather9PathCacheD1Ev(%"class.micropather::PathCache"* %0) #13
  %1 = bitcast %"class.micropather::PathCache"* %0 to i8*
  call void @_ZdlPv(i8* %1) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %entry
  %costVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 3
  call void @_ZN11micropather8MPVectorIfED1Ev(%"class.micropather::MPVector.1"* %costVec) #13
  %nodeCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  call void @_ZN11micropather8MPVectorINS_8NodeCostEED1Ev(%"class.micropather::MPVector.0"* %nodeCostVec) #13
  %stateCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  call void @_ZN11micropather8MPVectorINS_9StateCostEED1Ev(%"class.micropather::MPVector"* %stateCostVec) #13
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  call void @_ZN11micropather12PathNodePoolD1Ev(%"class.micropather::PathNodePool"* %pathNodePool) #13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather9PathCacheD1Ev(%"class.micropather::PathCache"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  call void @_ZN11micropather9PathCacheD2Ev(%"class.micropather::PathCache"* %this1) #13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather11MicroPatherD1Ev(%"class.micropather::MicroPather"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  call void @_ZN11micropather11MicroPatherD2Ev(%"class.micropather::MicroPather"* %this1) #13
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPather5ResetEv(%"class.micropather::MicroPather"* %this) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  call void @_ZN11micropather12PathNodePool5ClearEv(%"class.micropather::PathNodePool"* %pathNodePool)
  %pathCache = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %0 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache, align 8
  %tobool = icmp ne %"class.micropather::PathCache"* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pathCache2 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache2, align 8
  call void @_ZN11micropather9PathCache5ResetEv(%"class.micropather::PathCache"* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %frame = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  store i32 0, i32* %frame, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather9PathCache5ResetEv(%"class.micropather::PathCache"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %nItems = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  %0 = load i32, i32* %nItems, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mem = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %1 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem, align 8
  %2 = bitcast %"struct.micropather::PathCache::Item"* %1 to i8*
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %3 = load i32, i32* %allocated, align 8
  %conv = sext i32 %3 to i64
  %mul = mul i64 32, %conv
  call void @llvm.memset.p0i8.i64(i8* align 8 %2, i8 0, i64 %mul, i1 false)
  %nItems2 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  store i32 0, i32* %nItems2, align 4
  %hit = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 0
  store i32 0, i32* %hit, align 8
  %miss = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 1
  store i32 0, i32* %miss, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPather11GoalReachedEPNS_8PathNodeEPvS3_PNS_8MPVectorIS3_EE(%"class.micropather::MicroPather"* %this, %"class.micropather::PathNode"* %node, i8* %start, i8* %end, %"class.micropather::MPVector.2"* %_path) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %node.addr = alloca %"class.micropather::PathNode"*, align 8
  %start.addr = alloca i8*, align 8
  %end.addr = alloca i8*, align 8
  %_path.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %path = alloca %"class.micropather::MPVector.2"*, align 8
  %count = alloca i32, align 4
  %it = alloca %"class.micropather::PathNode"*, align 8
  %pn0 = alloca %"class.micropather::PathNode"*, align 8
  %pn1 = alloca %"class.micropather::PathNode"*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store %"class.micropather::PathNode"* %node, %"class.micropather::PathNode"** %node.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %end, i8** %end.addr, align 8
  store %"class.micropather::MPVector.2"* %_path, %"class.micropather::MPVector.2"** %_path.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %0 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %_path.addr, align 8
  store %"class.micropather::MPVector.2"* %0, %"class.micropather::MPVector.2"** %path, align 8
  %1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  call void @_ZN11micropather8MPVectorIPvE5clearEv(%"class.micropather::MPVector.2"* %1)
  store i32 1, i32* %count, align 4
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  store %"class.micropather::PathNode"* %2, %"class.micropather::PathNode"** %it, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %parent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %3, i32 0, i32 5
  %4 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %parent, align 8
  %tobool = icmp ne %"class.micropather::PathNode"* %4, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i32, i32* %count, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %count, align 4
  %6 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %parent2 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %6, i32 0, i32 5
  %7 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %parent2, align 8
  store %"class.micropather::PathNode"* %7, %"class.micropather::PathNode"** %it, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = load i32, i32* %count, align 4
  %cmp = icmp slt i32 %8, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.end
  %9 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  call void @_ZN11micropather8MPVectorIPvE6resizeEj(%"class.micropather::MPVector.2"* %9, i32 2)
  %10 = load i8*, i8** %start.addr, align 8
  %11 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %call = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %11, i32 0)
  store i8* %10, i8** %call, align 8
  %12 = load i8*, i8** %end.addr, align 8
  %13 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %call3 = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %13, i32 1)
  store i8* %12, i8** %call3, align 8
  br label %if.end

if.else:                                          ; preds = %while.end
  %14 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %15 = load i32, i32* %count, align 4
  call void @_ZN11micropather8MPVectorIPvE6resizeEj(%"class.micropather::MPVector.2"* %14, i32 %15)
  %16 = load i8*, i8** %start.addr, align 8
  %17 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %call4 = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %17, i32 0)
  store i8* %16, i8** %call4, align 8
  %18 = load i8*, i8** %end.addr, align 8
  %19 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %20 = load i32, i32* %count, align 4
  %sub = sub nsw i32 %20, 1
  %call5 = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %19, i32 %sub)
  store i8* %18, i8** %call5, align 8
  %21 = load i32, i32* %count, align 4
  %sub6 = sub nsw i32 %21, 2
  store i32 %sub6, i32* %count, align 4
  %22 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %parent7 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %22, i32 0, i32 5
  %23 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %parent7, align 8
  store %"class.micropather::PathNode"* %23, %"class.micropather::PathNode"** %it, align 8
  br label %while.cond8

while.cond8:                                      ; preds = %while.body11, %if.else
  %24 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %parent9 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %24, i32 0, i32 5
  %25 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %parent9, align 8
  %tobool10 = icmp ne %"class.micropather::PathNode"* %25, null
  br i1 %tobool10, label %while.body11, label %while.end14

while.body11:                                     ; preds = %while.cond8
  %26 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %26, i32 0, i32 0
  %27 = load i8*, i8** %state, align 8
  %28 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %29 = load i32, i32* %count, align 4
  %call12 = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %28, i32 %29)
  store i8* %27, i8** %call12, align 8
  %30 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %it, align 8
  %parent13 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %30, i32 0, i32 5
  %31 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %parent13, align 8
  store %"class.micropather::PathNode"* %31, %"class.micropather::PathNode"** %it, align 8
  %32 = load i32, i32* %count, align 4
  %dec = add nsw i32 %32, -1
  store i32 %dec, i32* %count, align 4
  br label %while.cond8

while.end14:                                      ; preds = %while.cond8
  br label %if.end

if.end:                                           ; preds = %while.end14, %if.then
  %pathCache = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %33 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache, align 8
  %tobool15 = icmp ne %"class.micropather::PathCache"* %33, null
  br i1 %tobool15, label %if.then16, label %if.end46

if.then16:                                        ; preds = %if.end
  %costVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 3
  call void @_ZN11micropather8MPVectorIfE5clearEv(%"class.micropather::MPVector.1"* %costVec)
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %34 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %call17 = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %34, i32 0)
  %35 = load i8*, i8** %call17, align 8
  %call18 = call %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool13FetchPathNodeEPv(%"class.micropather::PathNodePool"* %pathNodePool, i8* %35)
  store %"class.micropather::PathNode"* %call18, %"class.micropather::PathNode"** %pn0, align 8
  store %"class.micropather::PathNode"* null, %"class.micropather::PathNode"** %pn1, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc41, %if.then16
  %36 = load i32, i32* %i, align 4
  %37 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %call19 = call i32 @_ZNK11micropather8MPVectorIPvE4sizeEv(%"class.micropather::MPVector.2"* %37)
  %sub20 = sub i32 %call19, 1
  %cmp21 = icmp ult i32 %36, %sub20
  br i1 %cmp21, label %for.body, label %for.end43

for.body:                                         ; preds = %for.cond
  %pathNodePool22 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %38 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %39 = load i32, i32* %i, align 4
  %add = add i32 %39, 1
  %call23 = call dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %38, i32 %add)
  %40 = load i8*, i8** %call23, align 8
  %call24 = call %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool13FetchPathNodeEPv(%"class.micropather::PathNodePool"* %pathNodePool22, i8* %40)
  store %"class.micropather::PathNode"* %call24, %"class.micropather::PathNode"** %pn1, align 8
  %nodeCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  call void @_ZN11micropather8MPVectorINS_8NodeCostEE5clearEv(%"class.micropather::MPVector.0"* %nodeCostVec)
  %41 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pn0, align 8
  %nodeCostVec25 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  call void @_ZN11micropather11MicroPather16GetNodeNeighborsEPNS_8PathNodeEPNS_8MPVectorINS_8NodeCostEEE(%"class.micropather::MicroPather"* %this1, %"class.micropather::PathNode"* %41, %"class.micropather::MPVector.0"* %nodeCostVec25)
  store i32 0, i32* %j, align 4
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc, %for.body
  %42 = load i32, i32* %j, align 4
  %nodeCostVec27 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %call28 = call i32 @_ZNK11micropather8MPVectorINS_8NodeCostEE4sizeEv(%"class.micropather::MPVector.0"* %nodeCostVec27)
  %cmp29 = icmp ult i32 %42, %call28
  br i1 %cmp29, label %for.body30, label %for.end

for.body30:                                       ; preds = %for.cond26
  %nodeCostVec31 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %43 = load i32, i32* %j, align 4
  %call32 = call dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec31, i32 %43)
  %node33 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call32, i32 0, i32 0
  %44 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node33, align 8
  %45 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pn1, align 8
  %cmp34 = icmp eq %"class.micropather::PathNode"* %44, %45
  br i1 %cmp34, label %if.then35, label %if.end39

if.then35:                                        ; preds = %for.body30
  %costVec36 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 3
  %nodeCostVec37 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %46 = load i32, i32* %j, align 4
  %call38 = call dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec37, i32 %46)
  %cost = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call38, i32 0, i32 1
  call void @_ZN11micropather8MPVectorIfE9push_backERKf(%"class.micropather::MPVector.1"* %costVec36, float* dereferenceable(4) %cost)
  br label %for.end

if.end39:                                         ; preds = %for.body30
  br label %for.inc

for.inc:                                          ; preds = %if.end39
  %47 = load i32, i32* %j, align 4
  %inc40 = add i32 %47, 1
  store i32 %inc40, i32* %j, align 4
  br label %for.cond26

for.end:                                          ; preds = %if.then35, %for.cond26
  %48 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pn1, align 8
  store %"class.micropather::PathNode"* %48, %"class.micropather::PathNode"** %pn0, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.end
  %49 = load i32, i32* %i, align 4
  %inc42 = add i32 %49, 1
  store i32 %inc42, i32* %i, align 4
  br label %for.cond

for.end43:                                        ; preds = %for.cond
  %pathCache44 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %50 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache44, align 8
  %51 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %costVec45 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 3
  call void @_ZN11micropather9PathCache3AddERKNS_8MPVectorIPvEERKNS1_IfEE(%"class.micropather::PathCache"* %50, %"class.micropather::MPVector.2"* dereferenceable(16) %51, %"class.micropather::MPVector.1"* dereferenceable(16) %costVec45)
  br label %if.end46

if.end46:                                         ; preds = %for.end43, %if.end
  store i32 0, i32* %k, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc51, %if.end46
  %52 = load i32, i32* %k, align 4
  %53 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path, align 8
  %call48 = call i32 @_ZNK11micropather8MPVectorIPvE4sizeEv(%"class.micropather::MPVector.2"* %53)
  %cmp49 = icmp ult i32 %52, %call48
  br i1 %cmp49, label %for.body50, label %for.end53

for.body50:                                       ; preds = %for.cond47
  br label %for.inc51

for.inc51:                                        ; preds = %for.body50
  %54 = load i32, i32* %k, align 4
  %inc52 = add i32 %54, 1
  store i32 %inc52, i32* %k, align 4
  br label %for.cond47

for.end53:                                        ; preds = %for.cond47
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIPvE5clearEv(%"class.micropather::MPVector.2"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIPvE6resizeEj(%"class.micropather::MPVector.2"* %this, i32 %s) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %s.addr = alloca i32, align 4
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  store i32 %s, i32* %s.addr, align 4
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %0 = load i32, i32* %s.addr, align 4
  call void @_ZN11micropather8MPVectorIPvE8capacityEj(%"class.micropather::MPVector.2"* %this1, i32 %0)
  %1 = load i32, i32* %s.addr, align 4
  %m_size = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 1
  store i32 %1, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr dereferenceable(8) i8** @_ZN11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %this, i32 %i) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %i.addr = alloca i32, align 4
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 2
  %0 = load i8**, i8*** %m_buf, align 8
  %1 = load i32, i32* %i.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %0, i64 %idxprom
  ret i8** %arrayidx
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfE5clearEv(%"class.micropather::MPVector.1"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather8MPVectorIPvE4sizeEv(%"class.micropather::MPVector.2"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 1
  %0 = load i32, i32* %m_size, align 4
  ret i32 %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEE5clearEv(%"class.micropather::MPVector.0"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPather16GetNodeNeighborsEPNS_8PathNodeEPNS_8MPVectorINS_8NodeCostEEE(%"class.micropather::MicroPather"* %this, %"class.micropather::PathNode"* %node, %"class.micropather::MPVector.0"* %pNodeCost) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %node.addr = alloca %"class.micropather::PathNode"*, align 8
  %pNodeCost.addr = alloca %"class.micropather::MPVector.0"*, align 8
  %stateCostVecSize = alloca i32, align 4
  %stateCostVecPtr = alloca %"struct.micropather::StateCost"*, align 8
  %pNodeCostPtr = alloca %"struct.micropather::NodeCost"*, align 8
  %i = alloca i32, align 4
  %state18 = alloca i8*, align 8
  %start = alloca i32, align 4
  %pNodeCostPtr39 = alloca %"struct.micropather::NodeCost"*, align 8
  %i44 = alloca i32, align 4
  %pNode = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store %"class.micropather::PathNode"* %node, %"class.micropather::PathNode"** %node.addr, align 8
  store %"class.micropather::MPVector.0"* %pNodeCost, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %numAdjacent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 7
  %1 = load i32, i32* %numAdjacent, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  call void @_ZN11micropather8MPVectorINS_8NodeCostEE6resizeEj(%"class.micropather::MPVector.0"* %2, i32 0)
  br label %if.end63

if.else:                                          ; preds = %entry
  %3 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %cacheIndex = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %3, i32 0, i32 8
  %4 = load i32, i32* %cacheIndex, align 8
  %cmp2 = icmp slt i32 %4, 0
  br i1 %cmp2, label %if.then3, label %if.else37

if.then3:                                         ; preds = %if.else
  %stateCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  call void @_ZN11micropather8MPVectorINS_9StateCostEE6resizeEj(%"class.micropather::MPVector"* %stateCostVec, i32 0)
  %graph = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %5 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph, align 8
  %6 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %6, i32 0, i32 0
  %7 = load i8*, i8** %state, align 8
  %stateCostVec4 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  %8 = bitcast %"class.micropather::Graph"* %5 to void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)***
  %vtable = load void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)**, void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)*** %8, align 8
  %vfn = getelementptr inbounds void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)*, void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)** %vtable, i64 3
  %9 = load void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)*, void (%"class.micropather::Graph"*, i8*, %"class.micropather::MPVector"*)** %vfn, align 8
  call void %9(%"class.micropather::Graph"* %5, i8* %7, %"class.micropather::MPVector"* %stateCostVec4)
  %10 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %stateCostVec5 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  %call = call i32 @_ZNK11micropather8MPVectorINS_9StateCostEE4sizeEv(%"class.micropather::MPVector"* %stateCostVec5)
  call void @_ZN11micropather8MPVectorINS_8NodeCostEE6resizeEj(%"class.micropather::MPVector.0"* %10, i32 %call)
  %stateCostVec6 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  %call7 = call i32 @_ZNK11micropather8MPVectorINS_9StateCostEE4sizeEv(%"class.micropather::MPVector"* %stateCostVec6)
  %11 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %numAdjacent8 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %11, i32 0, i32 7
  store i32 %call7, i32* %numAdjacent8, align 4
  %12 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %numAdjacent9 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %12, i32 0, i32 7
  %13 = load i32, i32* %numAdjacent9, align 4
  %cmp10 = icmp sgt i32 %13, 0
  br i1 %cmp10, label %if.then11, label %if.end36

if.then11:                                        ; preds = %if.then3
  %stateCostVec12 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  %call13 = call i32 @_ZNK11micropather8MPVectorINS_9StateCostEE4sizeEv(%"class.micropather::MPVector"* %stateCostVec12)
  store i32 %call13, i32* %stateCostVecSize, align 4
  %stateCostVec14 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  %call15 = call dereferenceable(16) %"struct.micropather::StateCost"* @_ZN11micropather8MPVectorINS_9StateCostEEixEj(%"class.micropather::MPVector"* %stateCostVec14, i32 0)
  store %"struct.micropather::StateCost"* %call15, %"struct.micropather::StateCost"** %stateCostVecPtr, align 8
  %14 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %call16 = call dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %14, i32 0)
  store %"struct.micropather::NodeCost"* %call16, %"struct.micropather::NodeCost"** %pNodeCostPtr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then11
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %stateCostVecSize, align 4
  %cmp17 = icmp ult i32 %15, %16
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %stateCostVecPtr, align 8
  %18 = load i32, i32* %i, align 4
  %idxprom = zext i32 %18 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %17, i64 %idxprom
  %state19 = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %arrayidx, i32 0, i32 0
  %19 = load i8*, i8** %state19, align 8
  store i8* %19, i8** %state18, align 8
  %20 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %stateCostVecPtr, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom20 = zext i32 %21 to i64
  %arrayidx21 = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %20, i64 %idxprom20
  %cost = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %arrayidx21, i32 0, i32 1
  %22 = load float, float* %cost, align 8
  %23 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %pNodeCostPtr, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom22 = zext i32 %24 to i64
  %arrayidx23 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %23, i64 %idxprom22
  %cost24 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %arrayidx23, i32 0, i32 1
  store float %22, float* %cost24, align 8
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %frame = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %25 = load i32, i32* %frame, align 8
  %26 = load i8*, i8** %state18, align 8
  %call25 = call %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool11GetPathNodeEjPvffPNS_8PathNodeE(%"class.micropather::PathNodePool"* %pathNodePool, i32 %25, i8* %26, float 0x47EFFFFFE0000000, float 0x47EFFFFFE0000000, %"class.micropather::PathNode"* null)
  %27 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %pNodeCostPtr, align 8
  %28 = load i32, i32* %i, align 4
  %idxprom26 = zext i32 %28 to i64
  %arrayidx27 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %27, i64 %idxprom26
  %node28 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %arrayidx27, i32 0, i32 0
  store %"class.micropather::PathNode"* %call25, %"class.micropather::PathNode"** %node28, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %29 = load i32, i32* %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %start, align 4
  %30 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %call29 = call i32 @_ZNK11micropather8MPVectorINS_8NodeCostEE4sizeEv(%"class.micropather::MPVector.0"* %30)
  %cmp30 = icmp ugt i32 %call29, 0
  br i1 %cmp30, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.end
  %pathNodePool31 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %31 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %pNodeCostPtr, align 8
  %32 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %call32 = call i32 @_ZNK11micropather8MPVectorINS_8NodeCostEE4sizeEv(%"class.micropather::MPVector.0"* %32)
  %call33 = call zeroext i1 @_ZN11micropather12PathNodePool9PushCacheEPKNS_8NodeCostEiPi(%"class.micropather::PathNodePool"* %pathNodePool31, %"struct.micropather::NodeCost"* %31, i32 %call32, i32* %start)
  br i1 %call33, label %if.then34, label %if.end

if.then34:                                        ; preds = %land.lhs.true
  %33 = load i32, i32* %start, align 4
  %34 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %cacheIndex35 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %34, i32 0, i32 8
  store i32 %33, i32* %cacheIndex35, align 8
  br label %if.end

if.end:                                           ; preds = %if.then34, %land.lhs.true, %for.end
  br label %if.end36

if.end36:                                         ; preds = %if.end, %if.then3
  br label %if.end62

if.else37:                                        ; preds = %if.else
  %35 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %36 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %numAdjacent38 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %36, i32 0, i32 7
  %37 = load i32, i32* %numAdjacent38, align 4
  call void @_ZN11micropather8MPVectorINS_8NodeCostEE6resizeEj(%"class.micropather::MPVector.0"* %35, i32 %37)
  %38 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %pNodeCost.addr, align 8
  %call40 = call dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %38, i32 0)
  store %"struct.micropather::NodeCost"* %call40, %"struct.micropather::NodeCost"** %pNodeCostPtr39, align 8
  %pathNodePool41 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %39 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %cacheIndex42 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %39, i32 0, i32 8
  %40 = load i32, i32* %cacheIndex42, align 8
  %41 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %numAdjacent43 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %41, i32 0, i32 7
  %42 = load i32, i32* %numAdjacent43, align 4
  %43 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %pNodeCostPtr39, align 8
  call void @_ZN11micropather12PathNodePool8GetCacheEiiPNS_8NodeCostE(%"class.micropather::PathNodePool"* %pathNodePool41, i32 %40, i32 %42, %"struct.micropather::NodeCost"* %43)
  store i32 0, i32* %i44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc59, %if.else37
  %44 = load i32, i32* %i44, align 4
  %45 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node.addr, align 8
  %numAdjacent46 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %45, i32 0, i32 7
  %46 = load i32, i32* %numAdjacent46, align 4
  %cmp47 = icmp slt i32 %44, %46
  br i1 %cmp47, label %for.body48, label %for.end61

for.body48:                                       ; preds = %for.cond45
  %47 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %pNodeCostPtr39, align 8
  %48 = load i32, i32* %i44, align 4
  %idxprom49 = sext i32 %48 to i64
  %arrayidx50 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %47, i64 %idxprom49
  %node51 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %arrayidx50, i32 0, i32 0
  %49 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node51, align 8
  store %"class.micropather::PathNode"* %49, %"class.micropather::PathNode"** %pNode, align 8
  %50 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %frame52 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %50, i32 0, i32 6
  %51 = load i32, i32* %frame52, align 8
  %frame53 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %52 = load i32, i32* %frame53, align 8
  %cmp54 = icmp ne i32 %51, %52
  br i1 %cmp54, label %if.then55, label %if.end58

if.then55:                                        ; preds = %for.body48
  %53 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %frame56 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %54 = load i32, i32* %frame56, align 8
  %55 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %state57 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %55, i32 0, i32 0
  %56 = load i8*, i8** %state57, align 8
  call void @_ZN11micropather8PathNode4InitEjPvffPS0_(%"class.micropather::PathNode"* %53, i32 %54, i8* %56, float 0x47EFFFFFE0000000, float 0x47EFFFFFE0000000, %"class.micropather::PathNode"* null)
  br label %if.end58

if.end58:                                         ; preds = %if.then55, %for.body48
  br label %for.inc59

for.inc59:                                        ; preds = %if.end58
  %57 = load i32, i32* %i44, align 4
  %inc60 = add nsw i32 %57, 1
  store i32 %inc60, i32* %i44, align 4
  br label %for.cond45

for.end61:                                        ; preds = %for.cond45
  br label %if.end62

if.end62:                                         ; preds = %for.end61, %if.end36
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather8MPVectorINS_8NodeCostEE4sizeEv(%"class.micropather::MPVector.0"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 1
  %0 = load i32, i32* %m_size, align 4
  ret i32 %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %this, i32 %i) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  %i.addr = alloca i32, align 4
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %m_buf, align 8
  %1 = load i32, i32* %i.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %0, i64 %idxprom
  ret %"struct.micropather::NodeCost"* %arrayidx
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfE9push_backERKf(%"class.micropather::MPVector.1"* %this, float* dereferenceable(4) %t) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  %t.addr = alloca float*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  store float* %t, float** %t.addr, align 8
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 1
  %0 = load i32, i32* %m_size, align 4
  %add = add i32 %0, 1
  call void @_ZN11micropather8MPVectorIfE8capacityEj(%"class.micropather::MPVector.1"* %this1, i32 %add)
  %1 = load float*, float** %t.addr, align 8
  %2 = load float, float* %1, align 4
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  %3 = load float*, float** %m_buf, align 8
  %m_size2 = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 1
  %4 = load i32, i32* %m_size2, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %m_size2, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr inbounds float, float* %3, i64 %idxprom
  store float %2, float* %arrayidx, align 4
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather9PathCache3AddERKNS_8MPVectorIPvEERKNS1_IfEE(%"class.micropather::PathCache"* %this, %"class.micropather::MPVector.2"* dereferenceable(16) %path, %"class.micropather::MPVector.1"* dereferenceable(16) %cost) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %path.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %cost.addr = alloca %"class.micropather::MPVector.1"*, align 8
  %i = alloca i32, align 4
  %end = alloca i8*, align 8
  %item = alloca %"struct.micropather::PathCache::Item", align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store %"class.micropather::MPVector.2"* %path, %"class.micropather::MPVector.2"** %path.addr, align 8
  store %"class.micropather::MPVector.1"* %cost, %"class.micropather::MPVector.1"** %cost.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %nItems = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  %0 = load i32, i32* %nItems, align 4
  %1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %call = call i32 @_ZNK11micropather8MPVectorIPvE4sizeEv(%"class.micropather::MPVector.2"* %1)
  %add = add nsw i32 %0, %call
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %2 = load i32, i32* %allocated, align 8
  %mul = mul nsw i32 %2, 3
  %div = sdiv i32 %mul, 4
  %cmp = icmp sgt i32 %add, %div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %call2 = call i32 @_ZNK11micropather8MPVectorIPvE4sizeEv(%"class.micropather::MPVector.2"* %4)
  %sub = sub i32 %call2, 1
  %cmp3 = icmp ult i32 %3, %sub
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %6 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %call4 = call i32 @_ZNK11micropather8MPVectorIPvE4sizeEv(%"class.micropather::MPVector.2"* %6)
  %sub5 = sub i32 %call4, 1
  %call6 = call dereferenceable(8) i8** @_ZNK11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %5, i32 %sub5)
  %7 = load i8*, i8** %call6, align 8
  store i8* %7, i8** %end, align 8
  %start = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 0
  %8 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %9 = load i32, i32* %i, align 4
  %call7 = call dereferenceable(8) i8** @_ZNK11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %8, i32 %9)
  %10 = load i8*, i8** %call7, align 8
  store i8* %10, i8** %start, align 8
  %end8 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 1
  %11 = load i8*, i8** %end, align 8
  store i8* %11, i8** %end8, align 8
  %next = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 2
  %12 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %13 = load i32, i32* %i, align 4
  %add9 = add i32 %13, 1
  %call10 = call dereferenceable(8) i8** @_ZNK11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %12, i32 %add9)
  %14 = load i8*, i8** %call10, align 8
  store i8* %14, i8** %next, align 8
  %cost11 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 3
  %15 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %cost.addr, align 8
  %16 = load i32, i32* %i, align 4
  %call12 = call dereferenceable(4) float* @_ZNK11micropather8MPVectorIfEixEj(%"class.micropather::MPVector.1"* %15, i32 %16)
  %17 = load float, float* %call12, align 4
  store float %17, float* %cost11, align 8
  call void @_ZN11micropather9PathCache7AddItemERKNS0_4ItemE(%"class.micropather::PathCache"* %this1, %"struct.micropather::PathCache::Item"* dereferenceable(32) %item)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEE6resizeEj(%"class.micropather::MPVector.0"* %this, i32 %s) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  %s.addr = alloca i32, align 4
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  store i32 %s, i32* %s.addr, align 4
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %0 = load i32, i32* %s.addr, align 4
  call void @_ZN11micropather8MPVectorINS_8NodeCostEE8capacityEj(%"class.micropather::MPVector.0"* %this1, i32 %0)
  %1 = load i32, i32* %s.addr, align 4
  %m_size = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 1
  store i32 %1, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEE6resizeEj(%"class.micropather::MPVector"* %this, i32 %s) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  %s.addr = alloca i32, align 4
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  store i32 %s, i32* %s.addr, align 4
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %0 = load i32, i32* %s.addr, align 4
  call void @_ZN11micropather8MPVectorINS_9StateCostEE8capacityEj(%"class.micropather::MPVector"* %this1, i32 %0)
  %1 = load i32, i32* %s.addr, align 4
  %m_size = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  store i32 %1, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather8MPVectorINS_9StateCostEE4sizeEv(%"class.micropather::MPVector"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  %0 = load i32, i32* %m_size, align 4
  ret i32 %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr dereferenceable(16) %"struct.micropather::StateCost"* @_ZN11micropather8MPVectorINS_9StateCostEEixEj(%"class.micropather::MPVector"* %this, i32 %i) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  %i.addr = alloca i32, align 4
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %m_buf, align 8
  %1 = load i32, i32* %i.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %0, i64 %idxprom
  ret %"struct.micropather::StateCost"* %arrayidx
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPather12StatesInPoolEPNS_8MPVectorIPvEE(%"class.micropather::MicroPather"* %this, %"class.micropather::MPVector.2"* %stateVec) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %stateVec.addr = alloca %"class.micropather::MPVector.2"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store %"class.micropather::MPVector.2"* %stateVec, %"class.micropather::MPVector.2"** %stateVec.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %0 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %stateVec.addr, align 8
  call void @_ZN11micropather8MPVectorIPvE5clearEv(%"class.micropather::MPVector.2"* %0)
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %frame = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %1 = load i32, i32* %frame, align 8
  %2 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %stateVec.addr, align 8
  call void @_ZN11micropather12PathNodePool9AllStatesEjPNS_8MPVectorIPvEE(%"class.micropather::PathNodePool"* %pathNodePool, i32 %1, %"class.micropather::MPVector.2"* %2)
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather12PathNodePool9AllStatesEjPNS_8MPVectorIPvEE(%"class.micropather::PathNodePool"* %this, i32 %frame, %"class.micropather::MPVector.2"* %stateVec) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathNodePool"*, align 8
  %frame.addr = alloca i32, align 4
  %stateVec.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %b = alloca %"struct.micropather::PathNodePool::Block"*, align 8
  %i = alloca i32, align 4
  store %"class.micropather::PathNodePool"* %this, %"class.micropather::PathNodePool"** %this.addr, align 8
  store i32 %frame, i32* %frame.addr, align 4
  store %"class.micropather::MPVector.2"* %stateVec, %"class.micropather::MPVector.2"** %stateVec.addr, align 8
  %this1 = load %"class.micropather::PathNodePool"*, %"class.micropather::PathNodePool"** %this.addr, align 8
  %blocks = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %blocks, align 8
  store %"struct.micropather::PathNodePool::Block"* %0, %"struct.micropather::PathNodePool::Block"** %b, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %1 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %tobool = icmp ne %"struct.micropather::PathNodePool::Block"* %1, null
  br i1 %tobool, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %i, align 4
  %allocate = getelementptr inbounds %"class.micropather::PathNodePool", %"class.micropather::PathNodePool"* %this1, i32 0, i32 7
  %3 = load i32, i32* %allocate, align 8
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond2
  %4 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %pathNode = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %4, i32 0, i32 1
  %5 = load i32, i32* %i, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds [1 x %"class.micropather::PathNode"], [1 x %"class.micropather::PathNode"]* %pathNode, i64 0, i64 %idxprom
  %frame4 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %arrayidx, i32 0, i32 6
  %6 = load i32, i32* %frame4, align 8
  %7 = load i32, i32* %frame.addr, align 4
  %cmp5 = icmp eq i32 %6, %7
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %8 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %stateVec.addr, align 8
  %9 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %pathNode6 = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %9, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %idxprom7 = zext i32 %10 to i64
  %arrayidx8 = getelementptr inbounds [1 x %"class.micropather::PathNode"], [1 x %"class.micropather::PathNode"]* %pathNode6, i64 0, i64 %idxprom7
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %arrayidx8, i32 0, i32 0
  call void @_ZN11micropather8MPVectorIPvE9push_backERKS1_(%"class.micropather::MPVector.2"* %8, i8** dereferenceable(8) %state)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond2

for.end:                                          ; preds = %for.cond2
  br label %for.inc9

for.inc9:                                         ; preds = %for.end
  %12 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %b, align 8
  %nextBlock = getelementptr inbounds %"struct.micropather::PathNodePool::Block", %"struct.micropather::PathNodePool::Block"* %12, i32 0, i32 0
  %13 = load %"struct.micropather::PathNodePool::Block"*, %"struct.micropather::PathNodePool::Block"** %nextBlock, align 8
  store %"struct.micropather::PathNodePool::Block"* %13, %"struct.micropather::PathNodePool::Block"** %b, align 8
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIPvE9push_backERKS1_(%"class.micropather::MPVector.2"* %this, i8** dereferenceable(8) %t) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %t.addr = alloca i8**, align 8
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  store i8** %t, i8*** %t.addr, align 8
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 1
  %0 = load i32, i32* %m_size, align 4
  %add = add i32 %0, 1
  call void @_ZN11micropather8MPVectorIPvE8capacityEj(%"class.micropather::MPVector.2"* %this1, i32 %add)
  %1 = load i8**, i8*** %t.addr, align 8
  %2 = load i8*, i8** %1, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 2
  %3 = load i8**, i8*** %m_buf, align 8
  %m_size2 = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 1
  %4 = load i32, i32* %m_size2, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %m_size2, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %3, i64 %idxprom
  store i8* %2, i8** %arrayidx, align 8
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather9PathCacheC2Ei(%"class.micropather::PathCache"* %this, i32 %_allocated) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %_allocated.addr = alloca i32, align 4
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store i32 %_allocated, i32* %_allocated.addr, align 4
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %0 = load i32, i32* %_allocated.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 32)
  %2 = extractvalue { i64, i1 } %1, 1
  %3 = extractvalue { i64, i1 } %1, 0
  %4 = select i1 %2, i64 -1, i64 %3
  %call = call i8* @_Znam(i64 %4) #14
  %5 = bitcast i8* %call to %"struct.micropather::PathCache::Item"*
  %mem = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  store %"struct.micropather::PathCache::Item"* %5, %"struct.micropather::PathCache::Item"** %mem, align 8
  %mem2 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %6 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem2, align 8
  %7 = bitcast %"struct.micropather::PathCache::Item"* %6 to i8*
  %8 = load i32, i32* %_allocated.addr, align 4
  %conv3 = sext i32 %8 to i64
  %mul = mul i64 32, %conv3
  call void @llvm.memset.p0i8.i64(i8* align 8 %7, i8 0, i64 %mul, i1 false)
  %9 = load i32, i32* %_allocated.addr, align 4
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  store i32 %9, i32* %allocated, align 8
  %nItems = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  store i32 0, i32* %nItems, align 4
  %hit = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 0
  store i32 0, i32* %hit, align 8
  %miss = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 1
  store i32 0, i32* %miss, align 4
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #9

; Function Attrs: nobuiltin
declare noalias i8* @_Znam(i64) #7

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @_ZN11micropather9PathCacheD2Ev(%"class.micropather::PathCache"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %mem = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem, align 8
  %isnull = icmp eq %"struct.micropather::PathCache::Item"* %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  %1 = bitcast %"struct.micropather::PathCache::Item"* %0 to i8*
  call void @_ZdaPv(i8* %1) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %entry
  ret void
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdaPv(i8*) #8

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr dereferenceable(8) i8** @_ZNK11micropather8MPVectorIPvEixEj(%"class.micropather::MPVector.2"* %this, i32 %i) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %i.addr = alloca i32, align 4
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 2
  %0 = load i8**, i8*** %m_buf, align 8
  %1 = load i32, i32* %i.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %0, i64 %idxprom
  ret i8** %arrayidx
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr dereferenceable(4) float* @_ZNK11micropather8MPVectorIfEixEj(%"class.micropather::MPVector.1"* %this, i32 %i) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  %i.addr = alloca i32, align 4
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  %0 = load float*, float** %m_buf, align 8
  %1 = load i32, i32* %i.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds float, float* %0, i64 %idxprom
  ret float* %arrayidx
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather9PathCache7AddItemERKNS0_4ItemE(%"class.micropather::PathCache"* %this, %"struct.micropather::PathCache::Item"* dereferenceable(32) %item) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %item.addr = alloca %"struct.micropather::PathCache::Item"*, align 8
  %index = alloca i32, align 4
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store %"struct.micropather::PathCache::Item"* %item, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %0 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %call = call i32 @_ZNK11micropather9PathCache4Item4HashEv(%"struct.micropather::PathCache::Item"* %0)
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %1 = load i32, i32* %allocated, align 8
  %rem = urem i32 %call, %1
  store i32 %rem, i32* %index, align 4
  br label %while.body

while.body:                                       ; preds = %entry, %if.end15
  %mem = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %2 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem, align 8
  %3 = load i32, i32* %index, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %2, i64 %idxprom
  %call2 = call zeroext i1 @_ZNK11micropather9PathCache4Item5EmptyEv(%"struct.micropather::PathCache::Item"* %arrayidx)
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %4 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %mem3 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %5 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem3, align 8
  %6 = load i32, i32* %index, align 4
  %idxprom4 = zext i32 %6 to i64
  %arrayidx5 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %5, i64 %idxprom4
  %7 = bitcast %"struct.micropather::PathCache::Item"* %arrayidx5 to i8*
  %8 = bitcast %"struct.micropather::PathCache::Item"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 32, i1 false)
  %nItems = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  %9 = load i32, i32* %nItems, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %nItems, align 4
  br label %while.end

if.else:                                          ; preds = %while.body
  %mem6 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %10 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem6, align 8
  %11 = load i32, i32* %index, align 4
  %idxprom7 = zext i32 %11 to i64
  %arrayidx8 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %10, i64 %idxprom7
  %12 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %call9 = call zeroext i1 @_ZNK11micropather9PathCache4Item8KeyEqualERKS1_(%"struct.micropather::PathCache::Item"* %arrayidx8, %"struct.micropather::PathCache::Item"* dereferenceable(32) %12)
  br i1 %call9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  br label %while.end

if.end:                                           ; preds = %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end
  %13 = load i32, i32* %index, align 4
  %inc12 = add i32 %13, 1
  store i32 %inc12, i32* %index, align 4
  %14 = load i32, i32* %index, align 4
  %allocated13 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %15 = load i32, i32* %allocated13, align 8
  %cmp = icmp eq i32 %14, %15
  br i1 %cmp, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  store i32 0, i32* %index, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end11
  br label %while.body

while.end:                                        ; preds = %if.then10, %if.then
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather9PathCache13AddNoSolutionEPvPS1_i(%"class.micropather::PathCache"* %this, i8* %end, i8** %states, i32 %count) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %end.addr = alloca i8*, align 8
  %states.addr = alloca i8**, align 8
  %count.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %item = alloca %"struct.micropather::PathCache::Item", align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store i8* %end, i8** %end.addr, align 8
  store i8** %states, i8*** %states.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %0 = load i32, i32* %count.addr, align 4
  %nItems = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  %1 = load i32, i32* %nItems, align 4
  %add = add nsw i32 %0, %1
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %2 = load i32, i32* %allocated, align 8
  %mul = mul nsw i32 %2, 3
  %div = sdiv i32 %mul, 4
  %cmp = icmp sgt i32 %add, %div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %start = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 0
  %5 = load i8**, i8*** %states.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %5, i64 %idxprom
  %7 = load i8*, i8** %arrayidx, align 8
  store i8* %7, i8** %start, align 8
  %end3 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 1
  %8 = load i8*, i8** %end.addr, align 8
  store i8* %8, i8** %end3, align 8
  %next = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 2
  store i8* null, i8** %next, align 8
  %cost = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %item, i32 0, i32 3
  store float 0x47EFFFFFE0000000, float* %cost, align 8
  call void @_ZN11micropather9PathCache7AddItemERKNS0_4ItemE(%"class.micropather::PathCache"* %this1, %"struct.micropather::PathCache::Item"* dereferenceable(32) %item)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define i32 @_ZN11micropather9PathCache5SolveEPvS1_PNS_8MPVectorIS1_EEPf(%"class.micropather::PathCache"* %this, i8* %start, i8* %end, %"class.micropather::MPVector.2"* %path, float* %totalCost) #0 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %start.addr = alloca i8*, align 8
  %end.addr = alloca i8*, align 8
  %path.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %totalCost.addr = alloca float*, align 8
  %item = alloca %"struct.micropather::PathCache::Item"*, align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %end, i8** %end.addr, align 8
  store %"class.micropather::MPVector.2"* %path, %"class.micropather::MPVector.2"** %path.addr, align 8
  store float* %totalCost, float** %totalCost.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %0 = load i8*, i8** %start.addr, align 8
  %1 = load i8*, i8** %end.addr, align 8
  %call = call %"struct.micropather::PathCache::Item"* @_ZN11micropather9PathCache4FindEPvS1_(%"class.micropather::PathCache"* %this1, i8* %0, i8* %1)
  store %"struct.micropather::PathCache::Item"* %call, %"struct.micropather::PathCache::Item"** %item, align 8
  %2 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item, align 8
  %tobool = icmp ne %"struct.micropather::PathCache::Item"* %2, null
  br i1 %tobool, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %3 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item, align 8
  %cost = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %3, i32 0, i32 3
  %4 = load float, float* %cost, align 8
  %cmp = fcmp oeq float %4, 0x47EFFFFFE0000000
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %hit = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 0
  %5 = load i32, i32* %hit, align 8
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %hit, align 8
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  call void @_ZN11micropather8MPVectorIPvE5clearEv(%"class.micropather::MPVector.2"* %6)
  %7 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  call void @_ZN11micropather8MPVectorIPvE9push_backERKS1_(%"class.micropather::MPVector.2"* %7, i8** dereferenceable(8) %start.addr)
  %8 = load float*, float** %totalCost.addr, align 8
  store float 0.000000e+00, float* %8, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i8*, i8** %start.addr, align 8
  %10 = load i8*, i8** %end.addr, align 8
  %cmp3 = icmp ne i8* %9, %10
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item, align 8
  %cost4 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %11, i32 0, i32 3
  %12 = load float, float* %cost4, align 8
  %13 = load float*, float** %totalCost.addr, align 8
  %14 = load float, float* %13, align 4
  %add = fadd float %14, %12
  store float %add, float* %13, align 4
  %15 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %16 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item, align 8
  %next = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %16, i32 0, i32 2
  call void @_ZN11micropather8MPVectorIPvE9push_backERKS1_(%"class.micropather::MPVector.2"* %15, i8** dereferenceable(8) %next)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item, align 8
  %next5 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %17, i32 0, i32 2
  %18 = load i8*, i8** %next5, align 8
  store i8* %18, i8** %start.addr, align 8
  %19 = load i8*, i8** %start.addr, align 8
  %20 = load i8*, i8** %end.addr, align 8
  %call6 = call %"struct.micropather::PathCache::Item"* @_ZN11micropather9PathCache4FindEPvS1_(%"class.micropather::PathCache"* %this1, i8* %19, i8* %20)
  store %"struct.micropather::PathCache::Item"* %call6, %"struct.micropather::PathCache::Item"** %item, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %hit7 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 0
  %21 = load i32, i32* %hit7, align 8
  %inc8 = add nsw i32 %21, 1
  store i32 %inc8, i32* %hit7, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %entry
  %miss = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 1
  %22 = load i32, i32* %miss, align 4
  %inc10 = add nsw i32 %22, 1
  store i32 %inc10, i32* %miss, align 4
  store i32 3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %for.end, %if.then2
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline optnone ssp uwtable
define %"struct.micropather::PathCache::Item"* @_ZN11micropather9PathCache4FindEPvS1_(%"class.micropather::PathCache"* %this, i8* %start, i8* %end) #0 align 2 {
entry:
  %retval = alloca %"struct.micropather::PathCache::Item"*, align 8
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  %start.addr = alloca i8*, align 8
  %end.addr = alloca i8*, align 8
  %fake = alloca %"struct.micropather::PathCache::Item", align 8
  %index = alloca i32, align 4
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %end, i8** %end.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %start2 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %fake, i32 0, i32 0
  %0 = load i8*, i8** %start.addr, align 8
  store i8* %0, i8** %start2, align 8
  %end3 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %fake, i32 0, i32 1
  %1 = load i8*, i8** %end.addr, align 8
  store i8* %1, i8** %end3, align 8
  %next = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %fake, i32 0, i32 2
  store i8* null, i8** %next, align 8
  %cost = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %fake, i32 0, i32 3
  store float 0.000000e+00, float* %cost, align 8
  %call = call i32 @_ZNK11micropather9PathCache4Item4HashEv(%"struct.micropather::PathCache::Item"* %fake)
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %2 = load i32, i32* %allocated, align 8
  %rem = urem i32 %call, %2
  store i32 %rem, i32* %index, align 4
  br label %while.body

while.body:                                       ; preds = %entry, %if.end14
  %mem = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %3 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem, align 8
  %4 = load i32, i32* %index, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %3, i64 %idxprom
  %call4 = call zeroext i1 @_ZNK11micropather9PathCache4Item5EmptyEv(%"struct.micropather::PathCache::Item"* %arrayidx)
  br i1 %call4, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  store %"struct.micropather::PathCache::Item"* null, %"struct.micropather::PathCache::Item"** %retval, align 8
  br label %return

if.end:                                           ; preds = %while.body
  %mem5 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %5 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem5, align 8
  %6 = load i32, i32* %index, align 4
  %idxprom6 = zext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %5, i64 %idxprom6
  %call8 = call zeroext i1 @_ZNK11micropather9PathCache4Item8KeyEqualERKS1_(%"struct.micropather::PathCache::Item"* %arrayidx7, %"struct.micropather::PathCache::Item"* dereferenceable(32) %fake)
  br i1 %call8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %mem10 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 2
  %7 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %mem10, align 8
  %8 = load i32, i32* %index, align 4
  %idx.ext = zext i32 %8 to i64
  %add.ptr = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %7, i64 %idx.ext
  store %"struct.micropather::PathCache::Item"* %add.ptr, %"struct.micropather::PathCache::Item"** %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %9 = load i32, i32* %index, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %index, align 4
  %10 = load i32, i32* %index, align 4
  %allocated12 = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %11 = load i32, i32* %allocated12, align 8
  %cmp = icmp eq i32 %10, %11
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  store i32 0, i32* %index, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end11
  br label %while.body

return:                                           ; preds = %if.then9, %if.then
  %12 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %retval, align 8
  ret %"struct.micropather::PathCache::Item"* %12
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather9PathCache4Item4HashEv(%"struct.micropather::PathCache::Item"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"struct.micropather::PathCache::Item"*, align 8
  %p = alloca i8*, align 8
  %h = alloca i32, align 4
  %i = alloca i32, align 4
  store %"struct.micropather::PathCache::Item"* %this, %"struct.micropather::PathCache::Item"** %this.addr, align 8
  %this1 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %this.addr, align 8
  %start = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %this1, i32 0, i32 0
  %0 = bitcast i8** %start to i8*
  store i8* %0, i8** %p, align 8
  store i32 -2128831035, i32* %h, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %conv = zext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %p, align 8
  %3 = load i8, i8* %2, align 1
  %conv2 = zext i8 %3 to i32
  %4 = load i32, i32* %h, align 4
  %xor = xor i32 %4, %conv2
  store i32 %xor, i32* %h, align 4
  %5 = load i32, i32* %h, align 4
  %mul = mul i32 %5, 16777619
  store i32 %mul, i32* %h, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  %7 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* %h, align 4
  ret i32 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr zeroext i1 @_ZNK11micropather9PathCache4Item5EmptyEv(%"struct.micropather::PathCache::Item"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"struct.micropather::PathCache::Item"*, align 8
  store %"struct.micropather::PathCache::Item"* %this, %"struct.micropather::PathCache::Item"** %this.addr, align 8
  %this1 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %this.addr, align 8
  %start = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %this1, i32 0, i32 0
  %0 = load i8*, i8** %start, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %end = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %this1, i32 0, i32 1
  %1 = load i8*, i8** %end, align 8
  %cmp2 = icmp eq i8* %1, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr zeroext i1 @_ZNK11micropather9PathCache4Item8KeyEqualERKS1_(%"struct.micropather::PathCache::Item"* %this, %"struct.micropather::PathCache::Item"* dereferenceable(32) %item) #1 align 2 {
entry:
  %this.addr = alloca %"struct.micropather::PathCache::Item"*, align 8
  %item.addr = alloca %"struct.micropather::PathCache::Item"*, align 8
  store %"struct.micropather::PathCache::Item"* %this, %"struct.micropather::PathCache::Item"** %this.addr, align 8
  store %"struct.micropather::PathCache::Item"* %item, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %this1 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %this.addr, align 8
  %start = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %this1, i32 0, i32 0
  %0 = load i8*, i8** %start, align 8
  %1 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %start2 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %1, i32 0, i32 0
  %2 = load i8*, i8** %start2, align 8
  %cmp = icmp eq i8* %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %end = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %this1, i32 0, i32 1
  %3 = load i8*, i8** %end, align 8
  %4 = load %"struct.micropather::PathCache::Item"*, %"struct.micropather::PathCache::Item"** %item.addr, align 8
  %end3 = getelementptr inbounds %"struct.micropather::PathCache::Item", %"struct.micropather::PathCache::Item"* %4, i32 0, i32 1
  %5 = load i8*, i8** %end3, align 8
  %cmp4 = icmp eq i8* %3, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp4, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noinline optnone ssp uwtable
define void @_ZN11micropather11MicroPather12GetCacheDataEPNS_9CacheDataE(%"class.micropather::MicroPather"* %this, %"struct.micropather::CacheData"* %data) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %data.addr = alloca %"struct.micropather::CacheData"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store %"struct.micropather::CacheData"* %data, %"struct.micropather::CacheData"** %data.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %0 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %1 = bitcast %"struct.micropather::CacheData"* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %1, i8 0, i64 24, i1 false)
  %pathCache = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %2 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache, align 8
  %tobool = icmp ne %"class.micropather::PathCache"* %2, null
  br i1 %tobool, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  %pathCache2 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %3 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache2, align 8
  %call = call i32 @_ZNK11micropather9PathCache14AllocatedBytesEv(%"class.micropather::PathCache"* %3)
  %4 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %nBytesAllocated = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %4, i32 0, i32 0
  store i32 %call, i32* %nBytesAllocated, align 4
  %pathCache3 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %5 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache3, align 8
  %call4 = call i32 @_ZNK11micropather9PathCache9UsedBytesEv(%"class.micropather::PathCache"* %5)
  %6 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %nBytesUsed = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %6, i32 0, i32 1
  store i32 %call4, i32* %nBytesUsed, align 4
  %7 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %nBytesUsed5 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %7, i32 0, i32 1
  %8 = load i32, i32* %nBytesUsed5, align 4
  %conv = sitofp i32 %8 to double
  %9 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %nBytesAllocated6 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %9, i32 0, i32 0
  %10 = load i32, i32* %nBytesAllocated6, align 4
  %conv7 = sitofp i32 %10 to double
  %div = fdiv double %conv, %conv7
  %conv8 = fptrunc double %div to float
  %11 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %memoryFraction = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %11, i32 0, i32 2
  store float %conv8, float* %memoryFraction, align 4
  %pathCache9 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %12 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache9, align 8
  %hit = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %12, i32 0, i32 0
  %13 = load i32, i32* %hit, align 8
  %14 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %hit10 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %14, i32 0, i32 3
  store i32 %13, i32* %hit10, align 4
  %pathCache11 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %15 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache11, align 8
  %miss = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %15, i32 0, i32 1
  %16 = load i32, i32* %miss, align 4
  %17 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %miss12 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %17, i32 0, i32 4
  store i32 %16, i32* %miss12, align 4
  %18 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %hit13 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %18, i32 0, i32 3
  %19 = load i32, i32* %hit13, align 4
  %20 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %miss14 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %20, i32 0, i32 4
  %21 = load i32, i32* %miss14, align 4
  %add = add nsw i32 %19, %21
  %tobool15 = icmp ne i32 %add, 0
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then
  %22 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %hit17 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %22, i32 0, i32 3
  %23 = load i32, i32* %hit17, align 4
  %conv18 = sitofp i32 %23 to double
  %24 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %hit19 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %24, i32 0, i32 3
  %25 = load i32, i32* %hit19, align 4
  %26 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %miss20 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %26, i32 0, i32 4
  %27 = load i32, i32* %miss20, align 4
  %add21 = add nsw i32 %25, %27
  %conv22 = sitofp i32 %add21 to double
  %div23 = fdiv double %conv18, %conv22
  %conv24 = fptrunc double %div23 to float
  %28 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %hitFraction = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %28, i32 0, i32 5
  store float %conv24, float* %hitFraction, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %29 = load %"struct.micropather::CacheData"*, %"struct.micropather::CacheData"** %data.addr, align 8
  %hitFraction25 = getelementptr inbounds %"struct.micropather::CacheData", %"struct.micropather::CacheData"* %29, i32 0, i32 5
  store float 0.000000e+00, float* %hitFraction25, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then16
  br label %if.end26

if.end26:                                         ; preds = %if.end, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather9PathCache14AllocatedBytesEv(%"class.micropather::PathCache"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %allocated = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 3
  %0 = load i32, i32* %allocated, align 8
  %conv = sext i32 %0 to i64
  %mul = mul i64 %conv, 32
  %conv2 = trunc i64 %mul to i32
  ret i32 %conv2
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr i32 @_ZNK11micropather9PathCache9UsedBytesEv(%"class.micropather::PathCache"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::PathCache"*, align 8
  store %"class.micropather::PathCache"* %this, %"class.micropather::PathCache"** %this.addr, align 8
  %this1 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %this.addr, align 8
  %nItems = getelementptr inbounds %"class.micropather::PathCache", %"class.micropather::PathCache"* %this1, i32 0, i32 4
  %0 = load i32, i32* %nItems, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 %conv, 32
  %conv2 = trunc i64 %mul to i32
  ret i32 %conv2
}

; Function Attrs: noinline optnone ssp uwtable
define i32 @_ZN11micropather11MicroPather5SolveEPvS1_PNS_8MPVectorIS1_EEPf(%"class.micropather::MicroPather"* %this, i8* %startNode, i8* %endNode, %"class.micropather::MPVector.2"* %path, float* %cost) #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %startNode.addr = alloca i8*, align 8
  %endNode.addr = alloca i8*, align 8
  %path.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %cost.addr = alloca float*, align 8
  %cacheResult = alloca i32, align 4
  %open = alloca %class.OpenQueue, align 8
  %closed = alloca %class.ClosedSet, align 8
  %exn.slot = alloca i8*
  %ehselector.slot = alloca i32
  %newPathNode = alloca %"class.micropather::PathNode"*, align 8
  %node = alloca %"class.micropather::PathNode"*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %i = alloca i32, align 4
  %child = alloca %"class.micropather::PathNode"*, align 8
  %newCost = alloca float, align 4
  %inOpen = alloca %"class.micropather::PathNode"*, align 8
  %inClosed = alloca %"class.micropather::PathNode"*, align 8
  %inEither = alloca %"class.micropather::PathNode"*, align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store i8* %startNode, i8** %startNode.addr, align 8
  store i8* %endNode, i8** %endNode.addr, align 8
  store %"class.micropather::MPVector.2"* %path, %"class.micropather::MPVector.2"** %path.addr, align 8
  store float* %cost, float** %cost.addr, align 8
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %0 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  call void @_ZN11micropather8MPVectorIPvE5clearEv(%"class.micropather::MPVector.2"* %0)
  %1 = load float*, float** %cost.addr, align 8
  store float 0.000000e+00, float* %1, align 4
  %2 = load i8*, i8** %startNode.addr, align 8
  %3 = load i8*, i8** %endNode.addr, align 8
  %cmp = icmp eq i8* %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %pathCache = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %4 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache, align 8
  %tobool = icmp ne %"class.micropather::PathCache"* %4, null
  br i1 %tobool, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %pathCache3 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %5 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache3, align 8
  %6 = load i8*, i8** %startNode.addr, align 8
  %7 = load i8*, i8** %endNode.addr, align 8
  %8 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  %9 = load float*, float** %cost.addr, align 8
  %call = call i32 @_ZN11micropather9PathCache5SolveEPvS1_PNS_8MPVectorIS1_EEPf(%"class.micropather::PathCache"* %5, i8* %6, i8* %7, %"class.micropather::MPVector.2"* %8, float* %9)
  store i32 %call, i32* %cacheResult, align 4
  %10 = load i32, i32* %cacheResult, align 4
  %cmp4 = icmp eq i32 %10, 0
  br i1 %cmp4, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then2
  %11 = load i32, i32* %cacheResult, align 4
  %cmp5 = icmp eq i32 %11, 1
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.then2
  %12 = load i32, i32* %cacheResult, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %lor.lhs.false
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.end
  %frame = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %13 = load i32, i32* %frame, align 8
  %inc = add i32 %13, 1
  store i32 %inc, i32* %frame, align 8
  %graph = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %14 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph, align 8
  call void @_ZN9OpenQueueC1EPN11micropather5GraphE(%class.OpenQueue* %open, %"class.micropather::Graph"* %14)
  %graph9 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %15 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph9, align 8
  invoke void @_ZN9ClosedSetC1EPN11micropather5GraphE(%class.ClosedSet* %closed, %"class.micropather::Graph"* %15)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.end8
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %frame10 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %16 = load i32, i32* %frame10, align 8
  %17 = load i8*, i8** %startNode.addr, align 8
  %graph11 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %18 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph11, align 8
  %19 = load i8*, i8** %startNode.addr, align 8
  %20 = load i8*, i8** %endNode.addr, align 8
  %21 = bitcast %"class.micropather::Graph"* %18 to float (%"class.micropather::Graph"*, i8*, i8*)***
  %vtable = load float (%"class.micropather::Graph"*, i8*, i8*)**, float (%"class.micropather::Graph"*, i8*, i8*)*** %21, align 8
  %vfn = getelementptr inbounds float (%"class.micropather::Graph"*, i8*, i8*)*, float (%"class.micropather::Graph"*, i8*, i8*)** %vtable, i64 2
  %22 = load float (%"class.micropather::Graph"*, i8*, i8*)*, float (%"class.micropather::Graph"*, i8*, i8*)** %vfn, align 8
  %call14 = invoke float %22(%"class.micropather::Graph"* %18, i8* %19, i8* %20)
          to label %invoke.cont13 unwind label %lpad12

invoke.cont13:                                    ; preds = %invoke.cont
  %call16 = invoke %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool11GetPathNodeEjPvffPNS_8PathNodeE(%"class.micropather::PathNodePool"* %pathNodePool, i32 %16, i8* %17, float 0.000000e+00, float %call14, %"class.micropather::PathNode"* null)
          to label %invoke.cont15 unwind label %lpad12

invoke.cont15:                                    ; preds = %invoke.cont13
  store %"class.micropather::PathNode"* %call16, %"class.micropather::PathNode"** %newPathNode, align 8
  %23 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %newPathNode, align 8
  invoke void @_ZN9OpenQueue4PushEPN11micropather8PathNodeE(%class.OpenQueue* %open, %"class.micropather::PathNode"* %23)
          to label %invoke.cont17 unwind label %lpad12

invoke.cont17:                                    ; preds = %invoke.cont15
  %stateCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  invoke void @_ZN11micropather8MPVectorINS_9StateCostEE6resizeEj(%"class.micropather::MPVector"* %stateCostVec, i32 0)
          to label %invoke.cont18 unwind label %lpad12

invoke.cont18:                                    ; preds = %invoke.cont17
  %nodeCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  invoke void @_ZN11micropather8MPVectorINS_8NodeCostEE6resizeEj(%"class.micropather::MPVector.0"* %nodeCostVec, i32 0)
          to label %invoke.cont19 unwind label %lpad12

invoke.cont19:                                    ; preds = %invoke.cont18
  br label %while.cond

while.cond:                                       ; preds = %if.end87, %invoke.cont19
  %call21 = invoke zeroext i1 @_ZN9OpenQueue5EmptyEv(%class.OpenQueue* %open)
          to label %invoke.cont20 unwind label %lpad12

invoke.cont20:                                    ; preds = %while.cond
  %lnot = xor i1 %call21, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %invoke.cont20
  %call23 = invoke %"class.micropather::PathNode"* @_ZN9OpenQueue3PopEv(%class.OpenQueue* %open)
          to label %invoke.cont22 unwind label %lpad12

invoke.cont22:                                    ; preds = %while.body
  store %"class.micropather::PathNode"* %call23, %"class.micropather::PathNode"** %node, align 8
  %24 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %24, i32 0, i32 0
  %25 = load i8*, i8** %state, align 8
  %26 = load i8*, i8** %endNode.addr, align 8
  %cmp24 = icmp eq i8* %25, %26
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %invoke.cont22
  %27 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %28 = load i8*, i8** %startNode.addr, align 8
  %29 = load i8*, i8** %endNode.addr, align 8
  %30 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %path.addr, align 8
  invoke void @_ZN11micropather11MicroPather11GoalReachedEPNS_8PathNodeEPvS3_PNS_8MPVectorIS3_EE(%"class.micropather::MicroPather"* %this1, %"class.micropather::PathNode"* %27, i8* %28, i8* %29, %"class.micropather::MPVector.2"* %30)
          to label %invoke.cont26 unwind label %lpad12

invoke.cont26:                                    ; preds = %if.then25
  %31 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %costFromStart = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %31, i32 0, i32 1
  %32 = load float, float* %costFromStart, align 8
  %33 = load float*, float** %cost.addr, align 8
  store float %32, float* %33, align 4
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

lpad:                                             ; preds = %if.end8
  %34 = landingpad { i8*, i32 }
          cleanup
  %35 = extractvalue { i8*, i32 } %34, 0
  store i8* %35, i8** %exn.slot, align 8
  %36 = extractvalue { i8*, i32 } %34, 1
  store i32 %36, i32* %ehselector.slot, align 4
  br label %ehcleanup

lpad12:                                           ; preds = %if.then90, %invoke.cont83, %invoke.cont80, %if.else73, %if.then69, %invoke.cont65, %if.then59, %invoke.cont39, %if.end37, %for.body, %invoke.cont27, %if.else, %if.then25, %while.body, %while.cond, %invoke.cont18, %invoke.cont17, %invoke.cont15, %invoke.cont13, %invoke.cont
  %37 = landingpad { i8*, i32 }
          cleanup
  %38 = extractvalue { i8*, i32 } %37, 0
  store i8* %38, i8** %exn.slot, align 8
  %39 = extractvalue { i8*, i32 } %37, 1
  store i32 %39, i32* %ehselector.slot, align 4
  call void @_ZN9ClosedSetD1Ev(%class.ClosedSet* %closed) #13
  br label %ehcleanup

if.else:                                          ; preds = %invoke.cont22
  %40 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  invoke void @_ZN9ClosedSet3AddEPN11micropather8PathNodeE(%class.ClosedSet* %closed, %"class.micropather::PathNode"* %40)
          to label %invoke.cont27 unwind label %lpad12

invoke.cont27:                                    ; preds = %if.else
  %41 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %nodeCostVec28 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  invoke void @_ZN11micropather11MicroPather16GetNodeNeighborsEPNS_8PathNodeEPNS_8MPVectorINS_8NodeCostEEE(%"class.micropather::MicroPather"* %this1, %"class.micropather::PathNode"* %41, %"class.micropather::MPVector.0"* %nodeCostVec28)
          to label %invoke.cont29 unwind label %lpad12

invoke.cont29:                                    ; preds = %invoke.cont27
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont29
  %42 = load i32, i32* %i, align 4
  %43 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %numAdjacent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %43, i32 0, i32 7
  %44 = load i32, i32* %numAdjacent, align 4
  %cmp30 = icmp slt i32 %42, %44
  br i1 %cmp30, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %nodeCostVec31 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %45 = load i32, i32* %i, align 4
  %call33 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec31, i32 %45)
          to label %invoke.cont32 unwind label %lpad12

invoke.cont32:                                    ; preds = %for.body
  %cost34 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call33, i32 0, i32 1
  %46 = load float, float* %cost34, align 8
  %cmp35 = fcmp oeq float %46, 0x47EFFFFFE0000000
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %invoke.cont32
  br label %for.inc

if.end37:                                         ; preds = %invoke.cont32
  %nodeCostVec38 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %47 = load i32, i32* %i, align 4
  %call40 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec38, i32 %47)
          to label %invoke.cont39 unwind label %lpad12

invoke.cont39:                                    ; preds = %if.end37
  %node41 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call40, i32 0, i32 0
  %48 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node41, align 8
  store %"class.micropather::PathNode"* %48, %"class.micropather::PathNode"** %child, align 8
  %49 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %costFromStart42 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %49, i32 0, i32 1
  %50 = load float, float* %costFromStart42, align 8
  %nodeCostVec43 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %51 = load i32, i32* %i, align 4
  %call45 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec43, i32 %51)
          to label %invoke.cont44 unwind label %lpad12

invoke.cont44:                                    ; preds = %invoke.cont39
  %cost46 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call45, i32 0, i32 1
  %52 = load float, float* %cost46, align 8
  %add = fadd float %50, %52
  store float %add, float* %newCost, align 4
  %53 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %inOpen47 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %53, i32 0, i32 13
  %54 = load i8, i8* %inOpen47, align 8
  %tobool48 = trunc i8 %54 to i1
  br i1 %tobool48, label %cond.true, label %cond.false

cond.true:                                        ; preds = %invoke.cont44
  %55 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  br label %cond.end

cond.false:                                       ; preds = %invoke.cont44
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %"class.micropather::PathNode"* [ %55, %cond.true ], [ null, %cond.false ]
  store %"class.micropather::PathNode"* %cond, %"class.micropather::PathNode"** %inOpen, align 8
  %56 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %inClosed49 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %56, i32 0, i32 14
  %57 = load i8, i8* %inClosed49, align 1
  %tobool50 = trunc i8 %57 to i1
  br i1 %tobool50, label %cond.true51, label %cond.false52

cond.true51:                                      ; preds = %cond.end
  %58 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  br label %cond.end53

cond.false52:                                     ; preds = %cond.end
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false52, %cond.true51
  %cond54 = phi %"class.micropather::PathNode"* [ %58, %cond.true51 ], [ null, %cond.false52 ]
  store %"class.micropather::PathNode"* %cond54, %"class.micropather::PathNode"** %inClosed, align 8
  %59 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inOpen, align 8
  %60 = ptrtoint %"class.micropather::PathNode"* %59 to i64
  %61 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inClosed, align 8
  %62 = ptrtoint %"class.micropather::PathNode"* %61 to i64
  %or = or i64 %60, %62
  %63 = inttoptr i64 %or to %"class.micropather::PathNode"*
  store %"class.micropather::PathNode"* %63, %"class.micropather::PathNode"** %inEither, align 8
  %64 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inEither, align 8
  %tobool55 = icmp ne %"class.micropather::PathNode"* %64, null
  br i1 %tobool55, label %if.then56, label %if.else73

if.then56:                                        ; preds = %cond.end53
  %65 = load float, float* %newCost, align 4
  %66 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %costFromStart57 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %66, i32 0, i32 1
  %67 = load float, float* %costFromStart57, align 8
  %cmp58 = fcmp olt float %65, %67
  br i1 %cmp58, label %if.then59, label %if.end72

if.then59:                                        ; preds = %if.then56
  %68 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %69 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %parent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %69, i32 0, i32 5
  store %"class.micropather::PathNode"* %68, %"class.micropather::PathNode"** %parent, align 8
  %70 = load float, float* %newCost, align 4
  %71 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %costFromStart60 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %71, i32 0, i32 1
  store float %70, float* %costFromStart60, align 8
  %graph61 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %72 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph61, align 8
  %73 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %state62 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %73, i32 0, i32 0
  %74 = load i8*, i8** %state62, align 8
  %75 = load i8*, i8** %endNode.addr, align 8
  %76 = bitcast %"class.micropather::Graph"* %72 to float (%"class.micropather::Graph"*, i8*, i8*)***
  %vtable63 = load float (%"class.micropather::Graph"*, i8*, i8*)**, float (%"class.micropather::Graph"*, i8*, i8*)*** %76, align 8
  %vfn64 = getelementptr inbounds float (%"class.micropather::Graph"*, i8*, i8*)*, float (%"class.micropather::Graph"*, i8*, i8*)** %vtable63, i64 2
  %77 = load float (%"class.micropather::Graph"*, i8*, i8*)*, float (%"class.micropather::Graph"*, i8*, i8*)** %vfn64, align 8
  %call66 = invoke float %77(%"class.micropather::Graph"* %72, i8* %74, i8* %75)
          to label %invoke.cont65 unwind label %lpad12

invoke.cont65:                                    ; preds = %if.then59
  %78 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %estToGoal = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %78, i32 0, i32 2
  store float %call66, float* %estToGoal, align 4
  %79 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  invoke void @_ZN11micropather8PathNode13CalcTotalCostEv(%"class.micropather::PathNode"* %79)
          to label %invoke.cont67 unwind label %lpad12

invoke.cont67:                                    ; preds = %invoke.cont65
  %80 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inOpen, align 8
  %tobool68 = icmp ne %"class.micropather::PathNode"* %80, null
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %invoke.cont67
  %81 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  invoke void @_ZN9OpenQueue6UpdateEPN11micropather8PathNodeE(%class.OpenQueue* %open, %"class.micropather::PathNode"* %81)
          to label %invoke.cont70 unwind label %lpad12

invoke.cont70:                                    ; preds = %if.then69
  br label %if.end71

if.end71:                                         ; preds = %invoke.cont70, %invoke.cont67
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.then56
  br label %if.end85

if.else73:                                        ; preds = %cond.end53
  %82 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %83 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %parent74 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %83, i32 0, i32 5
  store %"class.micropather::PathNode"* %82, %"class.micropather::PathNode"** %parent74, align 8
  %84 = load float, float* %newCost, align 4
  %85 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %costFromStart75 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %85, i32 0, i32 1
  store float %84, float* %costFromStart75, align 8
  %graph76 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %86 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph76, align 8
  %87 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %state77 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %87, i32 0, i32 0
  %88 = load i8*, i8** %state77, align 8
  %89 = load i8*, i8** %endNode.addr, align 8
  %90 = bitcast %"class.micropather::Graph"* %86 to float (%"class.micropather::Graph"*, i8*, i8*)***
  %vtable78 = load float (%"class.micropather::Graph"*, i8*, i8*)**, float (%"class.micropather::Graph"*, i8*, i8*)*** %90, align 8
  %vfn79 = getelementptr inbounds float (%"class.micropather::Graph"*, i8*, i8*)*, float (%"class.micropather::Graph"*, i8*, i8*)** %vtable78, i64 2
  %91 = load float (%"class.micropather::Graph"*, i8*, i8*)*, float (%"class.micropather::Graph"*, i8*, i8*)** %vfn79, align 8
  %call81 = invoke float %91(%"class.micropather::Graph"* %86, i8* %88, i8* %89)
          to label %invoke.cont80 unwind label %lpad12

invoke.cont80:                                    ; preds = %if.else73
  %92 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %estToGoal82 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %92, i32 0, i32 2
  store float %call81, float* %estToGoal82, align 4
  %93 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  invoke void @_ZN11micropather8PathNode13CalcTotalCostEv(%"class.micropather::PathNode"* %93)
          to label %invoke.cont83 unwind label %lpad12

invoke.cont83:                                    ; preds = %invoke.cont80
  %94 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  invoke void @_ZN9OpenQueue4PushEPN11micropather8PathNodeE(%class.OpenQueue* %open, %"class.micropather::PathNode"* %94)
          to label %invoke.cont84 unwind label %lpad12

invoke.cont84:                                    ; preds = %invoke.cont83
  br label %if.end85

if.end85:                                         ; preds = %invoke.cont84, %if.end72
  br label %for.inc

for.inc:                                          ; preds = %if.end85, %if.then36
  %95 = load i32, i32* %i, align 4
  %inc86 = add nsw i32 %95, 1
  store i32 %inc86, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end87

if.end87:                                         ; preds = %for.end
  br label %while.cond

while.end:                                        ; preds = %invoke.cont20
  %pathCache88 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %96 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache88, align 8
  %tobool89 = icmp ne %"class.micropather::PathCache"* %96, null
  br i1 %tobool89, label %if.then90, label %if.end93

if.then90:                                        ; preds = %while.end
  %pathCache91 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 6
  %97 = load %"class.micropather::PathCache"*, %"class.micropather::PathCache"** %pathCache91, align 8
  %98 = load i8*, i8** %endNode.addr, align 8
  invoke void @_ZN11micropather9PathCache13AddNoSolutionEPvPS1_i(%"class.micropather::PathCache"* %97, i8* %98, i8** %startNode.addr, i32 1)
          to label %invoke.cont92 unwind label %lpad12

invoke.cont92:                                    ; preds = %if.then90
  br label %if.end93

if.end93:                                         ; preds = %invoke.cont92, %while.end
  store i32 1, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end93, %invoke.cont26
  call void @_ZN9ClosedSetD1Ev(%class.ClosedSet* %closed) #13
  call void @_ZN9OpenQueueD1Ev(%class.OpenQueue* %open) #13
  br label %return

ehcleanup:                                        ; preds = %lpad12, %lpad
  call void @_ZN9OpenQueueD1Ev(%class.OpenQueue* %open) #13
  br label %eh.resume

return:                                           ; preds = %cleanup, %if.then6, %if.then
  %99 = load i32, i32* %retval, align 4
  ret i32 %99

eh.resume:                                        ; preds = %ehcleanup
  %exn = load i8*, i8** %exn.slot, align 8
  %sel = load i32, i32* %ehselector.slot, align 4
  %lpad.val = insertvalue { i8*, i32 } undef, i8* %exn, 0
  %lpad.val95 = insertvalue { i8*, i32 } %lpad.val, i32 %sel, 1
  resume { i8*, i32 } %lpad.val95
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN9OpenQueueC1EPN11micropather5GraphE(%class.OpenQueue* %this, %"class.micropather::Graph"* %_graph) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  %_graph.addr = alloca %"class.micropather::Graph"*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  store %"class.micropather::Graph"* %_graph, %"class.micropather::Graph"** %_graph.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  %0 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %_graph.addr, align 8
  call void @_ZN9OpenQueueC2EPN11micropather5GraphE(%class.OpenQueue* %this1, %"class.micropather::Graph"* %0)
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN9ClosedSetC1EPN11micropather5GraphE(%class.ClosedSet* %this, %"class.micropather::Graph"* %_graph) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %class.ClosedSet*, align 8
  %_graph.addr = alloca %"class.micropather::Graph"*, align 8
  store %class.ClosedSet* %this, %class.ClosedSet** %this.addr, align 8
  store %"class.micropather::Graph"* %_graph, %"class.micropather::Graph"** %_graph.addr, align 8
  %this1 = load %class.ClosedSet*, %class.ClosedSet** %this.addr, align 8
  %0 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %_graph.addr, align 8
  call void @_ZN9ClosedSetC2EPN11micropather5GraphE(%class.ClosedSet* %this1, %"class.micropather::Graph"* %0)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr zeroext i1 @_ZN9OpenQueue5EmptyEv(%class.OpenQueue* %this) #1 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  %sentinel = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 11
  %1 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next, align 8
  %sentinel2 = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel2, align 8
  %cmp = icmp eq %"class.micropather::PathNode"* %1, %2
  ret i1 %cmp
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN9ClosedSet3AddEPN11micropather8PathNodeE(%class.ClosedSet* %this, %"class.micropather::PathNode"* %pNode) #1 align 2 {
entry:
  %this.addr = alloca %class.ClosedSet*, align 8
  %pNode.addr = alloca %"class.micropather::PathNode"*, align 8
  store %class.ClosedSet* %this, %class.ClosedSet** %this.addr, align 8
  store %"class.micropather::PathNode"* %pNode, %"class.micropather::PathNode"** %pNode.addr, align 8
  %this1 = load %class.ClosedSet*, %class.ClosedSet** %this.addr, align 8
  %0 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode.addr, align 8
  %inClosed = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %0, i32 0, i32 14
  store i8 1, i8* %inClosed, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN9ClosedSetD1Ev(%class.ClosedSet* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %class.ClosedSet*, align 8
  store %class.ClosedSet* %this, %class.ClosedSet** %this.addr, align 8
  %this1 = load %class.ClosedSet*, %class.ClosedSet** %this.addr, align 8
  call void @_ZN9ClosedSetD2Ev(%class.ClosedSet* %this1) #13
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN9OpenQueueD1Ev(%class.OpenQueue* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  call void @_ZN9OpenQueueD2Ev(%class.OpenQueue* %this1) #13
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define i32 @_ZN11micropather11MicroPather18SolveForNearStatesEPvPNS_8MPVectorINS_9StateCostEEEf(%"class.micropather::MicroPather"* %this, i8* %startState, %"class.micropather::MPVector"* %near, float %maxCost) #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
entry:
  %this.addr = alloca %"class.micropather::MicroPather"*, align 8
  %startState.addr = alloca i8*, align 8
  %near.addr = alloca %"class.micropather::MPVector"*, align 8
  %maxCost.addr = alloca float, align 4
  %open = alloca %class.OpenQueue, align 8
  %closed = alloca %class.ClosedSet, align 8
  %exn.slot = alloca i8*
  %ehselector.slot = alloca i32
  %closedSentinel = alloca %"class.micropather::PathNode", align 8
  %newPathNode = alloca %"class.micropather::PathNode"*, align 8
  %node = alloca %"class.micropather::PathNode"*, align 8
  %i = alloca i32, align 4
  %newCost = alloca float, align 4
  %inOpen = alloca %"class.micropather::PathNode"*, align 8
  %inClosed = alloca %"class.micropather::PathNode"*, align 8
  %inEither = alloca %"class.micropather::PathNode"*, align 8
  %child = alloca %"class.micropather::PathNode"*, align 8
  %pNode = alloca %"class.micropather::PathNode"*, align 8
  %sc = alloca %"struct.micropather::StateCost", align 8
  store %"class.micropather::MicroPather"* %this, %"class.micropather::MicroPather"** %this.addr, align 8
  store i8* %startState, i8** %startState.addr, align 8
  store %"class.micropather::MPVector"* %near, %"class.micropather::MPVector"** %near.addr, align 8
  store float %maxCost, float* %maxCost.addr, align 4
  %this1 = load %"class.micropather::MicroPather"*, %"class.micropather::MicroPather"** %this.addr, align 8
  %frame = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %0 = load i32, i32* %frame, align 8
  %inc = add i32 %0, 1
  store i32 %inc, i32* %frame, align 8
  %graph = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %1 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph, align 8
  call void @_ZN9OpenQueueC1EPN11micropather5GraphE(%class.OpenQueue* %open, %"class.micropather::Graph"* %1)
  %graph2 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 4
  %2 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %graph2, align 8
  invoke void @_ZN9ClosedSetC1EPN11micropather5GraphE(%class.ClosedSet* %closed, %"class.micropather::Graph"* %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %nodeCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  invoke void @_ZN11micropather8MPVectorINS_8NodeCostEE6resizeEj(%"class.micropather::MPVector.0"* %nodeCostVec, i32 0)
          to label %invoke.cont4 unwind label %lpad3

invoke.cont4:                                     ; preds = %invoke.cont
  %stateCostVec = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 1
  invoke void @_ZN11micropather8MPVectorINS_9StateCostEE6resizeEj(%"class.micropather::MPVector"* %stateCostVec, i32 0)
          to label %invoke.cont5 unwind label %lpad3

invoke.cont5:                                     ; preds = %invoke.cont4
  invoke void @_ZN11micropather8PathNode5ClearEv(%"class.micropather::PathNode"* %closedSentinel)
          to label %invoke.cont6 unwind label %lpad3

invoke.cont6:                                     ; preds = %invoke.cont5
  %frame7 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %3 = load i32, i32* %frame7, align 8
  invoke void @_ZN11micropather8PathNode4InitEjPvffPS0_(%"class.micropather::PathNode"* %closedSentinel, i32 %3, i8* null, float 0x47EFFFFFE0000000, float 0x47EFFFFFE0000000, %"class.micropather::PathNode"* null)
          to label %invoke.cont8 unwind label %lpad3

invoke.cont8:                                     ; preds = %invoke.cont6
  %prev = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %closedSentinel, i32 0, i32 12
  store %"class.micropather::PathNode"* %closedSentinel, %"class.micropather::PathNode"** %prev, align 8
  %next = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %closedSentinel, i32 0, i32 11
  store %"class.micropather::PathNode"* %closedSentinel, %"class.micropather::PathNode"** %next, align 8
  %pathNodePool = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 0
  %frame9 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 5
  %4 = load i32, i32* %frame9, align 8
  %5 = load i8*, i8** %startState.addr, align 8
  %call = invoke %"class.micropather::PathNode"* @_ZN11micropather12PathNodePool11GetPathNodeEjPvffPNS_8PathNodeE(%"class.micropather::PathNodePool"* %pathNodePool, i32 %4, i8* %5, float 0.000000e+00, float 0.000000e+00, %"class.micropather::PathNode"* null)
          to label %invoke.cont10 unwind label %lpad3

invoke.cont10:                                    ; preds = %invoke.cont8
  store %"class.micropather::PathNode"* %call, %"class.micropather::PathNode"** %newPathNode, align 8
  %6 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %newPathNode, align 8
  invoke void @_ZN9OpenQueue4PushEPN11micropather8PathNodeE(%class.OpenQueue* %open, %"class.micropather::PathNode"* %6)
          to label %invoke.cont11 unwind label %lpad3

invoke.cont11:                                    ; preds = %invoke.cont10
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.then, %invoke.cont11
  %call13 = invoke zeroext i1 @_ZN9OpenQueue5EmptyEv(%class.OpenQueue* %open)
          to label %invoke.cont12 unwind label %lpad3

invoke.cont12:                                    ; preds = %while.cond
  %lnot = xor i1 %call13, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %invoke.cont12
  %call15 = invoke %"class.micropather::PathNode"* @_ZN9OpenQueue3PopEv(%class.OpenQueue* %open)
          to label %invoke.cont14 unwind label %lpad3

invoke.cont14:                                    ; preds = %while.body
  store %"class.micropather::PathNode"* %call15, %"class.micropather::PathNode"** %node, align 8
  %7 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  invoke void @_ZN9ClosedSet3AddEPN11micropather8PathNodeE(%class.ClosedSet* %closed, %"class.micropather::PathNode"* %7)
          to label %invoke.cont16 unwind label %lpad3

invoke.cont16:                                    ; preds = %invoke.cont14
  %8 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  invoke void @_ZN11micropather8PathNode9AddBeforeEPS0_(%"class.micropather::PathNode"* %closedSentinel, %"class.micropather::PathNode"* %8)
          to label %invoke.cont17 unwind label %lpad3

invoke.cont17:                                    ; preds = %invoke.cont16
  %9 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %totalCost = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %9, i32 0, i32 3
  %10 = load float, float* %totalCost, align 8
  %11 = load float, float* %maxCost.addr, align 4
  %cmp = fcmp ogt float %10, %11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont17
  br label %while.cond

lpad:                                             ; preds = %entry
  %12 = landingpad { i8*, i32 }
          cleanup
  %13 = extractvalue { i8*, i32 } %12, 0
  store i8* %13, i8** %exn.slot, align 8
  %14 = extractvalue { i8*, i32 } %12, 1
  store i32 %14, i32* %ehselector.slot, align 4
  br label %ehcleanup

lpad3:                                            ; preds = %if.then80, %while.end, %if.then68, %if.then65, %if.end56, %cond.true39, %cond.end, %cond.true, %invoke.cont22, %for.body, %if.end, %invoke.cont16, %invoke.cont14, %while.body, %while.cond, %invoke.cont10, %invoke.cont8, %invoke.cont6, %invoke.cont5, %invoke.cont4, %invoke.cont
  %15 = landingpad { i8*, i32 }
          cleanup
  %16 = extractvalue { i8*, i32 } %15, 0
  store i8* %16, i8** %exn.slot, align 8
  %17 = extractvalue { i8*, i32 } %15, 1
  store i32 %17, i32* %ehselector.slot, align 4
  call void @_ZN9ClosedSetD1Ev(%class.ClosedSet* %closed) #13
  br label %ehcleanup

if.end:                                           ; preds = %invoke.cont17
  %18 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %nodeCostVec18 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  invoke void @_ZN11micropather11MicroPather16GetNodeNeighborsEPNS_8PathNodeEPNS_8MPVectorINS_8NodeCostEEE(%"class.micropather::MicroPather"* %this1, %"class.micropather::PathNode"* %18, %"class.micropather::MPVector.0"* %nodeCostVec18)
          to label %invoke.cont19 unwind label %lpad3

invoke.cont19:                                    ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont19
  %19 = load i32, i32* %i, align 4
  %20 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %numAdjacent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %20, i32 0, i32 7
  %21 = load i32, i32* %numAdjacent, align 4
  %cmp20 = icmp slt i32 %19, %21
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %costFromStart = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %22, i32 0, i32 1
  %23 = load float, float* %costFromStart, align 8
  %nodeCostVec21 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %24 = load i32, i32* %i, align 4
  %call23 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec21, i32 %24)
          to label %invoke.cont22 unwind label %lpad3

invoke.cont22:                                    ; preds = %for.body
  %cost = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call23, i32 0, i32 1
  %25 = load float, float* %cost, align 8
  %add = fadd float %23, %25
  store float %add, float* %newCost, align 4
  %nodeCostVec24 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %26 = load i32, i32* %i, align 4
  %call26 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec24, i32 %26)
          to label %invoke.cont25 unwind label %lpad3

invoke.cont25:                                    ; preds = %invoke.cont22
  %node27 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call26, i32 0, i32 0
  %27 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node27, align 8
  %inOpen28 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %27, i32 0, i32 13
  %28 = load i8, i8* %inOpen28, align 8
  %tobool = trunc i8 %28 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %invoke.cont25
  %nodeCostVec29 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %29 = load i32, i32* %i, align 4
  %call31 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec29, i32 %29)
          to label %invoke.cont30 unwind label %lpad3

invoke.cont30:                                    ; preds = %cond.true
  %node32 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call31, i32 0, i32 0
  %30 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node32, align 8
  br label %cond.end

cond.false:                                       ; preds = %invoke.cont25
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %invoke.cont30
  %cond = phi %"class.micropather::PathNode"* [ %30, %invoke.cont30 ], [ null, %cond.false ]
  store %"class.micropather::PathNode"* %cond, %"class.micropather::PathNode"** %inOpen, align 8
  %nodeCostVec33 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %31 = load i32, i32* %i, align 4
  %call35 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec33, i32 %31)
          to label %invoke.cont34 unwind label %lpad3

invoke.cont34:                                    ; preds = %cond.end
  %node36 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call35, i32 0, i32 0
  %32 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node36, align 8
  %inClosed37 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %32, i32 0, i32 14
  %33 = load i8, i8* %inClosed37, align 1
  %tobool38 = trunc i8 %33 to i1
  br i1 %tobool38, label %cond.true39, label %cond.false44

cond.true39:                                      ; preds = %invoke.cont34
  %nodeCostVec40 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %34 = load i32, i32* %i, align 4
  %call42 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec40, i32 %34)
          to label %invoke.cont41 unwind label %lpad3

invoke.cont41:                                    ; preds = %cond.true39
  %node43 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call42, i32 0, i32 0
  %35 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node43, align 8
  br label %cond.end45

cond.false44:                                     ; preds = %invoke.cont34
  br label %cond.end45

cond.end45:                                       ; preds = %cond.false44, %invoke.cont41
  %cond46 = phi %"class.micropather::PathNode"* [ %35, %invoke.cont41 ], [ null, %cond.false44 ]
  store %"class.micropather::PathNode"* %cond46, %"class.micropather::PathNode"** %inClosed, align 8
  %36 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inOpen, align 8
  %tobool47 = icmp ne %"class.micropather::PathNode"* %36, null
  br i1 %tobool47, label %cond.true48, label %cond.false49

cond.true48:                                      ; preds = %cond.end45
  %37 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inOpen, align 8
  br label %cond.end50

cond.false49:                                     ; preds = %cond.end45
  %38 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inClosed, align 8
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false49, %cond.true48
  %cond51 = phi %"class.micropather::PathNode"* [ %37, %cond.true48 ], [ %38, %cond.false49 ]
  store %"class.micropather::PathNode"* %cond51, %"class.micropather::PathNode"** %inEither, align 8
  %39 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inEither, align 8
  %tobool52 = icmp ne %"class.micropather::PathNode"* %39, null
  br i1 %tobool52, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %cond.end50
  %40 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inEither, align 8
  %costFromStart53 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %40, i32 0, i32 1
  %41 = load float, float* %costFromStart53, align 8
  %42 = load float, float* %newCost, align 4
  %cmp54 = fcmp ole float %41, %42
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end56:                                         ; preds = %land.lhs.true, %cond.end50
  %nodeCostVec57 = getelementptr inbounds %"class.micropather::MicroPather", %"class.micropather::MicroPather"* %this1, i32 0, i32 2
  %43 = load i32, i32* %i, align 4
  %call59 = invoke dereferenceable(16) %"struct.micropather::NodeCost"* @_ZN11micropather8MPVectorINS_8NodeCostEEixEj(%"class.micropather::MPVector.0"* %nodeCostVec57, i32 %43)
          to label %invoke.cont58 unwind label %lpad3

invoke.cont58:                                    ; preds = %if.end56
  %node60 = getelementptr inbounds %"struct.micropather::NodeCost", %"struct.micropather::NodeCost"* %call59, i32 0, i32 0
  %44 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node60, align 8
  store %"class.micropather::PathNode"* %44, %"class.micropather::PathNode"** %child, align 8
  %45 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %node, align 8
  %46 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %parent = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %46, i32 0, i32 5
  store %"class.micropather::PathNode"* %45, %"class.micropather::PathNode"** %parent, align 8
  %47 = load float, float* %newCost, align 4
  %48 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %costFromStart61 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %48, i32 0, i32 1
  store float %47, float* %costFromStart61, align 8
  %49 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %estToGoal = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %49, i32 0, i32 2
  store float 0.000000e+00, float* %estToGoal, align 4
  %50 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %costFromStart62 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %50, i32 0, i32 1
  %51 = load float, float* %costFromStart62, align 8
  %52 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  %totalCost63 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %52, i32 0, i32 3
  store float %51, float* %totalCost63, align 8
  %53 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inOpen, align 8
  %tobool64 = icmp ne %"class.micropather::PathNode"* %53, null
  br i1 %tobool64, label %if.then65, label %if.else

if.then65:                                        ; preds = %invoke.cont58
  %54 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inOpen, align 8
  invoke void @_ZN9OpenQueue6UpdateEPN11micropather8PathNodeE(%class.OpenQueue* %open, %"class.micropather::PathNode"* %54)
          to label %invoke.cont66 unwind label %lpad3

invoke.cont66:                                    ; preds = %if.then65
  br label %if.end71

if.else:                                          ; preds = %invoke.cont58
  %55 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %inClosed, align 8
  %tobool67 = icmp ne %"class.micropather::PathNode"* %55, null
  br i1 %tobool67, label %if.end70, label %if.then68

if.then68:                                        ; preds = %if.else
  %56 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %child, align 8
  invoke void @_ZN9OpenQueue4PushEPN11micropather8PathNodeE(%class.OpenQueue* %open, %"class.micropather::PathNode"* %56)
          to label %invoke.cont69 unwind label %lpad3

invoke.cont69:                                    ; preds = %if.then68
  br label %if.end70

if.end70:                                         ; preds = %invoke.cont69, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %invoke.cont66
  br label %for.inc

for.inc:                                          ; preds = %if.end71, %if.then55
  %57 = load i32, i32* %i, align 4
  %inc72 = add nsw i32 %57, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond

while.end:                                        ; preds = %invoke.cont12
  %58 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %near.addr, align 8
  invoke void @_ZN11micropather8MPVectorINS_9StateCostEE5clearEv(%"class.micropather::MPVector"* %58)
          to label %invoke.cont73 unwind label %lpad3

invoke.cont73:                                    ; preds = %while.end
  %next74 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %closedSentinel, i32 0, i32 11
  %59 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next74, align 8
  store %"class.micropather::PathNode"* %59, %"class.micropather::PathNode"** %pNode, align 8
  br label %for.cond75

for.cond75:                                       ; preds = %for.inc86, %invoke.cont73
  %60 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %cmp76 = icmp ne %"class.micropather::PathNode"* %60, %closedSentinel
  br i1 %cmp76, label %for.body77, label %for.end88

for.body77:                                       ; preds = %for.cond75
  %61 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %totalCost78 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %61, i32 0, i32 3
  %62 = load float, float* %totalCost78, align 8
  %63 = load float, float* %maxCost.addr, align 4
  %cmp79 = fcmp ole float %62, %63
  br i1 %cmp79, label %if.then80, label %if.end85

if.then80:                                        ; preds = %for.body77
  %64 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %totalCost81 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %64, i32 0, i32 3
  %65 = load float, float* %totalCost81, align 8
  %cost82 = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %sc, i32 0, i32 1
  store float %65, float* %cost82, align 8
  %66 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %state = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %66, i32 0, i32 0
  %67 = load i8*, i8** %state, align 8
  %state83 = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %sc, i32 0, i32 0
  store i8* %67, i8** %state83, align 8
  %68 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %near.addr, align 8
  invoke void @_ZN11micropather8MPVectorINS_9StateCostEE9push_backERKS1_(%"class.micropather::MPVector"* %68, %"struct.micropather::StateCost"* dereferenceable(16) %sc)
          to label %invoke.cont84 unwind label %lpad3

invoke.cont84:                                    ; preds = %if.then80
  br label %if.end85

if.end85:                                         ; preds = %invoke.cont84, %for.body77
  br label %for.inc86

for.inc86:                                        ; preds = %if.end85
  %69 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %pNode, align 8
  %next87 = getelementptr inbounds %"class.micropather::PathNode", %"class.micropather::PathNode"* %69, i32 0, i32 11
  %70 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %next87, align 8
  store %"class.micropather::PathNode"* %70, %"class.micropather::PathNode"** %pNode, align 8
  br label %for.cond75

for.end88:                                        ; preds = %for.cond75
  call void @_ZN9ClosedSetD1Ev(%class.ClosedSet* %closed) #13
  call void @_ZN9OpenQueueD1Ev(%class.OpenQueue* %open) #13
  ret i32 0

ehcleanup:                                        ; preds = %lpad3, %lpad
  call void @_ZN9OpenQueueD1Ev(%class.OpenQueue* %open) #13
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup
  %exn = load i8*, i8** %exn.slot, align 8
  %sel = load i32, i32* %ehselector.slot, align 4
  %lpad.val = insertvalue { i8*, i32 } undef, i8* %exn, 0
  %lpad.val89 = insertvalue { i8*, i32 } %lpad.val, i32 %sel, 1
  resume { i8*, i32 } %lpad.val89
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEE5clearEv(%"class.micropather::MPVector"* %this) #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEE9push_backERKS1_(%"class.micropather::MPVector"* %this, %"struct.micropather::StateCost"* dereferenceable(16) %t) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  %t.addr = alloca %"struct.micropather::StateCost"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  store %"struct.micropather::StateCost"* %t, %"struct.micropather::StateCost"** %t.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  %0 = load i32, i32* %m_size, align 4
  %add = add i32 %0, 1
  call void @_ZN11micropather8MPVectorINS_9StateCostEE8capacityEj(%"class.micropather::MPVector"* %this1, i32 %add)
  %1 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %t.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  %2 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %m_buf, align 8
  %m_size2 = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  %3 = load i32, i32* %m_size2, align 4
  %inc = add i32 %3, 1
  store i32 %inc, i32* %m_size2, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds %"struct.micropather::StateCost", %"struct.micropather::StateCost"* %2, i64 %idxprom
  %4 = bitcast %"struct.micropather::StateCost"* %arrayidx to i8*
  %5 = bitcast %"struct.micropather::StateCost"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 16, i1 false)
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN9OpenQueueC2EPN11micropather5GraphE(%class.OpenQueue* %this, %"class.micropather::Graph"* %_graph) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  %_graph.addr = alloca %"class.micropather::Graph"*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  store %"class.micropather::Graph"* %_graph, %"class.micropather::Graph"** %_graph.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  %0 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %_graph.addr, align 8
  %graph = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 2
  store %"class.micropather::Graph"* %0, %"class.micropather::Graph"** %graph, align 8
  %sentinelMem = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [23 x i32], [23 x i32]* %sentinelMem, i32 0, i32 0
  %1 = bitcast i32* %arraydecay to %"class.micropather::PathNode"*
  %sentinel = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  store %"class.micropather::PathNode"* %1, %"class.micropather::PathNode"** %sentinel, align 8
  %sentinel2 = getelementptr inbounds %class.OpenQueue, %class.OpenQueue* %this1, i32 0, i32 0
  %2 = load %"class.micropather::PathNode"*, %"class.micropather::PathNode"** %sentinel2, align 8
  call void @_ZN11micropather8PathNode12InitSentinelEv(%"class.micropather::PathNode"* %2)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN9ClosedSetC2EPN11micropather5GraphE(%class.ClosedSet* %this, %"class.micropather::Graph"* %_graph) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %class.ClosedSet*, align 8
  %_graph.addr = alloca %"class.micropather::Graph"*, align 8
  store %class.ClosedSet* %this, %class.ClosedSet** %this.addr, align 8
  store %"class.micropather::Graph"* %_graph, %"class.micropather::Graph"** %_graph.addr, align 8
  %this1 = load %class.ClosedSet*, %class.ClosedSet** %this.addr, align 8
  %0 = load %"class.micropather::Graph"*, %"class.micropather::Graph"** %_graph.addr, align 8
  %graph = getelementptr inbounds %class.ClosedSet, %class.ClosedSet* %this1, i32 0, i32 0
  store %"class.micropather::Graph"* %0, %"class.micropather::Graph"** %graph, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN9ClosedSetD2Ev(%class.ClosedSet* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %class.ClosedSet*, align 8
  store %class.ClosedSet* %this, %class.ClosedSet** %this.addr, align 8
  %this1 = load %class.ClosedSet*, %class.ClosedSet** %this.addr, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN9OpenQueueD2Ev(%class.OpenQueue* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %class.OpenQueue*, align 8
  store %class.OpenQueue* %this, %class.OpenQueue** %this.addr, align 8
  %this1 = load %class.OpenQueue*, %class.OpenQueue** %this.addr, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEEC2Ev(%"class.micropather::MPVector"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 0
  store i32 0, i32* %m_allocated, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  %m_buf = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  store %"struct.micropather::StateCost"* null, %"struct.micropather::StateCost"** %m_buf, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEEC2Ev(%"class.micropather::MPVector.0"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 0
  store i32 0, i32* %m_allocated, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 2
  store %"struct.micropather::NodeCost"* null, %"struct.micropather::NodeCost"** %m_buf, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfEC2Ev(%"class.micropather::MPVector.1"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 0
  store i32 0, i32* %m_allocated, align 8
  %m_size = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 1
  store i32 0, i32* %m_size, align 4
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  store float* null, float** %m_buf, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEED2Ev(%"class.micropather::MPVector"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %m_buf, align 8
  %isnull = icmp eq %"struct.micropather::StateCost"* %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  %1 = bitcast %"struct.micropather::StateCost"* %0 to i8*
  call void @_ZdaPv(i8* %1) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEED2Ev(%"class.micropather::MPVector.0"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 2
  %0 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %m_buf, align 8
  %isnull = icmp eq %"struct.micropather::NodeCost"* %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  %1 = bitcast %"struct.micropather::NodeCost"* %0 to i8*
  call void @_ZdaPv(i8* %1) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfED2Ev(%"class.micropather::MPVector.1"* %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  %0 = load float*, float** %m_buf, align 8
  %isnull = icmp eq float* %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  %1 = bitcast float* %0 to i8*
  call void @_ZdaPv(i8* %1) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %entry
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIPvE8capacityEj(%"class.micropather::MPVector.2"* %this, i32 %cap) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.2"*, align 8
  %cap.addr = alloca i32, align 4
  %newAllocated = alloca i32, align 4
  %newBuf = alloca i8**, align 8
  store %"class.micropather::MPVector.2"* %this, %"class.micropather::MPVector.2"** %this.addr, align 8
  store i32 %cap, i32* %cap.addr, align 4
  %this1 = load %"class.micropather::MPVector.2"*, %"class.micropather::MPVector.2"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 0
  %0 = load i32, i32* %m_allocated, align 8
  %1 = load i32, i32* %cap.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %cap.addr, align 4
  %mul = mul i32 %2, 3
  %div = udiv i32 %mul, 2
  %add = add i32 %div, 16
  store i32 %add, i32* %newAllocated, align 4
  %3 = load i32, i32* %newAllocated, align 4
  %conv = zext i32 %3 to i64
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 8)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  %7 = select i1 %5, i64 -1, i64 %6
  %call = call i8* @_Znam(i64 %7) #14
  %8 = bitcast i8* %call to i8**
  store i8** %8, i8*** %newBuf, align 8
  %9 = load i8**, i8*** %newBuf, align 8
  %10 = bitcast i8** %9 to i8*
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 2
  %11 = load i8**, i8*** %m_buf, align 8
  %12 = bitcast i8** %11 to i8*
  %m_size = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 1
  %13 = load i32, i32* %m_size, align 4
  %conv2 = zext i32 %13 to i64
  %mul3 = mul i64 8, %conv2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %12, i64 %mul3, i1 false)
  %m_buf4 = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 2
  %14 = load i8**, i8*** %m_buf4, align 8
  %isnull = icmp eq i8** %14, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  %15 = bitcast i8** %14 to i8*
  call void @_ZdaPv(i8* %15) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  %16 = load i8**, i8*** %newBuf, align 8
  %m_buf5 = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 2
  store i8** %16, i8*** %m_buf5, align 8
  %17 = load i32, i32* %newAllocated, align 4
  %m_allocated6 = getelementptr inbounds %"class.micropather::MPVector.2", %"class.micropather::MPVector.2"* %this1, i32 0, i32 0
  store i32 %17, i32* %m_allocated6, align 8
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorIfE8capacityEj(%"class.micropather::MPVector.1"* %this, i32 %cap) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.1"*, align 8
  %cap.addr = alloca i32, align 4
  %newAllocated = alloca i32, align 4
  %newBuf = alloca float*, align 8
  store %"class.micropather::MPVector.1"* %this, %"class.micropather::MPVector.1"** %this.addr, align 8
  store i32 %cap, i32* %cap.addr, align 4
  %this1 = load %"class.micropather::MPVector.1"*, %"class.micropather::MPVector.1"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 0
  %0 = load i32, i32* %m_allocated, align 8
  %1 = load i32, i32* %cap.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %cap.addr, align 4
  %mul = mul i32 %2, 3
  %div = udiv i32 %mul, 2
  %add = add i32 %div, 16
  store i32 %add, i32* %newAllocated, align 4
  %3 = load i32, i32* %newAllocated, align 4
  %conv = zext i32 %3 to i64
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 4)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  %7 = select i1 %5, i64 -1, i64 %6
  %call = call i8* @_Znam(i64 %7) #14
  %8 = bitcast i8* %call to float*
  store float* %8, float** %newBuf, align 8
  %9 = load float*, float** %newBuf, align 8
  %10 = bitcast float* %9 to i8*
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  %11 = load float*, float** %m_buf, align 8
  %12 = bitcast float* %11 to i8*
  %m_size = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 1
  %13 = load i32, i32* %m_size, align 4
  %conv2 = zext i32 %13 to i64
  %mul3 = mul i64 4, %conv2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %12, i64 %mul3, i1 false)
  %m_buf4 = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  %14 = load float*, float** %m_buf4, align 8
  %isnull = icmp eq float* %14, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  %15 = bitcast float* %14 to i8*
  call void @_ZdaPv(i8* %15) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  %16 = load float*, float** %newBuf, align 8
  %m_buf5 = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 2
  store float* %16, float** %m_buf5, align 8
  %17 = load i32, i32* %newAllocated, align 4
  %m_allocated6 = getelementptr inbounds %"class.micropather::MPVector.1", %"class.micropather::MPVector.1"* %this1, i32 0, i32 0
  store i32 %17, i32* %m_allocated6, align 8
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_8NodeCostEE8capacityEj(%"class.micropather::MPVector.0"* %this, i32 %cap) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector.0"*, align 8
  %cap.addr = alloca i32, align 4
  %newAllocated = alloca i32, align 4
  %newBuf = alloca %"struct.micropather::NodeCost"*, align 8
  store %"class.micropather::MPVector.0"* %this, %"class.micropather::MPVector.0"** %this.addr, align 8
  store i32 %cap, i32* %cap.addr, align 4
  %this1 = load %"class.micropather::MPVector.0"*, %"class.micropather::MPVector.0"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 0
  %0 = load i32, i32* %m_allocated, align 8
  %1 = load i32, i32* %cap.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %cap.addr, align 4
  %mul = mul i32 %2, 3
  %div = udiv i32 %mul, 2
  %add = add i32 %div, 16
  store i32 %add, i32* %newAllocated, align 4
  %3 = load i32, i32* %newAllocated, align 4
  %conv = zext i32 %3 to i64
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 16)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  %7 = select i1 %5, i64 -1, i64 %6
  %call = call i8* @_Znam(i64 %7) #14
  %8 = bitcast i8* %call to %"struct.micropather::NodeCost"*
  store %"struct.micropather::NodeCost"* %8, %"struct.micropather::NodeCost"** %newBuf, align 8
  %9 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %newBuf, align 8
  %10 = bitcast %"struct.micropather::NodeCost"* %9 to i8*
  %m_buf = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 2
  %11 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %m_buf, align 8
  %12 = bitcast %"struct.micropather::NodeCost"* %11 to i8*
  %m_size = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 1
  %13 = load i32, i32* %m_size, align 4
  %conv2 = zext i32 %13 to i64
  %mul3 = mul i64 16, %conv2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %12, i64 %mul3, i1 false)
  %m_buf4 = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 2
  %14 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %m_buf4, align 8
  %isnull = icmp eq %"struct.micropather::NodeCost"* %14, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  %15 = bitcast %"struct.micropather::NodeCost"* %14 to i8*
  call void @_ZdaPv(i8* %15) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  %16 = load %"struct.micropather::NodeCost"*, %"struct.micropather::NodeCost"** %newBuf, align 8
  %m_buf5 = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 2
  store %"struct.micropather::NodeCost"* %16, %"struct.micropather::NodeCost"** %m_buf5, align 8
  %17 = load i32, i32* %newAllocated, align 4
  %m_allocated6 = getelementptr inbounds %"class.micropather::MPVector.0", %"class.micropather::MPVector.0"* %this1, i32 0, i32 0
  store i32 %17, i32* %m_allocated6, align 8
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  ret void
}

; Function Attrs: noinline optnone ssp uwtable
define linkonce_odr void @_ZN11micropather8MPVectorINS_9StateCostEE8capacityEj(%"class.micropather::MPVector"* %this, i32 %cap) #0 align 2 {
entry:
  %this.addr = alloca %"class.micropather::MPVector"*, align 8
  %cap.addr = alloca i32, align 4
  %newAllocated = alloca i32, align 4
  %newBuf = alloca %"struct.micropather::StateCost"*, align 8
  store %"class.micropather::MPVector"* %this, %"class.micropather::MPVector"** %this.addr, align 8
  store i32 %cap, i32* %cap.addr, align 4
  %this1 = load %"class.micropather::MPVector"*, %"class.micropather::MPVector"** %this.addr, align 8
  %m_allocated = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 0
  %0 = load i32, i32* %m_allocated, align 8
  %1 = load i32, i32* %cap.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %cap.addr, align 4
  %mul = mul i32 %2, 3
  %div = udiv i32 %mul, 2
  %add = add i32 %div, 16
  store i32 %add, i32* %newAllocated, align 4
  %3 = load i32, i32* %newAllocated, align 4
  %conv = zext i32 %3 to i64
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 16)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  %7 = select i1 %5, i64 -1, i64 %6
  %call = call i8* @_Znam(i64 %7) #14
  %8 = bitcast i8* %call to %"struct.micropather::StateCost"*
  store %"struct.micropather::StateCost"* %8, %"struct.micropather::StateCost"** %newBuf, align 8
  %9 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %newBuf, align 8
  %10 = bitcast %"struct.micropather::StateCost"* %9 to i8*
  %m_buf = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  %11 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %m_buf, align 8
  %12 = bitcast %"struct.micropather::StateCost"* %11 to i8*
  %m_size = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 1
  %13 = load i32, i32* %m_size, align 4
  %conv2 = zext i32 %13 to i64
  %mul3 = mul i64 16, %conv2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %12, i64 %mul3, i1 false)
  %m_buf4 = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  %14 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %m_buf4, align 8
  %isnull = icmp eq %"struct.micropather::StateCost"* %14, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  %15 = bitcast %"struct.micropather::StateCost"* %14 to i8*
  call void @_ZdaPv(i8* %15) #15
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  %16 = load %"struct.micropather::StateCost"*, %"struct.micropather::StateCost"** %newBuf, align 8
  %m_buf5 = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 2
  store %"struct.micropather::StateCost"* %16, %"struct.micropather::StateCost"** %m_buf5, align 8
  %17 = load i32, i32* %newAllocated, align 4
  %m_allocated6 = getelementptr inbounds %"class.micropather::MPVector", %"class.micropather::MPVector"* %this1, i32 0, i32 0
  store i32 %17, i32* %m_allocated6, align 8
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  ret void
}

attributes #0 = { noinline optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { allocsize(0,1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noinline noreturn nounwind }
attributes #5 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { argmemonly nounwind }
attributes #7 = { nobuiltin "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nobuiltin nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind readnone speculatable }
attributes #10 = { allocsize(0) }
attributes #11 = { allocsize(0,1) }
attributes #12 = { noreturn nounwind }
attributes #13 = { nounwind }
attributes #14 = { builtin }
attributes #15 = { builtin nounwind }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 7.1.0 (https://github.com/llvm-mirror/clang.git 4519e2637fcc4bf6e3049a0a80e6a5e7b97667cb) (https://github.com/llvm-mirror/llvm.git dd3329aeb25d87d4ac6429c0af220f92e1ba5f26)"}
