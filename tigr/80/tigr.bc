; ModuleID = 'tigr.c'
source_filename = "tigr.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.TigrFont = type { %struct.Tigr*, i32, %struct.TigrGlyph* }
%struct.Tigr = type { i32, i32, %struct.TPixel*, i8* }
%struct.TPixel = type { i8, i8, i8, i8 }
%struct.TigrGlyph = type { i32, i32, i32, i32, i32 }
%struct.objc_object = type { %struct.objc_class* }
%struct.objc_class = type { %struct.objc_class*, %struct.objc_class*, i8*, i64, i64, i64, %struct.objc_ivar_list*, %struct.objc_method_list**, %struct.objc_cache*, %struct.objc_protocol_list* }
%struct.objc_ivar_list = type { i32, i32, [1 x %struct.objc_ivar] }
%struct.objc_ivar = type { i8*, i8*, i32, i32 }
%struct.objc_method_list = type { %struct.objc_method_list*, i32, i32, [1 x %struct.objc_method] }
%struct.objc_method = type { %struct.objc_selector*, i8*, void ()* }
%struct.objc_selector = type opaque
%struct.objc_cache = type { i32, i32, [1 x %struct.objc_method*] }
%struct.objc_protocol_list = type { %struct.objc_protocol_list*, i64, [1 x %struct.objc_object*] }
%struct.CGPoint = type { double, double }
%struct.mach_timebase_info = type { i32, i32 }
%struct.PNG = type { i8*, i8* }
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.Save = type { i32, i32, i32, i32, i32, %struct.__sFILE*, [256 x i32] }
%struct.TigrInternal = type { i32, i32, %struct.GLStuff, i8*, %struct.Tigr*, i32, i8, float, i32, i32, float, float, i32, i32, [4 x i32], i32, [256 x i8], [256 x i8], i32 }
%struct.GLStuff = type { [2 x i32], i32, i32, i32, i32, i32, i32 }
%struct.State = type { i32, i32, i8*, i8*, i8*, i8*, [37 x i32], [288 x i32], [32 x i32], [19 x i32], i32, i32, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.__CFString = type opaque
%struct.__CFAllocator = type opaque
%struct.__CFURL = type opaque
%struct.CGSize = type { double, double }
%struct.CGRect = type { %struct.CGPoint, %struct.CGSize }
%struct.anon = type { %union.anon }
%union.anon = type { %struct.anon.0 }
%struct.anon.0 = type { i8 }

@.str = private unnamed_addr constant [3 x i8] c"wb\00", align 1
@.str.1 = private unnamed_addr constant [5 x i8] c"IEND\00", align 1
@.str.2 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@tigr_font = constant [3850 x i8] c"\89PNG\0D\0A\1A\0A\00\00\00\0DIHDR\00\00\00\FD\00\00\00\5C\08\03\00\00\00\92\ABC\85\00\00\03\00PLTE_S\87\00\00\00TTT\FF\FF\FA1*B\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00\80\00\00JD\B7Z\00\00\0B\C5IDATx\9C\ED\5C\8B\82\E4&\0ED\C0\FF\7F\F3\8D\91J/\C0\8D{zv\93\9Bt2\C6\C6\BC\0A\09P!\BC\A5\FF\E6_\E9\85\7F\BD5\BA\FE\AE\A04\BA\FE\FFz\F5u-\EE\D1R\16I\8EX\17\A4[N,I\9B\14(\CF\1A\7F\DD]\E5\8D\08\8D\CF\CF.\BD/]ZE\C5\15\FD\09\F4\D2\08\BA\FE\1B\8F\E4R\D6\CE\89\A5\8B\10,\D0\7F%#\A0 .\80\9A\8F\E76\8Fg\FA*\17\F1\D7\93O\E7\C2\8E\AA+\AA\A3P\F4;\E8\E9\CAk2`\D8}\5C\EBH1j \15\BBK\B4C\DF\18\8D\CAv\14\F0U\1A\A3\E3\B0H\AFs\EF\8E\8A\0A\09.\C4\A7P\14\90\9B\C5\0A2$\84\22\DFA_\BE\F2\0E\99^\9D\C0\B2\BD\1AA\15\FD\CA\08\19\90\A0\1F\C0\AA\B6\A1\14\7F;\FAD{s\88E4\82\A5\86\BC_5\A0\D7\91\9E,\1D\B5f!\F7\DA\F8\BB\C0\97\A1!\A30\16\02gy\0B\BDH\0D\9AO\18\AE\5CM\E3\10\E2\09\B2\BF\FA\8B\C5e\CD)&\1D\D5p\19%#\FE\AB\C1\E4\C7{\D6t\A4\D3gB<7\02\CA\DE\FC0\E0,O\D1\93\0D\A1\A4\F9W\B9,\12<{\F4\97bp\B5+\CD\87\D2\D4\80\DE\BA\B1x\D4Y\D3\91N\9F\ED}\F7\CA\CE\9D-\1D\CAU|C\F6N\F3\1B\97\DB\08\22\11\A1\1A\FAR\04\09\1A\DA]\81\B9\F5:\EB\D5\B2F\95\C3\90n\1A\F7Pv\9E\F3\A5\19#\FC\8C\E6\8F\FE\F4\9D!\B2\87\86V'\E9\B2B/\89mn\F0\9A.\F1\AA\03~|\CB\E4\E2\F3k\C8s\D3\95\CF\CD\F9\B5\94\F7e\EF4\9F'?\95\A7>^\1A\86\01-3O^\EF\9D0F\8A*\89GR\12%E\88\F8+yx\D6\F4\B5\F8\FC.}\D7\8E\0F\0Dx\1B}.h\F7h)\FB\9C\A8Gm\E8\DB\02\BE\1Bv\ED\F8\8C\FE=\CD\FF\0C\FA\A8\0D?\88>\97\9E\AA\FA;\E8W\B7\FFd\F4\BF\F9\C7\F3\84.\C3\D1\D4J\CFy\CA\B6\F7X\88\5C|Z\C0\8A,\5Cy=\BF\AD0\B3\9D\C5\CAW\E6\1B\DF\94f\0B\8F\9AD\A6.\9D\D73\825\B3#\15\1A\82\84x2\82*I-c\D2\05+\A27{\FFeE>D\C1\E7\E8\9D\D5Xm\D9\A5.v\9B\A1\1Fv\18\AC\99\A9\F0\5C\A9\CA\B0\94\E9\BD\19\B2\05:\11\96\ED\96\95gUa\92\A0\D8\CC\0DV\D2\1A=\F9\AA\1A\CC}\901R\03\F3\02\EB\D6\E4\CE\FC\15\B6\9Ck\5Ch\B5\A9\13\0Ck\0A\BD\A0\96vB\DF`\A6\A3\1C\95\F9\0B\F4f\DD(/\B8C_H\AA2\FB\C9 \F4b\E8\AF\D5\D0\D6dA_\CC\92\8DaBO0\5C\116\9F~-\FB\80\1E\5C.\0E\19\DF\DD\A1@\92\F1\BFGo\F4I\E8g\13\F3\D4:^\E8\80\DA\D4%j\FE\D0\9B\DD\B0J\95&\CD\0F \16\E8\A7^\DCi:\A1\AD\B1@\0AJ\B5\D4\91\D6t\83\C0\F7\931\0C\9E\EA6\E8\A9\B1\01\BBV\AC]o\E4^I\8DT\99\9F\A2\D7\A1\91{e\85\DE\F1\06\CDPsJ\E5G]\C8\D0\12}![\D1\E6ag\1B\17\9E\A4D\F2\11E\81\FD\8Ey%\9C\D0\EF\D8L~\0FL\FALZA\A5P\B2\93\BD\ADxE\B6\D7\9A#`\E3\A9\B3el\A4BIH \1B\99\A4D\F2\11\F2\09Y\E1M\97\18?bq\E3Y\8D/p\A0N\EFa\BC\E7\E7P\A0\EC\85\E1\8D\F2\A91\C7\B9\DBRtK\C0,\DD\9F1HW\E1}\02k\E3\F3\02\D7)z\BE\0D\9A\7F\D4\A8\0F\86?W\E0\7F\E8\E7\F0\16\FDo\FE\F9\BD([\CB\5C\17\F9\D7b>\E6\D4\98W\D3\E2\F6\AE\AC\BB\99\0D\B7\92\9E\B2\F9=?\FF\F6S\E8[\F3\93\92.T2\AF&\83\E9\8F\A3\C7j\09\1F\D3\11\FA\B1k\BB\A2\96JU\E3k\C7`\D5Np\B2o\CE\BEV\B3\C7\17\9B\9E]A%T\B3\B4\89\D6/\D4\E0sNF&\B3\AF\D0\0F\B3a\E10\8B\14\96\D0\A7\8B\E8\80\DE\0C\1D3D\17\19\F6\A1\AF\E6\0C\BDc\B3pI\B5\C6\FE\B7+\FA\C6\AD5\F4F]D\A1\A2\E5\B6\C5\86l8\F4f_7\C7\E9^\9A\D0\E4<g\DBj\E2\C67^\98\BF\CB\CB\BE\0E2{m+\BFB\DF&\D2\95\D0\C3]r\80^\93\8Cl5\17\BB\D5\E9KI\85\AAl\AB\81\8B9Z\E6\A5\81\D7E\CD/\B2-\7F\80~\D1\9C)\FA\04\BD\11\9C\BB\81\BAa9\EA\E8\DEp\9Ai !{-K\F4\AF\C7}\D4|\CFo\CCg\0Av\D1\8Cll\D1\EB\0C1\A3\CF\B4\C9\17\84f\08\89\F1\B5\0A\A7\996pb\AB9\1DV\BC\FA\00}\F1N\16\E57\1A\ED|) \1B\CD\91\11Y\F1|T\E4\1E\99\B5\B4f\D5 \17\9A!$f\CDqj`U\96\1D.lx\B9\CC\ABp\84~\B3\82\AE\A3u X\B4\A8\FC\C2\C2\5C\95\A3\E3\BCdk\EAu\ED\A9\18\CBn\06mO\D9>\8B\DE;\1FQ!MQ?\8F>\B6\E3O\A1\F7\CEG\ADp\8A\BAA\AF\9A^V\8C\F6\18}l\C7{\E8\7F\F3/\F4\91\84y,\15\8B\F7a\93\CDb1(\CDO \16,\17c/:\EC\80\B06\16\9B1r\A5\BD`\E1m\84T\BE\16\FF\EB.\8Fk\D8\01z1\B2\AD\E9\F9L\C2\12\BD\98\91|\92\A9\E8I\87\A2S \EB\B4\BDx\8E\DE\CE\8CU\1C\9Aq\B5l\D0K\0A9s\F0\12\FD0\F2)\A0\9F\1ARf/\DE8\C8 \87\D9D\DE\14\D0\17\00V-\F0G> M,\E2+\F4b\AB\B2\1C\AF\1E\08\B5\B0\C9gT\EB\FAM\14\E9\15\FA\91zx\BB\BA\A2\5Ci>\9Ci\EA\AD\E3\9E\AE\C6\E8q\C2\A9K\A3\C6AG\E5 \E3\7Fw\E4\83W\EF\8EE\DC\99-n\DC\14'\C7\02\82E\1D\B6 W#\E5\0F!:\07\DE\11z\12\CF\0C\00\A9(^h>\22e\FEV\86B\15\9A_\A5\D0&dC\BB,h\AA\AA\96\9A-\A4\9B\C3\B3\08D\02f\E6\ABJ^B\F8z\99\8E\F8\1D\C9\DE\CFz\1B\CD\CF[\E5\8A^\A6\191\F0q\A8S5\1F\1C\C4\CF\AB\EBUp\9E\F5\E6F\C8daN\D7\06\872\D0Kub\1E\1F\C9\1E\D338\86LF\18\9D\0D<\D2\8D\00\E9*\A3\D1b\E0\D34\EE\E5(\D9=\FA\05\DA\D5\E4\03\1E\A4\E6>T\1C\E8\B5:n\ED+\F4E\CD\B43\F4Q\F3\C5\FF[\1DC\01\FD\90\B9.\CCz\DFE/\B58\7F-\18S\98\94\E9\1C\BD\9Ai\BD\E1\D0\AC\DA\ED\95'%\EF&\B1\B0`B\D2\E3l\E3-\D8\91\ACxv\F7\01\F4R\8B\F3\EC\04b\A6D\AD\9F\9D\DD\F2\D5ws+u\85\9C\9A\12\C3\9E_\CF\B1\DD\DF}\1F\FD\AA\96Ey\FA\F8\00\BD\E5\DBV\FC\1F\FA\FF'\F4\BF\F9\97;_\A7u[\F4\C3F\9E\BE\C3\D9u\18\01\F21\01\E9\972z\D5$2\1B{{\A2\E9&`$\FAfS\B88!/\DD3\AB\A2g\E0\A7\BB\03\F1\AF\D1\C3\06\E754\A2\17Z\C0\E7\95\F9a\18\01\F2}@:=\EC\93\C0,q\1F\B2\10>l\88\E8\9B\FB\12\C0\8B\A0\83\F5PBJ$]\E2\EE\1E\A1o\8ED4fh\F3\E1\0Cfu8\F6\C4\A7\DD\E4\B8\17\DB J\C1pe\A3\D7#\13\F5\00M6\EB\B8\DE\A2'\D38\81\DF\19h\95r\A6\BB\D7K~D\0F\C3\A6\81X\EB\0E-z\A1\13>\CE\11hl(\8A\B9W\E1\CB\80\DD\01\0E\EC\D0c_V\DE\B2U\CA;\9Bi\EB^w\8BM\F3\A5$\92\0E\D51p\95cL\1Bv\E6\03\F4\F0Qi\D3f_\0E\891gT\96X\F7X\F6\AA\9126D\D1[\13KZP\88U!\DE*\BF\01\1D\F6\AA3zTQm\84\B1\B1\87\A3\86\DAa\DA\DD/\0D\9EI\F6\10\8F\17\85;)\CA\1D\AFlXN\BB\C9\A1\18h$\CF\16\AA\F9Q\F6\B8\A2\9F\DC\06\B4\ED\D2\CA\F9I\BF\E9'UTSn\EEe\D4\AFw\BA\13\F2M\CD\8F^\14\8C\FBB*+\E2)M\99+\E9\10\D7\B9\8F\1A\F6(\12zg.\EBE\D13w\8Cs\BE\A5r#\9B\8F\D9\EE\EE\9E\A1\A7\84\96\A0\C3&{\1CG\13-\0EOE\BE\E7\0B0}\12\8B\8E4\D9\D0\83q\B5\1B\F4\B2\D9!\0AdKH\BEk\ED\99\E6\CB\A6\98\9E\F7\AA\90\22\C13\AB\C7\D1 A\8A2\0C\E2\9D\92X\B4\DB\BF\88\B27\F7M\D8\EEZ\98\89P \1Ee\F3]\93=\B7s\F4q\A5\CCa\DE{\8Fxw\E8W\85\F5\9C\CF4?\A5\EDv\0Aa]\8F;v\1C\EF0\8C\1E\A0\9F\C545\E6\07\D1{7\87V\D8^\A1\DF\DC\1Dln\AD\04\FB\F7\D0/+$\0C\F2\87\E8\E1\EA\B9E\FF\9B\7Fa\5Ca\D0\C7\1D,\F1\8A\F8\1D-\ED\DE\06:\E4\B2v\B3bAL$N\AEb\EB6\CBlI\8E\1A2\89{\93\D12(\CF\A2\D8\EE>Vi)\03\8B(\E7\81\DB\1C\1Ff\CE\E8a\0A\17\F9\00@\BE\04\C6.o\85\1D[\BA{\D3eYt\99\B1ev\D8\90\09\FD&\A3\B5\9C\DC7\E4\C5Ni\B9~8\0D#\FAb\A6\F1>X]\8B3\EA\B1\9Dz\D4\001\AE\8B\F8r\C2I\96\9A\C2\E2\9F\A1mR\C4@\EF\F2\1E\85\EAAP\CB\18\EB\F4:`V3_\B9\ED\C2\11\9E4@6\91\A1;\EB\A3m\AB\109x\EC\8D2\8E\F3\BA\90}\94\14\BF\B6\A2MP6W2\11YW\1E\81 =\A2\95\C9\D8:\0C\C7\8E\80\9E {\A7\A8\C7\A1h\90\93}\DD\04;\F4^\F3\9F\A1\C7l\DA\16_\C0l\BA\0B\FD%V\F7\FB\9A\0F\D9\FB\7FV\80{a\1D\9C\A0\0F\8E\C7\97\A1|S'\BAs\80^\17\8D&Vw@\FFT\F3\0B\F4 \1EA{<\EB!sT\D0\97\A1\B8s\09\92|\95\C1{ q0P\DE\F8sg\0FB=\CAf\B4\A8\EE\83\D5u\FA\1Ch\FA7\06v!\AF7\EC\C6\09\9F\EBl3\C0C\03Kz\E4\AD%\EEj>\09ag8\1B\E0&\D8]\DF\A8x\B5\DE?l\B9\C5|\13\BDg\AF\BF\0F\FD\A2A\FF*\F4\BF\F9W\F6\1C\C1\91\8F\B6c9\1An\CAh\04^\D3\99\D9\F8\E3f\0D\DC\00\E1m3\DA\878\8E?\CC6\C6\AE\A2\5C\92\0B\B0\95[\F4\F7<Cv\FB\ED\94\DBhSS\DB\A5\1E4\C3Q\96\84\FE\19\C7\F1\87\D9\CAs\96c\C6\DEy\1E^\A6\E5\94\9B\EC\D8\C9\F1\A8\D1\B7\0F\8A\C2\F6\D3x~\83\E3\E8\8B._\A0\EB\91\AF\07\E1S\FB\10\7F\E6\B4D[\B4M\87E\C1Vz\93\E3D\F4\E4\ED\B6\E3\10V\9Bc\B8\B7\DC \A3oJ\B7\1E\DA\B9\B0\B3\DA)\C7\F1\E8CD\EF\DF\B0\F3#\C7\D3\E7]8\A3/\8F\1A\AF \D4\CD|\C8q^\A2\7F\C3\CE\7F\9C\E7s\E81M\1Cr\9C{\F4ok\FE\09!\91pFOy\0E:-Jf\FAs\8E\83v+\ABB\04\CF\F9\C6X\1E\84\CA#\DA\091\11vd\87\C2\FE$\C7!\FB\D2+D\F4\FEQ\96s\1B\E2\CF]\DE\A9\F6\B9\9D\1B4\DFG|\00\FD\C2G\F7\0FC\EF\F7 \82g\FA\03\E8\8F\C3\BF\86\DE\FF\EB!\E1\DF:\EC\BF\DD\97\F3?\CA\1B\AA\DF\FC\A4\05\0A\00\00\00\00IEND\AEB`\82", align 16
@tigr_font_size = global i32 3850, align 4
@tigrStockFont = common global %struct.TigrFont zeroinitializer, align 8
@tfont = global %struct.TigrFont* @tigrStockFont, align 8
@cp1252 = internal global [128 x i32] [i32 8364, i32 65533, i32 8218, i32 402, i32 8222, i32 8230, i32 8224, i32 8225, i32 710, i32 8240, i32 352, i32 8249, i32 338, i32 65533, i32 381, i32 65533, i32 65533, i32 8216, i32 8217, i32 8220, i32 8221, i32 8226, i32 8211, i32 8212, i32 732, i32 8482, i32 353, i32 8250, i32 339, i32 65533, i32 382, i32 376, i32 160, i32 161, i32 162, i32 163, i32 164, i32 165, i32 166, i32 167, i32 168, i32 169, i32 170, i32 171, i32 172, i32 173, i32 174, i32 175, i32 176, i32 177, i32 178, i32 179, i32 180, i32 181, i32 182, i32 183, i32 184, i32 185, i32 186, i32 187, i32 188, i32 189, i32 190, i32 191, i32 192, i32 193, i32 194, i32 195, i32 196, i32 197, i32 198, i32 199, i32 200, i32 201, i32 202, i32 203, i32 204, i32 205, i32 206, i32 207, i32 208, i32 209, i32 210, i32 211, i32 212, i32 213, i32 214, i32 215, i32 216, i32 217, i32 218, i32 219, i32 220, i32 221, i32 222, i32 223, i32 224, i32 225, i32 226, i32 227, i32 228, i32 229, i32 230, i32 231, i32 232, i32 233, i32 234, i32 235, i32 236, i32 237, i32 238, i32 239, i32 240, i32 241, i32 242, i32 243, i32 244, i32 245, i32 246, i32 247, i32 248, i32 249, i32 250, i32 251, i32 252, i32 253, i32 254, i32 255], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@tigr_upscale_gl_vs = constant [259 x i8] c"#version 330 core\0D\0A\0D\0Alayout (location = 0) in vec2 pos_in;\0D\0Alayout (location = 1) in vec2 uv_in;\0D\0A\0D\0Aout vec2 uv;\0D\0A\0D\0Auniform mat4 model;\0D\0Auniform mat4 projection;\0D\0A\0D\0Avoid main()\0D\0A{\0D\0A\09uv = uv_in;\0D\0A\09gl_Position = projection * model * vec4(pos_in, 0.0, 1.0);\0D\0A}\0D\0A", align 16
@tigr_upscale_gl_vs_size = global i32 259, align 4
@tigr_upscale_gl_fs = constant [444 x i8] c"#version 330 core\0D\0A\0D\0Ain vec2 uv;\0D\0A\0D\0Aout vec4 color;\0D\0A\0D\0Auniform sampler2D image;\0D\0Auniform vec4 parameters;\0D\0A\0D\0Avoid main()\0D\0A{\0D\0A\09vec2 tex_size = textureSize(image, 0);\0D\0A\09vec2 uv_blur = mix(floor(uv * tex_size) + 0.5, uv * tex_size, parameters.xy) / tex_size;\0D\0A\09vec4 c = texture(image, uv_blur);\0D\0A\09c.rgb *= mix(0.5, 1.0 - fract(uv.y * tex_size.y), parameters.z) * 2.0; //scanline\0D\0A\09c = mix(vec4(0.5), c, parameters.w); //contrast \0D\0A\09color = c;\0D\0A}\0D\0A", align 16
@tigr_upscale_gl_fs_size = global i32 444, align 4
@__func__.tigrInternal = private unnamed_addr constant [13 x i8] c"tigrInternal\00", align 1
@.str.4 = private unnamed_addr constant [7 x i8] c"tigr.c\00", align 1
@.str.5 = private unnamed_addr constant [12 x i8] c"bmp->handle\00", align 1
@terminated = global i8 0, align 1
@.str.6 = private unnamed_addr constant [7 x i8] c"closed\00", align 1
@.str.7 = private unnamed_addr constant [11 x i8] c"tigrHandle\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"delegate\00", align 1
@autoreleasePool = internal global %struct.objc_object* null, align 8
@.str.9 = private unnamed_addr constant [6 x i8] c"drain\00", align 1
@tigrOSXInited = internal global i8 0, align 1
@.str.10 = private unnamed_addr constant [18 x i8] c"NSAutoreleasePool\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"alloc\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@.str.13 = private unnamed_addr constant [14 x i8] c"NSApplication\00", align 1
@.str.14 = private unnamed_addr constant [18 x i8] c"sharedApplication\00", align 1
@NSApp = external global %struct.objc_object*, align 8
@.str.15 = private unnamed_addr constant [21 x i8] c"setActivationPolicy:\00", align 1
@.str.16 = private unnamed_addr constant [9 x i8] c"NSObject\00", align 1
@.str.17 = private unnamed_addr constant [12 x i8] c"AppDelegate\00", align 1
@.str.18 = private unnamed_addr constant [22 x i8] c"NSApplicationDelegate\00", align 1
@__func__.tigrInitOSX = private unnamed_addr constant [12 x i8] c"tigrInitOSX\00", align 1
@.str.19 = private unnamed_addr constant [16 x i8] c"resultAddProtoc\00", align 1
@.str.20 = private unnamed_addr constant [28 x i8] c"applicationShouldTerminate:\00", align 1
@.str.21 = private unnamed_addr constant [5 x i8] c"L@:@\00", align 1
@.str.22 = private unnamed_addr constant [16 x i8] c"resultAddMethod\00", align 1
@.str.23 = private unnamed_addr constant [12 x i8] c"autorelease\00", align 1
@.str.24 = private unnamed_addr constant [13 x i8] c"setDelegate:\00", align 1
@.str.25 = private unnamed_addr constant [16 x i8] c"finishLaunching\00", align 1
@.str.26 = private unnamed_addr constant [7 x i8] c"NSMenu\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"NSMenuItem\00", align 1
@.str.28 = private unnamed_addr constant [9 x i8] c"addItem:\00", align 1
@.str.29 = private unnamed_addr constant [13 x i8] c"setMainMenu:\00", align 1
@.str.30 = private unnamed_addr constant [14 x i8] c"NSProcessInfo\00", align 1
@.str.31 = private unnamed_addr constant [12 x i8] c"processInfo\00", align 1
@.str.32 = private unnamed_addr constant [12 x i8] c"processName\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"NSString\00", align 1
@.str.34 = private unnamed_addr constant [22 x i8] c"stringWithUTF8String:\00", align 1
@.str.35 = private unnamed_addr constant [6 x i8] c"Quit \00", align 1
@.str.36 = private unnamed_addr constant [25 x i8] c"stringByAppendingString:\00", align 1
@.str.37 = private unnamed_addr constant [2 x i8] c"q\00", align 1
@.str.38 = private unnamed_addr constant [36 x i8] c"initWithTitle:action:keyEquivalent:\00", align 1
@.str.39 = private unnamed_addr constant [11 x i8] c"terminate:\00", align 1
@.str.40 = private unnamed_addr constant [12 x i8] c"setSubmenu:\00", align 1
@.str.41 = private unnamed_addr constant [6 x i8] c"Error\00", align 1
@.str.42 = private unnamed_addr constant [12 x i8] c"contentView\00", align 1
@.str.43 = private unnamed_addr constant [6 x i8] c"frame\00", align 1
@.str.44 = private unnamed_addr constant [22 x i8] c"convertRectToBacking:\00", align 1
@.str.45 = private unnamed_addr constant [9 x i8] c"NSWindow\00", align 1
@.str.46 = private unnamed_addr constant [45 x i8] c"initWithContentRect:styleMask:backing:defer:\00", align 1
@.str.47 = private unnamed_addr constant [23 x i8] c"setReleasedWhenClosed:\00", align 1
@.str.48 = private unnamed_addr constant [15 x i8] c"WindowDelegate\00", align 1
@.str.49 = private unnamed_addr constant [17 x i8] c"NSWindowDelegate\00", align 1
@__func__.tigrWindow = private unnamed_addr constant [11 x i8] c"tigrWindow\00", align 1
@.str.50 = private unnamed_addr constant [2 x i8] c"L\00", align 1
@.str.51 = private unnamed_addr constant [14 x i8] c"resultAddIvar\00", align 1
@.str.52 = private unnamed_addr constant [4 x i8] c"\CB\86v\00", align 1
@.str.53 = private unnamed_addr constant [17 x i8] c"windowWillClose:\00", align 1
@.str.54 = private unnamed_addr constant [5 x i8] c"v@:@\00", align 1
@.str.55 = private unnamed_addr constant [20 x i8] c"windowDidBecomeKey:\00", align 1
@.str.56 = private unnamed_addr constant [37 x i8] c"setWantsBestResolutionOpenGLSurface:\00", align 1
@__const.tigrWindow.point = private unnamed_addr constant %struct.CGPoint { double 2.000000e+01, double 2.000000e+01 }, align 8
@.str.57 = private unnamed_addr constant [25 x i8] c"cascadeTopLeftFromPoint:\00", align 1
@.str.58 = private unnamed_addr constant [10 x i8] c"setTitle:\00", align 1
@__const.tigrWindow.glAttributes = private unnamed_addr constant [9 x i32] [i32 8, i32 24, i32 11, i32 8, i32 5, i32 73, i32 99, i32 12800, i32 0], align 16
@.str.59 = private unnamed_addr constant [20 x i8] c"NSOpenGLPixelFormat\00", align 1
@.str.60 = private unnamed_addr constant [20 x i8] c"initWithAttributes:\00", align 1
@.str.61 = private unnamed_addr constant [16 x i8] c"NSOpenGLContext\00", align 1
@.str.62 = private unnamed_addr constant [29 x i8] c"initWithFormat:shareContext:\00", align 1
@.str.63 = private unnamed_addr constant [9 x i8] c"setView:\00", align 1
@.str.64 = private unnamed_addr constant [22 x i8] c"makeKeyAndOrderFront:\00", align 1
@.str.65 = private unnamed_addr constant [28 x i8] c"setAcceptsMouseMovedEvents:\00", align 1
@.str.66 = private unnamed_addr constant [8 x i8] c"NSColor\00", align 1
@.str.67 = private unnamed_addr constant [11 x i8] c"blackColor\00", align 1
@.str.68 = private unnamed_addr constant [20 x i8] c"setBackgroundColor:\00", align 1
@.str.69 = private unnamed_addr constant [27 x i8] c"activateIgnoringOtherApps:\00", align 1
@.str.70 = private unnamed_addr constant [19 x i8] c"makeCurrentContext\00", align 1
@.str.71 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.72 = private unnamed_addr constant [11 x i8] c"sendEvent:\00", align 1
@.str.73 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.74 = private unnamed_addr constant [13 x i8] c"buttonNumber\00", align 1
@.str.75 = private unnamed_addr constant [14 x i8] c"modifierFlags\00", align 1
@.str.76 = private unnamed_addr constant [11 x i8] c"characters\00", align 1
@.str.77 = private unnamed_addr constant [11 x i8] c"UTF8String\00", align 1
@.str.78 = private unnamed_addr constant [8 x i8] c"keyCode\00", align 1
@.str.79 = private unnamed_addr constant [10 x i8] c"keyWindow\00", align 1
@.str.80 = private unnamed_addr constant [7 x i8] c"NSDate\00", align 1
@.str.81 = private unnamed_addr constant [12 x i8] c"distantPast\00", align 1
@.str.82 = private unnamed_addr constant [48 x i8] c"nextEventMatchingMask:untilDate:inMode:dequeue:\00", align 1
@NSDefaultRunLoopMode = external constant %struct.objc_object*, align 8
@.str.83 = private unnamed_addr constant [14 x i8] c"updateWindows\00", align 1
@.str.84 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@.str.85 = private unnamed_addr constant [12 x i8] c"flushBuffer\00", align 1
@.str.86 = private unnamed_addr constant [34 x i8] c"mouseLocationOutsideOfEventStream\00", align 1
@__func__.tigrKeyDown = private unnamed_addr constant [12 x i8] c"tigrKeyDown\00", align 1
@.str.87 = private unnamed_addr constant [10 x i8] c"key < 256\00", align 1
@__func__.tigrKeyHeld = private unnamed_addr constant [12 x i8] c"tigrKeyHeld\00", align 1
@tigrTime.time = internal global i64 0, align 8
@tigrTime.timebaseInfo = internal global %struct.mach_timebase_info zeroinitializer, align 4
@.str.88 = private unnamed_addr constant [35 x i8] c"got gl error %x when was doing %s\0A\00", align 1
@.str.89 = private unnamed_addr constant [27 x i8] c"shader compile error : %s\0A\00", align 1
@.str.90 = private unnamed_addr constant [24 x i8] c"shader link error : %s\0A\00", align 1
@__const.tigrGAPICreate.vertices = private unnamed_addr constant [24 x float] [float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00], align 16
@.str.91 = private unnamed_addr constant [11 x i8] c"projection\00", align 1
@.str.92 = private unnamed_addr constant [6 x i8] c"model\00", align 1
@.str.93 = private unnamed_addr constant [11 x i8] c"parameters\00", align 1
@.str.94 = private unnamed_addr constant [15 x i8] c"initialization\00", align 1
@.str.95 = private unnamed_addr constant [8 x i8] c"destroy\00", align 1
@__func__.tigrGAPIDraw = private unnamed_addr constant [13 x i8] c"tigrGAPIDraw\00", align 1
@.str.96 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@__func__.tigrGAPIPresent = private unnamed_addr constant [16 x i8] c"tigrGAPIPresent\00", align 1
@.str.97 = private unnamed_addr constant [8 x i8] c"present\00", align 1
@.str.98 = private unnamed_addr constant [9 x i8] c"\89PNG\0D\0A\1A\0A\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"IHDR\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"IDAT\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"PLTE\00", align 1
@crctable = internal constant [16 x i32] [i32 0, i32 498536548, i32 997073096, i32 651767980, i32 1994146192, i32 1802195444, i32 1303535960, i32 1342533948, i32 -306674912, i32 -267414716, i32 -690576408, i32 -882789492, i32 -1687895376, i32 -2032938284, i32 -1609899400, i32 -1111625188], align 16
@reverseTable = internal constant [256 x i8] c"\00\80@\C0 \A0`\E0\10\90P\D00\B0p\F0\08\88H\C8(\A8h\E8\18\98X\D88\B8x\F8\04\84D\C4$\A4d\E4\14\94T\D44\B4t\F4\0C\8CL\CC,\ACl\EC\1C\9C\5C\DC<\BC|\FC\02\82B\C2\22\A2b\E2\12\92R\D22\B2r\F2\0A\8AJ\CA*\AAj\EA\1A\9AZ\DA:\BAz\FA\06\86F\C6&\A6f\E6\16\96V\D66\B6v\F6\0E\8EN\CE.\AEn\EE\1E\9E^\DE>\BE~\FE\01\81A\C1!\A1a\E1\11\91Q\D11\B1q\F1\09\89I\C9)\A9i\E9\19\99Y\D99\B9y\F9\05\85E\C5%\A5e\E5\15\95U\D55\B5u\F5\0D\8DM\CD-\ADm\ED\1D\9D]\DD=\BD}\FD\03\83C\C3#\A3c\E3\13\93S\D33\B3s\F3\0B\8BK\CB+\ABk\EB\1B\9B[\DB;\BB{\FB\07\87G\C7'\A7g\E7\17\97W\D77\B7w\F7\0F\8FO\CF/\AFo\EF\1F\9F_\DF?\BF\7F\FF", align 16
@lenBits = internal global [31 x i8] c"\00\00\00\00\00\00\00\00\01\01\01\01\02\02\02\02\03\03\03\03\04\04\04\04\05\05\05\05\00\00\00", align 16
@lenBase = internal global [31 x i32] [i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 13, i32 15, i32 17, i32 19, i32 23, i32 27, i32 31, i32 35, i32 43, i32 51, i32 59, i32 67, i32 83, i32 99, i32 115, i32 131, i32 163, i32 195, i32 227, i32 258, i32 0, i32 0], align 16
@distBits = internal global [32 x i8] c"\00\00\00\00\01\01\02\02\03\03\04\04\05\05\06\06\07\07\08\08\09\09\0A\0A\0B\0B\0C\0C\0D\0D\00\00", align 16
@distBase = internal global [32 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 7, i32 9, i32 13, i32 17, i32 25, i32 33, i32 49, i32 65, i32 97, i32 129, i32 193, i32 257, i32 385, i32 513, i32 769, i32 1025, i32 1537, i32 2049, i32 3073, i32 4097, i32 6145, i32 8193, i32 12289, i32 16385, i32 24577, i32 0, i32 0], align 16
@order = internal global [19 x i8] c"\10\11\12\00\08\07\09\06\0A\05\0B\04\0C\03\0D\02\0E\01\0F", align 16

; Function Attrs: nounwind ssp uwtable
define %struct.Tigr* @tigrBitmap2(i32 %w, i32 %h, i32 %extra) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %extra.addr = alloca i32, align 4
  %tigr = alloca %struct.Tigr*, align 8
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  store i32 %extra, i32* %extra.addr, align 4, !tbaa !4
  %0 = bitcast %struct.Tigr** %tigr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i32, i32* %extra.addr, align 4, !tbaa !4
  %conv = sext i32 %1 to i64
  %add = add i64 24, %conv
  %call = call i8* @calloc(i64 1, i64 %add) #15
  %2 = bitcast i8* %call to %struct.Tigr*
  store %struct.Tigr* %2, %struct.Tigr** %tigr, align 8, !tbaa !8
  %3 = load i32, i32* %w.addr, align 4, !tbaa !4
  %4 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8, !tbaa !8
  %w1 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 0
  store i32 %3, i32* %w1, align 8, !tbaa !10
  %5 = load i32, i32* %h.addr, align 4, !tbaa !4
  %6 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8, !tbaa !8
  %h2 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 1
  store i32 %5, i32* %h2, align 4, !tbaa !12
  %7 = load i32, i32* %w.addr, align 4, !tbaa !4
  %8 = load i32, i32* %h.addr, align 4, !tbaa !4
  %mul = mul nsw i32 %7, %8
  %conv3 = sext i32 %mul to i64
  %call4 = call i8* @calloc(i64 %conv3, i64 4) #15
  %9 = bitcast i8* %call4 to %struct.TPixel*
  %10 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %10, i32 0, i32 2
  store %struct.TPixel* %9, %struct.TPixel** %pix, align 8, !tbaa !13
  %11 = load %struct.Tigr*, %struct.Tigr** %tigr, align 8, !tbaa !8
  %12 = bitcast %struct.Tigr** %tigr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #11
  ret %struct.Tigr* %11
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: allocsize(0,1)
declare i8* @calloc(i64, i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind ssp uwtable
define %struct.Tigr* @tigrBitmap(i32 %w, i32 %h) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %0 = load i32, i32* %w.addr, align 4, !tbaa !4
  %1 = load i32, i32* %h.addr, align 4, !tbaa !4
  %call = call %struct.Tigr* @tigrBitmap2(i32 %0, i32 %1, i32 0)
  ret %struct.Tigr* %call
}

; Function Attrs: nounwind ssp uwtable
define void @tigrResize(%struct.Tigr* %bmp, i32 %w, i32 %h) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %y = alloca i32, align 4
  %cw = alloca i32, align 4
  %ch = alloca i32, align 4
  %newpix = alloca %struct.TPixel*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %0 = bitcast i32* %y to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %cw to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %ch to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = bitcast %struct.TPixel** %newpix to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i32, i32* %w.addr, align 4, !tbaa !4
  %5 = load i32, i32* %h.addr, align 4, !tbaa !4
  %mul = mul nsw i32 %4, %5
  %conv = sext i32 %mul to i64
  %call = call i8* @calloc(i64 %conv, i64 4) #15
  %6 = bitcast i8* %call to %struct.TPixel*
  store %struct.TPixel* %6, %struct.TPixel** %newpix, align 8, !tbaa !8
  %7 = load i32, i32* %w.addr, align 4, !tbaa !4
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w1 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %8, i32 0, i32 0
  %9 = load i32, i32* %w1, align 8, !tbaa !10
  %cmp = icmp slt i32 %7, %9
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load i32, i32* %w.addr, align 4, !tbaa !4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %11 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w3 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %11, i32 0, i32 0
  %12 = load i32, i32* %w3, align 8, !tbaa !10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %12, %cond.false ]
  store i32 %cond, i32* %cw, align 4, !tbaa !4
  %13 = load i32, i32* %h.addr, align 4, !tbaa !4
  %14 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h4 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %14, i32 0, i32 1
  %15 = load i32, i32* %h4, align 4, !tbaa !12
  %cmp5 = icmp slt i32 %13, %15
  br i1 %cmp5, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %16 = load i32, i32* %h.addr, align 4, !tbaa !4
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %17 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h9 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %17, i32 0, i32 1
  %18 = load i32, i32* %h9, align 4, !tbaa !12
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true7
  %cond11 = phi i32 [ %16, %cond.true7 ], [ %18, %cond.false8 ]
  store i32 %cond11, i32* %ch, align 4, !tbaa !4
  store i32 0, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end10
  %19 = load i32, i32* %y, align 4, !tbaa !4
  %20 = load i32, i32* %ch, align 4, !tbaa !4
  %cmp12 = icmp slt i32 %19, %20
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load %struct.TPixel*, %struct.TPixel** %newpix, align 8, !tbaa !8
  %22 = load i32, i32* %y, align 4, !tbaa !4
  %23 = load i32, i32* %w.addr, align 4, !tbaa !4
  %mul14 = mul nsw i32 %22, %23
  %idx.ext = sext i32 %mul14 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %21, i64 %idx.ext
  %24 = bitcast %struct.TPixel* %add.ptr to i8*
  %25 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %25, i32 0, i32 2
  %26 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %27 = load i32, i32* %y, align 4, !tbaa !4
  %28 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w15 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %28, i32 0, i32 0
  %29 = load i32, i32* %w15, align 8, !tbaa !10
  %mul16 = mul nsw i32 %27, %29
  %idx.ext17 = sext i32 %mul16 to i64
  %add.ptr18 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %26, i64 %idx.ext17
  %30 = bitcast %struct.TPixel* %add.ptr18 to i8*
  %31 = load i32, i32* %cw, align 4, !tbaa !4
  %conv19 = sext i32 %31 to i64
  %mul20 = mul i64 %conv19, 4
  %32 = load %struct.TPixel*, %struct.TPixel** %newpix, align 8, !tbaa !8
  %33 = load i32, i32* %y, align 4, !tbaa !4
  %34 = load i32, i32* %w.addr, align 4, !tbaa !4
  %mul21 = mul nsw i32 %33, %34
  %idx.ext22 = sext i32 %mul21 to i64
  %add.ptr23 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %32, i64 %idx.ext22
  %35 = bitcast %struct.TPixel* %add.ptr23 to i8*
  %36 = call i64 @llvm.objectsize.i64.p0i8(i8* %35, i1 false, i1 true)
  %call24 = call i8* @__memcpy_chk(i8* %24, i8* %30, i64 %mul20, i64 %36) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %37 = load i32, i32* %y, align 4, !tbaa !4
  %inc = add nsw i32 %37, 1
  store i32 %inc, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %38 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix25 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %38, i32 0, i32 2
  %39 = load %struct.TPixel*, %struct.TPixel** %pix25, align 8, !tbaa !13
  %40 = bitcast %struct.TPixel* %39 to i8*
  call void @free(i8* %40)
  %41 = load %struct.TPixel*, %struct.TPixel** %newpix, align 8, !tbaa !8
  %42 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix26 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %42, i32 0, i32 2
  store %struct.TPixel* %41, %struct.TPixel** %pix26, align 8, !tbaa !13
  %43 = load i32, i32* %w.addr, align 4, !tbaa !4
  %44 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w27 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %44, i32 0, i32 0
  store i32 %43, i32* %w27, align 8, !tbaa !10
  %45 = load i32, i32* %h.addr, align 4, !tbaa !4
  %46 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h28 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %46, i32 0, i32 1
  store i32 %45, i32* %h28, align 4, !tbaa !12
  %47 = bitcast %struct.TPixel** %newpix to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #11
  %48 = bitcast i32* %ch to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %48) #11
  %49 = bitcast i32* %cw to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %49) #11
  %50 = bitcast i32* %y to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %50) #11
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #3

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #4

declare void @free(i8*) #5

; Function Attrs: nounwind ssp uwtable
define i32 @tigrCalcScale(i32 %bmpW, i32 %bmpH, i32 %areaW, i32 %areaH) #0 {
entry:
  %bmpW.addr = alloca i32, align 4
  %bmpH.addr = alloca i32, align 4
  %areaW.addr = alloca i32, align 4
  %areaH.addr = alloca i32, align 4
  %scale = alloca i32, align 4
  store i32 %bmpW, i32* %bmpW.addr, align 4, !tbaa !4
  store i32 %bmpH, i32* %bmpH.addr, align 4, !tbaa !4
  store i32 %areaW, i32* %areaW.addr, align 4, !tbaa !4
  store i32 %areaH, i32* %areaH.addr, align 4, !tbaa !4
  %0 = bitcast i32* %scale to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  store i32 0, i32* %scale, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %1 = load i32, i32* %scale, align 4, !tbaa !4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %scale, align 4, !tbaa !4
  %2 = load i32, i32* %bmpW.addr, align 4, !tbaa !4
  %3 = load i32, i32* %scale, align 4, !tbaa !4
  %mul = mul nsw i32 %2, %3
  %4 = load i32, i32* %areaW.addr, align 4, !tbaa !4
  %cmp = icmp sgt i32 %mul, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %5 = load i32, i32* %bmpH.addr, align 4, !tbaa !4
  %6 = load i32, i32* %scale, align 4, !tbaa !4
  %mul1 = mul nsw i32 %5, %6
  %7 = load i32, i32* %areaH.addr, align 4, !tbaa !4
  %cmp2 = icmp sgt i32 %mul1, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %for.cond
  %8 = load i32, i32* %scale, align 4, !tbaa !4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %scale, align 4, !tbaa !4
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false
  br label %for.cond

for.end:                                          ; preds = %if.then
  %9 = load i32, i32* %scale, align 4, !tbaa !4
  %cmp3 = icmp sgt i32 %9, 1
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %10 = load i32, i32* %scale, align 4, !tbaa !4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ 1, %cond.false ]
  %11 = bitcast i32* %scale to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #11
  ret i32 %cond
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrEnforceScale(i32 %scale, i32 %flags) #0 {
entry:
  %scale.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %scale, i32* %scale.addr, align 4, !tbaa !4
  store i32 %flags, i32* %flags.addr, align 4, !tbaa !4
  %0 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %and = and i32 %0, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %1, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 4, i32* %scale.addr, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %and1 = and i32 %2, 4
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end6

land.lhs.true3:                                   ; preds = %if.end
  %3 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %cmp4 = icmp slt i32 %3, 3
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true3
  store i32 3, i32* %scale.addr, align 4, !tbaa !4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true3, %if.end
  %4 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %and7 = and i32 %4, 2
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.end12

land.lhs.true9:                                   ; preds = %if.end6
  %5 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %cmp10 = icmp slt i32 %5, 2
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true9
  store i32 2, i32* %scale.addr, align 4, !tbaa !4
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %land.lhs.true9, %if.end6
  %6 = load i32, i32* %scale.addr, align 4, !tbaa !4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define void @tigrPosition(%struct.Tigr* %bmp, i32 %scale, i32 %windowW, i32 %windowH, i32* %out) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %scale.addr = alloca i32, align 4
  %windowW.addr = alloca i32, align 4
  %windowH.addr = alloca i32, align 4
  %out.addr = alloca i32*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %scale, i32* %scale.addr, align 4, !tbaa !4
  store i32 %windowW, i32* %windowW.addr, align 4, !tbaa !4
  store i32 %windowH, i32* %windowH.addr, align 4, !tbaa !4
  store i32* %out, i32** %out.addr, align 8, !tbaa !8
  %0 = load i32, i32* %windowW.addr, align 4, !tbaa !4
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 0
  %2 = load i32, i32* %w, align 8, !tbaa !10
  %3 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %mul = mul nsw i32 %2, %3
  %sub = sub nsw i32 %0, %mul
  %div = sdiv i32 %sub, 2
  %4 = load i32*, i32** %out.addr, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 0
  store i32 %div, i32* %arrayidx, align 4, !tbaa !4
  %5 = load i32, i32* %windowH.addr, align 4, !tbaa !4
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 1
  %7 = load i32, i32* %h, align 4, !tbaa !12
  %8 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %mul1 = mul nsw i32 %7, %8
  %sub2 = sub nsw i32 %5, %mul1
  %div3 = sdiv i32 %sub2, 2
  %9 = load i32*, i32** %out.addr, align 8, !tbaa !8
  %arrayidx4 = getelementptr inbounds i32, i32* %9, i64 1
  store i32 %div3, i32* %arrayidx4, align 4, !tbaa !4
  %10 = load i32*, i32** %out.addr, align 8, !tbaa !8
  %arrayidx5 = getelementptr inbounds i32, i32* %10, i64 0
  %11 = load i32, i32* %arrayidx5, align 4, !tbaa !4
  %12 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w6 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %12, i32 0, i32 0
  %13 = load i32, i32* %w6, align 8, !tbaa !10
  %14 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %mul7 = mul nsw i32 %13, %14
  %add = add nsw i32 %11, %mul7
  %15 = load i32*, i32** %out.addr, align 8, !tbaa !8
  %arrayidx8 = getelementptr inbounds i32, i32* %15, i64 2
  store i32 %add, i32* %arrayidx8, align 4, !tbaa !4
  %16 = load i32*, i32** %out.addr, align 8, !tbaa !8
  %arrayidx9 = getelementptr inbounds i32, i32* %16, i64 1
  %17 = load i32, i32* %arrayidx9, align 4, !tbaa !4
  %18 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h10 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %18, i32 0, i32 1
  %19 = load i32, i32* %h10, align 4, !tbaa !12
  %20 = load i32, i32* %scale.addr, align 4, !tbaa !4
  %mul11 = mul nsw i32 %19, %20
  %add12 = add nsw i32 %17, %mul11
  %21 = load i32*, i32** %out.addr, align 8, !tbaa !8
  %arrayidx13 = getelementptr inbounds i32, i32* %21, i64 3
  store i32 %add12, i32* %arrayidx13, align 4, !tbaa !4
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrClear(%struct.Tigr* %bmp, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %count = alloca i32, align 4
  %n = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %1 = bitcast i32* %count to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %2, i32 0, i32 0
  %3 = load i32, i32* %w, align 8, !tbaa !10
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 1
  %5 = load i32, i32* %h, align 4, !tbaa !12
  %mul = mul nsw i32 %3, %5
  store i32 %mul, i32* %count, align 4, !tbaa !4
  %6 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %n, align 4, !tbaa !4
  %8 = load i32, i32* %count, align 4, !tbaa !4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %9, i32 0, i32 2
  %10 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %11 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %10, i64 %idxprom
  %12 = bitcast %struct.TPixel* %arrayidx to i8*
  %13 = bitcast %struct.TPixel* %color to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %12, i8* align 1 %13, i64 4, i1 false), !tbaa.struct !14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %n, align 4, !tbaa !4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #11
  %16 = bitcast i32* %count to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #11
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #1

; Function Attrs: nounwind ssp uwtable
define void @tigrFill(%struct.Tigr* %bmp, i32 %x, i32 %y, i32 %w, i32 %h, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %td = alloca %struct.TPixel*, align 8
  %dt = alloca i32, align 4
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x, i32* %x.addr, align 4, !tbaa !4
  store i32 %y, i32* %y.addr, align 4, !tbaa !4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %1 = bitcast %struct.TPixel** %td to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast i32* %dt to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load i32, i32* %x.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %x.addr, align 4, !tbaa !4
  %6 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add = add nsw i32 %6, %5
  store i32 %add, i32* %w.addr, align 4, !tbaa !4
  store i32 0, i32* %x.addr, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32, i32* %y.addr, align 4, !tbaa !4
  %cmp1 = icmp slt i32 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %8 = load i32, i32* %y.addr, align 4, !tbaa !4
  %9 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add3 = add nsw i32 %9, %8
  store i32 %add3, i32* %h.addr, align 4, !tbaa !4
  store i32 0, i32* %y.addr, align 4, !tbaa !4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load i32, i32* %x.addr, align 4, !tbaa !4
  %11 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add5 = add nsw i32 %10, %11
  %12 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w6 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %12, i32 0, i32 0
  %13 = load i32, i32* %w6, align 8, !tbaa !10
  %cmp7 = icmp sgt i32 %add5, %13
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end4
  %14 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w9 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %14, i32 0, i32 0
  %15 = load i32, i32* %w9, align 8, !tbaa !10
  %16 = load i32, i32* %x.addr, align 4, !tbaa !4
  %sub = sub nsw i32 %15, %16
  store i32 %sub, i32* %w.addr, align 4, !tbaa !4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end4
  %17 = load i32, i32* %y.addr, align 4, !tbaa !4
  %18 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add11 = add nsw i32 %17, %18
  %19 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h12 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %19, i32 0, i32 1
  %20 = load i32, i32* %h12, align 4, !tbaa !12
  %cmp13 = icmp sgt i32 %add11, %20
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end10
  %21 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h15 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %21, i32 0, i32 1
  %22 = load i32, i32* %h15, align 4, !tbaa !12
  %23 = load i32, i32* %y.addr, align 4, !tbaa !4
  %sub16 = sub nsw i32 %22, %23
  store i32 %sub16, i32* %h.addr, align 4, !tbaa !4
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  %24 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp18 = icmp sle i32 %24, 0
  br i1 %cmp18, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end17
  %25 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp19 = icmp sle i32 %25, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false, %if.end17
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end21:                                         ; preds = %lor.lhs.false
  %26 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %26, i32 0, i32 2
  %27 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %28 = load i32, i32* %y.addr, align 4, !tbaa !4
  %29 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w22 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %29, i32 0, i32 0
  %30 = load i32, i32* %w22, align 8, !tbaa !10
  %mul = mul nsw i32 %28, %30
  %31 = load i32, i32* %x.addr, align 4, !tbaa !4
  %add23 = add nsw i32 %mul, %31
  %idxprom = sext i32 %add23 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %27, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %td, align 8, !tbaa !8
  %32 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w24 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %32, i32 0, i32 0
  %33 = load i32, i32* %w24, align 8, !tbaa !10
  store i32 %33, i32* %dt, align 4, !tbaa !4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end21
  store i32 0, i32* %i, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %34 = load i32, i32* %i, align 4, !tbaa !4
  %35 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp25 = icmp slt i32 %34, %35
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %37 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom26 = sext i32 %37 to i64
  %arrayidx27 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %36, i64 %idxprom26
  %38 = bitcast %struct.TPixel* %arrayidx27 to i8*
  %39 = bitcast %struct.TPixel* %color to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %38, i8* align 1 %39, i64 4, i1 false), !tbaa.struct !14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %40 = load i32, i32* %i, align 4, !tbaa !4
  %inc = add nsw i32 %40, 1
  store i32 %inc, i32* %i, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %41 = load i32, i32* %dt, align 4, !tbaa !4
  %42 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %idx.ext = sext i32 %41 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %42, i64 %idx.ext
  store %struct.TPixel* %add.ptr, %struct.TPixel** %td, align 8, !tbaa !8
  br label %do.cond

do.cond:                                          ; preds = %for.end
  %43 = load i32, i32* %h.addr, align 4, !tbaa !4
  %dec = add nsw i32 %43, -1
  store i32 %dec, i32* %h.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then20
  %44 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %44) #11
  %45 = bitcast i32* %dt to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %45) #11
  %46 = bitcast %struct.TPixel** %td to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define void @tigrLine(%struct.Tigr* %bmp, i32 %x0, i32 %y0, i32 %x1, i32 %y1, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x0.addr = alloca i32, align 4
  %y0.addr = alloca i32, align 4
  %x1.addr = alloca i32, align 4
  %y1.addr = alloca i32, align 4
  %sx = alloca i32, align 4
  %sy = alloca i32, align 4
  %dx = alloca i32, align 4
  %dy = alloca i32, align 4
  %err = alloca i32, align 4
  %e2 = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x0, i32* %x0.addr, align 4, !tbaa !4
  store i32 %y0, i32* %y0.addr, align 4, !tbaa !4
  store i32 %x1, i32* %x1.addr, align 4, !tbaa !4
  store i32 %y1, i32* %y1.addr, align 4, !tbaa !4
  %1 = bitcast i32* %sx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %sy to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = bitcast i32* %dx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = bitcast i32* %dy to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  %6 = bitcast i32* %e2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %7 = load i32, i32* %x1.addr, align 4, !tbaa !4
  %8 = load i32, i32* %x0.addr, align 4, !tbaa !4
  %sub = sub nsw i32 %7, %8
  %call = call i32 @abs(i32 %sub) #12
  store i32 %call, i32* %dx, align 4, !tbaa !4
  %9 = load i32, i32* %y1.addr, align 4, !tbaa !4
  %10 = load i32, i32* %y0.addr, align 4, !tbaa !4
  %sub1 = sub nsw i32 %9, %10
  %call2 = call i32 @abs(i32 %sub1) #12
  store i32 %call2, i32* %dy, align 4, !tbaa !4
  %11 = load i32, i32* %x0.addr, align 4, !tbaa !4
  %12 = load i32, i32* %x1.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %sx, align 4, !tbaa !4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 -1, i32* %sx, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load i32, i32* %y0.addr, align 4, !tbaa !4
  %14 = load i32, i32* %y1.addr, align 4, !tbaa !4
  %cmp3 = icmp slt i32 %13, %14
  br i1 %cmp3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  store i32 1, i32* %sy, align 4, !tbaa !4
  br label %if.end6

if.else5:                                         ; preds = %if.end
  store i32 -1, i32* %sy, align 4, !tbaa !4
  br label %if.end6

if.end6:                                          ; preds = %if.else5, %if.then4
  %15 = load i32, i32* %dx, align 4, !tbaa !4
  %16 = load i32, i32* %dy, align 4, !tbaa !4
  %sub7 = sub nsw i32 %15, %16
  store i32 %sub7, i32* %err, align 4, !tbaa !4
  %17 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %18 = load i32, i32* %x0.addr, align 4, !tbaa !4
  %19 = load i32, i32* %y0.addr, align 4, !tbaa !4
  %20 = bitcast %struct.TPixel* %color to i32*
  %21 = load i32, i32* %20, align 1
  call void @tigrPlot(%struct.Tigr* %17, i32 %18, i32 %19, i32 %21)
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.end6
  %22 = load i32, i32* %x0.addr, align 4, !tbaa !4
  %23 = load i32, i32* %x1.addr, align 4, !tbaa !4
  %cmp8 = icmp ne i32 %22, %23
  br i1 %cmp8, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %24 = load i32, i32* %y0.addr, align 4, !tbaa !4
  %25 = load i32, i32* %y1.addr, align 4, !tbaa !4
  %cmp9 = icmp ne i32 %24, %25
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond
  %26 = phi i1 [ true, %while.cond ], [ %cmp9, %lor.rhs ]
  br i1 %26, label %while.body, label %while.end

while.body:                                       ; preds = %lor.end
  %27 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %28 = load i32, i32* %x0.addr, align 4, !tbaa !4
  %29 = load i32, i32* %y0.addr, align 4, !tbaa !4
  %30 = bitcast %struct.TPixel* %color to i32*
  %31 = load i32, i32* %30, align 1
  call void @tigrPlot(%struct.Tigr* %27, i32 %28, i32 %29, i32 %31)
  %32 = load i32, i32* %err, align 4, !tbaa !4
  %mul = mul nsw i32 2, %32
  store i32 %mul, i32* %e2, align 4, !tbaa !4
  %33 = load i32, i32* %e2, align 4, !tbaa !4
  %34 = load i32, i32* %dy, align 4, !tbaa !4
  %sub10 = sub nsw i32 0, %34
  %cmp11 = icmp sgt i32 %33, %sub10
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %while.body
  %35 = load i32, i32* %dy, align 4, !tbaa !4
  %36 = load i32, i32* %err, align 4, !tbaa !4
  %sub13 = sub nsw i32 %36, %35
  store i32 %sub13, i32* %err, align 4, !tbaa !4
  %37 = load i32, i32* %sx, align 4, !tbaa !4
  %38 = load i32, i32* %x0.addr, align 4, !tbaa !4
  %add = add nsw i32 %38, %37
  store i32 %add, i32* %x0.addr, align 4, !tbaa !4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %while.body
  %39 = load i32, i32* %e2, align 4, !tbaa !4
  %40 = load i32, i32* %dx, align 4, !tbaa !4
  %cmp15 = icmp slt i32 %39, %40
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end14
  %41 = load i32, i32* %dx, align 4, !tbaa !4
  %42 = load i32, i32* %err, align 4, !tbaa !4
  %add17 = add nsw i32 %42, %41
  store i32 %add17, i32* %err, align 4, !tbaa !4
  %43 = load i32, i32* %sy, align 4, !tbaa !4
  %44 = load i32, i32* %y0.addr, align 4, !tbaa !4
  %add18 = add nsw i32 %44, %43
  store i32 %add18, i32* %y0.addr, align 4, !tbaa !4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end14
  br label %while.cond

while.end:                                        ; preds = %lor.end
  %45 = bitcast i32* %e2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %45) #11
  %46 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %46) #11
  %47 = bitcast i32* %dy to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %47) #11
  %48 = bitcast i32* %dx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %48) #11
  %49 = bitcast i32* %sy to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %49) #11
  %50 = bitcast i32* %sx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %50) #11
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @abs(i32) #6

; Function Attrs: nounwind ssp uwtable
define void @tigrPlot(%struct.Tigr* %bmp, i32 %x, i32 %y, i32 %pix.coerce) #0 {
entry:
  %pix = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %xa = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %pix to i32*
  store i32 %pix.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x, i32* %x.addr, align 4, !tbaa !4
  store i32 %y, i32* %y.addr, align 4, !tbaa !4
  %1 = bitcast i32* %xa to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = bitcast i32* %a to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load i32, i32* %x.addr, align 4, !tbaa !4
  %cmp = icmp sge i32 %4, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32, i32* %y.addr, align 4, !tbaa !4
  %cmp1 = icmp sge i32 %5, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %6 = load i32, i32* %x.addr, align 4, !tbaa !4
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 0
  %8 = load i32, i32* %w, align 8, !tbaa !10
  %cmp3 = icmp slt i32 %6, %8
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %9 = load i32, i32* %y.addr, align 4, !tbaa !4
  %10 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %10, i32 0, i32 1
  %11 = load i32, i32* %h, align 4, !tbaa !12
  %cmp5 = icmp slt i32 %9, %11
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %a6 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %12 = load i8, i8* %a6, align 1, !tbaa !16
  %conv = zext i8 %12 to i32
  %a7 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %13 = load i8, i8* %a7, align 1, !tbaa !16
  %conv8 = zext i8 %13 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  %conv10 = zext i1 %cmp9 to i32
  %add = add nsw i32 %conv, %conv10
  store i32 %add, i32* %xa, align 4, !tbaa !4
  %14 = load i32, i32* %y.addr, align 4, !tbaa !4
  %15 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w11 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %15, i32 0, i32 0
  %16 = load i32, i32* %w11, align 8, !tbaa !10
  %mul = mul nsw i32 %14, %16
  %17 = load i32, i32* %x.addr, align 4, !tbaa !4
  %add12 = add nsw i32 %mul, %17
  store i32 %add12, i32* %i, align 4, !tbaa !4
  %18 = load i32, i32* %xa, align 4, !tbaa !4
  %a13 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %19 = load i8, i8* %a13, align 1, !tbaa !16
  %conv14 = zext i8 %19 to i32
  %a15 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %20 = load i8, i8* %a15, align 1, !tbaa !16
  %conv16 = zext i8 %20 to i32
  %cmp17 = icmp sgt i32 %conv16, 0
  %conv18 = zext i1 %cmp17 to i32
  %add19 = add nsw i32 %conv14, %conv18
  %mul20 = mul nsw i32 %18, %add19
  store i32 %mul20, i32* %a, align 4, !tbaa !4
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 2
  %21 = load i8, i8* %r, align 1, !tbaa !18
  %conv21 = zext i8 %21 to i32
  %22 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix22 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %22, i32 0, i32 2
  %23 = load %struct.TPixel*, %struct.TPixel** %pix22, align 8, !tbaa !13
  %24 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom = sext i32 %24 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %23, i64 %idxprom
  %r23 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx, i32 0, i32 2
  %25 = load i8, i8* %r23, align 1, !tbaa !18
  %conv24 = zext i8 %25 to i32
  %sub = sub nsw i32 %conv21, %conv24
  %26 = load i32, i32* %a, align 4, !tbaa !4
  %mul25 = mul nsw i32 %sub, %26
  %shr = ashr i32 %mul25, 16
  %conv26 = trunc i32 %shr to i8
  %conv27 = zext i8 %conv26 to i32
  %27 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix28 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %27, i32 0, i32 2
  %28 = load %struct.TPixel*, %struct.TPixel** %pix28, align 8, !tbaa !13
  %29 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom29 = sext i32 %29 to i64
  %arrayidx30 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %28, i64 %idxprom29
  %r31 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx30, i32 0, i32 2
  %30 = load i8, i8* %r31, align 1, !tbaa !18
  %conv32 = zext i8 %30 to i32
  %add33 = add nsw i32 %conv32, %conv27
  %conv34 = trunc i32 %add33 to i8
  store i8 %conv34, i8* %r31, align 1, !tbaa !18
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 1
  %31 = load i8, i8* %g, align 1, !tbaa !19
  %conv35 = zext i8 %31 to i32
  %32 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix36 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %32, i32 0, i32 2
  %33 = load %struct.TPixel*, %struct.TPixel** %pix36, align 8, !tbaa !13
  %34 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom37 = sext i32 %34 to i64
  %arrayidx38 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %33, i64 %idxprom37
  %g39 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx38, i32 0, i32 1
  %35 = load i8, i8* %g39, align 1, !tbaa !19
  %conv40 = zext i8 %35 to i32
  %sub41 = sub nsw i32 %conv35, %conv40
  %36 = load i32, i32* %a, align 4, !tbaa !4
  %mul42 = mul nsw i32 %sub41, %36
  %shr43 = ashr i32 %mul42, 16
  %conv44 = trunc i32 %shr43 to i8
  %conv45 = zext i8 %conv44 to i32
  %37 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix46 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %37, i32 0, i32 2
  %38 = load %struct.TPixel*, %struct.TPixel** %pix46, align 8, !tbaa !13
  %39 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom47 = sext i32 %39 to i64
  %arrayidx48 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %38, i64 %idxprom47
  %g49 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx48, i32 0, i32 1
  %40 = load i8, i8* %g49, align 1, !tbaa !19
  %conv50 = zext i8 %40 to i32
  %add51 = add nsw i32 %conv50, %conv45
  %conv52 = trunc i32 %add51 to i8
  store i8 %conv52, i8* %g49, align 1, !tbaa !19
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 0
  %41 = load i8, i8* %b, align 1, !tbaa !20
  %conv53 = zext i8 %41 to i32
  %42 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix54 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %42, i32 0, i32 2
  %43 = load %struct.TPixel*, %struct.TPixel** %pix54, align 8, !tbaa !13
  %44 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom55 = sext i32 %44 to i64
  %arrayidx56 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %43, i64 %idxprom55
  %b57 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx56, i32 0, i32 0
  %45 = load i8, i8* %b57, align 1, !tbaa !20
  %conv58 = zext i8 %45 to i32
  %sub59 = sub nsw i32 %conv53, %conv58
  %46 = load i32, i32* %a, align 4, !tbaa !4
  %mul60 = mul nsw i32 %sub59, %46
  %shr61 = ashr i32 %mul60, 16
  %conv62 = trunc i32 %shr61 to i8
  %conv63 = zext i8 %conv62 to i32
  %47 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix64 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %47, i32 0, i32 2
  %48 = load %struct.TPixel*, %struct.TPixel** %pix64, align 8, !tbaa !13
  %49 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom65 = sext i32 %49 to i64
  %arrayidx66 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %48, i64 %idxprom65
  %b67 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx66, i32 0, i32 0
  %50 = load i8, i8* %b67, align 1, !tbaa !20
  %conv68 = zext i8 %50 to i32
  %add69 = add nsw i32 %conv68, %conv63
  %conv70 = trunc i32 %add69 to i8
  store i8 %conv70, i8* %b67, align 1, !tbaa !20
  %a71 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %pix, i32 0, i32 3
  %51 = load i8, i8* %a71, align 1, !tbaa !16
  %conv72 = zext i8 %51 to i32
  %52 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix73 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %52, i32 0, i32 2
  %53 = load %struct.TPixel*, %struct.TPixel** %pix73, align 8, !tbaa !13
  %54 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom74 = sext i32 %54 to i64
  %arrayidx75 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %53, i64 %idxprom74
  %a76 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx75, i32 0, i32 3
  %55 = load i8, i8* %a76, align 1, !tbaa !16
  %conv77 = zext i8 %55 to i32
  %sub78 = sub nsw i32 %conv72, %conv77
  %56 = load i32, i32* %a, align 4, !tbaa !4
  %mul79 = mul nsw i32 %sub78, %56
  %shr80 = ashr i32 %mul79, 16
  %conv81 = trunc i32 %shr80 to i8
  %conv82 = zext i8 %conv81 to i32
  %57 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix83 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %57, i32 0, i32 2
  %58 = load %struct.TPixel*, %struct.TPixel** %pix83, align 8, !tbaa !13
  %59 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom84 = sext i32 %59 to i64
  %arrayidx85 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %58, i64 %idxprom84
  %a86 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx85, i32 0, i32 3
  %60 = load i8, i8* %a86, align 1, !tbaa !16
  %conv87 = zext i8 %60 to i32
  %add88 = add nsw i32 %conv87, %conv82
  %conv89 = trunc i32 %add88 to i8
  store i8 %conv89, i8* %a86, align 1, !tbaa !16
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %61 = bitcast i32* %a to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %61) #11
  %62 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %62) #11
  %63 = bitcast i32* %xa to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %63) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrRect(%struct.Tigr* %bmp, i32 %x, i32 %y, i32 %w, i32 %h, i32 %color.coerce) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x, i32* %x.addr, align 4, !tbaa !4
  store i32 %y, i32* %y.addr, align 4, !tbaa !4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %1 = bitcast i32* %x1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %y1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp = icmp sle i32 %3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp1 = icmp sle i32 %4, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %5 = load i32, i32* %x.addr, align 4, !tbaa !4
  %6 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add = add nsw i32 %5, %6
  %sub = sub nsw i32 %add, 1
  store i32 %sub, i32* %x1, align 4, !tbaa !4
  %7 = load i32, i32* %y.addr, align 4, !tbaa !4
  %8 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add2 = add nsw i32 %7, %8
  %sub3 = sub nsw i32 %add2, 1
  store i32 %sub3, i32* %y1, align 4, !tbaa !4
  %9 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %10 = load i32, i32* %x.addr, align 4, !tbaa !4
  %11 = load i32, i32* %y.addr, align 4, !tbaa !4
  %12 = load i32, i32* %x1, align 4, !tbaa !4
  %13 = load i32, i32* %y.addr, align 4, !tbaa !4
  %14 = bitcast %struct.TPixel* %color to i32*
  %15 = load i32, i32* %14, align 1
  call void @tigrLine(%struct.Tigr* %9, i32 %10, i32 %11, i32 %12, i32 %13, i32 %15)
  %16 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %17 = load i32, i32* %x1, align 4, !tbaa !4
  %18 = load i32, i32* %y.addr, align 4, !tbaa !4
  %19 = load i32, i32* %x1, align 4, !tbaa !4
  %20 = load i32, i32* %y1, align 4, !tbaa !4
  %21 = bitcast %struct.TPixel* %color to i32*
  %22 = load i32, i32* %21, align 1
  call void @tigrLine(%struct.Tigr* %16, i32 %17, i32 %18, i32 %19, i32 %20, i32 %22)
  %23 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %24 = load i32, i32* %x1, align 4, !tbaa !4
  %25 = load i32, i32* %y1, align 4, !tbaa !4
  %26 = load i32, i32* %x.addr, align 4, !tbaa !4
  %27 = load i32, i32* %y1, align 4, !tbaa !4
  %28 = bitcast %struct.TPixel* %color to i32*
  %29 = load i32, i32* %28, align 1
  call void @tigrLine(%struct.Tigr* %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %29)
  %30 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %31 = load i32, i32* %x.addr, align 4, !tbaa !4
  %32 = load i32, i32* %y1, align 4, !tbaa !4
  %33 = load i32, i32* %x.addr, align 4, !tbaa !4
  %34 = load i32, i32* %y.addr, align 4, !tbaa !4
  %35 = bitcast %struct.TPixel* %color to i32*
  %36 = load i32, i32* %35, align 1
  call void @tigrLine(%struct.Tigr* %30, i32 %31, i32 %32, i32 %33, i32 %34, i32 %36)
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %37 = bitcast i32* %y1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %37) #11
  %38 = bitcast i32* %x1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %38) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrGet(%struct.Tigr* %bmp, i32 %x, i32 %y) #0 {
entry:
  %retval = alloca %struct.TPixel, align 1
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %empty = alloca %struct.TPixel, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x, i32* %x.addr, align 4, !tbaa !4
  store i32 %y, i32* %y.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TPixel* %empty to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast %struct.TPixel* %empty to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %1, i8 0, i64 4, i1 false)
  %2 = load i32, i32* %x.addr, align 4, !tbaa !4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i32, i32* %y.addr, align 4, !tbaa !4
  %cmp1 = icmp sge i32 %3, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %4 = load i32, i32* %x.addr, align 4, !tbaa !4
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %5, i32 0, i32 0
  %6 = load i32, i32* %w, align 8, !tbaa !10
  %cmp3 = icmp slt i32 %4, %6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %7 = load i32, i32* %y.addr, align 4, !tbaa !4
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %8, i32 0, i32 1
  %9 = load i32, i32* %h, align 4, !tbaa !12
  %cmp5 = icmp slt i32 %7, %9
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %10 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %10, i32 0, i32 2
  %11 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %12 = load i32, i32* %y.addr, align 4, !tbaa !4
  %13 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w6 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %13, i32 0, i32 0
  %14 = load i32, i32* %w6, align 8, !tbaa !10
  %mul = mul nsw i32 %12, %14
  %15 = load i32, i32* %x.addr, align 4, !tbaa !4
  %add = add nsw i32 %mul, %15
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %11, i64 %idxprom
  %16 = bitcast %struct.TPixel* %retval to i8*
  %17 = bitcast %struct.TPixel* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %16, i8* align 1 %17, i64 4, i1 false), !tbaa.struct !14
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %18 = bitcast %struct.TPixel* %retval to i8*
  %19 = bitcast %struct.TPixel* %empty to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %18, i8* align 1 %19, i64 4, i1 false), !tbaa.struct !14
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %20 = bitcast %struct.TPixel* %empty to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %20) #11
  %21 = bitcast %struct.TPixel* %retval to i32*
  %22 = load i32, i32* %21, align 1
  ret i32 %22
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #1

; Function Attrs: nounwind ssp uwtable
define void @tigrBlit(%struct.Tigr* %dst, %struct.Tigr* %src, i32 %dx, i32 %dy, i32 %sx, i32 %sy, i32 %w, i32 %h) #0 {
entry:
  %dst.addr = alloca %struct.Tigr*, align 8
  %src.addr = alloca %struct.Tigr*, align 8
  %dx.addr = alloca i32, align 4
  %dy.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %td = alloca %struct.TPixel*, align 8
  %ts = alloca %struct.TPixel*, align 8
  %st = alloca i32, align 4
  %dt = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Tigr* %dst, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  store %struct.Tigr* %src, %struct.Tigr** %src.addr, align 8, !tbaa !8
  store i32 %dx, i32* %dx.addr, align 4, !tbaa !4
  store i32 %dy, i32* %dy.addr, align 4, !tbaa !4
  store i32 %sx, i32* %sx.addr, align 4, !tbaa !4
  store i32 %sy, i32* %sy.addr, align 4, !tbaa !4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TPixel** %td to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast %struct.TPixel** %ts to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast i32* %st to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = bitcast i32* %dt to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %6 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add = add nsw i32 %6, %5
  store i32 %add, i32* %w.addr, align 4, !tbaa !4
  %7 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %8 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %sub = sub nsw i32 %8, %7
  store i32 %sub, i32* %sx.addr, align 4, !tbaa !4
  store i32 0, i32* %dx.addr, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %cmp1 = icmp slt i32 %9, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %10 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %11 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add3 = add nsw i32 %11, %10
  store i32 %add3, i32* %h.addr, align 4, !tbaa !4
  %12 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %13 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %sub4 = sub nsw i32 %13, %12
  store i32 %sub4, i32* %sy.addr, align 4, !tbaa !4
  store i32 0, i32* %dy.addr, align 4, !tbaa !4
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %14 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %cmp6 = icmp slt i32 %14, 0
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %15 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %16 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add8 = add nsw i32 %16, %15
  store i32 %add8, i32* %w.addr, align 4, !tbaa !4
  %17 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %18 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %sub9 = sub nsw i32 %18, %17
  store i32 %sub9, i32* %dx.addr, align 4, !tbaa !4
  store i32 0, i32* %sx.addr, align 4, !tbaa !4
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %19 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %cmp11 = icmp slt i32 %19, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %20 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %21 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add13 = add nsw i32 %21, %20
  store i32 %add13, i32* %h.addr, align 4, !tbaa !4
  %22 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %23 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %sub14 = sub nsw i32 %23, %22
  store i32 %sub14, i32* %dy.addr, align 4, !tbaa !4
  store i32 0, i32* %sy.addr, align 4, !tbaa !4
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %24 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %25 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add16 = add nsw i32 %24, %25
  %26 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w17 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %26, i32 0, i32 0
  %27 = load i32, i32* %w17, align 8, !tbaa !10
  %cmp18 = icmp sgt i32 %add16, %27
  br i1 %cmp18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end15
  %28 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w20 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %28, i32 0, i32 0
  %29 = load i32, i32* %w20, align 8, !tbaa !10
  %30 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %sub21 = sub nsw i32 %29, %30
  store i32 %sub21, i32* %w.addr, align 4, !tbaa !4
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end15
  %31 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %32 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add23 = add nsw i32 %31, %32
  %33 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %h24 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %33, i32 0, i32 1
  %34 = load i32, i32* %h24, align 4, !tbaa !12
  %cmp25 = icmp sgt i32 %add23, %34
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end22
  %35 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %h27 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %35, i32 0, i32 1
  %36 = load i32, i32* %h27, align 4, !tbaa !12
  %37 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %sub28 = sub nsw i32 %36, %37
  store i32 %sub28, i32* %h.addr, align 4, !tbaa !4
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end22
  %38 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %39 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add30 = add nsw i32 %38, %39
  %40 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w31 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %40, i32 0, i32 0
  %41 = load i32, i32* %w31, align 8, !tbaa !10
  %cmp32 = icmp sgt i32 %add30, %41
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.end29
  %42 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w34 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %42, i32 0, i32 0
  %43 = load i32, i32* %w34, align 8, !tbaa !10
  %44 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %sub35 = sub nsw i32 %43, %44
  store i32 %sub35, i32* %w.addr, align 4, !tbaa !4
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.end29
  %45 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %46 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add37 = add nsw i32 %45, %46
  %47 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %h38 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %47, i32 0, i32 1
  %48 = load i32, i32* %h38, align 4, !tbaa !12
  %cmp39 = icmp sgt i32 %add37, %48
  br i1 %cmp39, label %if.then40, label %if.end43

if.then40:                                        ; preds = %if.end36
  %49 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %h41 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %49, i32 0, i32 1
  %50 = load i32, i32* %h41, align 4, !tbaa !12
  %51 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %sub42 = sub nsw i32 %50, %51
  store i32 %sub42, i32* %h.addr, align 4, !tbaa !4
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %if.end36
  %52 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp44 = icmp sle i32 %52, 0
  br i1 %cmp44, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end43
  %53 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp45 = icmp sle i32 %53, 0
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %lor.lhs.false, %if.end43
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end47:                                         ; preds = %lor.lhs.false
  %54 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %54, i32 0, i32 2
  %55 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %56 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %57 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w48 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %57, i32 0, i32 0
  %58 = load i32, i32* %w48, align 8, !tbaa !10
  %mul = mul nsw i32 %56, %58
  %59 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %add49 = add nsw i32 %mul, %59
  %idxprom = sext i32 %add49 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %55, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %ts, align 8, !tbaa !8
  %60 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %pix50 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %60, i32 0, i32 2
  %61 = load %struct.TPixel*, %struct.TPixel** %pix50, align 8, !tbaa !13
  %62 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %63 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w51 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %63, i32 0, i32 0
  %64 = load i32, i32* %w51, align 8, !tbaa !10
  %mul52 = mul nsw i32 %62, %64
  %65 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %add53 = add nsw i32 %mul52, %65
  %idxprom54 = sext i32 %add53 to i64
  %arrayidx55 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %61, i64 %idxprom54
  store %struct.TPixel* %arrayidx55, %struct.TPixel** %td, align 8, !tbaa !8
  %66 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w56 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %66, i32 0, i32 0
  %67 = load i32, i32* %w56, align 8, !tbaa !10
  store i32 %67, i32* %st, align 4, !tbaa !4
  %68 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w57 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %68, i32 0, i32 0
  %69 = load i32, i32* %w57, align 8, !tbaa !10
  store i32 %69, i32* %dt, align 4, !tbaa !4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end47
  %70 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %71 = bitcast %struct.TPixel* %70 to i8*
  %72 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %73 = bitcast %struct.TPixel* %72 to i8*
  %74 = load i32, i32* %w.addr, align 4, !tbaa !4
  %conv = sext i32 %74 to i64
  %mul58 = mul i64 %conv, 4
  %75 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %76 = bitcast %struct.TPixel* %75 to i8*
  %77 = call i64 @llvm.objectsize.i64.p0i8(i8* %76, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %71, i8* %73, i64 %mul58, i64 %77) #11
  %78 = load i32, i32* %st, align 4, !tbaa !4
  %79 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %idx.ext = sext i32 %78 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %79, i64 %idx.ext
  store %struct.TPixel* %add.ptr, %struct.TPixel** %ts, align 8, !tbaa !8
  %80 = load i32, i32* %dt, align 4, !tbaa !4
  %81 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %idx.ext59 = sext i32 %80 to i64
  %add.ptr60 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %81, i64 %idx.ext59
  store %struct.TPixel* %add.ptr60, %struct.TPixel** %td, align 8, !tbaa !8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %82 = load i32, i32* %h.addr, align 4, !tbaa !4
  %dec = add nsw i32 %82, -1
  store i32 %dec, i32* %h.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then46
  %83 = bitcast i32* %dt to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %83) #11
  %84 = bitcast i32* %st to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %84) #11
  %85 = bitcast %struct.TPixel** %ts to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %85) #11
  %86 = bitcast %struct.TPixel** %td to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %86) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define void @tigrBlitTint(%struct.Tigr* %dst, %struct.Tigr* %src, i32 %dx, i32 %dy, i32 %sx, i32 %sy, i32 %w, i32 %h, i32 %tint.coerce) #0 {
entry:
  %tint = alloca %struct.TPixel, align 1
  %dst.addr = alloca %struct.Tigr*, align 8
  %src.addr = alloca %struct.Tigr*, align 8
  %dx.addr = alloca i32, align 4
  %dy.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %td = alloca %struct.TPixel*, align 8
  %ts = alloca %struct.TPixel*, align 8
  %x = alloca i32, align 4
  %st = alloca i32, align 4
  %dt = alloca i32, align 4
  %xr = alloca i32, align 4
  %xg = alloca i32, align 4
  %xb = alloca i32, align 4
  %xa = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %r83 = alloca i32, align 4
  %g89 = alloca i32, align 4
  %b96 = alloca i32, align 4
  %a103 = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %tint to i32*
  store i32 %tint.coerce, i32* %0, align 1
  store %struct.Tigr* %dst, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  store %struct.Tigr* %src, %struct.Tigr** %src.addr, align 8, !tbaa !8
  store i32 %dx, i32* %dx.addr, align 4, !tbaa !4
  store i32 %dy, i32* %dy.addr, align 4, !tbaa !4
  store i32 %sx, i32* %sx.addr, align 4, !tbaa !4
  store i32 %sy, i32* %sy.addr, align 4, !tbaa !4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %1 = bitcast %struct.TPixel** %td to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast %struct.TPixel** %ts to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = bitcast i32* %st to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast i32* %dt to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  %6 = bitcast i32* %xr to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %7 = bitcast i32* %xg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #11
  %8 = bitcast i32* %xb to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #11
  %9 = bitcast i32* %xa to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #11
  %10 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %10, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %12 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add = add nsw i32 %12, %11
  store i32 %add, i32* %w.addr, align 4, !tbaa !4
  %13 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %14 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %sub = sub nsw i32 %14, %13
  store i32 %sub, i32* %sx.addr, align 4, !tbaa !4
  store i32 0, i32* %dx.addr, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %cmp1 = icmp slt i32 %15, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %16 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %17 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add3 = add nsw i32 %17, %16
  store i32 %add3, i32* %h.addr, align 4, !tbaa !4
  %18 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %19 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %sub4 = sub nsw i32 %19, %18
  store i32 %sub4, i32* %sy.addr, align 4, !tbaa !4
  store i32 0, i32* %dy.addr, align 4, !tbaa !4
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %20 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %cmp6 = icmp slt i32 %20, 0
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %21 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %22 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add8 = add nsw i32 %22, %21
  store i32 %add8, i32* %w.addr, align 4, !tbaa !4
  %23 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %24 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %sub9 = sub nsw i32 %24, %23
  store i32 %sub9, i32* %dx.addr, align 4, !tbaa !4
  store i32 0, i32* %sx.addr, align 4, !tbaa !4
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %25 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %cmp11 = icmp slt i32 %25, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %26 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %27 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add13 = add nsw i32 %27, %26
  store i32 %add13, i32* %h.addr, align 4, !tbaa !4
  %28 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %29 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %sub14 = sub nsw i32 %29, %28
  store i32 %sub14, i32* %dy.addr, align 4, !tbaa !4
  store i32 0, i32* %sy.addr, align 4, !tbaa !4
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %30 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %31 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add16 = add nsw i32 %30, %31
  %32 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w17 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %32, i32 0, i32 0
  %33 = load i32, i32* %w17, align 8, !tbaa !10
  %cmp18 = icmp sgt i32 %add16, %33
  br i1 %cmp18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end15
  %34 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w20 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %34, i32 0, i32 0
  %35 = load i32, i32* %w20, align 8, !tbaa !10
  %36 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %sub21 = sub nsw i32 %35, %36
  store i32 %sub21, i32* %w.addr, align 4, !tbaa !4
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end15
  %37 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %38 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add23 = add nsw i32 %37, %38
  %39 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %h24 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %39, i32 0, i32 1
  %40 = load i32, i32* %h24, align 4, !tbaa !12
  %cmp25 = icmp sgt i32 %add23, %40
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end22
  %41 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %h27 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %41, i32 0, i32 1
  %42 = load i32, i32* %h27, align 4, !tbaa !12
  %43 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %sub28 = sub nsw i32 %42, %43
  store i32 %sub28, i32* %h.addr, align 4, !tbaa !4
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end22
  %44 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %45 = load i32, i32* %w.addr, align 4, !tbaa !4
  %add30 = add nsw i32 %44, %45
  %46 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w31 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %46, i32 0, i32 0
  %47 = load i32, i32* %w31, align 8, !tbaa !10
  %cmp32 = icmp sgt i32 %add30, %47
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.end29
  %48 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w34 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %48, i32 0, i32 0
  %49 = load i32, i32* %w34, align 8, !tbaa !10
  %50 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %sub35 = sub nsw i32 %49, %50
  store i32 %sub35, i32* %w.addr, align 4, !tbaa !4
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.end29
  %51 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %52 = load i32, i32* %h.addr, align 4, !tbaa !4
  %add37 = add nsw i32 %51, %52
  %53 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %h38 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %53, i32 0, i32 1
  %54 = load i32, i32* %h38, align 4, !tbaa !12
  %cmp39 = icmp sgt i32 %add37, %54
  br i1 %cmp39, label %if.then40, label %if.end43

if.then40:                                        ; preds = %if.end36
  %55 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %h41 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %55, i32 0, i32 1
  %56 = load i32, i32* %h41, align 4, !tbaa !12
  %57 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %sub42 = sub nsw i32 %56, %57
  store i32 %sub42, i32* %h.addr, align 4, !tbaa !4
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %if.end36
  %58 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp44 = icmp sle i32 %58, 0
  br i1 %cmp44, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end43
  %59 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp45 = icmp sle i32 %59, 0
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %lor.lhs.false, %if.end43
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end47:                                         ; preds = %lor.lhs.false
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 2
  %60 = load i8, i8* %r, align 1, !tbaa !18
  %conv = zext i8 %60 to i32
  %r48 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 2
  %61 = load i8, i8* %r48, align 1, !tbaa !18
  %conv49 = zext i8 %61 to i32
  %cmp50 = icmp sgt i32 %conv49, 0
  %conv51 = zext i1 %cmp50 to i32
  %add52 = add nsw i32 %conv, %conv51
  store i32 %add52, i32* %xr, align 4, !tbaa !4
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 1
  %62 = load i8, i8* %g, align 1, !tbaa !19
  %conv53 = zext i8 %62 to i32
  %g54 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 1
  %63 = load i8, i8* %g54, align 1, !tbaa !19
  %conv55 = zext i8 %63 to i32
  %cmp56 = icmp sgt i32 %conv55, 0
  %conv57 = zext i1 %cmp56 to i32
  %add58 = add nsw i32 %conv53, %conv57
  store i32 %add58, i32* %xg, align 4, !tbaa !4
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 0
  %64 = load i8, i8* %b, align 1, !tbaa !20
  %conv59 = zext i8 %64 to i32
  %b60 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 0
  %65 = load i8, i8* %b60, align 1, !tbaa !20
  %conv61 = zext i8 %65 to i32
  %cmp62 = icmp sgt i32 %conv61, 0
  %conv63 = zext i1 %cmp62 to i32
  %add64 = add nsw i32 %conv59, %conv63
  store i32 %add64, i32* %xb, align 4, !tbaa !4
  %a = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 3
  %66 = load i8, i8* %a, align 1, !tbaa !16
  %conv65 = zext i8 %66 to i32
  %a66 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %tint, i32 0, i32 3
  %67 = load i8, i8* %a66, align 1, !tbaa !16
  %conv67 = zext i8 %67 to i32
  %cmp68 = icmp sgt i32 %conv67, 0
  %conv69 = zext i1 %cmp68 to i32
  %add70 = add nsw i32 %conv65, %conv69
  store i32 %add70, i32* %xa, align 4, !tbaa !4
  %68 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %68, i32 0, i32 2
  %69 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %70 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %71 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w71 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %71, i32 0, i32 0
  %72 = load i32, i32* %w71, align 8, !tbaa !10
  %mul = mul nsw i32 %70, %72
  %73 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %add72 = add nsw i32 %mul, %73
  %idxprom = sext i32 %add72 to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %69, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %ts, align 8, !tbaa !8
  %74 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %pix73 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %74, i32 0, i32 2
  %75 = load %struct.TPixel*, %struct.TPixel** %pix73, align 8, !tbaa !13
  %76 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %77 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w74 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %77, i32 0, i32 0
  %78 = load i32, i32* %w74, align 8, !tbaa !10
  %mul75 = mul nsw i32 %76, %78
  %79 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %add76 = add nsw i32 %mul75, %79
  %idxprom77 = sext i32 %add76 to i64
  %arrayidx78 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %75, i64 %idxprom77
  store %struct.TPixel* %arrayidx78, %struct.TPixel** %td, align 8, !tbaa !8
  %80 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %w79 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %80, i32 0, i32 0
  %81 = load i32, i32* %w79, align 8, !tbaa !10
  store i32 %81, i32* %st, align 4, !tbaa !4
  %82 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %w80 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %82, i32 0, i32 0
  %83 = load i32, i32* %w80, align 8, !tbaa !10
  store i32 %83, i32* %dt, align 4, !tbaa !4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end47
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %84 = load i32, i32* %x, align 4, !tbaa !4
  %85 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp81 = icmp slt i32 %84, %85
  br i1 %cmp81, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %86 = bitcast i32* %r83 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %86) #11
  %87 = load i32, i32* %xr, align 4, !tbaa !4
  %88 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %89 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom84 = sext i32 %89 to i64
  %arrayidx85 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %88, i64 %idxprom84
  %r86 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx85, i32 0, i32 2
  %90 = load i8, i8* %r86, align 1, !tbaa !18
  %conv87 = zext i8 %90 to i32
  %mul88 = mul nsw i32 %87, %conv87
  %shr = ashr i32 %mul88, 8
  store i32 %shr, i32* %r83, align 4, !tbaa !4
  %91 = bitcast i32* %g89 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %91) #11
  %92 = load i32, i32* %xg, align 4, !tbaa !4
  %93 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %94 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom90 = sext i32 %94 to i64
  %arrayidx91 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %93, i64 %idxprom90
  %g92 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx91, i32 0, i32 1
  %95 = load i8, i8* %g92, align 1, !tbaa !19
  %conv93 = zext i8 %95 to i32
  %mul94 = mul nsw i32 %92, %conv93
  %shr95 = ashr i32 %mul94, 8
  store i32 %shr95, i32* %g89, align 4, !tbaa !4
  %96 = bitcast i32* %b96 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %96) #11
  %97 = load i32, i32* %xb, align 4, !tbaa !4
  %98 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %99 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom97 = sext i32 %99 to i64
  %arrayidx98 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %98, i64 %idxprom97
  %b99 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx98, i32 0, i32 0
  %100 = load i8, i8* %b99, align 1, !tbaa !20
  %conv100 = zext i8 %100 to i32
  %mul101 = mul nsw i32 %97, %conv100
  %shr102 = ashr i32 %mul101, 8
  store i32 %shr102, i32* %b96, align 4, !tbaa !4
  %101 = bitcast i32* %a103 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %101) #11
  %102 = load i32, i32* %xa, align 4, !tbaa !4
  %103 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %104 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom104 = sext i32 %104 to i64
  %arrayidx105 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %103, i64 %idxprom104
  %a106 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx105, i32 0, i32 3
  %105 = load i8, i8* %a106, align 1, !tbaa !16
  %conv107 = zext i8 %105 to i32
  %106 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %107 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom108 = sext i32 %107 to i64
  %arrayidx109 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %106, i64 %idxprom108
  %a110 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx109, i32 0, i32 3
  %108 = load i8, i8* %a110, align 1, !tbaa !16
  %conv111 = zext i8 %108 to i32
  %cmp112 = icmp sgt i32 %conv111, 0
  %conv113 = zext i1 %cmp112 to i32
  %add114 = add nsw i32 %conv107, %conv113
  %mul115 = mul nsw i32 %102, %add114
  store i32 %mul115, i32* %a103, align 4, !tbaa !4
  %109 = load i32, i32* %r83, align 4, !tbaa !4
  %110 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %111 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom116 = sext i32 %111 to i64
  %arrayidx117 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %110, i64 %idxprom116
  %r118 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx117, i32 0, i32 2
  %112 = load i8, i8* %r118, align 1, !tbaa !18
  %conv119 = zext i8 %112 to i32
  %sub120 = sub i32 %109, %conv119
  %113 = load i32, i32* %a103, align 4, !tbaa !4
  %mul121 = mul i32 %sub120, %113
  %shr122 = lshr i32 %mul121, 16
  %conv123 = trunc i32 %shr122 to i8
  %conv124 = zext i8 %conv123 to i32
  %114 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %115 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom125 = sext i32 %115 to i64
  %arrayidx126 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %114, i64 %idxprom125
  %r127 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx126, i32 0, i32 2
  %116 = load i8, i8* %r127, align 1, !tbaa !18
  %conv128 = zext i8 %116 to i32
  %add129 = add nsw i32 %conv128, %conv124
  %conv130 = trunc i32 %add129 to i8
  store i8 %conv130, i8* %r127, align 1, !tbaa !18
  %117 = load i32, i32* %g89, align 4, !tbaa !4
  %118 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %119 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom131 = sext i32 %119 to i64
  %arrayidx132 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %118, i64 %idxprom131
  %g133 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx132, i32 0, i32 1
  %120 = load i8, i8* %g133, align 1, !tbaa !19
  %conv134 = zext i8 %120 to i32
  %sub135 = sub i32 %117, %conv134
  %121 = load i32, i32* %a103, align 4, !tbaa !4
  %mul136 = mul i32 %sub135, %121
  %shr137 = lshr i32 %mul136, 16
  %conv138 = trunc i32 %shr137 to i8
  %conv139 = zext i8 %conv138 to i32
  %122 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %123 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom140 = sext i32 %123 to i64
  %arrayidx141 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %122, i64 %idxprom140
  %g142 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx141, i32 0, i32 1
  %124 = load i8, i8* %g142, align 1, !tbaa !19
  %conv143 = zext i8 %124 to i32
  %add144 = add nsw i32 %conv143, %conv139
  %conv145 = trunc i32 %add144 to i8
  store i8 %conv145, i8* %g142, align 1, !tbaa !19
  %125 = load i32, i32* %b96, align 4, !tbaa !4
  %126 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %127 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom146 = sext i32 %127 to i64
  %arrayidx147 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %126, i64 %idxprom146
  %b148 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx147, i32 0, i32 0
  %128 = load i8, i8* %b148, align 1, !tbaa !20
  %conv149 = zext i8 %128 to i32
  %sub150 = sub i32 %125, %conv149
  %129 = load i32, i32* %a103, align 4, !tbaa !4
  %mul151 = mul i32 %sub150, %129
  %shr152 = lshr i32 %mul151, 16
  %conv153 = trunc i32 %shr152 to i8
  %conv154 = zext i8 %conv153 to i32
  %130 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %131 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom155 = sext i32 %131 to i64
  %arrayidx156 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %130, i64 %idxprom155
  %b157 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx156, i32 0, i32 0
  %132 = load i8, i8* %b157, align 1, !tbaa !20
  %conv158 = zext i8 %132 to i32
  %add159 = add nsw i32 %conv158, %conv154
  %conv160 = trunc i32 %add159 to i8
  store i8 %conv160, i8* %b157, align 1, !tbaa !20
  %133 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %134 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom161 = sext i32 %134 to i64
  %arrayidx162 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %133, i64 %idxprom161
  %a163 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx162, i32 0, i32 3
  %135 = load i8, i8* %a163, align 1, !tbaa !16
  %conv164 = zext i8 %135 to i32
  %136 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %137 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom165 = sext i32 %137 to i64
  %arrayidx166 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %136, i64 %idxprom165
  %a167 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx166, i32 0, i32 3
  %138 = load i8, i8* %a167, align 1, !tbaa !16
  %conv168 = zext i8 %138 to i32
  %sub169 = sub nsw i32 %conv164, %conv168
  %139 = load i32, i32* %a103, align 4, !tbaa !4
  %mul170 = mul i32 %sub169, %139
  %shr171 = lshr i32 %mul170, 16
  %conv172 = trunc i32 %shr171 to i8
  %conv173 = zext i8 %conv172 to i32
  %140 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %141 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom174 = sext i32 %141 to i64
  %arrayidx175 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %140, i64 %idxprom174
  %a176 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx175, i32 0, i32 3
  %142 = load i8, i8* %a176, align 1, !tbaa !16
  %conv177 = zext i8 %142 to i32
  %add178 = add nsw i32 %conv177, %conv173
  %conv179 = trunc i32 %add178 to i8
  store i8 %conv179, i8* %a176, align 1, !tbaa !16
  %143 = bitcast i32* %a103 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %143) #11
  %144 = bitcast i32* %b96 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %144) #11
  %145 = bitcast i32* %g89 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %145) #11
  %146 = bitcast i32* %r83 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %146) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %147 = load i32, i32* %x, align 4, !tbaa !4
  %inc = add nsw i32 %147, 1
  store i32 %inc, i32* %x, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %148 = load i32, i32* %st, align 4, !tbaa !4
  %149 = load %struct.TPixel*, %struct.TPixel** %ts, align 8, !tbaa !8
  %idx.ext = sext i32 %148 to i64
  %add.ptr = getelementptr inbounds %struct.TPixel, %struct.TPixel* %149, i64 %idx.ext
  store %struct.TPixel* %add.ptr, %struct.TPixel** %ts, align 8, !tbaa !8
  %150 = load i32, i32* %dt, align 4, !tbaa !4
  %151 = load %struct.TPixel*, %struct.TPixel** %td, align 8, !tbaa !8
  %idx.ext180 = sext i32 %150 to i64
  %add.ptr181 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %151, i64 %idx.ext180
  store %struct.TPixel* %add.ptr181, %struct.TPixel** %td, align 8, !tbaa !8
  br label %do.cond

do.cond:                                          ; preds = %for.end
  %152 = load i32, i32* %h.addr, align 4, !tbaa !4
  %dec = add nsw i32 %152, -1
  store i32 %dec, i32* %h.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then46
  %153 = bitcast i32* %xa to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %153) #11
  %154 = bitcast i32* %xb to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %154) #11
  %155 = bitcast i32* %xg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %155) #11
  %156 = bitcast i32* %xr to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %156) #11
  %157 = bitcast i32* %dt to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %157) #11
  %158 = bitcast i32* %st to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %158) #11
  %159 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %159) #11
  %160 = bitcast %struct.TPixel** %ts to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %160) #11
  %161 = bitcast %struct.TPixel** %td to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %161) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define void @tigrBlitAlpha(%struct.Tigr* %dst, %struct.Tigr* %src, i32 %dx, i32 %dy, i32 %sx, i32 %sy, i32 %w, i32 %h, float %alpha) #0 {
entry:
  %dst.addr = alloca %struct.Tigr*, align 8
  %src.addr = alloca %struct.Tigr*, align 8
  %dx.addr = alloca i32, align 4
  %dy.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %alpha.addr = alloca float, align 4
  %agg.tmp = alloca %struct.TPixel, align 1
  store %struct.Tigr* %dst, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  store %struct.Tigr* %src, %struct.Tigr** %src.addr, align 8, !tbaa !8
  store i32 %dx, i32* %dx.addr, align 4, !tbaa !4
  store i32 %dy, i32* %dy.addr, align 4, !tbaa !4
  store i32 %sx, i32* %sx.addr, align 4, !tbaa !4
  store i32 %sy, i32* %sy.addr, align 4, !tbaa !4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  store float %alpha, float* %alpha.addr, align 4, !tbaa !21
  %0 = load float, float* %alpha.addr, align 4, !tbaa !21
  %cmp = fcmp olt float %0, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load float, float* %alpha.addr, align 4, !tbaa !21
  %cmp1 = fcmp ogt float %1, 1.000000e+00
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %2 = load float, float* %alpha.addr, align 4, !tbaa !21
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi float [ 1.000000e+00, %cond.true2 ], [ %2, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi float [ 0.000000e+00, %cond.true ], [ %cond, %cond.end ]
  store float %cond5, float* %alpha.addr, align 4, !tbaa !21
  %3 = load %struct.Tigr*, %struct.Tigr** %dst.addr, align 8, !tbaa !8
  %4 = load %struct.Tigr*, %struct.Tigr** %src.addr, align 8, !tbaa !8
  %5 = load i32, i32* %dx.addr, align 4, !tbaa !4
  %6 = load i32, i32* %dy.addr, align 4, !tbaa !4
  %7 = load i32, i32* %sx.addr, align 4, !tbaa !4
  %8 = load i32, i32* %sy.addr, align 4, !tbaa !4
  %9 = load i32, i32* %w.addr, align 4, !tbaa !4
  %10 = load i32, i32* %h.addr, align 4, !tbaa !4
  %11 = load float, float* %alpha.addr, align 4, !tbaa !21
  %mul = fmul float %11, 2.550000e+02
  %conv = fptoui float %mul to i8
  %call = call i32 @tigrRGBA(i8 zeroext -1, i8 zeroext -1, i8 zeroext -1, i8 zeroext %conv)
  %12 = bitcast %struct.TPixel* %agg.tmp to i32*
  store i32 %call, i32* %12, align 1
  %13 = bitcast %struct.TPixel* %agg.tmp to i32*
  %14 = load i32, i32* %13, align 1
  call void @tigrBlitTint(%struct.Tigr* %3, %struct.Tigr* %4, i32 %5, i32 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %14)
  ret void
}

; Function Attrs: inlinehint nounwind ssp uwtable
define internal i32 @tigrRGBA(i8 zeroext %r, i8 zeroext %g, i8 zeroext %b, i8 zeroext %a) #7 {
entry:
  %retval = alloca %struct.TPixel, align 1
  %r.addr = alloca i8, align 1
  %g.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %a.addr = alloca i8, align 1
  store i8 %r, i8* %r.addr, align 1, !tbaa !15
  store i8 %g, i8* %g.addr, align 1, !tbaa !15
  store i8 %b, i8* %b.addr, align 1, !tbaa !15
  store i8 %a, i8* %a.addr, align 1, !tbaa !15
  %0 = load i8, i8* %r.addr, align 1, !tbaa !15
  %r1 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 2
  store i8 %0, i8* %r1, align 1, !tbaa !18
  %1 = load i8, i8* %g.addr, align 1, !tbaa !15
  %g2 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 1
  store i8 %1, i8* %g2, align 1, !tbaa !19
  %2 = load i8, i8* %b.addr, align 1, !tbaa !15
  %b3 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 0
  store i8 %2, i8* %b3, align 1, !tbaa !20
  %3 = load i8, i8* %a.addr, align 1, !tbaa !15
  %a4 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 3
  store i8 %3, i8* %a4, align 1, !tbaa !16
  %4 = bitcast %struct.TPixel* %retval to i32*
  %5 = load i32, i32* %4, align 1
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define %struct.Tigr* @tigrLoadImageMem(i8* %data, i32 %length) #0 {
entry:
  %data.addr = alloca i8*, align 8
  %length.addr = alloca i32, align 4
  %png = alloca %struct.PNG, align 8
  store i8* %data, i8** %data.addr, align 8, !tbaa !8
  store i32 %length, i32* %length.addr, align 4, !tbaa !4
  %0 = bitcast %struct.PNG* %png to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #11
  %1 = load i8*, i8** %data.addr, align 8, !tbaa !8
  %p = getelementptr inbounds %struct.PNG, %struct.PNG* %png, i32 0, i32 0
  store i8* %1, i8** %p, align 8, !tbaa !23
  %2 = load i8*, i8** %data.addr, align 8, !tbaa !8
  %3 = load i32, i32* %length.addr, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %end = getelementptr inbounds %struct.PNG, %struct.PNG* %png, i32 0, i32 1
  store i8* %add.ptr, i8** %end, align 8, !tbaa !25
  %call = call %struct.Tigr* @tigrLoadPng(%struct.PNG* %png)
  %4 = bitcast %struct.PNG* %png to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %4) #11
  ret %struct.Tigr* %call
}

; Function Attrs: nounwind ssp uwtable
define internal %struct.Tigr* @tigrLoadPng(%struct.PNG* %png) #0 {
entry:
  %retval = alloca %struct.Tigr*, align 8
  %png.addr = alloca %struct.PNG*, align 8
  %ihdr = alloca i8*, align 8
  %idat = alloca i8*, align 8
  %plte = alloca i8*, align 8
  %first = alloca i8*, align 8
  %depth = alloca i32, align 4
  %ctype = alloca i32, align 4
  %bpp = alloca i32, align 4
  %datalen = alloca i32, align 4
  %data = alloca i8*, align 8
  %out = alloca i8*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  %len = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.PNG* %png, %struct.PNG** %png.addr, align 8, !tbaa !8
  %0 = bitcast i8** %ihdr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast i8** %idat to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast i8** %plte to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = bitcast i8** %first to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = bitcast i32* %depth to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast i32* %ctype to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  %6 = bitcast i32* %bpp to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %7 = bitcast i32* %datalen to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #11
  store i32 0, i32* %datalen, align 4, !tbaa !4
  %8 = bitcast i8** %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #11
  store i8* null, i8** %data, align 8, !tbaa !8
  %9 = bitcast i8** %out to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #11
  %10 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #11
  store %struct.Tigr* null, %struct.Tigr** %bmp, align 8, !tbaa !8
  %11 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p = getelementptr inbounds %struct.PNG, %struct.PNG* %11, i32 0, i32 0
  %12 = load i8*, i8** %p, align 8, !tbaa !23
  %call = call i32 @memcmp(i8* %12, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.98, i32 0, i32 0), i64 8)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i32* @__error()
  store i32 22, i32* %call1, align 4, !tbaa !4
  br label %err

if.end:                                           ; preds = %entry
  %13 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p2 = getelementptr inbounds %struct.PNG, %struct.PNG* %13, i32 0, i32 0
  %14 = load i8*, i8** %p2, align 8, !tbaa !23
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 8
  store i8* %add.ptr, i8** %p2, align 8, !tbaa !23
  %15 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p3 = getelementptr inbounds %struct.PNG, %struct.PNG* %15, i32 0, i32 0
  %16 = load i8*, i8** %p3, align 8, !tbaa !23
  store i8* %16, i8** %first, align 8, !tbaa !8
  %17 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %call4 = call i8* @find(%struct.PNG* %17, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i32 13)
  store i8* %call4, i8** %ihdr, align 8, !tbaa !8
  %18 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %tobool = icmp ne i8* %18, null
  br i1 %tobool, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %call6 = call i32* @__error()
  store i32 22, i32* %call6, align 4, !tbaa !4
  br label %err

if.end7:                                          ; preds = %if.end
  %19 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i8, i8* %19, i64 8
  %20 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv = zext i8 %20 to i32
  store i32 %conv, i32* %depth, align 4, !tbaa !4
  %21 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %arrayidx8 = getelementptr inbounds i8, i8* %21, i64 9
  %22 = load i8, i8* %arrayidx8, align 1, !tbaa !15
  %conv9 = zext i8 %22 to i32
  store i32 %conv9, i32* %ctype, align 4, !tbaa !4
  %23 = load i32, i32* %ctype, align 4, !tbaa !4
  switch i32 %23, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb10
    i32 3, label %sw.bb11
    i32 4, label %sw.bb12
    i32 6, label %sw.bb13
  ]

sw.bb:                                            ; preds = %if.end7
  store i32 1, i32* %bpp, align 4, !tbaa !4
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end7
  store i32 3, i32* %bpp, align 4, !tbaa !4
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end7
  store i32 1, i32* %bpp, align 4, !tbaa !4
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end7
  store i32 2, i32* %bpp, align 4, !tbaa !4
  br label %sw.epilog

sw.bb13:                                          ; preds = %if.end7
  store i32 4, i32* %bpp, align 4, !tbaa !4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end7
  %call14 = call i32* @__error()
  store i32 22, i32* %call14, align 4, !tbaa !4
  br label %err

sw.epilog:                                        ; preds = %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb
  %24 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %add.ptr15 = getelementptr inbounds i8, i8* %24, i64 0
  %call16 = call i32 @get32(i8* %add.ptr15)
  %add = add i32 %call16, 1
  %25 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %add.ptr17 = getelementptr inbounds i8, i8* %25, i64 4
  %call18 = call i32 @get32(i8* %add.ptr17)
  %call19 = call %struct.Tigr* @tigrBitmap(i32 %add, i32 %call18)
  store %struct.Tigr* %call19, %struct.Tigr** %bmp, align 8, !tbaa !8
  %26 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %tobool20 = icmp ne %struct.Tigr* %26, null
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %sw.epilog
  %call22 = call i32* @__error()
  store i32 22, i32* %call22, align 4, !tbaa !4
  br label %err

if.end23:                                         ; preds = %sw.epilog
  %27 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %27, i32 0, i32 0
  %28 = load i32, i32* %w, align 8, !tbaa !10
  %dec = add nsw i32 %28, -1
  store i32 %dec, i32* %w, align 8, !tbaa !10
  %29 = load i32, i32* %depth, align 4, !tbaa !4
  %cmp24 = icmp eq i32 %29, 8
  br i1 %cmp24, label %land.lhs.true, label %if.then40

land.lhs.true:                                    ; preds = %if.end23
  %30 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %arrayidx26 = getelementptr inbounds i8, i8* %30, i64 10
  %31 = load i8, i8* %arrayidx26, align 1, !tbaa !15
  %conv27 = zext i8 %31 to i32
  %cmp28 = icmp eq i32 %conv27, 0
  br i1 %cmp28, label %land.lhs.true30, label %if.then40

land.lhs.true30:                                  ; preds = %land.lhs.true
  %32 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %arrayidx31 = getelementptr inbounds i8, i8* %32, i64 11
  %33 = load i8, i8* %arrayidx31, align 1, !tbaa !15
  %conv32 = zext i8 %33 to i32
  %cmp33 = icmp eq i32 %conv32, 0
  br i1 %cmp33, label %land.lhs.true35, label %if.then40

land.lhs.true35:                                  ; preds = %land.lhs.true30
  %34 = load i8*, i8** %ihdr, align 8, !tbaa !8
  %arrayidx36 = getelementptr inbounds i8, i8* %34, i64 12
  %35 = load i8, i8* %arrayidx36, align 1, !tbaa !15
  %conv37 = zext i8 %35 to i32
  %cmp38 = icmp eq i32 %conv37, 0
  br i1 %cmp38, label %if.end42, label %if.then40

if.then40:                                        ; preds = %land.lhs.true35, %land.lhs.true30, %land.lhs.true, %if.end23
  %call41 = call i32* @__error()
  store i32 22, i32* %call41, align 4, !tbaa !4
  br label %err

if.end42:                                         ; preds = %land.lhs.true35
  %36 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %call43 = call i8* @find(%struct.PNG* %36, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i32 0)
  store i8* %call43, i8** %idat, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end42
  %37 = load i8*, i8** %idat, align 8, !tbaa !8
  %tobool44 = icmp ne i8* %37, null
  br i1 %tobool44, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %38 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %38) #11
  %39 = load i8*, i8** %idat, align 8, !tbaa !8
  %add.ptr45 = getelementptr inbounds i8, i8* %39, i64 -8
  %call46 = call i32 @get32(i8* %add.ptr45)
  store i32 %call46, i32* %len, align 4, !tbaa !4
  %40 = load i8*, i8** %data, align 8, !tbaa !8
  %41 = load i32, i32* %datalen, align 4, !tbaa !4
  %42 = load i32, i32* %len, align 4, !tbaa !4
  %add47 = add i32 %41, %42
  %conv48 = zext i32 %add47 to i64
  %call49 = call i8* @realloc(i8* %40, i64 %conv48) #16
  store i8* %call49, i8** %data, align 8, !tbaa !8
  %43 = load i8*, i8** %data, align 8, !tbaa !8
  %tobool50 = icmp ne i8* %43, null
  br i1 %tobool50, label %if.end52, label %if.then51

if.then51:                                        ; preds = %for.body
  store i32 4, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end52:                                         ; preds = %for.body
  %44 = load i8*, i8** %data, align 8, !tbaa !8
  %45 = load i32, i32* %datalen, align 4, !tbaa !4
  %idx.ext = sext i32 %45 to i64
  %add.ptr53 = getelementptr inbounds i8, i8* %44, i64 %idx.ext
  %46 = load i8*, i8** %idat, align 8, !tbaa !8
  %47 = load i32, i32* %len, align 4, !tbaa !4
  %conv54 = zext i32 %47 to i64
  %48 = load i8*, i8** %data, align 8, !tbaa !8
  %49 = load i32, i32* %datalen, align 4, !tbaa !4
  %idx.ext55 = sext i32 %49 to i64
  %add.ptr56 = getelementptr inbounds i8, i8* %48, i64 %idx.ext55
  %50 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr56, i1 false, i1 true)
  %call57 = call i8* @__memcpy_chk(i8* %add.ptr53, i8* %46, i64 %conv54, i64 %50) #11
  %51 = load i32, i32* %len, align 4, !tbaa !4
  %52 = load i32, i32* %datalen, align 4, !tbaa !4
  %add58 = add i32 %52, %51
  store i32 %add58, i32* %datalen, align 4, !tbaa !4
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end52, %if.then51
  %53 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %53) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 4, label %for.end
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %54 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %call59 = call i8* @find(%struct.PNG* %54, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i32 0)
  store i8* %call59, i8** %idat, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %cleanup, %for.cond
  %55 = load i8*, i8** %first, align 8, !tbaa !8
  %56 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p60 = getelementptr inbounds %struct.PNG, %struct.PNG* %56, i32 0, i32 0
  store i8* %55, i8** %p60, align 8, !tbaa !23
  %57 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %call61 = call i8* @find(%struct.PNG* %57, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.101, i32 0, i32 0), i32 0)
  store i8* %call61, i8** %plte, align 8, !tbaa !8
  %58 = load i8*, i8** %data, align 8, !tbaa !8
  %tobool62 = icmp ne i8* %58, null
  br i1 %tobool62, label %land.lhs.true63, label %if.then66

land.lhs.true63:                                  ; preds = %for.end
  %59 = load i32, i32* %datalen, align 4, !tbaa !4
  %cmp64 = icmp sge i32 %59, 6
  br i1 %cmp64, label %if.end68, label %if.then66

if.then66:                                        ; preds = %land.lhs.true63, %for.end
  %call67 = call i32* @__error()
  store i32 22, i32* %call67, align 4, !tbaa !4
  br label %err

if.end68:                                         ; preds = %land.lhs.true63
  %60 = load i8*, i8** %data, align 8, !tbaa !8
  %arrayidx69 = getelementptr inbounds i8, i8* %60, i64 0
  %61 = load i8, i8* %arrayidx69, align 1, !tbaa !15
  %conv70 = zext i8 %61 to i32
  %and = and i32 %conv70, 15
  %cmp71 = icmp eq i32 %and, 8
  br i1 %cmp71, label %land.lhs.true73, label %if.then85

land.lhs.true73:                                  ; preds = %if.end68
  %62 = load i8*, i8** %data, align 8, !tbaa !8
  %arrayidx74 = getelementptr inbounds i8, i8* %62, i64 0
  %63 = load i8, i8* %arrayidx74, align 1, !tbaa !15
  %conv75 = zext i8 %63 to i32
  %and76 = and i32 %conv75, 240
  %cmp77 = icmp sle i32 %and76, 112
  br i1 %cmp77, label %land.lhs.true79, label %if.then85

land.lhs.true79:                                  ; preds = %land.lhs.true73
  %64 = load i8*, i8** %data, align 8, !tbaa !8
  %arrayidx80 = getelementptr inbounds i8, i8* %64, i64 1
  %65 = load i8, i8* %arrayidx80, align 1, !tbaa !15
  %conv81 = zext i8 %65 to i32
  %and82 = and i32 %conv81, 32
  %cmp83 = icmp eq i32 %and82, 0
  br i1 %cmp83, label %if.end87, label %if.then85

if.then85:                                        ; preds = %land.lhs.true79, %land.lhs.true73, %if.end68
  %call86 = call i32* @__error()
  store i32 22, i32* %call86, align 4, !tbaa !4
  br label %err

if.end87:                                         ; preds = %land.lhs.true79
  %66 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %66, i32 0, i32 2
  %67 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %68 = bitcast %struct.TPixel* %67 to i8*
  %69 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %call88 = call i32 @outsize(%struct.Tigr* %69, i32 4)
  %idx.ext89 = sext i32 %call88 to i64
  %add.ptr90 = getelementptr inbounds i8, i8* %68, i64 %idx.ext89
  %70 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %71 = load i32, i32* %bpp, align 4, !tbaa !4
  %call91 = call i32 @outsize(%struct.Tigr* %70, i32 %71)
  %idx.ext92 = sext i32 %call91 to i64
  %idx.neg = sub i64 0, %idx.ext92
  %add.ptr93 = getelementptr inbounds i8, i8* %add.ptr90, i64 %idx.neg
  store i8* %add.ptr93, i8** %out, align 8, !tbaa !8
  %72 = load i8*, i8** %out, align 8, !tbaa !8
  %73 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %74 = load i32, i32* %bpp, align 4, !tbaa !4
  %call94 = call i32 @outsize(%struct.Tigr* %73, i32 %74)
  %75 = load i8*, i8** %data, align 8, !tbaa !8
  %add.ptr95 = getelementptr inbounds i8, i8* %75, i64 2
  %76 = load i32, i32* %datalen, align 4, !tbaa !4
  %sub = sub nsw i32 %76, 6
  %call96 = call i32 @tigrInflate(i8* %72, i32 %call94, i8* %add.ptr95, i32 %sub)
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.end87
  %call99 = call i32* @__error()
  store i32 22, i32* %call99, align 4, !tbaa !4
  br label %err

if.end100:                                        ; preds = %if.end87
  %77 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %w101 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %77, i32 0, i32 0
  %78 = load i32, i32* %w101, align 8, !tbaa !10
  %79 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %79, i32 0, i32 1
  %80 = load i32, i32* %h, align 4, !tbaa !12
  %81 = load i32, i32* %bpp, align 4, !tbaa !4
  %82 = load i8*, i8** %out, align 8, !tbaa !8
  %call102 = call i32 @unfilter(i32 %78, i32 %80, i32 %81, i8* %82)
  %tobool103 = icmp ne i32 %call102, 0
  br i1 %tobool103, label %if.end106, label %if.then104

if.then104:                                       ; preds = %if.end100
  %call105 = call i32* @__error()
  store i32 22, i32* %call105, align 4, !tbaa !4
  br label %err

if.end106:                                        ; preds = %if.end100
  %83 = load i32, i32* %ctype, align 4, !tbaa !4
  %cmp107 = icmp eq i32 %83, 3
  br i1 %cmp107, label %if.then109, label %if.else

if.then109:                                       ; preds = %if.end106
  %84 = load i8*, i8** %plte, align 8, !tbaa !8
  %tobool110 = icmp ne i8* %84, null
  br i1 %tobool110, label %if.end113, label %if.then111

if.then111:                                       ; preds = %if.then109
  %call112 = call i32* @__error()
  store i32 22, i32* %call112, align 4, !tbaa !4
  br label %err

if.end113:                                        ; preds = %if.then109
  %85 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %w114 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %85, i32 0, i32 0
  %86 = load i32, i32* %w114, align 8, !tbaa !10
  %87 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %h115 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %87, i32 0, i32 1
  %88 = load i32, i32* %h115, align 4, !tbaa !12
  %89 = load i8*, i8** %out, align 8, !tbaa !8
  %90 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %pix116 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %90, i32 0, i32 2
  %91 = load %struct.TPixel*, %struct.TPixel** %pix116, align 8, !tbaa !13
  %92 = load i8*, i8** %plte, align 8, !tbaa !8
  call void @depalette(i32 %86, i32 %88, i8* %89, %struct.TPixel* %91, i8* %92)
  br label %if.end120

if.else:                                          ; preds = %if.end106
  %93 = load i32, i32* %bpp, align 4, !tbaa !4
  %94 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %w117 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %94, i32 0, i32 0
  %95 = load i32, i32* %w117, align 8, !tbaa !10
  %96 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %h118 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %96, i32 0, i32 1
  %97 = load i32, i32* %h118, align 4, !tbaa !12
  %98 = load i8*, i8** %out, align 8, !tbaa !8
  %99 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %pix119 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %99, i32 0, i32 2
  %100 = load %struct.TPixel*, %struct.TPixel** %pix119, align 8, !tbaa !13
  call void @convert(i32 %93, i32 %95, i32 %97, i8* %98, %struct.TPixel* %100)
  br label %if.end120

if.end120:                                        ; preds = %if.else, %if.end113
  %101 = load i8*, i8** %data, align 8, !tbaa !8
  call void @free(i8* %101)
  %102 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  store %struct.Tigr* %102, %struct.Tigr** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup127

err:                                              ; preds = %if.then111, %if.then104, %if.then98, %if.then85, %if.then66, %if.then40, %if.then21, %sw.default, %if.then5, %if.then
  %103 = load i8*, i8** %data, align 8, !tbaa !8
  %tobool121 = icmp ne i8* %103, null
  br i1 %tobool121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %err
  %104 = load i8*, i8** %data, align 8, !tbaa !8
  call void @free(i8* %104)
  br label %if.end123

if.end123:                                        ; preds = %if.then122, %err
  %105 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %tobool124 = icmp ne %struct.Tigr* %105, null
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end123
  %106 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  call void @tigrFree(%struct.Tigr* %106)
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %if.end123
  store %struct.Tigr* null, %struct.Tigr** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup127

cleanup127:                                       ; preds = %if.end126, %if.end120
  %107 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %107) #11
  %108 = bitcast i8** %out to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %108) #11
  %109 = bitcast i8** %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %109) #11
  %110 = bitcast i32* %datalen to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %110) #11
  %111 = bitcast i32* %bpp to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %111) #11
  %112 = bitcast i32* %ctype to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %112) #11
  %113 = bitcast i32* %depth to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %113) #11
  %114 = bitcast i8** %first to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %114) #11
  %115 = bitcast i8** %plte to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %115) #11
  %116 = bitcast i8** %idat to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %116) #11
  %117 = bitcast i8** %ihdr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %117) #11
  %118 = load %struct.Tigr*, %struct.Tigr** %retval, align 8
  ret %struct.Tigr* %118

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define %struct.Tigr* @tigrLoadImage(i8* %fileName) #0 {
entry:
  %retval = alloca %struct.Tigr*, align 8
  %fileName.addr = alloca i8*, align 8
  %len = alloca i32, align 4
  %data = alloca i8*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i8* %fileName, i8** %fileName.addr, align 8, !tbaa !8
  %0 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i8** %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load i8*, i8** %fileName.addr, align 8, !tbaa !8
  %call = call i8* @tigrReadFile(i8* %3, i32* %len)
  store i8* %call, i8** %data, align 8, !tbaa !8
  %4 = load i8*, i8** %data, align 8, !tbaa !8
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.Tigr* null, %struct.Tigr** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i8*, i8** %data, align 8, !tbaa !8
  %6 = load i32, i32* %len, align 4, !tbaa !4
  %call1 = call %struct.Tigr* @tigrLoadImageMem(i8* %5, i32 %6)
  store %struct.Tigr* %call1, %struct.Tigr** %bmp, align 8, !tbaa !8
  %7 = load i8*, i8** %data, align 8, !tbaa !8
  call void @free(i8* %7)
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  store %struct.Tigr* %8, %struct.Tigr** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %9 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  %10 = bitcast i8** %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  %11 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #11
  %12 = load %struct.Tigr*, %struct.Tigr** %retval, align 8
  ret %struct.Tigr* %12
}

; Function Attrs: nounwind ssp uwtable
define i8* @tigrReadFile(i8* %fileName, i32* %length) #0 {
entry:
  %retval = alloca i8*, align 8
  %fileName.addr = alloca i8*, align 8
  %length.addr = alloca i32*, align 8
  %file = alloca %struct.__sFILE*, align 8
  %data = alloca i8*, align 8
  %len = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i8* %fileName, i8** %fileName.addr, align 8, !tbaa !8
  store i32* %length, i32** %length.addr, align 8, !tbaa !8
  %0 = bitcast %struct.__sFILE** %file to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast i8** %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast i64* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load i32*, i32** %length.addr, align 8, !tbaa !8
  %tobool = icmp ne i32* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32*, i32** %length.addr, align 8, !tbaa !8
  store i32 0, i32* %4, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8*, i8** %fileName.addr, align 8, !tbaa !8
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %file, align 8, !tbaa !8
  %6 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %tobool1 = icmp ne %struct.__sFILE* %6, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i8* null, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %7 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call4 = call i32 @fseek(%struct.__sFILE* %7, i64 0, i32 2)
  %8 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call5 = call i64 @ftell(%struct.__sFILE* %8)
  store i64 %call5, i64* %len, align 8, !tbaa !26
  %9 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call6 = call i32 @fseek(%struct.__sFILE* %9, i64 0, i32 0)
  %10 = load i64, i64* %len, align 8, !tbaa !26
  %add = add i64 %10, 1
  %call7 = call i8* @malloc(i64 %add) #17
  store i8* %call7, i8** %data, align 8, !tbaa !8
  %11 = load i8*, i8** %data, align 8, !tbaa !8
  %tobool8 = icmp ne i8* %11, null
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end3
  %12 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call10 = call i32 @fclose(%struct.__sFILE* %12)
  store i8* null, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end11:                                         ; preds = %if.end3
  %13 = load i8*, i8** %data, align 8, !tbaa !8
  %14 = load i64, i64* %len, align 8, !tbaa !26
  %15 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call12 = call i64 @fread(i8* %13, i64 1, i64 %14, %struct.__sFILE* %15)
  %16 = load i64, i64* %len, align 8, !tbaa !26
  %cmp = icmp ne i64 %call12, %16
  br i1 %cmp, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %17 = load i8*, i8** %data, align 8, !tbaa !8
  call void @free(i8* %17)
  %18 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call14 = call i32 @fclose(%struct.__sFILE* %18)
  store i8* null, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end15:                                         ; preds = %if.end11
  %19 = load i8*, i8** %data, align 8, !tbaa !8
  %20 = load i64, i64* %len, align 8, !tbaa !26
  %arrayidx = getelementptr inbounds i8, i8* %19, i64 %20
  store i8 0, i8* %arrayidx, align 1, !tbaa !15
  %21 = load %struct.__sFILE*, %struct.__sFILE** %file, align 8, !tbaa !8
  %call16 = call i32 @fclose(%struct.__sFILE* %21)
  %22 = load i32*, i32** %length.addr, align 8, !tbaa !8
  %tobool17 = icmp ne i32* %22, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %23 = load i64, i64* %len, align 8, !tbaa !26
  %conv = trunc i64 %23 to i32
  %24 = load i32*, i32** %length.addr, align 8, !tbaa !8
  store i32 %conv, i32* %24, align 4, !tbaa !4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %25 = load i8*, i8** %data, align 8, !tbaa !8
  store i8* %25, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then13, %if.then9, %if.then2
  %26 = bitcast i64* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %26) #11
  %27 = bitcast i8** %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %27) #11
  %28 = bitcast %struct.__sFILE** %file to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #11
  %29 = load i8*, i8** %retval, align 8
  ret i8* %29
}

; Function Attrs: nounwind ssp uwtable
define void @putbits(%struct.Save* %s, i32 %data, i32 %bitcount) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %data.addr = alloca i32, align 4
  %bitcount.addr = alloca i32, align 4
  %prev = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %data, i32* %data.addr, align 4, !tbaa !4
  store i32 %bitcount, i32* %bitcount.addr, align 4, !tbaa !4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load i32, i32* %bitcount.addr, align 4, !tbaa !4
  %dec = add i32 %0, -1
  store i32 %dec, i32* %bitcount.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = bitcast i32* %prev to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %bits = getelementptr inbounds %struct.Save, %struct.Save* %2, i32 0, i32 2
  %3 = load i32, i32* %bits, align 8, !tbaa !28
  store i32 %3, i32* %prev, align 4, !tbaa !4
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %bits1 = getelementptr inbounds %struct.Save, %struct.Save* %4, i32 0, i32 2
  %5 = load i32, i32* %bits1, align 8, !tbaa !28
  %shr = lshr i32 %5, 1
  %6 = load i32, i32* %data.addr, align 4, !tbaa !4
  %and = and i32 %6, 1
  %shl = shl i32 %and, 7
  %or = or i32 %shr, %shl
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %bits2 = getelementptr inbounds %struct.Save, %struct.Save* %7, i32 0, i32 2
  store i32 %or, i32* %bits2, align 8, !tbaa !28
  %8 = load i32, i32* %data.addr, align 4, !tbaa !4
  %shr3 = lshr i32 %8, 1
  store i32 %shr3, i32* %data.addr, align 4, !tbaa !4
  %9 = load i32, i32* %prev, align 4, !tbaa !4
  %and4 = and i32 %9, 1
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %11 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %bits6 = getelementptr inbounds %struct.Save, %struct.Save* %11, i32 0, i32 2
  %12 = load i32, i32* %bits6, align 8, !tbaa !28
  call void @put(%struct.Save* %10, i32 %12)
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %bits7 = getelementptr inbounds %struct.Save, %struct.Save* %13, i32 0, i32 2
  store i32 128, i32* %bits7, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %14 = bitcast i32* %prev to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #11
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @put(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %v, i32* %v.addr, align 4, !tbaa !4
  %0 = load i32, i32* %v.addr, align 4, !tbaa !4
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %out = getelementptr inbounds %struct.Save, %struct.Save* %1, i32 0, i32 5
  %2 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !30
  %call = call i32 @fputc(i32 %0, %struct.__sFILE* %2)
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %3, i32 0, i32 0
  %4 = load i32, i32* %crc, align 8, !tbaa !31
  %shr = lshr i32 %4, 4
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc1 = getelementptr inbounds %struct.Save, %struct.Save* %5, i32 0, i32 0
  %6 = load i32, i32* %crc1, align 8, !tbaa !31
  %and = and i32 %6, 15
  %7 = load i32, i32* %v.addr, align 4, !tbaa !4
  %and2 = and i32 %7, 15
  %xor = xor i32 %and, %and2
  %idxprom = zext i32 %xor to i64
  %arrayidx = getelementptr inbounds [16 x i32], [16 x i32]* @crctable, i64 0, i64 %idxprom
  %8 = load i32, i32* %arrayidx, align 4, !tbaa !4
  %xor3 = xor i32 %shr, %8
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc4 = getelementptr inbounds %struct.Save, %struct.Save* %9, i32 0, i32 0
  store i32 %xor3, i32* %crc4, align 8, !tbaa !31
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc5 = getelementptr inbounds %struct.Save, %struct.Save* %10, i32 0, i32 0
  %11 = load i32, i32* %crc5, align 8, !tbaa !31
  %shr6 = lshr i32 %11, 4
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc7 = getelementptr inbounds %struct.Save, %struct.Save* %12, i32 0, i32 0
  %13 = load i32, i32* %crc7, align 8, !tbaa !31
  %and8 = and i32 %13, 15
  %14 = load i32, i32* %v.addr, align 4, !tbaa !4
  %shr9 = lshr i32 %14, 4
  %xor10 = xor i32 %and8, %shr9
  %idxprom11 = zext i32 %xor10 to i64
  %arrayidx12 = getelementptr inbounds [16 x i32], [16 x i32]* @crctable, i64 0, i64 %idxprom11
  %15 = load i32, i32* %arrayidx12, align 4, !tbaa !4
  %xor13 = xor i32 %shr6, %15
  %16 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc14 = getelementptr inbounds %struct.Save, %struct.Save* %16, i32 0, i32 0
  store i32 %xor13, i32* %crc14, align 8, !tbaa !31
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @putbitsr(%struct.Save* %s, i32 %data, i32 %bitcount) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %data.addr = alloca i32, align 4
  %bitcount.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %data, i32* %data.addr, align 4, !tbaa !4
  store i32 %bitcount, i32* %bitcount.addr, align 4, !tbaa !4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %bitcount.addr, align 4, !tbaa !4
  %dec = add i32 %0, -1
  store i32 %dec, i32* %bitcount.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %2 = load i32, i32* %data.addr, align 4, !tbaa !4
  %3 = load i32, i32* %bitcount.addr, align 4, !tbaa !4
  %shr = lshr i32 %2, %3
  call void @putbits(%struct.Save* %1, i32 %shr, i32 1)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrSaveImage(i8* %fileName, %struct.Tigr* %bmp) #0 {
entry:
  %retval = alloca i32, align 4
  %fileName.addr = alloca i8*, align 8
  %bmp.addr = alloca %struct.Tigr*, align 8
  %s = alloca %struct.Save, align 8
  %dataPos = alloca i64, align 8
  %dataSize = alloca i64, align 8
  %err = alloca i64, align 8
  %out = alloca %struct.__sFILE*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i8* %fileName, i8** %fileName.addr, align 8, !tbaa !8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = bitcast %struct.Save* %s to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* %0) #11
  %1 = bitcast i64* %dataPos to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast i64* %dataSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = bitcast i64* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = bitcast %struct.__sFILE** %out to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load i8*, i8** %fileName.addr, align 8, !tbaa !8
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %out, align 8, !tbaa !8
  %6 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !8
  %tobool = icmp ne %struct.__sFILE* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %7 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !8
  %out1 = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 5
  store %struct.__sFILE* %7, %struct.__sFILE** %out1, align 8, !tbaa !30
  %adler = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 1
  store i32 1, i32* %adler, align 4, !tbaa !32
  %bits = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 2
  store i32 128, i32* %bits, align 8, !tbaa !28
  %prev = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 3
  store i32 65535, i32* %prev, align 4, !tbaa !33
  %runlen = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 4
  store i32 0, i32* %runlen, align 8, !tbaa !34
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  call void @savePngHeader(%struct.Save* %s, %struct.Tigr* %8)
  %out2 = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 5
  %9 = load %struct.__sFILE*, %struct.__sFILE** %out2, align 8, !tbaa !30
  %call3 = call i64 @ftell(%struct.__sFILE* %9)
  store i64 %call3, i64* %dataPos, align 8, !tbaa !26
  %10 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %11 = load i64, i64* %dataPos, align 8, !tbaa !26
  %call4 = call i64 @savePngData(%struct.Save* %s, %struct.Tigr* %10, i64 %11)
  store i64 %call4, i64* %dataSize, align 8, !tbaa !26
  call void @begin(%struct.Save* %s, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i32 0, i32 0), i32 0)
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %s, i32 0, i32 0
  %12 = load i32, i32* %crc, align 8, !tbaa !31
  %neg = xor i32 %12, -1
  call void @put32(%struct.Save* %s, i32 %neg)
  %13 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !8
  %14 = load i64, i64* %dataPos, align 8, !tbaa !26
  %call5 = call i32 @fseek(%struct.__sFILE* %13, i64 %14, i32 0)
  %15 = load i64, i64* %dataSize, align 8, !tbaa !26
  %conv = trunc i64 %15 to i32
  call void @put32(%struct.Save* %s, i32 %conv)
  %16 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !8
  %call6 = call i32 @ferror(%struct.__sFILE* %16)
  %conv7 = sext i32 %call6 to i64
  store i64 %conv7, i64* %err, align 8, !tbaa !26
  %17 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !8
  %call8 = call i32 @fclose(%struct.__sFILE* %17)
  %18 = load i64, i64* %err, align 8, !tbaa !26
  %tobool9 = icmp ne i64 %18, 0
  %lnot = xor i1 %tobool9, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %19 = bitcast %struct.__sFILE** %out to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %19) #11
  %20 = bitcast i64* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #11
  %21 = bitcast i64* %dataSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %21) #11
  %22 = bitcast i64* %dataPos to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #11
  %23 = bitcast %struct.Save* %s to i8*
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* %23) #11
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #5

; Function Attrs: nounwind ssp uwtable
define internal void @savePngHeader(%struct.Save* %s, %struct.Tigr* %bmp) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %out = getelementptr inbounds %struct.Save, %struct.Save* %0, i32 0, i32 5
  %1 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !30
  %call = call i64 @"\01_fwrite"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.98, i32 0, i32 0), i64 8, i64 1, %struct.__sFILE* %1)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @begin(%struct.Save* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i32 13)
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 0
  %5 = load i32, i32* %w, align 8, !tbaa !10
  call void @put32(%struct.Save* %3, i32 %5)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %7, i32 0, i32 1
  %8 = load i32, i32* %h, align 4, !tbaa !12
  call void @put32(%struct.Save* %6, i32 %8)
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %9, i32 8)
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %10, i32 6)
  %11 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %11, i32 0)
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %12, i32 0)
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %13, i32 0)
  %14 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %15 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %15, i32 0, i32 0
  %16 = load i32, i32* %crc, align 8, !tbaa !31
  %neg = xor i32 %16, -1
  call void @put32(%struct.Save* %14, i32 %neg)
  ret void
}

declare i64 @ftell(%struct.__sFILE*) #5

; Function Attrs: nounwind ssp uwtable
define internal i64 @savePngData(%struct.Save* %s, %struct.Tigr* %bmp, i64 %dataPos) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %bmp.addr = alloca %struct.Tigr*, align 8
  %dataPos.addr = alloca i64, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %dataSize = alloca i64, align 8
  %row = alloca %struct.TPixel*, align 8
  %prev = alloca %struct.TPixel, align 1
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i64 %dataPos, i64* %dataPos.addr, align 8, !tbaa !26
  %0 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %y to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i64* %dataSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @begin(%struct.Save* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i32 0)
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %4, i32 8)
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @put(%struct.Save* %5, i32 29)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @putbits(%struct.Save* %6, i32 3, i32 3)
  store i32 0, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc33, %entry
  %7 = load i32, i32* %y, align 4, !tbaa !4
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %8, i32 0, i32 1
  %9 = load i32, i32* %h, align 4, !tbaa !12
  %cmp = icmp slt i32 %7, %9
  br i1 %cmp, label %for.body, label %for.end35

for.body:                                         ; preds = %for.cond
  %10 = bitcast %struct.TPixel** %row to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #11
  %11 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %11, i32 0, i32 2
  %12 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %13 = load i32, i32* %y, align 4, !tbaa !4
  %14 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %14, i32 0, i32 0
  %15 = load i32, i32* %w, align 8, !tbaa !10
  %mul = mul nsw i32 %13, %15
  %idxprom = sext i32 %mul to i64
  %arrayidx = getelementptr inbounds %struct.TPixel, %struct.TPixel* %12, i64 %idxprom
  store %struct.TPixel* %arrayidx, %struct.TPixel** %row, align 8, !tbaa !8
  %16 = bitcast %struct.TPixel* %prev to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %16) #11
  %call = call i32 @tigrRGBA(i8 zeroext 0, i8 zeroext 0, i8 zeroext 0, i8 zeroext 0)
  %17 = bitcast %struct.TPixel* %prev to i32*
  store i32 %call, i32* %17, align 1
  %18 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @encodeByte(%struct.Save* %18, i8 zeroext 1)
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %19 = load i32, i32* %x, align 4, !tbaa !4
  %20 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w2 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %20, i32 0, i32 0
  %21 = load i32, i32* %w2, align 8, !tbaa !10
  %cmp3 = icmp slt i32 %19, %21
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %22 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %23 = load %struct.TPixel*, %struct.TPixel** %row, align 8, !tbaa !8
  %24 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom5 = sext i32 %24 to i64
  %arrayidx6 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %23, i64 %idxprom5
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx6, i32 0, i32 2
  %25 = load i8, i8* %r, align 1, !tbaa !18
  %conv = zext i8 %25 to i32
  %r7 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 2
  %26 = load i8, i8* %r7, align 1, !tbaa !18
  %conv8 = zext i8 %26 to i32
  %sub = sub nsw i32 %conv, %conv8
  %conv9 = trunc i32 %sub to i8
  call void @encodeByte(%struct.Save* %22, i8 zeroext %conv9)
  %27 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %28 = load %struct.TPixel*, %struct.TPixel** %row, align 8, !tbaa !8
  %29 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom10 = sext i32 %29 to i64
  %arrayidx11 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %28, i64 %idxprom10
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx11, i32 0, i32 1
  %30 = load i8, i8* %g, align 1, !tbaa !19
  %conv12 = zext i8 %30 to i32
  %g13 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 1
  %31 = load i8, i8* %g13, align 1, !tbaa !19
  %conv14 = zext i8 %31 to i32
  %sub15 = sub nsw i32 %conv12, %conv14
  %conv16 = trunc i32 %sub15 to i8
  call void @encodeByte(%struct.Save* %27, i8 zeroext %conv16)
  %32 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %33 = load %struct.TPixel*, %struct.TPixel** %row, align 8, !tbaa !8
  %34 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom17 = sext i32 %34 to i64
  %arrayidx18 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %33, i64 %idxprom17
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx18, i32 0, i32 0
  %35 = load i8, i8* %b, align 1, !tbaa !20
  %conv19 = zext i8 %35 to i32
  %b20 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 0
  %36 = load i8, i8* %b20, align 1, !tbaa !20
  %conv21 = zext i8 %36 to i32
  %sub22 = sub nsw i32 %conv19, %conv21
  %conv23 = trunc i32 %sub22 to i8
  call void @encodeByte(%struct.Save* %32, i8 zeroext %conv23)
  %37 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %38 = load %struct.TPixel*, %struct.TPixel** %row, align 8, !tbaa !8
  %39 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom24 = sext i32 %39 to i64
  %arrayidx25 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %38, i64 %idxprom24
  %a = getelementptr inbounds %struct.TPixel, %struct.TPixel* %arrayidx25, i32 0, i32 3
  %40 = load i8, i8* %a, align 1, !tbaa !16
  %conv26 = zext i8 %40 to i32
  %a27 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %prev, i32 0, i32 3
  %41 = load i8, i8* %a27, align 1, !tbaa !16
  %conv28 = zext i8 %41 to i32
  %sub29 = sub nsw i32 %conv26, %conv28
  %conv30 = trunc i32 %sub29 to i8
  call void @encodeByte(%struct.Save* %37, i8 zeroext %conv30)
  %42 = load %struct.TPixel*, %struct.TPixel** %row, align 8, !tbaa !8
  %43 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom31 = sext i32 %43 to i64
  %arrayidx32 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %42, i64 %idxprom31
  %44 = bitcast %struct.TPixel* %prev to i8*
  %45 = bitcast %struct.TPixel* %arrayidx32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %44, i8* align 1 %45, i64 4, i1 false), !tbaa.struct !14
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %46 = load i32, i32* %x, align 4, !tbaa !4
  %inc = add nsw i32 %46, 1
  store i32 %inc, i32* %x, align 4, !tbaa !4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %47 = bitcast %struct.TPixel* %prev to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %47) #11
  %48 = bitcast %struct.TPixel** %row to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #11
  br label %for.inc33

for.inc33:                                        ; preds = %for.end
  %49 = load i32, i32* %y, align 4, !tbaa !4
  %inc34 = add nsw i32 %49, 1
  store i32 %inc34, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.end35:                                        ; preds = %for.cond
  %50 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @endrun(%struct.Save* %50)
  %51 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @literal(%struct.Save* %51, i32 256)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end35
  %52 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %bits = getelementptr inbounds %struct.Save, %struct.Save* %52, i32 0, i32 2
  %53 = load i32, i32* %bits, align 8, !tbaa !28
  %cmp36 = icmp ne i32 %53, 128
  br i1 %cmp36, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %54 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @putbits(%struct.Save* %54, i32 0, i32 1)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %55 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %56 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %adler = getelementptr inbounds %struct.Save, %struct.Save* %56, i32 0, i32 1
  %57 = load i32, i32* %adler, align 4, !tbaa !32
  call void @put32(%struct.Save* %55, i32 %57)
  %58 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %out = getelementptr inbounds %struct.Save, %struct.Save* %58, i32 0, i32 5
  %59 = load %struct.__sFILE*, %struct.__sFILE** %out, align 8, !tbaa !30
  %call38 = call i64 @ftell(%struct.__sFILE* %59)
  %60 = load i64, i64* %dataPos.addr, align 8, !tbaa !26
  %sub39 = sub nsw i64 %call38, %60
  %sub40 = sub nsw i64 %sub39, 8
  store i64 %sub40, i64* %dataSize, align 8, !tbaa !26
  %61 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %62 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %62, i32 0, i32 0
  %63 = load i32, i32* %crc, align 8, !tbaa !31
  %neg = xor i32 %63, -1
  call void @put32(%struct.Save* %61, i32 %neg)
  %64 = load i64, i64* %dataSize, align 8, !tbaa !26
  %65 = bitcast i64* %dataSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %65) #11
  %66 = bitcast i32* %y to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %66) #11
  %67 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %67) #11
  ret i64 %64
}

; Function Attrs: nounwind ssp uwtable
define internal void @begin(%struct.Save* %s, i8* %id, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %id.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i8* %id, i8** %id.addr, align 8, !tbaa !8
  store i32 %len, i32* %len.addr, align 4, !tbaa !4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %1 = load i32, i32* %len.addr, align 4, !tbaa !4
  call void @put32(%struct.Save* %0, i32 %1)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %crc = getelementptr inbounds %struct.Save, %struct.Save* %2, i32 0, i32 0
  store i32 -1, i32* %crc, align 8, !tbaa !31
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %4 = load i8*, i8** %id.addr, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv = sext i8 %5 to i32
  call void @put(%struct.Save* %3, i32 %conv)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %7 = load i8*, i8** %id.addr, align 8, !tbaa !8
  %arrayidx1 = getelementptr inbounds i8, i8* %7, i64 1
  %8 = load i8, i8* %arrayidx1, align 1, !tbaa !15
  %conv2 = sext i8 %8 to i32
  call void @put(%struct.Save* %6, i32 %conv2)
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %10 = load i8*, i8** %id.addr, align 8, !tbaa !8
  %arrayidx3 = getelementptr inbounds i8, i8* %10, i64 2
  %11 = load i8, i8* %arrayidx3, align 1, !tbaa !15
  %conv4 = sext i8 %11 to i32
  call void @put(%struct.Save* %9, i32 %conv4)
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %13 = load i8*, i8** %id.addr, align 8, !tbaa !8
  %arrayidx5 = getelementptr inbounds i8, i8* %13, i64 3
  %14 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %conv6 = sext i8 %14 to i32
  call void @put(%struct.Save* %12, i32 %conv6)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @put32(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %v, i32* %v.addr, align 4, !tbaa !4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %1 = load i32, i32* %v.addr, align 4, !tbaa !4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 255
  call void @put(%struct.Save* %0, i32 %and)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %3 = load i32, i32* %v.addr, align 4, !tbaa !4
  %shr1 = lshr i32 %3, 16
  %and2 = and i32 %shr1, 255
  call void @put(%struct.Save* %2, i32 %and2)
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %5 = load i32, i32* %v.addr, align 4, !tbaa !4
  %shr3 = lshr i32 %5, 8
  %and4 = and i32 %shr3, 255
  call void @put(%struct.Save* %4, i32 %and4)
  %6 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %7 = load i32, i32* %v.addr, align 4, !tbaa !4
  %and5 = and i32 %7, 255
  call void @put(%struct.Save* %6, i32 %and5)
  ret void
}

declare i32 @fseek(%struct.__sFILE*, i64, i32) #5

declare i32 @ferror(%struct.__sFILE*) #5

declare i32 @fclose(%struct.__sFILE*) #5

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #8

declare i64 @fread(i8*, i64, i64, %struct.__sFILE*) #5

; Function Attrs: nounwind ssp uwtable
define i8* @tigrDecodeUTF8(i8* %text, i32* %cp) #0 {
entry:
  %text.addr = alloca i8*, align 8
  %cp.addr = alloca i32*, align 8
  %c = alloca i8, align 1
  %extra = alloca i32, align 4
  %min = alloca i32, align 4
  store i8* %text, i8** %text.addr, align 8, !tbaa !8
  store i32* %cp, i32** %cp.addr, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #11
  %0 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 1
  store i8* %incdec.ptr, i8** %text.addr, align 8, !tbaa !8
  %1 = load i8, i8* %0, align 1, !tbaa !15
  store i8 %1, i8* %c, align 1, !tbaa !15
  %2 = bitcast i32* %extra to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  store i32 0, i32* %extra, align 4, !tbaa !4
  %3 = bitcast i32* %min to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  store i32 0, i32* %min, align 4, !tbaa !4
  %4 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 0, i32* %4, align 4, !tbaa !4
  %5 = load i8, i8* %c, align 1, !tbaa !15
  %conv = zext i8 %5 to i32
  %cmp = icmp sge i32 %conv, 240
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i8, i8* %c, align 1, !tbaa !15
  %conv2 = zext i8 %6 to i32
  %and = and i32 %conv2, 7
  %7 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 %and, i32* %7, align 4, !tbaa !4
  store i32 3, i32* %extra, align 4, !tbaa !4
  store i32 65536, i32* %min, align 4, !tbaa !4
  br label %if.end25

if.else:                                          ; preds = %entry
  %8 = load i8, i8* %c, align 1, !tbaa !15
  %conv3 = zext i8 %8 to i32
  %cmp4 = icmp sge i32 %conv3, 224
  br i1 %cmp4, label %if.then6, label %if.else9

if.then6:                                         ; preds = %if.else
  %9 = load i8, i8* %c, align 1, !tbaa !15
  %conv7 = zext i8 %9 to i32
  %and8 = and i32 %conv7, 15
  %10 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 %and8, i32* %10, align 4, !tbaa !4
  store i32 2, i32* %extra, align 4, !tbaa !4
  store i32 2048, i32* %min, align 4, !tbaa !4
  br label %if.end24

if.else9:                                         ; preds = %if.else
  %11 = load i8, i8* %c, align 1, !tbaa !15
  %conv10 = zext i8 %11 to i32
  %cmp11 = icmp sge i32 %conv10, 192
  br i1 %cmp11, label %if.then13, label %if.else16

if.then13:                                        ; preds = %if.else9
  %12 = load i8, i8* %c, align 1, !tbaa !15
  %conv14 = zext i8 %12 to i32
  %and15 = and i32 %conv14, 31
  %13 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 %and15, i32* %13, align 4, !tbaa !4
  store i32 1, i32* %extra, align 4, !tbaa !4
  store i32 128, i32* %min, align 4, !tbaa !4
  br label %if.end23

if.else16:                                        ; preds = %if.else9
  %14 = load i8, i8* %c, align 1, !tbaa !15
  %conv17 = zext i8 %14 to i32
  %cmp18 = icmp sge i32 %conv17, 128
  br i1 %cmp18, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.else16
  %15 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 65533, i32* %15, align 4, !tbaa !4
  br label %if.end

if.else21:                                        ; preds = %if.else16
  %16 = load i8, i8* %c, align 1, !tbaa !15
  %conv22 = zext i8 %16 to i32
  %17 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 %conv22, i32* %17, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.else21, %if.then20
  br label %if.end23

if.end23:                                         ; preds = %if.end, %if.then13
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then6
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then
  br label %while.cond

while.cond:                                       ; preds = %if.end32, %if.end25
  %18 = load i32, i32* %extra, align 4, !tbaa !4
  %dec = add nsw i32 %18, -1
  store i32 %dec, i32* %extra, align 4, !tbaa !4
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr26 = getelementptr inbounds i8, i8* %19, i32 1
  store i8* %incdec.ptr26, i8** %text.addr, align 8, !tbaa !8
  %20 = load i8, i8* %19, align 1, !tbaa !15
  store i8 %20, i8* %c, align 1, !tbaa !15
  %21 = load i8, i8* %c, align 1, !tbaa !15
  %conv27 = zext i8 %21 to i32
  %and28 = and i32 %conv27, 192
  %cmp29 = icmp ne i32 %and28, 128
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %while.body
  %22 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 65533, i32* %22, align 4, !tbaa !4
  br label %while.end

if.end32:                                         ; preds = %while.body
  %23 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  %24 = load i32, i32* %23, align 4, !tbaa !4
  %shl = shl i32 %24, 6
  %25 = load i8, i8* %c, align 1, !tbaa !15
  %conv33 = zext i8 %25 to i32
  %and34 = and i32 %conv33, 63
  %or = or i32 %shl, %and34
  %26 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 %or, i32* %26, align 4, !tbaa !4
  br label %while.cond

while.end:                                        ; preds = %if.then31, %while.cond
  %27 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  %28 = load i32, i32* %27, align 4, !tbaa !4
  %29 = load i32, i32* %min, align 4, !tbaa !4
  %cmp35 = icmp slt i32 %28, %29
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %while.end
  %30 = load i32*, i32** %cp.addr, align 8, !tbaa !8
  store i32 65533, i32* %30, align 4, !tbaa !4
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %while.end
  %31 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %32 = bitcast i32* %min to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #11
  %33 = bitcast i32* %extra to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #11
  ret i8* %31
}

; Function Attrs: nounwind ssp uwtable
define i8* @tigrEncodeUTF8(i8* %text, i32 %cp) #0 {
entry:
  %text.addr = alloca i8*, align 8
  %cp.addr = alloca i32, align 4
  store i8* %text, i8** %text.addr, align 8, !tbaa !8
  store i32 %cp, i32* %cp.addr, align 4, !tbaa !4
  %0 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %cmp1 = icmp sgt i32 %1, 1114111
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 65533, i32* %cp.addr, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %2 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %cmp2 = icmp slt i32 %2, 128
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr = ashr i32 %3, 0
  %and = and i32 %shr, 127
  %or = or i32 0, %and
  %conv = trunc i32 %or to i8
  %4 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv, i8* %4, align 1, !tbaa !15
  br label %if.end59

if.else:                                          ; preds = %if.end
  %5 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %cmp4 = icmp slt i32 %5, 2048
  br i1 %cmp4, label %if.then6, label %if.else17

if.then6:                                         ; preds = %if.else
  %6 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr7 = ashr i32 %6, 6
  %and8 = and i32 %shr7, 31
  %or9 = or i32 192, %and8
  %conv10 = trunc i32 %or9 to i8
  %7 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr11 = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr11, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv10, i8* %7, align 1, !tbaa !15
  %8 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr12 = ashr i32 %8, 0
  %and13 = and i32 %shr12, 63
  %or14 = or i32 128, %and13
  %conv15 = trunc i32 %or14 to i8
  %9 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr16 = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr16, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv15, i8* %9, align 1, !tbaa !15
  br label %if.end58

if.else17:                                        ; preds = %if.else
  %10 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %cmp18 = icmp slt i32 %10, 65536
  br i1 %cmp18, label %if.then20, label %if.else36

if.then20:                                        ; preds = %if.else17
  %11 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr21 = ashr i32 %11, 12
  %and22 = and i32 %shr21, 15
  %or23 = or i32 224, %and22
  %conv24 = trunc i32 %or23 to i8
  %12 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr25 = getelementptr inbounds i8, i8* %12, i32 1
  store i8* %incdec.ptr25, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv24, i8* %12, align 1, !tbaa !15
  %13 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr26 = ashr i32 %13, 6
  %and27 = and i32 %shr26, 63
  %or28 = or i32 128, %and27
  %conv29 = trunc i32 %or28 to i8
  %14 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr30 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr30, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv29, i8* %14, align 1, !tbaa !15
  %15 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr31 = ashr i32 %15, 0
  %and32 = and i32 %shr31, 63
  %or33 = or i32 128, %and32
  %conv34 = trunc i32 %or33 to i8
  %16 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr35 = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr35, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv34, i8* %16, align 1, !tbaa !15
  br label %if.end57

if.else36:                                        ; preds = %if.else17
  %17 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr37 = ashr i32 %17, 18
  %and38 = and i32 %shr37, 7
  %or39 = or i32 240, %and38
  %conv40 = trunc i32 %or39 to i8
  %18 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr41 = getelementptr inbounds i8, i8* %18, i32 1
  store i8* %incdec.ptr41, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv40, i8* %18, align 1, !tbaa !15
  %19 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr42 = ashr i32 %19, 12
  %and43 = and i32 %shr42, 63
  %or44 = or i32 128, %and43
  %conv45 = trunc i32 %or44 to i8
  %20 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr46 = getelementptr inbounds i8, i8* %20, i32 1
  store i8* %incdec.ptr46, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv45, i8* %20, align 1, !tbaa !15
  %21 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr47 = ashr i32 %21, 6
  %and48 = and i32 %shr47, 63
  %or49 = or i32 128, %and48
  %conv50 = trunc i32 %or49 to i8
  %22 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr51 = getelementptr inbounds i8, i8* %22, i32 1
  store i8* %incdec.ptr51, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv50, i8* %22, align 1, !tbaa !15
  %23 = load i32, i32* %cp.addr, align 4, !tbaa !4
  %shr52 = ashr i32 %23, 0
  %and53 = and i32 %shr52, 63
  %or54 = or i32 128, %and53
  %conv55 = trunc i32 %or54 to i8
  %24 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %incdec.ptr56 = getelementptr inbounds i8, i8* %24, i32 1
  store i8* %incdec.ptr56, i8** %text.addr, align 8, !tbaa !8
  store i8 %conv55, i8* %24, align 1, !tbaa !15
  br label %if.end57

if.end57:                                         ; preds = %if.else36, %if.then20
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.then6
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then3
  %25 = load i8*, i8** %text.addr, align 8, !tbaa !8
  ret i8* %25
}

; Function Attrs: nounwind ssp uwtable
define void @tigrSetPostFX(%struct.Tigr* %bmp, i32 %hblur, i32 %vblur, float %scanlines, float %contrast) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %hblur.addr = alloca i32, align 4
  %vblur.addr = alloca i32, align 4
  %scanlines.addr = alloca float, align 4
  %contrast.addr = alloca float, align 4
  %win = alloca %struct.TigrInternal*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %hblur, i32* %hblur.addr, align 4, !tbaa !4
  store i32 %vblur, i32* %vblur.addr, align 4, !tbaa !4
  store float %scanlines, float* %scanlines.addr, align 4, !tbaa !21
  store float %contrast, float* %contrast.addr, align 4, !tbaa !21
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %1)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %2 = load i32, i32* %hblur.addr, align 4, !tbaa !4
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %hblur1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %3, i32 0, i32 8
  store i32 %2, i32* %hblur1, align 4, !tbaa !35
  %4 = load i32, i32* %vblur.addr, align 4, !tbaa !4
  %5 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %vblur2 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %5, i32 0, i32 9
  store i32 %4, i32* %vblur2, align 8, !tbaa !38
  %6 = load float, float* %scanlines.addr, align 4, !tbaa !21
  %7 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scanlines3 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %7, i32 0, i32 10
  store float %6, float* %scanlines3, align 4, !tbaa !39
  %8 = load float, float* %contrast.addr, align 4, !tbaa !21
  %9 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %contrast4 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %9, i32 0, i32 11
  store float %8, float* %contrast4, align 8, !tbaa !40
  %10 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define %struct.TigrInternal* @tigrInternal(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %0, i32 0, i32 3
  %1 = load i8*, i8** %handle, align 8, !tbaa !41
  %tobool = icmp ne i8* %1, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool1 = icmp ne i64 %expval, 0
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.tigrInternal, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 2107, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.5, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %2
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i64 1
  %4 = bitcast %struct.Tigr* %add.ptr to %struct.TigrInternal*
  ret %struct.TigrInternal* %4
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrInflate(i8* %out, i32 %outlen, i8* %in, i32 %inlen) #0 {
entry:
  %retval = alloca i32, align 4
  %out.addr = alloca i8*, align 8
  %outlen.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 8
  %inlen.addr = alloca i32, align 4
  %last = alloca i32, align 4
  %s = alloca %struct.State*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 8, !tbaa !8
  store i32 %outlen, i32* %outlen.addr, align 4, !tbaa !4
  store i8* %in, i8** %in.addr, align 8, !tbaa !8
  store i32 %inlen, i32* %inlen.addr, align 4, !tbaa !4
  %0 = bitcast i32* %last to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast %struct.State** %s to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %call = call i8* @calloc(i64 1, i64 1560) #15
  %2 = bitcast i8* %call to %struct.State*
  store %struct.State* %2, %struct.State** %s, align 8, !tbaa !8
  %3 = load i8*, i8** %in.addr, align 8, !tbaa !8
  %4 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %in1 = getelementptr inbounds %struct.State, %struct.State* %4, i32 0, i32 2
  store i8* %3, i8** %in1, align 8, !tbaa !42
  %5 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %in2 = getelementptr inbounds %struct.State, %struct.State* %5, i32 0, i32 2
  %6 = load i8*, i8** %in2, align 8, !tbaa !42
  %7 = load i32, i32* %inlen.addr, align 4, !tbaa !4
  %idx.ext = zext i32 %7 to i64
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %idx.ext
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 2
  %8 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %inend = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 3
  store i8* %add.ptr3, i8** %inend, align 8, !tbaa !44
  %9 = load i8*, i8** %out.addr, align 8, !tbaa !8
  %10 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %out4 = getelementptr inbounds %struct.State, %struct.State* %10, i32 0, i32 4
  store i8* %9, i8** %out4, align 8, !tbaa !45
  %11 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %out5 = getelementptr inbounds %struct.State, %struct.State* %11, i32 0, i32 4
  %12 = load i8*, i8** %out5, align 8, !tbaa !45
  %13 = load i32, i32* %outlen.addr, align 4, !tbaa !4
  %idx.ext6 = zext i32 %13 to i64
  %add.ptr7 = getelementptr inbounds i8, i8* %12, i64 %idx.ext6
  %14 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %outend = getelementptr inbounds %struct.State, %struct.State* %14, i32 0, i32 5
  store i8* %add.ptr7, i8** %outend, align 8, !tbaa !46
  %15 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %bits = getelementptr inbounds %struct.State, %struct.State* %15, i32 0, i32 0
  store i32 0, i32* %bits, align 8, !tbaa !47
  %16 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %count = getelementptr inbounds %struct.State, %struct.State* %16, i32 0, i32 1
  store i32 0, i32* %count, align 4, !tbaa !48
  %17 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %call8 = call i32 @bits(%struct.State* %17, i32 0)
  %18 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %18, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  %call9 = call i32 @setjmp(i32* %arraydecay) #19
  %cmp = icmp eq i32 %call9, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %19 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %20 = bitcast %struct.State* %19 to i8*
  call void @free(i8* %20)
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %21 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %call10 = call i32 @bits(%struct.State* %21, i32 1)
  store i32 %call10, i32* %last, align 4, !tbaa !4
  %22 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %call11 = call i32 @bits(%struct.State* %22, i32 2)
  switch i32 %call11, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb12
    i32 2, label %sw.bb13
    i32 3, label %sw.bb14
  ]

sw.bb:                                            ; preds = %do.body
  %23 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  call void @stored(%struct.State* %23)
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.body
  %24 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  call void @fixed(%struct.State* %24)
  %25 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  call void @block(%struct.State* %25)
  br label %sw.epilog

sw.bb13:                                          ; preds = %do.body
  %26 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  call void @dynamic(%struct.State* %26)
  %27 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  call void @block(%struct.State* %27)
  br label %sw.epilog

sw.bb14:                                          ; preds = %do.body
  %28 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %jmp15 = getelementptr inbounds %struct.State, %struct.State* %28, i32 0, i32 6
  %arraydecay16 = getelementptr inbounds [37 x i32], [37 x i32]* %jmp15, i32 0, i32 0
  call void @longjmp(i32* %arraydecay16, i32 1) #20
  unreachable

sw.epilog:                                        ; preds = %do.body, %sw.bb13, %sw.bb12, %sw.bb
  br label %do.cond

do.cond:                                          ; preds = %sw.epilog
  %29 = load i32, i32* %last, align 4, !tbaa !4
  %tobool = icmp ne i32 %29, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %30 = load %struct.State*, %struct.State** %s, align 8, !tbaa !8
  %31 = bitcast %struct.State* %30 to i8*
  call void @free(i8* %31)
  store i32 1, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  %32 = bitcast %struct.State** %s to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #11
  %33 = bitcast i32* %last to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #11
  %34 = load i32, i32* %retval, align 4
  ret i32 %34
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @bits(%struct.State* %s, i32 %n) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %n.addr = alloca i32, align 4
  %v = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  store i32 %n, i32* %n.addr, align 4, !tbaa !4
  %0 = bitcast i32* %v to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %bits = getelementptr inbounds %struct.State, %struct.State* %1, i32 0, i32 0
  %2 = load i32, i32* %bits, align 8, !tbaa !47
  %3 = load i32, i32* %n.addr, align 4, !tbaa !4
  %shl = shl i32 1, %3
  %sub = sub nsw i32 %shl, 1
  %and = and i32 %2, %sub
  store i32 %and, i32* %v, align 4, !tbaa !4
  %4 = load i32, i32* %n.addr, align 4, !tbaa !4
  %5 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %bits1 = getelementptr inbounds %struct.State, %struct.State* %5, i32 0, i32 0
  %6 = load i32, i32* %bits1, align 8, !tbaa !47
  %shr = lshr i32 %6, %4
  store i32 %shr, i32* %bits1, align 8, !tbaa !47
  %7 = load i32, i32* %n.addr, align 4, !tbaa !4
  %8 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %count = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 1
  %9 = load i32, i32* %count, align 4, !tbaa !48
  %sub2 = sub i32 %9, %7
  store i32 %sub2, i32* %count, align 4, !tbaa !48
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %10 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %count3 = getelementptr inbounds %struct.State, %struct.State* %10, i32 0, i32 1
  %11 = load i32, i32* %count3, align 4, !tbaa !48
  %cmp = icmp ult i32 %11, 16
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %in = getelementptr inbounds %struct.State, %struct.State* %12, i32 0, i32 2
  %13 = load i8*, i8** %in, align 8, !tbaa !42
  %14 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %inend = getelementptr inbounds %struct.State, %struct.State* %14, i32 0, i32 3
  %15 = load i8*, i8** %inend, align 8, !tbaa !44
  %cmp4 = icmp ne i8* %13, %15
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %16 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %16, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #20
  unreachable

if.end:                                           ; preds = %while.body
  %17 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %in5 = getelementptr inbounds %struct.State, %struct.State* %17, i32 0, i32 2
  %18 = load i8*, i8** %in5, align 8, !tbaa !42
  %incdec.ptr = getelementptr inbounds i8, i8* %18, i32 1
  store i8* %incdec.ptr, i8** %in5, align 8, !tbaa !42
  %19 = load i8, i8* %18, align 1, !tbaa !15
  %conv = zext i8 %19 to i32
  %20 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %count6 = getelementptr inbounds %struct.State, %struct.State* %20, i32 0, i32 1
  %21 = load i32, i32* %count6, align 4, !tbaa !48
  %shl7 = shl i32 %conv, %21
  %22 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %bits8 = getelementptr inbounds %struct.State, %struct.State* %22, i32 0, i32 0
  %23 = load i32, i32* %bits8, align 8, !tbaa !47
  %or = or i32 %23, %shl7
  store i32 %or, i32* %bits8, align 8, !tbaa !47
  %24 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %count9 = getelementptr inbounds %struct.State, %struct.State* %24, i32 0, i32 1
  %25 = load i32, i32* %count9, align 4, !tbaa !48
  %add = add i32 %25, 8
  store i32 %add, i32* %count9, align 4, !tbaa !48
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %26 = load i32, i32* %v, align 4, !tbaa !4
  %27 = bitcast i32* %v to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %27) #11
  ret i32 %26
}

; Function Attrs: returns_twice
declare i32 @setjmp(i32*) #9

; Function Attrs: nounwind ssp uwtable
define internal void @stored(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %len = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  %0 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %2 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %count = getelementptr inbounds %struct.State, %struct.State* %2, i32 0, i32 1
  %3 = load i32, i32* %count, align 4, !tbaa !48
  %and = and i32 %3, 7
  %call = call i32 @bits(%struct.State* %1, i32 %and)
  %4 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call1 = call i32 @bits(%struct.State* %4, i32 16)
  store i32 %call1, i32* %len, align 4, !tbaa !4
  %5 = load i32, i32* %len, align 4, !tbaa !4
  %6 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %bits = getelementptr inbounds %struct.State, %struct.State* %6, i32 0, i32 0
  %7 = load i32, i32* %bits, align 8, !tbaa !47
  %xor = xor i32 %5, %7
  %and2 = and i32 %xor, 65535
  %cmp = icmp eq i32 %and2, 65535
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #20
  unreachable

if.end:                                           ; preds = %entry
  %9 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %in = getelementptr inbounds %struct.State, %struct.State* %9, i32 0, i32 2
  %10 = load i8*, i8** %in, align 8, !tbaa !42
  %11 = load i32, i32* %len, align 4, !tbaa !4
  %idx.ext = sext i32 %11 to i64
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 %idx.ext
  %12 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %inend = getelementptr inbounds %struct.State, %struct.State* %12, i32 0, i32 3
  %13 = load i8*, i8** %inend, align 8, !tbaa !44
  %cmp3 = icmp ule i8* %add.ptr, %13
  br i1 %cmp3, label %if.end7, label %if.then4

if.then4:                                         ; preds = %if.end
  %14 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %jmp5 = getelementptr inbounds %struct.State, %struct.State* %14, i32 0, i32 6
  %arraydecay6 = getelementptr inbounds [37 x i32], [37 x i32]* %jmp5, i32 0, i32 0
  call void @longjmp(i32* %arraydecay6, i32 1) #20
  unreachable

if.end7:                                          ; preds = %if.end
  %15 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %16 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %in8 = getelementptr inbounds %struct.State, %struct.State* %16, i32 0, i32 2
  %17 = load i8*, i8** %in8, align 8, !tbaa !42
  %18 = load i32, i32* %len, align 4, !tbaa !4
  call void @copy(%struct.State* %15, i8* %17, i32 %18)
  %19 = load i32, i32* %len, align 4, !tbaa !4
  %20 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %in9 = getelementptr inbounds %struct.State, %struct.State* %20, i32 0, i32 2
  %21 = load i8*, i8** %in9, align 8, !tbaa !42
  %idx.ext10 = sext i32 %19 to i64
  %add.ptr11 = getelementptr inbounds i8, i8* %21, i64 %idx.ext10
  store i8* %add.ptr11, i8** %in9, align 8, !tbaa !42
  %22 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call12 = call i32 @bits(%struct.State* %22, i32 16)
  %23 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @fixed(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %n = alloca i32, align 4
  %lens = alloca [320 x i8], align 16
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  %0 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast [320 x i8]* %lens to i8*
  call void @llvm.lifetime.start.p0i8(i64 320, i8* %1) #11
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %n, align 4, !tbaa !4
  %cmp = icmp sle i32 %2, 143
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom
  store i8 8, i8* %arrayidx, align 1, !tbaa !15
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, i32* %n, align 4, !tbaa !4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 144, i32* %n, align 4, !tbaa !4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc6, %for.end
  %5 = load i32, i32* %n, align 4, !tbaa !4
  %cmp2 = icmp sle i32 %5, 255
  br i1 %cmp2, label %for.body3, label %for.end8

for.body3:                                        ; preds = %for.cond1
  %6 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom4 = sext i32 %6 to i64
  %arrayidx5 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom4
  store i8 9, i8* %arrayidx5, align 1, !tbaa !15
  br label %for.inc6

for.inc6:                                         ; preds = %for.body3
  %7 = load i32, i32* %n, align 4, !tbaa !4
  %inc7 = add nsw i32 %7, 1
  store i32 %inc7, i32* %n, align 4, !tbaa !4
  br label %for.cond1

for.end8:                                         ; preds = %for.cond1
  store i32 256, i32* %n, align 4, !tbaa !4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc14, %for.end8
  %8 = load i32, i32* %n, align 4, !tbaa !4
  %cmp10 = icmp sle i32 %8, 279
  br i1 %cmp10, label %for.body11, label %for.end16

for.body11:                                       ; preds = %for.cond9
  %9 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom12 = sext i32 %9 to i64
  %arrayidx13 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom12
  store i8 7, i8* %arrayidx13, align 1, !tbaa !15
  br label %for.inc14

for.inc14:                                        ; preds = %for.body11
  %10 = load i32, i32* %n, align 4, !tbaa !4
  %inc15 = add nsw i32 %10, 1
  store i32 %inc15, i32* %n, align 4, !tbaa !4
  br label %for.cond9

for.end16:                                        ; preds = %for.cond9
  store i32 280, i32* %n, align 4, !tbaa !4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc22, %for.end16
  %11 = load i32, i32* %n, align 4, !tbaa !4
  %cmp18 = icmp sle i32 %11, 287
  br i1 %cmp18, label %for.body19, label %for.end24

for.body19:                                       ; preds = %for.cond17
  %12 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom20 = sext i32 %12 to i64
  %arrayidx21 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom20
  store i8 8, i8* %arrayidx21, align 1, !tbaa !15
  br label %for.inc22

for.inc22:                                        ; preds = %for.body19
  %13 = load i32, i32* %n, align 4, !tbaa !4
  %inc23 = add nsw i32 %13, 1
  store i32 %inc23, i32* %n, align 4, !tbaa !4
  br label %for.cond17

for.end24:                                        ; preds = %for.cond17
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc30, %for.end24
  %14 = load i32, i32* %n, align 4, !tbaa !4
  %cmp26 = icmp slt i32 %14, 32
  br i1 %cmp26, label %for.body27, label %for.end32

for.body27:                                       ; preds = %for.cond25
  %15 = load i32, i32* %n, align 4, !tbaa !4
  %add = add nsw i32 288, %15
  %idxprom28 = sext i32 %add to i64
  %arrayidx29 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom28
  store i8 5, i8* %arrayidx29, align 1, !tbaa !15
  br label %for.inc30

for.inc30:                                        ; preds = %for.body27
  %16 = load i32, i32* %n, align 4, !tbaa !4
  %inc31 = add nsw i32 %16, 1
  store i32 %inc31, i32* %n, align 4, !tbaa !4
  br label %for.cond25

for.end32:                                        ; preds = %for.cond25
  %17 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %18 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %litcodes = getelementptr inbounds %struct.State, %struct.State* %18, i32 0, i32 7
  %arraydecay = getelementptr inbounds [288 x i32], [288 x i32]* %litcodes, i32 0, i32 0
  %arraydecay33 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %call = call i32 @build(%struct.State* %17, i32* %arraydecay, i8* %arraydecay33, i32 288)
  %19 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tlit = getelementptr inbounds %struct.State, %struct.State* %19, i32 0, i32 10
  store i32 %call, i32* %tlit, align 8, !tbaa !49
  %20 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %21 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %distcodes = getelementptr inbounds %struct.State, %struct.State* %21, i32 0, i32 8
  %arraydecay34 = getelementptr inbounds [32 x i32], [32 x i32]* %distcodes, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay35, i64 288
  %call36 = call i32 @build(%struct.State* %20, i32* %arraydecay34, i8* %add.ptr, i32 32)
  %22 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tdist = getelementptr inbounds %struct.State, %struct.State* %22, i32 0, i32 11
  store i32 %call36, i32* %tdist, align 4, !tbaa !50
  %23 = bitcast [320 x i8]* %lens to i8*
  call void @llvm.lifetime.end.p0i8(i64 320, i8* %23) #11
  %24 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %24) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @block(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %sym = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %entry
  %0 = bitcast i32* %sym to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %2 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %litcodes = getelementptr inbounds %struct.State, %struct.State* %2, i32 0, i32 7
  %arraydecay = getelementptr inbounds [288 x i32], [288 x i32]* %litcodes, i32 0, i32 0
  %3 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tlit = getelementptr inbounds %struct.State, %struct.State* %3, i32 0, i32 10
  %4 = load i32, i32* %tlit, align 8, !tbaa !49
  %call = call i32 @decode(%struct.State* %1, i32* %arraydecay, i32 %4)
  store i32 %call, i32* %sym, align 4, !tbaa !4
  %5 = load i32, i32* %sym, align 4, !tbaa !4
  %cmp = icmp slt i32 %5, 256
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.cond
  %6 = load i32, i32* %sym, align 4, !tbaa !4
  %conv = trunc i32 %6 to i8
  %7 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call1 = call i8* @emit(%struct.State* %7, i32 1)
  store i8 %conv, i8* %call1, align 1, !tbaa !15
  br label %if.end6

if.else:                                          ; preds = %for.cond
  %8 = load i32, i32* %sym, align 4, !tbaa !4
  %cmp2 = icmp sgt i32 %8, 256
  br i1 %cmp2, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  %9 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %10 = load i32, i32* %sym, align 4, !tbaa !4
  %sub = sub nsw i32 %10, 257
  call void @run(%struct.State* %9, i32 %sub)
  br label %if.end

if.else5:                                         ; preds = %if.else
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %if.then4
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.else5
  %11 = bitcast i32* %sym to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 2, label %for.end
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.cond

for.end:                                          ; preds = %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal void @dynamic(%struct.State* %s) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %nlit = alloca i32, align 4
  %ndist = alloca i32, align 4
  %nlen = alloca i32, align 4
  %lenlens = alloca [19 x i8], align 16
  %lens = alloca [320 x i8], align 16
  %sym = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  %0 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %nlit to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = bitcast i32* %ndist to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = bitcast i32* %nlen to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast [19 x i8]* %lenlens to i8*
  call void @llvm.lifetime.start.p0i8(i64 19, i8* %5) #11
  %6 = bitcast [19 x i8]* %lenlens to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %6, i8 0, i64 19, i1 false)
  %7 = bitcast [320 x i8]* %lens to i8*
  call void @llvm.lifetime.start.p0i8(i64 320, i8* %7) #11
  %8 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call = call i32 @bits(%struct.State* %8, i32 5)
  %add = add nsw i32 257, %call
  store i32 %add, i32* %nlit, align 4, !tbaa !4
  %9 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call1 = call i32 @bits(%struct.State* %9, i32 5)
  %add2 = add nsw i32 1, %call1
  store i32 %add2, i32* %ndist, align 4, !tbaa !4
  %10 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call3 = call i32 @bits(%struct.State* %10, i32 4)
  %add4 = add nsw i32 4, %call3
  store i32 %add4, i32* %nlen, align 4, !tbaa !4
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, i32* %n, align 4, !tbaa !4
  %12 = load i32, i32* %nlen, align 4, !tbaa !4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call5 = call i32 @bits(%struct.State* %13, i32 3)
  %conv = trunc i32 %call5 to i8
  %14 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom = sext i32 %14 to i64
  %arrayidx = getelementptr inbounds [19 x i8], [19 x i8]* @order, i64 0, i64 %idxprom
  %15 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %idxprom6 = sext i8 %15 to i64
  %arrayidx7 = getelementptr inbounds [19 x i8], [19 x i8]* %lenlens, i64 0, i64 %idxprom6
  store i8 %conv, i8* %arrayidx7, align 1, !tbaa !15
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %n, align 4, !tbaa !4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %18 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %lencodes = getelementptr inbounds %struct.State, %struct.State* %18, i32 0, i32 9
  %arraydecay = getelementptr inbounds [19 x i32], [19 x i32]* %lencodes, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [19 x i8], [19 x i8]* %lenlens, i32 0, i32 0
  %call9 = call i32 @build(%struct.State* %17, i32* %arraydecay, i8* %arraydecay8, i32 19)
  %19 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tlen = getelementptr inbounds %struct.State, %struct.State* %19, i32 0, i32 12
  store i32 %call9, i32* %tlen, align 8, !tbaa !51
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond10

for.cond10:                                       ; preds = %sw.epilog, %for.end
  %20 = load i32, i32* %n, align 4, !tbaa !4
  %21 = load i32, i32* %nlit, align 4, !tbaa !4
  %22 = load i32, i32* %ndist, align 4, !tbaa !4
  %add11 = add nsw i32 %21, %22
  %cmp12 = icmp slt i32 %20, %add11
  br i1 %cmp12, label %for.body14, label %for.end58

for.body14:                                       ; preds = %for.cond10
  %23 = bitcast i32* %sym to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %23) #11
  %24 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %25 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %lencodes15 = getelementptr inbounds %struct.State, %struct.State* %25, i32 0, i32 9
  %arraydecay16 = getelementptr inbounds [19 x i32], [19 x i32]* %lencodes15, i32 0, i32 0
  %26 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tlen17 = getelementptr inbounds %struct.State, %struct.State* %26, i32 0, i32 12
  %27 = load i32, i32* %tlen17, align 8, !tbaa !51
  %call18 = call i32 @decode(%struct.State* %24, i32* %arraydecay16, i32 %27)
  store i32 %call18, i32* %sym, align 4, !tbaa !4
  %28 = load i32, i32* %sym, align 4, !tbaa !4
  switch i32 %28, label %sw.default [
    i32 16, label %sw.bb
    i32 17, label %sw.bb30
    i32 18, label %sw.bb42
  ]

sw.bb:                                            ; preds = %for.body14
  %29 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call19 = call i32 @bits(%struct.State* %29, i32 2)
  %add20 = add nsw i32 3, %call19
  store i32 %add20, i32* %i, align 4, !tbaa !4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc27, %sw.bb
  %30 = load i32, i32* %i, align 4, !tbaa !4
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %for.body22, label %for.end29

for.body22:                                       ; preds = %for.cond21
  %31 = load i32, i32* %n, align 4, !tbaa !4
  %sub = sub nsw i32 %31, 1
  %idxprom23 = sext i32 %sub to i64
  %arrayidx24 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom23
  %32 = load i8, i8* %arrayidx24, align 1, !tbaa !15
  %33 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom25 = sext i32 %33 to i64
  %arrayidx26 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom25
  store i8 %32, i8* %arrayidx26, align 1, !tbaa !15
  br label %for.inc27

for.inc27:                                        ; preds = %for.body22
  %34 = load i32, i32* %i, align 4, !tbaa !4
  %dec = add nsw i32 %34, -1
  store i32 %dec, i32* %i, align 4, !tbaa !4
  %35 = load i32, i32* %n, align 4, !tbaa !4
  %inc28 = add nsw i32 %35, 1
  store i32 %inc28, i32* %n, align 4, !tbaa !4
  br label %for.cond21

for.end29:                                        ; preds = %for.cond21
  br label %sw.epilog

sw.bb30:                                          ; preds = %for.body14
  %36 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call31 = call i32 @bits(%struct.State* %36, i32 3)
  %add32 = add nsw i32 3, %call31
  store i32 %add32, i32* %i, align 4, !tbaa !4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc38, %sw.bb30
  %37 = load i32, i32* %i, align 4, !tbaa !4
  %tobool34 = icmp ne i32 %37, 0
  br i1 %tobool34, label %for.body35, label %for.end41

for.body35:                                       ; preds = %for.cond33
  %38 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom36 = sext i32 %38 to i64
  %arrayidx37 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom36
  store i8 0, i8* %arrayidx37, align 1, !tbaa !15
  br label %for.inc38

for.inc38:                                        ; preds = %for.body35
  %39 = load i32, i32* %i, align 4, !tbaa !4
  %dec39 = add nsw i32 %39, -1
  store i32 %dec39, i32* %i, align 4, !tbaa !4
  %40 = load i32, i32* %n, align 4, !tbaa !4
  %inc40 = add nsw i32 %40, 1
  store i32 %inc40, i32* %n, align 4, !tbaa !4
  br label %for.cond33

for.end41:                                        ; preds = %for.cond33
  br label %sw.epilog

sw.bb42:                                          ; preds = %for.body14
  %41 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %call43 = call i32 @bits(%struct.State* %41, i32 7)
  %add44 = add nsw i32 11, %call43
  store i32 %add44, i32* %i, align 4, !tbaa !4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc50, %sw.bb42
  %42 = load i32, i32* %i, align 4, !tbaa !4
  %tobool46 = icmp ne i32 %42, 0
  br i1 %tobool46, label %for.body47, label %for.end53

for.body47:                                       ; preds = %for.cond45
  %43 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom48 = sext i32 %43 to i64
  %arrayidx49 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom48
  store i8 0, i8* %arrayidx49, align 1, !tbaa !15
  br label %for.inc50

for.inc50:                                        ; preds = %for.body47
  %44 = load i32, i32* %i, align 4, !tbaa !4
  %dec51 = add nsw i32 %44, -1
  store i32 %dec51, i32* %i, align 4, !tbaa !4
  %45 = load i32, i32* %n, align 4, !tbaa !4
  %inc52 = add nsw i32 %45, 1
  store i32 %inc52, i32* %n, align 4, !tbaa !4
  br label %for.cond45

for.end53:                                        ; preds = %for.cond45
  br label %sw.epilog

sw.default:                                       ; preds = %for.body14
  %46 = load i32, i32* %sym, align 4, !tbaa !4
  %conv54 = trunc i32 %46 to i8
  %47 = load i32, i32* %n, align 4, !tbaa !4
  %inc55 = add nsw i32 %47, 1
  store i32 %inc55, i32* %n, align 4, !tbaa !4
  %idxprom56 = sext i32 %47 to i64
  %arrayidx57 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i64 0, i64 %idxprom56
  store i8 %conv54, i8* %arrayidx57, align 1, !tbaa !15
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %for.end53, %for.end41, %for.end29
  %48 = bitcast i32* %sym to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %48) #11
  br label %for.cond10

for.end58:                                        ; preds = %for.cond10
  %49 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %50 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %litcodes = getelementptr inbounds %struct.State, %struct.State* %50, i32 0, i32 7
  %arraydecay59 = getelementptr inbounds [288 x i32], [288 x i32]* %litcodes, i32 0, i32 0
  %arraydecay60 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %51 = load i32, i32* %nlit, align 4, !tbaa !4
  %call61 = call i32 @build(%struct.State* %49, i32* %arraydecay59, i8* %arraydecay60, i32 %51)
  %52 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tlit = getelementptr inbounds %struct.State, %struct.State* %52, i32 0, i32 10
  store i32 %call61, i32* %tlit, align 8, !tbaa !49
  %53 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %54 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %distcodes = getelementptr inbounds %struct.State, %struct.State* %54, i32 0, i32 8
  %arraydecay62 = getelementptr inbounds [32 x i32], [32 x i32]* %distcodes, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [320 x i8], [320 x i8]* %lens, i32 0, i32 0
  %55 = load i32, i32* %nlit, align 4, !tbaa !4
  %idx.ext = sext i32 %55 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay63, i64 %idx.ext
  %56 = load i32, i32* %ndist, align 4, !tbaa !4
  %call64 = call i32 @build(%struct.State* %53, i32* %arraydecay62, i8* %add.ptr, i32 %56)
  %57 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tdist = getelementptr inbounds %struct.State, %struct.State* %57, i32 0, i32 11
  store i32 %call64, i32* %tdist, align 4, !tbaa !50
  %58 = bitcast [320 x i8]* %lens to i8*
  call void @llvm.lifetime.end.p0i8(i64 320, i8* %58) #11
  %59 = bitcast [19 x i8]* %lenlens to i8*
  call void @llvm.lifetime.end.p0i8(i64 19, i8* %59) #11
  %60 = bitcast i32* %nlen to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %60) #11
  %61 = bitcast i32* %ndist to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %61) #11
  %62 = bitcast i32* %nlit to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %62) #11
  %63 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %63) #11
  %64 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %64) #11
  ret void
}

; Function Attrs: noreturn
declare void @longjmp(i32*, i32) #10

; Function Attrs: nounwind ssp uwtable
define i32 @tigrLoadGlyphs(%struct.TigrFont* %font, i32 %codepage) #0 {
entry:
  %retval = alloca i32, align 4
  %font.addr = alloca %struct.TigrFont*, align 8
  %codepage.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %w = alloca i32, align 4
  %h = alloca i32, align 4
  %rowh = alloca i32, align 4
  %g = alloca %struct.TigrGlyph*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %j = alloca i32, align 4
  %g61 = alloca %struct.TigrGlyph, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  store i32 %codepage, i32* %codepage.addr, align 4, !tbaa !4
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  store i32 0, i32* %x, align 4, !tbaa !4
  %2 = bitcast i32* %y to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  store i32 0, i32* %y, align 4, !tbaa !4
  %3 = bitcast i32* %w to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = bitcast i32* %h to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast i32* %rowh to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  store i32 1, i32* %rowh, align 4, !tbaa !4
  %6 = bitcast %struct.TigrGlyph** %g to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %7 = load i32, i32* %codepage.addr, align 4, !tbaa !4
  switch i32 %7, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1252, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %8 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %numGlyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %8, i32 0, i32 1
  store i32 96, i32* %numGlyphs, align 8, !tbaa !52
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %9 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %numGlyphs2 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %9, i32 0, i32 1
  store i32 224, i32* %numGlyphs2, align 8, !tbaa !52
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %sw.bb1, %sw.bb
  %10 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %numGlyphs3 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %10, i32 0, i32 1
  %11 = load i32, i32* %numGlyphs3, align 8, !tbaa !52
  %conv = sext i32 %11 to i64
  %call = call i8* @calloc(i64 %conv, i64 20) #15
  %12 = bitcast i8* %call to %struct.TigrGlyph*
  %13 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %13, i32 0, i32 2
  store %struct.TigrGlyph* %12, %struct.TigrGlyph** %glyphs, align 8, !tbaa !54
  store i32 32, i32* %i, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %14 = load i32, i32* %i, align 4, !tbaa !4
  %15 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %numGlyphs4 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %15, i32 0, i32 1
  %16 = load i32, i32* %numGlyphs4, align 8, !tbaa !52
  %add = add nsw i32 %16, 32
  %cmp = icmp slt i32 %14, %add
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %17, i32 0, i32 0
  %18 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8, !tbaa !55
  call void @scan(%struct.Tigr* %18, i32* %x, i32* %y, i32* %rowh)
  %19 = load i32, i32* %y, align 4, !tbaa !4
  %20 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %bitmap6 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %20, i32 0, i32 0
  %21 = load %struct.Tigr*, %struct.Tigr** %bitmap6, align 8, !tbaa !55
  %h7 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %21, i32 0, i32 1
  %22 = load i32, i32* %h7, align 4, !tbaa !12
  %cmp8 = icmp sge i32 %19, %22
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call10 = call i32* @__error()
  store i32 22, i32* %call10, align 4, !tbaa !4
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  store i32 0, i32* %h, align 4, !tbaa !4
  store i32 0, i32* %w, align 4, !tbaa !4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %23 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %bitmap11 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %23, i32 0, i32 0
  %24 = load %struct.Tigr*, %struct.Tigr** %bitmap11, align 8, !tbaa !55
  %25 = load i32, i32* %x, align 4, !tbaa !4
  %26 = load i32, i32* %w, align 4, !tbaa !4
  %add12 = add nsw i32 %25, %26
  %27 = load i32, i32* %y, align 4, !tbaa !4
  %call13 = call i32 @border(%struct.Tigr* %24, i32 %add12, i32 %27)
  %tobool = icmp ne i32 %call13, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %28 = load i32, i32* %w, align 4, !tbaa !4
  %inc = add nsw i32 %28, 1
  store i32 %inc, i32* %w, align 4, !tbaa !4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond14

while.cond14:                                     ; preds = %while.body20, %while.end
  %29 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %bitmap15 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %29, i32 0, i32 0
  %30 = load %struct.Tigr*, %struct.Tigr** %bitmap15, align 8, !tbaa !55
  %31 = load i32, i32* %x, align 4, !tbaa !4
  %32 = load i32, i32* %y, align 4, !tbaa !4
  %33 = load i32, i32* %h, align 4, !tbaa !4
  %add16 = add nsw i32 %32, %33
  %call17 = call i32 @border(%struct.Tigr* %30, i32 %31, i32 %add16)
  %tobool18 = icmp ne i32 %call17, 0
  %lnot19 = xor i1 %tobool18, true
  br i1 %lnot19, label %while.body20, label %while.end22

while.body20:                                     ; preds = %while.cond14
  %34 = load i32, i32* %h, align 4, !tbaa !4
  %inc21 = add nsw i32 %34, 1
  store i32 %inc21, i32* %h, align 4, !tbaa !4
  br label %while.cond14

while.end22:                                      ; preds = %while.cond14
  %35 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs23 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %35, i32 0, i32 2
  %36 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs23, align 8, !tbaa !54
  %37 = load i32, i32* %i, align 4, !tbaa !4
  %sub = sub nsw i32 %37, 32
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %36, i64 %idxprom
  store %struct.TigrGlyph* %arrayidx, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %38 = load i32, i32* %i, align 4, !tbaa !4
  %cmp24 = icmp slt i32 %38, 128
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %while.end22
  %39 = load i32, i32* %i, align 4, !tbaa !4
  %40 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %code = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %40, i32 0, i32 0
  store i32 %39, i32* %code, align 4, !tbaa !56
  br label %if.end37

if.else:                                          ; preds = %while.end22
  %41 = load i32, i32* %codepage.addr, align 4, !tbaa !4
  %cmp27 = icmp eq i32 %41, 1252
  br i1 %cmp27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %if.else
  %42 = load i32, i32* %i, align 4, !tbaa !4
  %sub30 = sub nsw i32 %42, 128
  %idxprom31 = sext i32 %sub30 to i64
  %arrayidx32 = getelementptr inbounds [128 x i32], [128 x i32]* @cp1252, i64 0, i64 %idxprom31
  %43 = load i32, i32* %arrayidx32, align 4, !tbaa !4
  %44 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %code33 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %44, i32 0, i32 0
  store i32 %43, i32* %code33, align 4, !tbaa !56
  br label %if.end36

if.else34:                                        ; preds = %if.else
  %call35 = call i32* @__error()
  store i32 22, i32* %call35, align 4, !tbaa !4
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end36:                                         ; preds = %if.then29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then26
  %45 = load i32, i32* %x, align 4, !tbaa !4
  %46 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %x38 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %46, i32 0, i32 1
  store i32 %45, i32* %x38, align 4, !tbaa !58
  %47 = load i32, i32* %y, align 4, !tbaa !4
  %48 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %y39 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %48, i32 0, i32 2
  store i32 %47, i32* %y39, align 4, !tbaa !59
  %49 = load i32, i32* %w, align 4, !tbaa !4
  %50 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %w40 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %50, i32 0, i32 3
  store i32 %49, i32* %w40, align 4, !tbaa !60
  %51 = load i32, i32* %h, align 4, !tbaa !4
  %52 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %h41 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %52, i32 0, i32 4
  store i32 %51, i32* %h41, align 4, !tbaa !61
  %53 = load i32, i32* %w, align 4, !tbaa !4
  %54 = load i32, i32* %x, align 4, !tbaa !4
  %add42 = add nsw i32 %54, %53
  store i32 %add42, i32* %x, align 4, !tbaa !4
  %55 = load i32, i32* %h, align 4, !tbaa !4
  %56 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs43 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %56, i32 0, i32 2
  %57 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs43, align 8, !tbaa !54
  %arrayidx44 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %57, i64 0
  %h45 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx44, i32 0, i32 4
  %58 = load i32, i32* %h45, align 4, !tbaa !61
  %cmp46 = icmp ne i32 %55, %58
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end37
  %call49 = call i32* @__error()
  store i32 22, i32* %call49, align 4, !tbaa !4
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end50:                                         ; preds = %if.end37
  %59 = load i32, i32* %h, align 4, !tbaa !4
  %60 = load i32, i32* %rowh, align 4, !tbaa !4
  %cmp51 = icmp sgt i32 %59, %60
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end50
  %61 = load i32, i32* %h, align 4, !tbaa !4
  store i32 %61, i32* %rowh, align 4, !tbaa !4
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.end50
  br label %for.inc

for.inc:                                          ; preds = %if.end54
  %62 = load i32, i32* %i, align 4, !tbaa !4
  %inc55 = add nsw i32 %62, 1
  store i32 %inc55, i32* %i, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %i, align 4, !tbaa !4
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc88, %for.end
  %63 = load i32, i32* %i, align 4, !tbaa !4
  %64 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %numGlyphs57 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %64, i32 0, i32 1
  %65 = load i32, i32* %numGlyphs57, align 8, !tbaa !52
  %cmp58 = icmp slt i32 %63, %65
  br i1 %cmp58, label %for.body60, label %for.end90

for.body60:                                       ; preds = %for.cond56
  %66 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %66) #11
  %67 = load i32, i32* %i, align 4, !tbaa !4
  store i32 %67, i32* %j, align 4, !tbaa !4
  %68 = bitcast %struct.TigrGlyph* %g61 to i8*
  call void @llvm.lifetime.start.p0i8(i64 20, i8* %68) #11
  %69 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs62 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %69, i32 0, i32 2
  %70 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs62, align 8, !tbaa !54
  %71 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom63 = sext i32 %71 to i64
  %arrayidx64 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %70, i64 %idxprom63
  %72 = bitcast %struct.TigrGlyph* %g61 to i8*
  %73 = bitcast %struct.TigrGlyph* %arrayidx64 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %72, i8* align 4 %73, i64 20, i1 false), !tbaa.struct !62
  br label %while.cond65

while.cond65:                                     ; preds = %while.body76, %for.body60
  %74 = load i32, i32* %j, align 4, !tbaa !4
  %cmp66 = icmp sgt i32 %74, 0
  br i1 %cmp66, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond65
  %75 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs68 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %75, i32 0, i32 2
  %76 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs68, align 8, !tbaa !54
  %77 = load i32, i32* %j, align 4, !tbaa !4
  %sub69 = sub nsw i32 %77, 1
  %idxprom70 = sext i32 %sub69 to i64
  %arrayidx71 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %76, i64 %idxprom70
  %code72 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx71, i32 0, i32 0
  %78 = load i32, i32* %code72, align 4, !tbaa !56
  %code73 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %g61, i32 0, i32 0
  %79 = load i32, i32* %code73, align 4, !tbaa !56
  %cmp74 = icmp sgt i32 %78, %79
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond65
  %80 = phi i1 [ false, %while.cond65 ], [ %cmp74, %land.rhs ]
  br i1 %80, label %while.body76, label %while.end84

while.body76:                                     ; preds = %land.end
  %81 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs77 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %81, i32 0, i32 2
  %82 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs77, align 8, !tbaa !54
  %83 = load i32, i32* %j, align 4, !tbaa !4
  %idxprom78 = sext i32 %83 to i64
  %arrayidx79 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %82, i64 %idxprom78
  %84 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs80 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %84, i32 0, i32 2
  %85 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs80, align 8, !tbaa !54
  %86 = load i32, i32* %j, align 4, !tbaa !4
  %sub81 = sub nsw i32 %86, 1
  %idxprom82 = sext i32 %sub81 to i64
  %arrayidx83 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %85, i64 %idxprom82
  %87 = bitcast %struct.TigrGlyph* %arrayidx79 to i8*
  %88 = bitcast %struct.TigrGlyph* %arrayidx83 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %87, i8* align 4 %88, i64 20, i1 false), !tbaa.struct !62
  %89 = load i32, i32* %j, align 4, !tbaa !4
  %dec = add nsw i32 %89, -1
  store i32 %dec, i32* %j, align 4, !tbaa !4
  br label %while.cond65

while.end84:                                      ; preds = %land.end
  %90 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs85 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %90, i32 0, i32 2
  %91 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs85, align 8, !tbaa !54
  %92 = load i32, i32* %j, align 4, !tbaa !4
  %idxprom86 = sext i32 %92 to i64
  %arrayidx87 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %91, i64 %idxprom86
  %93 = bitcast %struct.TigrGlyph* %arrayidx87 to i8*
  %94 = bitcast %struct.TigrGlyph* %g61 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %93, i8* align 4 %94, i64 20, i1 false), !tbaa.struct !62
  %95 = bitcast %struct.TigrGlyph* %g61 to i8*
  call void @llvm.lifetime.end.p0i8(i64 20, i8* %95) #11
  %96 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %96) #11
  br label %for.inc88

for.inc88:                                        ; preds = %while.end84
  %97 = load i32, i32* %i, align 4, !tbaa !4
  %inc89 = add nsw i32 %97, 1
  store i32 %inc89, i32* %i, align 4, !tbaa !4
  br label %for.cond56

for.end90:                                        ; preds = %for.cond56
  store i32 1, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end90, %if.then48, %if.else34, %if.then
  %98 = bitcast %struct.TigrGlyph** %g to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %98) #11
  %99 = bitcast i32* %rowh to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %99) #11
  %100 = bitcast i32* %h to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %100) #11
  %101 = bitcast i32* %w to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %101) #11
  %102 = bitcast i32* %y to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %102) #11
  %103 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %103) #11
  %104 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %104) #11
  %105 = load i32, i32* %retval, align 4
  ret i32 %105
}

; Function Attrs: nounwind ssp uwtable
define internal void @scan(%struct.Tigr* %bmp, i32* %x, i32* %y, i32* %rowh) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32*, align 8
  %y.addr = alloca i32*, align 8
  %rowh.addr = alloca i32*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32* %x, i32** %x.addr, align 8, !tbaa !8
  store i32* %y, i32** %y.addr, align 8, !tbaa !8
  store i32* %rowh, i32** %rowh.addr, align 8, !tbaa !8
  br label %while.cond

while.cond:                                       ; preds = %if.end3, %entry
  %0 = load i32*, i32** %y.addr, align 8, !tbaa !8
  %1 = load i32, i32* %0, align 4, !tbaa !4
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %2, i32 0, i32 1
  %3 = load i32, i32* %h, align 4, !tbaa !12
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i32*, i32** %x.addr, align 8, !tbaa !8
  %5 = load i32, i32* %4, align 4, !tbaa !4
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 0
  %7 = load i32, i32* %w, align 8, !tbaa !10
  %cmp1 = icmp sge i32 %5, %7
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %8 = load i32*, i32** %x.addr, align 8, !tbaa !8
  store i32 0, i32* %8, align 4, !tbaa !4
  %9 = load i32*, i32** %rowh.addr, align 8, !tbaa !8
  %10 = load i32, i32* %9, align 4, !tbaa !4
  %11 = load i32*, i32** %y.addr, align 8, !tbaa !8
  %12 = load i32, i32* %11, align 4, !tbaa !4
  %add = add nsw i32 %12, %10
  store i32 %add, i32* %11, align 4, !tbaa !4
  %13 = load i32*, i32** %rowh.addr, align 8, !tbaa !8
  store i32 1, i32* %13, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %14 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %15 = load i32*, i32** %x.addr, align 8, !tbaa !8
  %16 = load i32, i32* %15, align 4, !tbaa !4
  %17 = load i32*, i32** %y.addr, align 8, !tbaa !8
  %18 = load i32, i32* %17, align 4, !tbaa !4
  %call = call i32 @border(%struct.Tigr* %14, i32 %16, i32 %18)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %while.end

if.end3:                                          ; preds = %if.end
  %19 = load i32*, i32** %x.addr, align 8, !tbaa !8
  %20 = load i32, i32* %19, align 4, !tbaa !4
  %inc = add nsw i32 %20, 1
  store i32 %inc, i32* %19, align 4, !tbaa !4
  br label %while.cond

while.end:                                        ; preds = %if.then2, %while.cond
  ret void
}

declare i32* @__error() #5

; Function Attrs: nounwind ssp uwtable
define internal i32 @border(%struct.Tigr* %bmp, i32 %x, i32 %y) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %top = alloca %struct.TPixel, align 1
  %c = alloca %struct.TPixel, align 1
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x, i32* %x.addr, align 4, !tbaa !4
  store i32 %y, i32* %y.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TPixel* %top to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call i32 @tigrGet(%struct.Tigr* %1, i32 0, i32 0)
  %2 = bitcast %struct.TPixel* %top to i32*
  store i32 %call, i32* %2, align 1
  %3 = bitcast %struct.TPixel* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %5 = load i32, i32* %x.addr, align 4, !tbaa !4
  %6 = load i32, i32* %y.addr, align 4, !tbaa !4
  %call1 = call i32 @tigrGet(%struct.Tigr* %4, i32 %5, i32 %6)
  %7 = bitcast %struct.TPixel* %c to i32*
  store i32 %call1, i32* %7, align 1
  %r = getelementptr inbounds %struct.TPixel, %struct.TPixel* %c, i32 0, i32 2
  %8 = load i8, i8* %r, align 1, !tbaa !18
  %conv = zext i8 %8 to i32
  %r2 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %top, i32 0, i32 2
  %9 = load i8, i8* %r2, align 1, !tbaa !18
  %conv3 = zext i8 %9 to i32
  %cmp = icmp eq i32 %conv, %conv3
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %g = getelementptr inbounds %struct.TPixel, %struct.TPixel* %c, i32 0, i32 1
  %10 = load i8, i8* %g, align 1, !tbaa !19
  %conv5 = zext i8 %10 to i32
  %g6 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %top, i32 0, i32 1
  %11 = load i8, i8* %g6, align 1, !tbaa !19
  %conv7 = zext i8 %11 to i32
  %cmp8 = icmp eq i32 %conv5, %conv7
  br i1 %cmp8, label %land.lhs.true10, label %lor.lhs.false

land.lhs.true10:                                  ; preds = %land.lhs.true
  %b = getelementptr inbounds %struct.TPixel, %struct.TPixel* %c, i32 0, i32 0
  %12 = load i8, i8* %b, align 1, !tbaa !20
  %conv11 = zext i8 %12 to i32
  %b12 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %top, i32 0, i32 0
  %13 = load i8, i8* %b12, align 1, !tbaa !20
  %conv13 = zext i8 %13 to i32
  %cmp14 = icmp eq i32 %conv11, %conv13
  br i1 %cmp14, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true10, %land.lhs.true, %entry
  %14 = load i32, i32* %x.addr, align 4, !tbaa !4
  %15 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %15, i32 0, i32 0
  %16 = load i32, i32* %w, align 8, !tbaa !10
  %cmp16 = icmp sge i32 %14, %16
  br i1 %cmp16, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %17 = load i32, i32* %y.addr, align 4, !tbaa !4
  %18 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %18, i32 0, i32 1
  %19 = load i32, i32* %h, align 4, !tbaa !12
  %cmp18 = icmp sge i32 %17, %19
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %land.lhs.true10
  %20 = phi i1 [ true, %lor.lhs.false ], [ true, %land.lhs.true10 ], [ %cmp18, %lor.rhs ]
  %lor.ext = zext i1 %20 to i32
  %21 = bitcast %struct.TPixel* %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %21) #11
  %22 = bitcast %struct.TPixel* %top to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %22) #11
  ret i32 %lor.ext
}

; Function Attrs: nounwind ssp uwtable
define %struct.TigrFont* @tigrLoadFont(%struct.Tigr* %bitmap, i32 %codepage) #0 {
entry:
  %retval = alloca %struct.TigrFont*, align 8
  %bitmap.addr = alloca %struct.Tigr*, align 8
  %codepage.addr = alloca i32, align 4
  %font = alloca %struct.TigrFont*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Tigr* %bitmap, %struct.Tigr** %bitmap.addr, align 8, !tbaa !8
  store i32 %codepage, i32* %codepage.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TigrFont** %font to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %call = call i8* @calloc(i64 1, i64 24) #15
  %1 = bitcast i8* %call to %struct.TigrFont*
  store %struct.TigrFont* %1, %struct.TigrFont** %font, align 8, !tbaa !8
  %2 = load %struct.Tigr*, %struct.Tigr** %bitmap.addr, align 8, !tbaa !8
  %3 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8, !tbaa !8
  %bitmap1 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %3, i32 0, i32 0
  store %struct.Tigr* %2, %struct.Tigr** %bitmap1, align 8, !tbaa !55
  %4 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8, !tbaa !8
  %5 = load i32, i32* %codepage.addr, align 4, !tbaa !4
  %call2 = call i32 @tigrLoadGlyphs(%struct.TigrFont* %4, i32 %5)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8, !tbaa !8
  call void @tigrFreeFont(%struct.TigrFont* %6)
  store %struct.TigrFont* null, %struct.TigrFont** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %7 = load %struct.TigrFont*, %struct.TigrFont** %font, align 8, !tbaa !8
  store %struct.TigrFont* %7, %struct.TigrFont** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %8 = bitcast %struct.TigrFont** %font to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #11
  %9 = load %struct.TigrFont*, %struct.TigrFont** %retval, align 8
  ret %struct.TigrFont* %9
}

; Function Attrs: nounwind ssp uwtable
define void @tigrFreeFont(%struct.TigrFont* %font) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %0, i32 0, i32 0
  %1 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8, !tbaa !55
  call void @tigrFree(%struct.Tigr* %1)
  %2 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 2
  %3 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs, align 8, !tbaa !54
  %4 = bitcast %struct.TigrGlyph* %3 to i8*
  call void @free(i8* %4)
  %5 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %6 = bitcast %struct.TigrFont* %5 to i8*
  call void @free(i8* %6)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrFree(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %window = alloca %struct.objc_object*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %0, i32 0, i32 3
  %1 = load i8*, i8** %handle, align 8, !tbaa !41
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %3)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %4 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %glContext = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %4, i32 0, i32 3
  %5 = load i8*, i8** %glContext, align 8, !tbaa !63
  %6 = bitcast i8* %5 to %struct.objc_object*
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %6, %struct.objc_selector* %call1)
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  call void @tigrGAPIEnd(%struct.Tigr* %7)
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  call void @tigrGAPIDestroy(%struct.Tigr* %8)
  %9 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgets = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %9, i32 0, i32 4
  %10 = load %struct.Tigr*, %struct.Tigr** %widgets, align 8, !tbaa !64
  call void @tigrFree(%struct.Tigr* %10)
  %11 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #11
  %12 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle2 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %12, i32 0, i32 3
  %13 = load i8*, i8** %handle2, align 8, !tbaa !41
  %14 = bitcast i8* %13 to %struct.objc_object*
  store %struct.objc_object* %14, %struct.objc_object** %window, align 8, !tbaa !8
  %15 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call3 = call zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %15)
  br i1 %call3, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %16 = load i8, i8* @terminated, align 1, !tbaa !65, !range !67
  %tobool4 = trunc i8 %16 to i1
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %17 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call6 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.71, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %17, %struct.objc_selector* %call6)
  br label %if.end

if.end:                                           ; preds = %if.then5, %land.lhs.true, %if.then
  %18 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #11
  %19 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %19) #11
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %20 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %20, i32 0, i32 2
  %21 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %22 = bitcast %struct.TPixel* %21 to i8*
  call void @free(i8* %22)
  %23 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %24 = bitcast %struct.Tigr* %23 to i8*
  call void @free(i8* %24)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrSetupFont(%struct.TigrFont* %font) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %0 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %1 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8, !tbaa !8
  %cmp = icmp eq %struct.TigrFont* %0, %1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8, !tbaa !8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 0
  %3 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8, !tbaa !55
  %tobool = icmp ne %struct.Tigr* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = load i32, i32* @tigr_font_size, align 4, !tbaa !4
  %call = call %struct.Tigr* @tigrLoadImageMem(i8* getelementptr inbounds ([3850 x i8], [3850 x i8]* @tigr_font, i32 0, i32 0), i32 %4)
  %5 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8, !tbaa !8
  %bitmap1 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %5, i32 0, i32 0
  store %struct.Tigr* %call, %struct.Tigr** %bitmap1, align 8, !tbaa !55
  %6 = load %struct.TigrFont*, %struct.TigrFont** @tfont, align 8, !tbaa !8
  %call2 = call i32 @tigrLoadGlyphs(%struct.TigrFont* %6, i32 1252)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrPrint(%struct.Tigr* %dest, %struct.TigrFont* %font, i32 %x, i32 %y, i32 %color.coerce, i8* %text, ...) #0 {
entry:
  %color = alloca %struct.TPixel, align 1
  %dest.addr = alloca %struct.Tigr*, align 8
  %font.addr = alloca %struct.TigrFont*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %text.addr = alloca i8*, align 8
  %tmp = alloca [1024 x i8], align 16
  %g = alloca %struct.TigrGlyph*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %p = alloca i8*, align 8
  %start = alloca i32, align 4
  %c = alloca i32, align 4
  %0 = bitcast %struct.TPixel* %color to i32*
  store i32 %color.coerce, i32* %0, align 1
  store %struct.Tigr* %dest, %struct.Tigr** %dest.addr, align 8, !tbaa !8
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  store i32 %x, i32* %x.addr, align 4, !tbaa !4
  store i32 %y, i32* %y.addr, align 4, !tbaa !4
  store i8* %text, i8** %text.addr, align 8, !tbaa !8
  %1 = bitcast [1024 x i8]* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 1024, i8* %1) #11
  %2 = bitcast %struct.TigrGlyph** %g to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %3) #11
  %4 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = bitcast i32* %start to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  %6 = load i32, i32* %x.addr, align 4, !tbaa !4
  store i32 %6, i32* %start, align 4, !tbaa !4
  %7 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #11
  %8 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  call void @tigrSetupFont(%struct.TigrFont* %8)
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %9 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %9, %struct.__va_list_tag* %arraydecay3)
  %arrayidx = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i64 0, i64 1023
  store i8 0, i8* %arrayidx, align 1, !tbaa !15
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %arraydecay6 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  store i8* %arraydecay6, i8** %p, align 8, !tbaa !8
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.then9, %if.then, %entry
  %10 = load i8*, i8** %p, align 8, !tbaa !8
  %11 = load i8, i8* %10, align 1, !tbaa !15
  %tobool = icmp ne i8 %11, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %p, align 8, !tbaa !8
  %call7 = call i8* @tigrDecodeUTF8(i8* %12, i32* %c)
  store i8* %call7, i8** %p, align 8, !tbaa !8
  %13 = load i32, i32* %c, align 4, !tbaa !4
  %cmp = icmp eq i32 %13, 13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond

if.end:                                           ; preds = %while.body
  %14 = load i32, i32* %c, align 4, !tbaa !4
  %cmp8 = icmp eq i32 %14, 10
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %15 = load i32, i32* %start, align 4, !tbaa !4
  store i32 %15, i32* %x.addr, align 4, !tbaa !4
  %16 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %call10 = call i32 @tigrTextHeight(%struct.TigrFont* %16, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %17 = load i32, i32* %y.addr, align 4, !tbaa !4
  %add = add nsw i32 %17, %call10
  store i32 %add, i32* %y.addr, align 4, !tbaa !4
  br label %while.cond

if.end11:                                         ; preds = %if.end
  %18 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %19 = load i32, i32* %c, align 4, !tbaa !4
  %call12 = call %struct.TigrGlyph* @get(%struct.TigrFont* %18, i32 %19)
  store %struct.TigrGlyph* %call12, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %20 = load %struct.Tigr*, %struct.Tigr** %dest.addr, align 8, !tbaa !8
  %21 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %bitmap = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %21, i32 0, i32 0
  %22 = load %struct.Tigr*, %struct.Tigr** %bitmap, align 8, !tbaa !55
  %23 = load i32, i32* %x.addr, align 4, !tbaa !4
  %24 = load i32, i32* %y.addr, align 4, !tbaa !4
  %25 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %x13 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %25, i32 0, i32 1
  %26 = load i32, i32* %x13, align 4, !tbaa !58
  %27 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %y14 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %27, i32 0, i32 2
  %28 = load i32, i32* %y14, align 4, !tbaa !59
  %29 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %29, i32 0, i32 3
  %30 = load i32, i32* %w, align 4, !tbaa !60
  %31 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %31, i32 0, i32 4
  %32 = load i32, i32* %h, align 4, !tbaa !61
  %33 = bitcast %struct.TPixel* %color to i32*
  %34 = load i32, i32* %33, align 1
  call void @tigrBlitTint(%struct.Tigr* %20, %struct.Tigr* %22, i32 %23, i32 %24, i32 %26, i32 %28, i32 %30, i32 %32, i32 %34)
  %35 = load %struct.TigrGlyph*, %struct.TigrGlyph** %g, align 8, !tbaa !8
  %w15 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %35, i32 0, i32 3
  %36 = load i32, i32* %w15, align 4, !tbaa !60
  %37 = load i32, i32* %x.addr, align 4, !tbaa !4
  %add16 = add nsw i32 %37, %36
  store i32 %add16, i32* %x.addr, align 4, !tbaa !4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %38 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %38) #11
  %39 = bitcast i32* %start to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %39) #11
  %40 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %40) #11
  %41 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %41) #11
  %42 = bitcast %struct.TigrGlyph** %g to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %42) #11
  %43 = bitcast [1024 x i8]* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 1024, i8* %43) #11
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #11

declare i32 @__vsnprintf_chk(i8*, i64, i32, i64, i8*, %struct.__va_list_tag*) #5

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #11

; Function Attrs: nounwind ssp uwtable
define i32 @tigrTextHeight(%struct.TigrFont* %font, i8* %text) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  %text.addr = alloca i8*, align 8
  %rowh = alloca i32, align 4
  %h = alloca i32, align 4
  %c = alloca i32, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  store i8* %text, i8** %text.addr, align 8, !tbaa !8
  %0 = bitcast i32* %rowh to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %h to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  call void @tigrSetupFont(%struct.TigrFont* %3)
  %4 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %call = call %struct.TigrGlyph* @get(%struct.TigrFont* %4, i32 0)
  %h1 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %call, i32 0, i32 4
  %5 = load i32, i32* %h1, align 4, !tbaa !61
  store i32 %5, i32* %rowh, align 4, !tbaa !4
  store i32 %5, i32* %h, align 4, !tbaa !4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %6 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %7 = load i8, i8* %6, align 1, !tbaa !15
  %tobool = icmp ne i8 %7, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %call2 = call i8* @tigrDecodeUTF8(i8* %8, i32* %c)
  store i8* %call2, i8** %text.addr, align 8, !tbaa !8
  %9 = load i32, i32* %c, align 4, !tbaa !4
  %cmp = icmp eq i32 %9, 10
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %10 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %11 = load i8, i8* %10, align 1, !tbaa !15
  %conv = sext i8 %11 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %12 = load i32, i32* %rowh, align 4, !tbaa !4
  %13 = load i32, i32* %h, align 4, !tbaa !4
  %add = add nsw i32 %13, %12
  store i32 %add, i32* %h, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %14 = load i32, i32* %h, align 4, !tbaa !4
  %15 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #11
  %16 = bitcast i32* %h to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #11
  %17 = bitcast i32* %rowh to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #11
  ret i32 %14
}

; Function Attrs: nounwind ssp uwtable
define internal %struct.TigrGlyph* @get(%struct.TigrFont* %font, i32 %code) #0 {
entry:
  %retval = alloca %struct.TigrGlyph*, align 8
  %font.addr = alloca %struct.TigrFont*, align 8
  %code.addr = alloca i32, align 4
  %lo = alloca i32, align 4
  %hi = alloca i32, align 4
  %guess = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  store i32 %code, i32* %code.addr, align 4, !tbaa !4
  %0 = bitcast i32* %lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  store i32 0, i32* %lo, align 4, !tbaa !4
  %1 = bitcast i32* %hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %numGlyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %2, i32 0, i32 1
  %3 = load i32, i32* %numGlyphs, align 8, !tbaa !52
  store i32 %3, i32* %hi, align 4, !tbaa !4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %4 = load i32, i32* %lo, align 4, !tbaa !4
  %5 = load i32, i32* %hi, align 4, !tbaa !4
  %cmp = icmp ult i32 %4, %5
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = bitcast i32* %guess to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %7 = load i32, i32* %lo, align 4, !tbaa !4
  %8 = load i32, i32* %hi, align 4, !tbaa !4
  %add = add i32 %7, %8
  %div = udiv i32 %add, 2
  store i32 %div, i32* %guess, align 4, !tbaa !4
  %9 = load i32, i32* %code.addr, align 4, !tbaa !4
  %10 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %10, i32 0, i32 2
  %11 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs, align 8, !tbaa !54
  %12 = load i32, i32* %guess, align 4, !tbaa !4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %11, i64 %idxprom
  %code1 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx, i32 0, i32 0
  %13 = load i32, i32* %code1, align 4, !tbaa !56
  %cmp2 = icmp slt i32 %9, %13
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %14 = load i32, i32* %guess, align 4, !tbaa !4
  store i32 %14, i32* %hi, align 4, !tbaa !4
  br label %if.end

if.else:                                          ; preds = %while.body
  %15 = load i32, i32* %guess, align 4, !tbaa !4
  %add3 = add i32 %15, 1
  store i32 %add3, i32* %lo, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = bitcast i32* %guess to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #11
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %17 = load i32, i32* %lo, align 4, !tbaa !4
  %cmp4 = icmp eq i32 %17, 0
  br i1 %cmp4, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %18 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs5 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %18, i32 0, i32 2
  %19 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs5, align 8, !tbaa !54
  %20 = load i32, i32* %lo, align 4, !tbaa !4
  %sub = sub i32 %20, 1
  %idxprom6 = zext i32 %sub to i64
  %arrayidx7 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %19, i64 %idxprom6
  %code8 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %arrayidx7, i32 0, i32 0
  %21 = load i32, i32* %code8, align 4, !tbaa !56
  %22 = load i32, i32* %code.addr, align 4, !tbaa !4
  %cmp9 = icmp ne i32 %21, %22
  br i1 %cmp9, label %if.then10, label %if.else13

if.then10:                                        ; preds = %lor.lhs.false, %while.end
  %23 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs11 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %23, i32 0, i32 2
  %24 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs11, align 8, !tbaa !54
  %arrayidx12 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %24, i64 31
  store %struct.TigrGlyph* %arrayidx12, %struct.TigrGlyph** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.else13:                                        ; preds = %lor.lhs.false
  %25 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %glyphs14 = getelementptr inbounds %struct.TigrFont, %struct.TigrFont* %25, i32 0, i32 2
  %26 = load %struct.TigrGlyph*, %struct.TigrGlyph** %glyphs14, align 8, !tbaa !54
  %27 = load i32, i32* %lo, align 4, !tbaa !4
  %sub15 = sub i32 %27, 1
  %idxprom16 = zext i32 %sub15 to i64
  %arrayidx17 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %26, i64 %idxprom16
  store %struct.TigrGlyph* %arrayidx17, %struct.TigrGlyph** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.else13, %if.then10
  %28 = bitcast i32* %hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %28) #11
  %29 = bitcast i32* %lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %29) #11
  %30 = load %struct.TigrGlyph*, %struct.TigrGlyph** %retval, align 8
  ret %struct.TigrGlyph* %30
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrTextWidth(%struct.TigrFont* %font, i8* %text) #0 {
entry:
  %font.addr = alloca %struct.TigrFont*, align 8
  %text.addr = alloca i8*, align 8
  %x = alloca i32, align 4
  %w = alloca i32, align 4
  %c = alloca i32, align 4
  store %struct.TigrFont* %font, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  store i8* %text, i8** %text.addr, align 8, !tbaa !8
  %0 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  store i32 0, i32* %x, align 4, !tbaa !4
  %1 = bitcast i32* %w to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  store i32 0, i32* %w, align 4, !tbaa !4
  %2 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  call void @tigrSetupFont(%struct.TigrFont* %3)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %4 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %5 = load i8, i8* %4, align 1, !tbaa !15
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load i8*, i8** %text.addr, align 8, !tbaa !8
  %call = call i8* @tigrDecodeUTF8(i8* %6, i32* %c)
  store i8* %call, i8** %text.addr, align 8, !tbaa !8
  %7 = load i32, i32* %c, align 4, !tbaa !4
  %cmp = icmp eq i32 %7, 10
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %8 = load i32, i32* %c, align 4, !tbaa !4
  %cmp1 = icmp eq i32 %8, 13
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %9 = load %struct.TigrFont*, %struct.TigrFont** %font.addr, align 8, !tbaa !8
  %10 = load i32, i32* %c, align 4, !tbaa !4
  %call2 = call %struct.TigrGlyph* @get(%struct.TigrFont* %9, i32 %10)
  %w3 = getelementptr inbounds %struct.TigrGlyph, %struct.TigrGlyph* %call2, i32 0, i32 3
  %11 = load i32, i32* %w3, align 4, !tbaa !60
  %12 = load i32, i32* %x, align 4, !tbaa !4
  %add = add nsw i32 %12, %11
  store i32 %add, i32* %x, align 4, !tbaa !4
  %13 = load i32, i32* %x, align 4, !tbaa !4
  %14 = load i32, i32* %w, align 4, !tbaa !4
  %cmp4 = icmp sgt i32 %13, %14
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %15 = load i32, i32* %x, align 4, !tbaa !4
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %16 = load i32, i32* %w, align 4, !tbaa !4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %15, %cond.true ], [ %16, %cond.false ]
  store i32 %cond, i32* %w, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %17 = load i32, i32* %w, align 4, !tbaa !4
  %18 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %18) #11
  %19 = bitcast i32* %w to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %19) #11
  %20 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %20) #11
  ret i32 %17
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #12

; Function Attrs: cold noreturn
declare void @__assert_rtn(i8*, i8*, i32, i8*) #13

; Function Attrs: nounwind ssp uwtable
define i64 @applicationShouldTerminate(%struct.objc_object* %self, %struct.objc_selector* %_sel, %struct.objc_object* %sender) #0 {
entry:
  %self.addr = alloca %struct.objc_object*, align 8
  %_sel.addr = alloca %struct.objc_selector*, align 8
  %sender.addr = alloca %struct.objc_object*, align 8
  store %struct.objc_object* %self, %struct.objc_object** %self.addr, align 8, !tbaa !8
  store %struct.objc_selector* %_sel, %struct.objc_selector** %_sel.addr, align 8, !tbaa !8
  store %struct.objc_object* %sender, %struct.objc_object** %sender.addr, align 8, !tbaa !8
  store i8 1, i8* @terminated, align 1, !tbaa !65
  ret i64 0
}

; Function Attrs: nounwind ssp uwtable
define void @windowWillClose(%struct.objc_object* %self, %struct.objc_selector* %_sel, %struct.objc_object* %notification) #0 {
entry:
  %self.addr = alloca %struct.objc_object*, align 8
  %_sel.addr = alloca %struct.objc_selector*, align 8
  %notification.addr = alloca %struct.objc_object*, align 8
  %value = alloca i64, align 8
  store %struct.objc_object* %self, %struct.objc_object** %self.addr, align 8, !tbaa !8
  store %struct.objc_selector* %_sel, %struct.objc_selector** %_sel.addr, align 8, !tbaa !8
  store %struct.objc_object* %notification, %struct.objc_object** %notification.addr, align 8, !tbaa !8
  %0 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  store i64 1, i64* %value, align 8, !tbaa !26
  %1 = load %struct.objc_object*, %struct.objc_object** %self.addr, align 8, !tbaa !8
  %2 = load i64, i64* %value, align 8, !tbaa !26
  %3 = inttoptr i64 %2 to i8*
  %call = call %struct.objc_ivar* @object_setInstanceVariable(%struct.objc_object* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i8* %3)
  %4 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #11
  ret void
}

declare %struct.objc_ivar* @object_setInstanceVariable(%struct.objc_object*, i8*, i8*) #5

; Function Attrs: nounwind ssp uwtable
define void @windowDidBecomeKey(%struct.objc_object* %self, %struct.objc_selector* %_sel, %struct.objc_object* %notification) #0 {
entry:
  %self.addr = alloca %struct.objc_object*, align 8
  %_sel.addr = alloca %struct.objc_selector*, align 8
  %notification.addr = alloca %struct.objc_object*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %bmp = alloca %struct.Tigr*, align 8
  store %struct.objc_object* %self, %struct.objc_object** %self.addr, align 8, !tbaa !8
  store %struct.objc_selector* %_sel, %struct.objc_selector** %_sel.addr, align 8, !tbaa !8
  store %struct.objc_object* %notification, %struct.objc_object** %notification.addr, align 8, !tbaa !8
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  store %struct.Tigr* null, %struct.Tigr** %bmp, align 8, !tbaa !8
  %2 = load %struct.objc_object*, %struct.objc_object** %self.addr, align 8, !tbaa !8
  %3 = bitcast %struct.Tigr** %bmp to i8**
  %call = call %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object* %2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i8** %3)
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %tobool = icmp ne %struct.Tigr* %4, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %call1 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.TigrInternal* [ %call1, %cond.true ], [ null, %cond.false ]
  store %struct.TigrInternal* %cond, %struct.TigrInternal** %win, align 8, !tbaa !8
  %6 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %tobool2 = icmp ne %struct.TigrInternal* %6, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %7 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %7, i32 0, i32 16
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i32 0, i32 0
  %8 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys3 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %8, i32 0, i32 16
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %keys3, i32 0, i32 0
  %9 = call i64 @llvm.objectsize.i64.p0i8(i8* %arraydecay4, i1 false, i1 true)
  %call5 = call i8* @__memset_chk(i8* %arraydecay, i32 0, i64 256, i64 %9) #11
  %10 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %prev = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %10, i32 0, i32 17
  %arraydecay6 = getelementptr inbounds [256 x i8], [256 x i8]* %prev, i32 0, i32 0
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %prev7 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %11, i32 0, i32 17
  %arraydecay8 = getelementptr inbounds [256 x i8], [256 x i8]* %prev7, i32 0, i32 0
  %12 = call i64 @llvm.objectsize.i64.p0i8(i8* %arraydecay8, i1 false, i1 true)
  %call9 = call i8* @__memset_chk(i8* %arraydecay6, i32 0, i64 256, i64 %12) #11
  %13 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %13, i32 0, i32 15
  store i32 0, i32* %lastChar, align 4, !tbaa !68
  %14 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %14, i32 0, i32 18
  store i32 0, i32* %mouseButtons, align 8, !tbaa !69
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %15 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #11
  %16 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #11
  ret void
}

declare %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object*, i8*, i8**) #5

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #3

; Function Attrs: nounwind ssp uwtable
define zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %window) #0 {
entry:
  %retval = alloca i1, align 1
  %window.addr = alloca %struct.objc_object*, align 8
  %wdg = alloca %struct.objc_object*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %value = alloca i64, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %0 = bitcast %struct.objc_object** %wdg to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %1, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %wdg, align 8, !tbaa !8
  %2 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  %tobool = icmp ne %struct.objc_object* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %3 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  store i64 0, i64* %value, align 8, !tbaa !26
  %4 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  %5 = bitcast i64* %value to i8**
  %call2 = call %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object* %4, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i8** %5)
  %6 = load i64, i64* %value, align 8, !tbaa !26
  %tobool3 = icmp ne i64 %6, 0
  %7 = zext i1 %tobool3 to i64
  %cond = select i1 %tobool3, i32 1, i32 0
  %tobool4 = icmp ne i32 %cond, 0
  store i1 %tobool4, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  %8 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #11
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %9 = bitcast %struct.objc_object** %wdg to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

declare void @objc_msgSend() #5

declare %struct.objc_selector* @sel_registerName(i8*) #5

; Function Attrs: nounwind ssp uwtable
define void @_tigrCleanupOSX() #0 {
entry:
  %0 = load %struct.objc_object*, %struct.objc_object** @autoreleasePool, align 8, !tbaa !8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %0, %struct.objc_selector* %call)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrInitOSX() #0 {
entry:
  %poolAlloc = alloca %struct.objc_object*, align 8
  %appDelegateClass = alloca %struct.objc_class*, align 8
  %resultAddProtoc = alloca i8, align 1
  %resultAddMethod = alloca i8, align 1
  %dgAlloc = alloca %struct.objc_object*, align 8
  %dg = alloca %struct.objc_object*, align 8
  %menubarAlloc = alloca %struct.objc_object*, align 8
  %menubar = alloca %struct.objc_object*, align 8
  %appMenuItemAlloc = alloca %struct.objc_object*, align 8
  %appMenuItem = alloca %struct.objc_object*, align 8
  %appMenuAlloc = alloca %struct.objc_object*, align 8
  %appMenu = alloca %struct.objc_object*, align 8
  %processInfo = alloca %struct.objc_object*, align 8
  %appName = alloca %struct.objc_object*, align 8
  %quitTitlePrefixString = alloca %struct.objc_object*, align 8
  %quitTitle = alloca %struct.objc_object*, align 8
  %quitMenuItemKey = alloca %struct.objc_object*, align 8
  %quitMenuItemAlloc = alloca %struct.objc_object*, align 8
  %quitMenuItem = alloca %struct.objc_object*, align 8
  %0 = load i8, i8* @tigrOSXInited, align 1, !tbaa !65, !range !67
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.objc_object** %poolAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %call = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.10, i32 0, i32 0))
  %2 = bitcast %struct.objc_class* %call to %struct.objc_object*
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call2 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %2, %struct.objc_selector* %call1)
  store %struct.objc_object* %call2, %struct.objc_object** %poolAlloc, align 8, !tbaa !8
  %3 = load %struct.objc_object*, %struct.objc_object** %poolAlloc, align 8, !tbaa !8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call4 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %3, %struct.objc_selector* %call3)
  store %struct.objc_object* %call4, %struct.objc_object** @autoreleasePool, align 8, !tbaa !8
  %call5 = call i32 @atexit(void ()* @_tigrCleanupOSX)
  %call6 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.13, i32 0, i32 0))
  %4 = bitcast %struct.objc_class* %call6 to %struct.objc_object*
  %call7 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.14, i32 0, i32 0))
  %call8 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %4, %struct.objc_selector* %call7)
  %5 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call9 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.15, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i64)*)(%struct.objc_object* %5, %struct.objc_selector* %call9, i64 0)
  %6 = bitcast %struct.objc_class** %appDelegateClass to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %call10 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.16, i32 0, i32 0))
  %call11 = call %struct.objc_class* @objc_allocateClassPair(%struct.objc_class* %call10, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.17, i32 0, i32 0), i64 0)
  store %struct.objc_class* %call11, %struct.objc_class** %appDelegateClass, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %resultAddProtoc) #11
  %7 = load %struct.objc_class*, %struct.objc_class** %appDelegateClass, align 8, !tbaa !8
  %call12 = call %struct.objc_object* @objc_getProtocol(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.18, i32 0, i32 0))
  %call13 = call signext i8 @class_addProtocol(%struct.objc_class* %7, %struct.objc_object* %call12)
  %tobool14 = icmp ne i8 %call13, 0
  %frombool = zext i1 %tobool14 to i8
  store i8 %frombool, i8* %resultAddProtoc, align 1, !tbaa !65
  %8 = load i8, i8* %resultAddProtoc, align 1, !tbaa !65, !range !67
  %tobool15 = trunc i8 %8 to i1
  %lnot = xor i1 %tobool15, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrInitOSX, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 2906, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.19, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %9
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %resultAddMethod) #11
  %10 = load %struct.objc_class*, %struct.objc_class** %appDelegateClass, align 8, !tbaa !8
  %call17 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.20, i32 0, i32 0))
  %call18 = call signext i8 @class_addMethod(%struct.objc_class* %10, %struct.objc_selector* %call17, void ()* bitcast (i64 (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)* @applicationShouldTerminate to void ()*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21, i32 0, i32 0))
  %tobool19 = icmp ne i8 %call18, 0
  %frombool20 = zext i1 %tobool19 to i8
  store i8 %frombool20, i8* %resultAddMethod, align 1, !tbaa !65
  %11 = load i8, i8* %resultAddMethod, align 1, !tbaa !65, !range !67
  %tobool21 = trunc i8 %11 to i1
  %lnot22 = xor i1 %tobool21, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %cond.true27, label %cond.false28

cond.true27:                                      ; preds = %cond.end
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrInitOSX, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 2908, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end29

cond.false28:                                     ; preds = %cond.end
  br label %cond.end29

cond.end29:                                       ; preds = %cond.false28, %12
  %13 = bitcast %struct.objc_object** %dgAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #11
  %14 = load %struct.objc_class*, %struct.objc_class** %appDelegateClass, align 8, !tbaa !8
  %15 = bitcast %struct.objc_class* %14 to %struct.objc_object*
  %call30 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call31 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %15, %struct.objc_selector* %call30)
  store %struct.objc_object* %call31, %struct.objc_object** %dgAlloc, align 8, !tbaa !8
  %16 = bitcast %struct.objc_object** %dg to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #11
  %17 = load %struct.objc_object*, %struct.objc_object** %dgAlloc, align 8, !tbaa !8
  %call32 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call33 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %17, %struct.objc_selector* %call32)
  store %struct.objc_object* %call33, %struct.objc_object** %dg, align 8, !tbaa !8
  %18 = load %struct.objc_object*, %struct.objc_object** %dg, align 8, !tbaa !8
  %call34 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %18, %struct.objc_selector* %call34)
  %19 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call35 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.24, i32 0, i32 0))
  %20 = load %struct.objc_object*, %struct.objc_object** %dg, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %19, %struct.objc_selector* %call35, %struct.objc_object* %20)
  %21 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call36 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.25, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %21, %struct.objc_selector* %call36)
  %22 = bitcast %struct.objc_object** %menubarAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %22) #11
  %call37 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %23 = bitcast %struct.objc_class* %call37 to %struct.objc_object*
  %call38 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call39 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %23, %struct.objc_selector* %call38)
  store %struct.objc_object* %call39, %struct.objc_object** %menubarAlloc, align 8, !tbaa !8
  %24 = bitcast %struct.objc_object** %menubar to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #11
  %25 = load %struct.objc_object*, %struct.objc_object** %menubarAlloc, align 8, !tbaa !8
  %call40 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call41 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %25, %struct.objc_selector* %call40)
  store %struct.objc_object* %call41, %struct.objc_object** %menubar, align 8, !tbaa !8
  %26 = load %struct.objc_object*, %struct.objc_object** %menubar, align 8, !tbaa !8
  %call42 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %26, %struct.objc_selector* %call42)
  %27 = bitcast %struct.objc_object** %appMenuItemAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %27) #11
  %call43 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0))
  %28 = bitcast %struct.objc_class* %call43 to %struct.objc_object*
  %call44 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call45 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %28, %struct.objc_selector* %call44)
  store %struct.objc_object* %call45, %struct.objc_object** %appMenuItemAlloc, align 8, !tbaa !8
  %29 = bitcast %struct.objc_object** %appMenuItem to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %29) #11
  %30 = load %struct.objc_object*, %struct.objc_object** %appMenuItemAlloc, align 8, !tbaa !8
  %call46 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call47 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %30, %struct.objc_selector* %call46)
  store %struct.objc_object* %call47, %struct.objc_object** %appMenuItem, align 8, !tbaa !8
  %31 = load %struct.objc_object*, %struct.objc_object** %appMenuItem, align 8, !tbaa !8
  %call48 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %31, %struct.objc_selector* %call48)
  %32 = load %struct.objc_object*, %struct.objc_object** %menubar, align 8, !tbaa !8
  %call49 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28, i32 0, i32 0))
  %33 = load %struct.objc_object*, %struct.objc_object** %appMenuItem, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %32, %struct.objc_selector* %call49, %struct.objc_object* %33)
  %34 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call50 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.29, i32 0, i32 0))
  %35 = load %struct.objc_object*, %struct.objc_object** %menubar, align 8, !tbaa !8
  %call51 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %34, %struct.objc_selector* %call50, %struct.objc_object* %35)
  %36 = bitcast %struct.objc_object** %appMenuAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %36) #11
  %call52 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %37 = bitcast %struct.objc_class* %call52 to %struct.objc_object*
  %call53 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call54 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %37, %struct.objc_selector* %call53)
  store %struct.objc_object* %call54, %struct.objc_object** %appMenuAlloc, align 8, !tbaa !8
  %38 = bitcast %struct.objc_object** %appMenu to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %38) #11
  %39 = load %struct.objc_object*, %struct.objc_object** %appMenuAlloc, align 8, !tbaa !8
  %call55 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call56 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %39, %struct.objc_selector* %call55)
  store %struct.objc_object* %call56, %struct.objc_object** %appMenu, align 8, !tbaa !8
  %40 = load %struct.objc_object*, %struct.objc_object** %appMenu, align 8, !tbaa !8
  %call57 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %40, %struct.objc_selector* %call57)
  %41 = bitcast %struct.objc_object** %processInfo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %41) #11
  %call58 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.30, i32 0, i32 0))
  %42 = bitcast %struct.objc_class* %call58 to %struct.objc_object*
  %call59 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.31, i32 0, i32 0))
  %call60 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %42, %struct.objc_selector* %call59)
  store %struct.objc_object* %call60, %struct.objc_object** %processInfo, align 8, !tbaa !8
  %43 = bitcast %struct.objc_object** %appName to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %43) #11
  %44 = load %struct.objc_object*, %struct.objc_object** %processInfo, align 8, !tbaa !8
  %call61 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.32, i32 0, i32 0))
  %call62 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %44, %struct.objc_selector* %call61)
  store %struct.objc_object* %call62, %struct.objc_object** %appName, align 8, !tbaa !8
  %45 = bitcast %struct.objc_object** %quitTitlePrefixString to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %45) #11
  %call63 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0))
  %46 = bitcast %struct.objc_class* %call63 to %struct.objc_object*
  %call64 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34, i32 0, i32 0))
  %call65 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i8*)*)(%struct.objc_object* %46, %struct.objc_selector* %call64, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.35, i32 0, i32 0))
  store %struct.objc_object* %call65, %struct.objc_object** %quitTitlePrefixString, align 8, !tbaa !8
  %47 = bitcast %struct.objc_object** %quitTitle to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %47) #11
  %48 = load %struct.objc_object*, %struct.objc_object** %quitTitlePrefixString, align 8, !tbaa !8
  %call66 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36, i32 0, i32 0))
  %49 = load %struct.objc_object*, %struct.objc_object** %appName, align 8, !tbaa !8
  %call67 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %48, %struct.objc_selector* %call66, %struct.objc_object* %49)
  store %struct.objc_object* %call67, %struct.objc_object** %quitTitle, align 8, !tbaa !8
  %50 = bitcast %struct.objc_object** %quitMenuItemKey to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %50) #11
  %call68 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0))
  %51 = bitcast %struct.objc_class* %call68 to %struct.objc_object*
  %call69 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34, i32 0, i32 0))
  %call70 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i8*)*)(%struct.objc_object* %51, %struct.objc_selector* %call69, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.37, i32 0, i32 0))
  store %struct.objc_object* %call70, %struct.objc_object** %quitMenuItemKey, align 8, !tbaa !8
  %52 = bitcast %struct.objc_object** %quitMenuItemAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %52) #11
  %call71 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0))
  %53 = bitcast %struct.objc_class* %call71 to %struct.objc_object*
  %call72 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call73 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %53, %struct.objc_selector* %call72)
  store %struct.objc_object* %call73, %struct.objc_object** %quitMenuItemAlloc, align 8, !tbaa !8
  %54 = bitcast %struct.objc_object** %quitMenuItem to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %54) #11
  %55 = load %struct.objc_object*, %struct.objc_object** %quitMenuItemAlloc, align 8, !tbaa !8
  %call74 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.38, i32 0, i32 0))
  %56 = load %struct.objc_object*, %struct.objc_object** %quitTitle, align 8, !tbaa !8
  %call75 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.39, i32 0, i32 0))
  %57 = load %struct.objc_object*, %struct.objc_object** %quitMenuItemKey, align 8, !tbaa !8
  %call76 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %55, %struct.objc_selector* %call74, %struct.objc_object* %56, %struct.objc_selector* %call75, %struct.objc_object* %57)
  store %struct.objc_object* %call76, %struct.objc_object** %quitMenuItem, align 8, !tbaa !8
  %58 = load %struct.objc_object*, %struct.objc_object** %quitMenuItem, align 8, !tbaa !8
  %call77 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %58, %struct.objc_selector* %call77)
  %59 = load %struct.objc_object*, %struct.objc_object** %appMenu, align 8, !tbaa !8
  %call78 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28, i32 0, i32 0))
  %60 = load %struct.objc_object*, %struct.objc_object** %quitMenuItem, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %59, %struct.objc_selector* %call78, %struct.objc_object* %60)
  %61 = load %struct.objc_object*, %struct.objc_object** %appMenuItem, align 8, !tbaa !8
  %call79 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.40, i32 0, i32 0))
  %62 = load %struct.objc_object*, %struct.objc_object** %appMenu, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %61, %struct.objc_selector* %call79, %struct.objc_object* %62)
  store i8 1, i8* @tigrOSXInited, align 1, !tbaa !65
  %63 = bitcast %struct.objc_object** %quitMenuItem to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %63) #11
  %64 = bitcast %struct.objc_object** %quitMenuItemAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %64) #11
  %65 = bitcast %struct.objc_object** %quitMenuItemKey to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %65) #11
  %66 = bitcast %struct.objc_object** %quitTitle to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %66) #11
  %67 = bitcast %struct.objc_object** %quitTitlePrefixString to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %67) #11
  %68 = bitcast %struct.objc_object** %appName to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %68) #11
  %69 = bitcast %struct.objc_object** %processInfo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %69) #11
  %70 = bitcast %struct.objc_object** %appMenu to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %70) #11
  %71 = bitcast %struct.objc_object** %appMenuAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #11
  %72 = bitcast %struct.objc_object** %appMenuItem to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %72) #11
  %73 = bitcast %struct.objc_object** %appMenuItemAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %73) #11
  %74 = bitcast %struct.objc_object** %menubar to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %74) #11
  %75 = bitcast %struct.objc_object** %menubarAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %75) #11
  %76 = bitcast %struct.objc_object** %dg to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %76) #11
  %77 = bitcast %struct.objc_object** %dgAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %77) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %resultAddMethod) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %resultAddProtoc) #11
  %78 = bitcast %struct.objc_class** %appDelegateClass to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %78) #11
  %79 = bitcast %struct.objc_object** %poolAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %79) #11
  br label %return

return:                                           ; preds = %cond.end29, %if.then
  ret void
}

declare %struct.objc_class* @objc_getClass(i8*) #5

declare i32 @atexit(void ()*) #5

declare %struct.objc_class* @objc_allocateClassPair(%struct.objc_class*, i8*, i64) #5

declare signext i8 @class_addProtocol(%struct.objc_class*, %struct.objc_object*) #5

declare %struct.objc_object* @objc_getProtocol(i8*) #5

declare signext i8 @class_addMethod(%struct.objc_class*, %struct.objc_selector*, void ()*, i8*) #5

; Function Attrs: nounwind ssp uwtable
define void @tigrError(%struct.Tigr* %bmp, i8* %message, ...) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %message.addr = alloca i8*, align 8
  %tmp = alloca [1024 x i8], align 16
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %header = alloca %struct.__CFString*, align 8
  %msg = alloca %struct.__CFString*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i8* %message, i8** %message.addr, align 8, !tbaa !8
  %0 = bitcast [1024 x i8]* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 1024, i8* %0) #11
  %1 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %1) #11
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %2 = load i8*, i8** %message.addr, align 8, !tbaa !8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %2, %struct.__va_list_tag* %arraydecay3)
  %arrayidx = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i64 0, i64 1023
  store i8 0, i8* %arrayidx, align 1, !tbaa !15
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %3 = bitcast %struct.__CFString** %header to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %call6 = call %struct.__CFString* @CFStringCreateWithCString(%struct.__CFAllocator* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.41, i32 0, i32 0), i32 134217984)
  store %struct.__CFString* %call6, %struct.__CFString** %header, align 8, !tbaa !8
  %4 = bitcast %struct.__CFString** %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %arraydecay7 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %call8 = call %struct.__CFString* @CFStringCreateWithCString(%struct.__CFAllocator* null, i8* %arraydecay7, i32 134217984)
  store %struct.__CFString* %call8, %struct.__CFString** %msg, align 8, !tbaa !8
  %5 = load %struct.__CFString*, %struct.__CFString** %header, align 8, !tbaa !8
  %6 = load %struct.__CFString*, %struct.__CFString** %msg, align 8, !tbaa !8
  %call9 = call i32 @CFUserNotificationDisplayNotice(double 0.000000e+00, i64 0, %struct.__CFURL* null, %struct.__CFURL* null, %struct.__CFURL* null, %struct.__CFString* %5, %struct.__CFString* %6, %struct.__CFString* null)
  %7 = load %struct.__CFString*, %struct.__CFString** %header, align 8, !tbaa !8
  %8 = bitcast %struct.__CFString* %7 to i8*
  call void @CFRelease(i8* %8)
  %9 = load %struct.__CFString*, %struct.__CFString** %msg, align 8, !tbaa !8
  %10 = bitcast %struct.__CFString* %9 to i8*
  call void @CFRelease(i8* %10)
  call void @exit(i32 1) #20
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare %struct.__CFString* @CFStringCreateWithCString(%struct.__CFAllocator*, i8*, i32) #5

declare i32 @CFUserNotificationDisplayNotice(double, i64, %struct.__CFURL*, %struct.__CFURL*, %struct.__CFURL*, %struct.__CFString*, %struct.__CFString*, %struct.__CFString*) #5

declare void @CFRelease(i8*) #5

; Function Attrs: noreturn
declare void @exit(i32) #10

; Function Attrs: nounwind ssp uwtable
define { double, double } @_tigrCocoaWindowSize(%struct.objc_object* %window) #0 {
entry:
  %retval = alloca %struct.CGSize, align 8
  %window.addr = alloca %struct.objc_object*, align 8
  %contentView = alloca %struct.objc_object*, align 8
  %rect = alloca %struct.CGRect, align 8
  %tmp = alloca %struct.CGRect, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %0 = bitcast %struct.objc_object** %contentView to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %1, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %contentView, align 8, !tbaa !8
  %2 = bitcast %struct.CGRect* %rect to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %2) #11
  %3 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8, !tbaa !8
  %call2 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.43, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*)*)(%struct.CGRect* sret %rect, %struct.objc_object* %3, %struct.objc_selector* %call2)
  %4 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %4) #11
  %5 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8, !tbaa !8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.44, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*, %struct.CGRect*)*)(%struct.CGRect* sret %tmp, %struct.objc_object* %5, %struct.objc_selector* %call3, %struct.CGRect* byval align 8 %rect)
  %6 = bitcast %struct.CGRect* %rect to i8*
  %7 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 %7, i64 32, i1 false), !tbaa.struct !70
  %8 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %8) #11
  %size = getelementptr inbounds %struct.CGRect, %struct.CGRect* %rect, i32 0, i32 1
  %9 = bitcast %struct.CGSize* %retval to i8*
  %10 = bitcast %struct.CGSize* %size to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %10, i64 16, i1 false), !tbaa.struct !73
  %11 = bitcast %struct.CGRect* %rect to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %11) #11
  %12 = bitcast %struct.objc_object** %contentView to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #11
  %13 = bitcast %struct.CGSize* %retval to { double, double }*
  %14 = load { double, double }, { double, double }* %13, align 8
  ret { double, double } %14
}

declare void @objc_msgSend_stret() #5

; Function Attrs: nounwind ssp uwtable
define %struct.TigrInternal* @_tigrInternalCocoa(%struct.objc_object* %window) #0 {
entry:
  %retval = alloca %struct.TigrInternal*, align 8
  %window.addr = alloca %struct.objc_object*, align 8
  %wdg = alloca %struct.objc_object*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %bmp = alloca %struct.Tigr*, align 8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %0 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %tobool = icmp ne %struct.objc_object* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.TigrInternal* null, %struct.TigrInternal** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.objc_object** %wdg to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %2, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %wdg, align 8, !tbaa !8
  %3 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  %tobool2 = icmp ne %struct.objc_object* %3, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store %struct.TigrInternal* null, %struct.TigrInternal** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %4 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  store %struct.Tigr* null, %struct.Tigr** %bmp, align 8, !tbaa !8
  %5 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  %6 = bitcast %struct.Tigr** %bmp to i8**
  %call5 = call %struct.objc_ivar* @object_getInstanceVariable(%struct.objc_object* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i8** %6)
  %7 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %tobool6 = icmp ne %struct.Tigr* %7, null
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %8 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %call7 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %8)
  br label %cond.end

cond.false:                                       ; preds = %if.end4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.TigrInternal* [ %call7, %cond.true ], [ null, %cond.false ]
  store %struct.TigrInternal* %cond, %struct.TigrInternal** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  %9 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  br label %cleanup

cleanup:                                          ; preds = %cond.end, %if.then3
  %10 = bitcast %struct.objc_object** %wdg to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  br label %return

return:                                           ; preds = %cleanup, %if.then
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %retval, align 8
  ret %struct.TigrInternal* %11
}

; Function Attrs: nounwind ssp uwtable
define %struct.Tigr* @tigrWindow(i32 %w, i32 %h, i8* %title, i32 %flags) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %title.addr = alloca i8*, align 8
  %flags.addr = alloca i32, align 4
  %scale = alloca i32, align 4
  %bmp = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %mainMonitor = alloca %struct.CGRect, align 8
  %maxW = alloca i32, align 4
  %maxH = alloca i32, align 4
  %rect = alloca %struct.CGRect, align 8
  %windowAlloc = alloca %struct.objc_object*, align 8
  %window = alloca %struct.objc_object*, align 8
  %WindowDelegateClass = alloca %struct.objc_class*, align 8
  %resultAddProtoc = alloca i8, align 1
  %resultAddIvar = alloca i8, align 1
  %resultAddMethod = alloca i8, align 1
  %wdgAlloc = alloca %struct.objc_object*, align 8
  %wdg = alloca %struct.objc_object*, align 8
  %contentView = alloca %struct.objc_object*, align 8
  %point = alloca %struct.CGPoint, align 8
  %titleString = alloca %struct.objc_object*, align 8
  %glAttributes = alloca [9 x i32], align 16
  %pixelFormatAlloc = alloca %struct.objc_object*, align 8
  %pixelFormat = alloca %struct.objc_object*, align 8
  %openGLContextAlloc = alloca %struct.objc_object*, align 8
  %openGLContext = alloca %struct.objc_object*, align 8
  %blackColor = alloca %struct.objc_object*, align 8
  %windowSize = alloca %struct.CGSize, align 8
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  store i8* %title, i8** %title.addr, align 8, !tbaa !8
  store i32 %flags, i32* %flags.addr, align 4, !tbaa !4
  %0 = bitcast i32* %scale to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  call void @tigrInitOSX()
  %3 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %scale, align 4, !tbaa !4
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = bitcast %struct.CGRect* %mainMonitor to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %4) #11
  %call = call i32 @CGMainDisplayID()
  call void @CGDisplayBounds(%struct.CGRect* sret %mainMonitor, i32 %call)
  %5 = bitcast i32* %maxW to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  %call1 = call double @CGRectGetHeight(%struct.CGRect* byval align 8 %mainMonitor)
  %mul = fmul double %call1, 3.000000e+00
  %div = fdiv double %mul, 4.000000e+00
  %conv = fptosi double %div to i32
  store i32 %conv, i32* %maxW, align 4, !tbaa !4
  %6 = bitcast i32* %maxH to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %call2 = call double @CGRectGetWidth(%struct.CGRect* byval align 8 %mainMonitor)
  %mul3 = fmul double %call2, 3.000000e+00
  %div4 = fdiv double %mul3, 4.000000e+00
  %conv5 = fptosi double %div4 to i32
  store i32 %conv5, i32* %maxH, align 4, !tbaa !4
  %7 = load i32, i32* %w.addr, align 4, !tbaa !4
  %8 = load i32, i32* %h.addr, align 4, !tbaa !4
  %9 = load i32, i32* %maxW, align 4, !tbaa !4
  %10 = load i32, i32* %maxH, align 4, !tbaa !4
  %call6 = call i32 @tigrCalcScale(i32 %7, i32 %8, i32 %9, i32 %10)
  store i32 %call6, i32* %scale, align 4, !tbaa !4
  %11 = bitcast i32* %maxH to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #11
  %12 = bitcast i32* %maxW to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #11
  %13 = bitcast %struct.CGRect* %mainMonitor to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %13) #11
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %14 = load i32, i32* %scale, align 4, !tbaa !4
  %15 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %call7 = call i32 @tigrEnforceScale(i32 %14, i32 %15)
  store i32 %call7, i32* %scale, align 4, !tbaa !4
  %16 = bitcast %struct.CGRect* %rect to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %16) #11
  %origin = getelementptr inbounds %struct.CGRect, %struct.CGRect* %rect, i32 0, i32 0
  %x = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 0
  store double 0.000000e+00, double* %x, align 8, !tbaa !74
  %y = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 1
  store double 0.000000e+00, double* %y, align 8, !tbaa !76
  %size = getelementptr inbounds %struct.CGRect, %struct.CGRect* %rect, i32 0, i32 1
  %width = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size, i32 0, i32 0
  %17 = load i32, i32* %w.addr, align 4, !tbaa !4
  %18 = load i32, i32* %scale, align 4, !tbaa !4
  %mul8 = mul nsw i32 %17, %18
  %conv9 = sitofp i32 %mul8 to double
  store double %conv9, double* %width, align 8, !tbaa !77
  %height = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size, i32 0, i32 1
  %19 = load i32, i32* %h.addr, align 4, !tbaa !4
  %20 = load i32, i32* %scale, align 4, !tbaa !4
  %mul10 = mul nsw i32 %19, %20
  %conv11 = sitofp i32 %mul10 to double
  store double %conv11, double* %height, align 8, !tbaa !79
  %21 = bitcast %struct.objc_object** %windowAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) #11
  %call12 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.45, i32 0, i32 0))
  %22 = bitcast %struct.objc_class* %call12 to %struct.objc_object*
  %call13 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call14 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %22, %struct.objc_selector* %call13)
  store %struct.objc_object* %call14, %struct.objc_object** %windowAlloc, align 8, !tbaa !8
  %23 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %23) #11
  %24 = load %struct.objc_object*, %struct.objc_object** %windowAlloc, align 8, !tbaa !8
  %call15 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.46, i32 0, i32 0))
  %call16 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.CGRect*, i64, i64, i8)*)(%struct.objc_object* %24, %struct.objc_selector* %call15, %struct.CGRect* byval align 8 %rect, i64 15, i64 2, i8 signext 0)
  store %struct.objc_object* %call16, %struct.objc_object** %window, align 8, !tbaa !8
  %25 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call17 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %25, %struct.objc_selector* %call17)
  %26 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call18 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.47, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %26, %struct.objc_selector* %call18, i8 signext 0)
  %27 = bitcast %struct.objc_class** %WindowDelegateClass to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %27) #11
  %call19 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.16, i32 0, i32 0))
  %call20 = call %struct.objc_class* @objc_allocateClassPair(%struct.objc_class* %call19, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.48, i32 0, i32 0), i64 0)
  store %struct.objc_class* %call20, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %resultAddProtoc) #11
  %28 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  %call21 = call %struct.objc_object* @objc_getProtocol(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.49, i32 0, i32 0))
  %call22 = call signext i8 @class_addProtocol(%struct.objc_class* %28, %struct.objc_object* %call21)
  %tobool23 = icmp ne i8 %call22, 0
  %frombool = zext i1 %tobool23 to i8
  store i8 %frombool, i8* %resultAddProtoc, align 1, !tbaa !65
  %29 = load i8, i8* %resultAddProtoc, align 1, !tbaa !65, !range !67
  %tobool24 = trunc i8 %29 to i1
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %conv25 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool26 = icmp ne i64 %expval, 0
  br i1 %tobool26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3035, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.19, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %30
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %resultAddIvar) #11
  %31 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  %32 = call double @llvm.log2.f64(double 8.000000e+00)
  %33 = call double @llvm.rint.f64(double %32)
  %conv27 = fptoui double %33 to i8
  %call28 = call signext i8 @class_addIvar(%struct.objc_class* %31, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i64 8, i8 zeroext %conv27, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.50, i32 0, i32 0))
  %tobool29 = icmp ne i8 %call28, 0
  %frombool30 = zext i1 %tobool29 to i8
  store i8 %frombool30, i8* %resultAddIvar, align 1, !tbaa !65
  %34 = load i8, i8* %resultAddIvar, align 1, !tbaa !65, !range !67
  %tobool31 = trunc i8 %34 to i1
  %lnot32 = xor i1 %tobool31, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %cond.end
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3037, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.51, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end39

cond.false38:                                     ; preds = %cond.end
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %35
  %36 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  %37 = call double @llvm.log2.f64(double 8.000000e+00)
  %38 = call double @llvm.rint.f64(double %37)
  %conv40 = fptoui double %38 to i8
  %call41 = call signext i8 @class_addIvar(%struct.objc_class* %36, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i64 8, i8 zeroext %conv40, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.52, i32 0, i32 0))
  %tobool42 = icmp ne i8 %call41, 0
  %frombool43 = zext i1 %tobool42 to i8
  store i8 %frombool43, i8* %resultAddIvar, align 1, !tbaa !65
  %39 = load i8, i8* %resultAddIvar, align 1, !tbaa !65, !range !67
  %tobool44 = trunc i8 %39 to i1
  %lnot45 = xor i1 %tobool44, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  %expval48 = call i64 @llvm.expect.i64(i64 %conv47, i64 0)
  %tobool49 = icmp ne i64 %expval48, 0
  br i1 %tobool49, label %cond.true50, label %cond.false51

cond.true50:                                      ; preds = %cond.end39
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3039, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.51, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end52

cond.false51:                                     ; preds = %cond.end39
  br label %cond.end52

cond.end52:                                       ; preds = %cond.false51, %40
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %resultAddMethod) #11
  %41 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  %call53 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.53, i32 0, i32 0))
  %call54 = call signext i8 @class_addMethod(%struct.objc_class* %41, %struct.objc_selector* %call53, void ()* bitcast (void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)* @windowWillClose to void ()*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.54, i32 0, i32 0))
  %tobool55 = icmp ne i8 %call54, 0
  %frombool56 = zext i1 %tobool55 to i8
  store i8 %frombool56, i8* %resultAddMethod, align 1, !tbaa !65
  %42 = load i8, i8* %resultAddMethod, align 1, !tbaa !65, !range !67
  %tobool57 = trunc i8 %42 to i1
  %lnot58 = xor i1 %tobool57, true
  %lnot.ext59 = zext i1 %lnot58 to i32
  %conv60 = sext i32 %lnot.ext59 to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %cond.true63, label %cond.false64

cond.true63:                                      ; preds = %cond.end52
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3041, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end65

cond.false64:                                     ; preds = %cond.end52
  br label %cond.end65

cond.end65:                                       ; preds = %cond.false64, %43
  %44 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  %call66 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.55, i32 0, i32 0))
  %call67 = call signext i8 @class_addMethod(%struct.objc_class* %44, %struct.objc_selector* %call66, void ()* bitcast (void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)* @windowDidBecomeKey to void ()*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.54, i32 0, i32 0))
  %tobool68 = icmp ne i8 %call67, 0
  %frombool69 = zext i1 %tobool68 to i8
  store i8 %frombool69, i8* %resultAddMethod, align 1, !tbaa !65
  %45 = load i8, i8* %resultAddMethod, align 1, !tbaa !65, !range !67
  %tobool70 = trunc i8 %45 to i1
  %lnot71 = xor i1 %tobool70, true
  %lnot.ext72 = zext i1 %lnot71 to i32
  %conv73 = sext i32 %lnot.ext72 to i64
  %expval74 = call i64 @llvm.expect.i64(i64 %conv73, i64 0)
  %tobool75 = icmp ne i64 %expval74, 0
  br i1 %tobool75, label %cond.true76, label %cond.false77

cond.true76:                                      ; preds = %cond.end65
  call void @__assert_rtn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.tigrWindow, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3043, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end78

cond.false77:                                     ; preds = %cond.end65
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false77, %46
  %47 = bitcast %struct.objc_object** %wdgAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %47) #11
  %48 = load %struct.objc_class*, %struct.objc_class** %WindowDelegateClass, align 8, !tbaa !8
  %49 = bitcast %struct.objc_class* %48 to %struct.objc_object*
  %call79 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call80 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %49, %struct.objc_selector* %call79)
  store %struct.objc_object* %call80, %struct.objc_object** %wdgAlloc, align 8, !tbaa !8
  %50 = bitcast %struct.objc_object** %wdg to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %50) #11
  %51 = load %struct.objc_object*, %struct.objc_object** %wdgAlloc, align 8, !tbaa !8
  %call81 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0))
  %call82 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %51, %struct.objc_selector* %call81)
  store %struct.objc_object* %call82, %struct.objc_object** %wdg, align 8, !tbaa !8
  %52 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  %call83 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %52, %struct.objc_selector* %call83)
  %53 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call84 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.24, i32 0, i32 0))
  %54 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %53, %struct.objc_selector* %call84, %struct.objc_object* %54)
  %55 = bitcast %struct.objc_object** %contentView to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %55) #11
  %56 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call85 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0))
  %call86 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %56, %struct.objc_selector* %call85)
  store %struct.objc_object* %call86, %struct.objc_object** %contentView, align 8, !tbaa !8
  %57 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %and87 = and i32 %57, 16
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.then89, label %if.end91

if.then89:                                        ; preds = %cond.end78
  %58 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8, !tbaa !8
  %call90 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.56, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %58, %struct.objc_selector* %call90, i8 signext 1)
  br label %if.end91

if.end91:                                         ; preds = %if.then89, %cond.end78
  %59 = bitcast %struct.CGPoint* %point to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %59) #11
  %60 = bitcast %struct.CGPoint* %point to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %60, i8* align 8 bitcast (%struct.CGPoint* @__const.tigrWindow.point to i8*), i64 16, i1 false)
  %61 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call92 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.57, i32 0, i32 0))
  %62 = bitcast %struct.CGPoint* %point to { double, double }*
  %63 = getelementptr inbounds { double, double }, { double, double }* %62, i32 0, i32 0
  %64 = load double, double* %63, align 8
  %65 = getelementptr inbounds { double, double }, { double, double }* %62, i32 0, i32 1
  %66 = load double, double* %65, align 8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, double, double)*)(%struct.objc_object* %61, %struct.objc_selector* %call92, double %64, double %66)
  %67 = bitcast %struct.objc_object** %titleString to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %67) #11
  %call93 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0))
  %68 = bitcast %struct.objc_class* %call93 to %struct.objc_object*
  %call94 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34, i32 0, i32 0))
  %69 = load i8*, i8** %title.addr, align 8, !tbaa !8
  %call95 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i8*)*)(%struct.objc_object* %68, %struct.objc_selector* %call94, i8* %69)
  store %struct.objc_object* %call95, %struct.objc_object** %titleString, align 8, !tbaa !8
  %70 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call96 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.58, i32 0, i32 0))
  %71 = load %struct.objc_object*, %struct.objc_object** %titleString, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %70, %struct.objc_selector* %call96, %struct.objc_object* %71)
  %72 = bitcast [9 x i32]* %glAttributes to i8*
  call void @llvm.lifetime.start.p0i8(i64 36, i8* %72) #11
  %73 = bitcast [9 x i32]* %glAttributes to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %73, i8* align 16 bitcast ([9 x i32]* @__const.tigrWindow.glAttributes to i8*), i64 36, i1 false)
  %74 = bitcast %struct.objc_object** %pixelFormatAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %74) #11
  %call97 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.59, i32 0, i32 0))
  %75 = bitcast %struct.objc_class* %call97 to %struct.objc_object*
  %call98 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call99 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %75, %struct.objc_selector* %call98)
  store %struct.objc_object* %call99, %struct.objc_object** %pixelFormatAlloc, align 8, !tbaa !8
  %76 = bitcast %struct.objc_object** %pixelFormat to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %76) #11
  %77 = load %struct.objc_object*, %struct.objc_object** %pixelFormatAlloc, align 8, !tbaa !8
  %call100 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.60, i32 0, i32 0))
  %arraydecay = getelementptr inbounds [9 x i32], [9 x i32]* %glAttributes, i32 0, i32 0
  %call101 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i32*)*)(%struct.objc_object* %77, %struct.objc_selector* %call100, i32* %arraydecay)
  store %struct.objc_object* %call101, %struct.objc_object** %pixelFormat, align 8, !tbaa !8
  %78 = load %struct.objc_object*, %struct.objc_object** %pixelFormat, align 8, !tbaa !8
  %call102 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %78, %struct.objc_selector* %call102)
  %79 = bitcast %struct.objc_object** %openGLContextAlloc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %79) #11
  %call103 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.61, i32 0, i32 0))
  %80 = bitcast %struct.objc_class* %call103 to %struct.objc_object*
  %call104 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0))
  %call105 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %80, %struct.objc_selector* %call104)
  store %struct.objc_object* %call105, %struct.objc_object** %openGLContextAlloc, align 8, !tbaa !8
  %81 = bitcast %struct.objc_object** %openGLContext to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %81) #11
  %82 = load %struct.objc_object*, %struct.objc_object** %openGLContextAlloc, align 8, !tbaa !8
  %call106 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.62, i32 0, i32 0))
  %83 = load %struct.objc_object*, %struct.objc_object** %pixelFormat, align 8, !tbaa !8
  %call107 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*, %struct.objc_object*)*)(%struct.objc_object* %82, %struct.objc_selector* %call106, %struct.objc_object* %83, %struct.objc_object* null)
  store %struct.objc_object* %call107, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %84 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %call108 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %84, %struct.objc_selector* %call108)
  %85 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %call109 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.63, i32 0, i32 0))
  %86 = load %struct.objc_object*, %struct.objc_object** %contentView, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %85, %struct.objc_selector* %call109, %struct.objc_object* %86)
  %87 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call110 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.64, i32 0, i32 0))
  %88 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %87, %struct.objc_selector* %call110, %struct.objc_object* %88)
  %89 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call111 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.65, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %89, %struct.objc_selector* %call111, i8 signext 1)
  %90 = bitcast %struct.objc_object** %blackColor to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %90) #11
  %call112 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.66, i32 0, i32 0))
  %91 = bitcast %struct.objc_class* %call112 to %struct.objc_object*
  %call113 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.67, i32 0, i32 0))
  %call114 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %91, %struct.objc_selector* %call113)
  store %struct.objc_object* %call114, %struct.objc_object** %blackColor, align 8, !tbaa !8
  %92 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call115 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.68, i32 0, i32 0))
  %93 = load %struct.objc_object*, %struct.objc_object** %blackColor, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %92, %struct.objc_selector* %call115, %struct.objc_object* %93)
  %94 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call116 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.69, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, i8)*)(%struct.objc_object* %94, %struct.objc_selector* %call116, i8 signext 1)
  %95 = bitcast %struct.CGSize* %windowSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %95) #11
  %96 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call117 = call { double, double } @_tigrCocoaWindowSize(%struct.objc_object* %96)
  %97 = bitcast %struct.CGSize* %windowSize to { double, double }*
  %98 = getelementptr inbounds { double, double }, { double, double }* %97, i32 0, i32 0
  %99 = extractvalue { double, double } %call117, 0
  store double %99, double* %98, align 8
  %100 = getelementptr inbounds { double, double }, { double, double }* %97, i32 0, i32 1
  %101 = extractvalue { double, double } %call117, 1
  store double %101, double* %100, align 8
  %width118 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %102 = load double, double* %width118, align 8, !tbaa !77
  %103 = load i32, i32* %scale, align 4, !tbaa !4
  %conv119 = sitofp i32 %103 to double
  %div120 = fdiv double %102, %conv119
  %conv121 = fptosi double %div120 to i32
  %height122 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %104 = load double, double* %height122, align 8, !tbaa !79
  %105 = load i32, i32* %scale, align 4, !tbaa !4
  %conv123 = sitofp i32 %105 to double
  %div124 = fdiv double %104, %conv123
  %conv125 = fptosi double %div124 to i32
  %call126 = call %struct.Tigr* @tigrBitmap2(i32 %conv121, i32 %conv125, i32 632)
  store %struct.Tigr* %call126, %struct.Tigr** %bmp, align 8, !tbaa !8
  %106 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %107 = bitcast %struct.objc_object* %106 to i8*
  %108 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %108, i32 0, i32 3
  store i8* %107, i8** %handle, align 8, !tbaa !41
  %109 = load %struct.objc_object*, %struct.objc_object** %wdg, align 8, !tbaa !8
  %110 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %111 = bitcast %struct.Tigr* %110 to i8*
  %call127 = call %struct.objc_ivar* @object_setInstanceVariable(%struct.objc_object* %109, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.7, i32 0, i32 0), i8* %111)
  %112 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %call128 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %112)
  store %struct.TigrInternal* %call128, %struct.TigrInternal** %win, align 8, !tbaa !8
  %113 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %114 = bitcast %struct.objc_object* %113 to i8*
  %115 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %glContext = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %115, i32 0, i32 3
  store i8* %114, i8** %glContext, align 8, !tbaa !63
  %116 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %shown = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %116, i32 0, i32 0
  store i32 0, i32* %shown, align 8, !tbaa !80
  %117 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %closed = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %117, i32 0, i32 1
  store i32 0, i32* %closed, align 4, !tbaa !81
  %118 = load i32, i32* %scale, align 4, !tbaa !4
  %119 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale129 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %119, i32 0, i32 13
  store i32 %118, i32* %scale129, align 8, !tbaa !82
  %120 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %120, i32 0, i32 15
  store i32 0, i32* %lastChar, align 4, !tbaa !68
  %121 = load i32, i32* %flags.addr, align 4, !tbaa !4
  %122 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %flags130 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %122, i32 0, i32 12
  store i32 %121, i32* %flags130, align 4, !tbaa !83
  %123 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %vblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %123, i32 0, i32 9
  store i32 0, i32* %vblur, align 8, !tbaa !38
  %124 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %hblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %124, i32 0, i32 8
  store i32 0, i32* %hblur, align 4, !tbaa !35
  %125 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scanlines = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %125, i32 0, i32 10
  store float 0.000000e+00, float* %scanlines, align 4, !tbaa !39
  %126 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %contrast = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %126, i32 0, i32 11
  store float 1.000000e+00, float* %contrast, align 8, !tbaa !40
  %127 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgetsWanted = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %127, i32 0, i32 5
  store i32 0, i32* %widgetsWanted, align 8, !tbaa !84
  %128 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgetAlpha = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %128, i32 0, i32 6
  store i8 0, i8* %widgetAlpha, align 4, !tbaa !85
  %129 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgetsScale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %129, i32 0, i32 7
  store float 0.000000e+00, float* %widgetsScale, align 8, !tbaa !86
  %call131 = call %struct.Tigr* @tigrBitmap(i32 40, i32 14)
  %130 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgets = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %130, i32 0, i32 4
  store %struct.Tigr* %call131, %struct.Tigr** %widgets, align 8, !tbaa !64
  %131 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %gl = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %131, i32 0, i32 2
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %gl, i32 0, i32 6
  store i32 0, i32* %gl_legacy, align 4, !tbaa !87
  %132 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %132, i32 0, i32 18
  store i32 0, i32* %mouseButtons, align 8, !tbaa !69
  %133 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %134 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale132 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %134, i32 0, i32 13
  %135 = load i32, i32* %scale132, align 8, !tbaa !82
  %136 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %w133 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %136, i32 0, i32 0
  %137 = load i32, i32* %w133, align 8, !tbaa !10
  %138 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %h134 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %138, i32 0, i32 1
  %139 = load i32, i32* %h134, align 4, !tbaa !12
  %140 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %140, i32 0, i32 14
  %arraydecay135 = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i32 0, i32 0
  call void @tigrPosition(%struct.Tigr* %133, i32 %135, i32 %137, i32 %139, i32* %arraydecay135)
  %141 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %call136 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %141, %struct.objc_selector* %call136)
  %142 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  call void @tigrGAPICreate(%struct.Tigr* %142)
  %143 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  call void @tigrGAPIBegin(%struct.Tigr* %143)
  %144 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %145 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %w137 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %145, i32 0, i32 0
  %146 = load i32, i32* %w137, align 8, !tbaa !10
  %147 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %h138 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %147, i32 0, i32 1
  %148 = load i32, i32* %h138, align 4, !tbaa !12
  call void @tigrGAPIResize(%struct.Tigr* %144, i32 %146, i32 %148)
  %149 = load %struct.Tigr*, %struct.Tigr** %bmp, align 8, !tbaa !8
  %150 = bitcast %struct.CGSize* %windowSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %150) #11
  %151 = bitcast %struct.objc_object** %blackColor to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %151) #11
  %152 = bitcast %struct.objc_object** %openGLContext to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %152) #11
  %153 = bitcast %struct.objc_object** %openGLContextAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %153) #11
  %154 = bitcast %struct.objc_object** %pixelFormat to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %154) #11
  %155 = bitcast %struct.objc_object** %pixelFormatAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %155) #11
  %156 = bitcast [9 x i32]* %glAttributes to i8*
  call void @llvm.lifetime.end.p0i8(i64 36, i8* %156) #11
  %157 = bitcast %struct.objc_object** %titleString to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %157) #11
  %158 = bitcast %struct.CGPoint* %point to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %158) #11
  %159 = bitcast %struct.objc_object** %contentView to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %159) #11
  %160 = bitcast %struct.objc_object** %wdg to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %160) #11
  %161 = bitcast %struct.objc_object** %wdgAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %161) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %resultAddMethod) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %resultAddIvar) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %resultAddProtoc) #11
  %162 = bitcast %struct.objc_class** %WindowDelegateClass to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %162) #11
  %163 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %163) #11
  %164 = bitcast %struct.objc_object** %windowAlloc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %164) #11
  %165 = bitcast %struct.CGRect* %rect to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %165) #11
  %166 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %166) #11
  %167 = bitcast %struct.Tigr** %bmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %167) #11
  %168 = bitcast i32* %scale to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %168) #11
  ret %struct.Tigr* %149
}

declare void @CGDisplayBounds(%struct.CGRect* sret, i32) #5

declare i32 @CGMainDisplayID() #5

declare double @CGRectGetHeight(%struct.CGRect* byval align 8) #5

declare double @CGRectGetWidth(%struct.CGRect* byval align 8) #5

declare signext i8 @class_addIvar(%struct.objc_class*, i8*, i64, i8 zeroext, i8*) #5

; Function Attrs: nounwind readnone speculatable
declare double @llvm.log2.f64(double) #4

; Function Attrs: nounwind readnone speculatable
declare double @llvm.rint.f64(double) #4

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPICreate(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %vs = alloca i32, align 4
  %fs = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %gl = alloca %struct.GLStuff*, align 8
  %VBO = alloca i32, align 4
  %vertices = alloca [24 x float], align 16
  %vs_source = alloca i8*, align 8
  %fs_source = alloca i8*, align 8
  %i = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = bitcast i32* %vs to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %fs to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %3)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %4 = bitcast %struct.GLStuff** %gl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %gl1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %5, i32 0, i32 2
  store %struct.GLStuff* %gl1, %struct.GLStuff** %gl, align 8, !tbaa !8
  %6 = bitcast i32* %VBO to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %7 = bitcast [24 x float]* %vertices to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* %7) #11
  %8 = bitcast [24 x float]* %vertices to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %8, i8* align 16 bitcast ([24 x float]* @__const.tigrGAPICreate.vertices to i8*), i64 96, i1 false)
  %9 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %9, i32 0, i32 6
  %10 = load i32, i32* %gl_legacy, align 4, !tbaa !88
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %11 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %vao = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %11, i32 0, i32 1
  call void @glGenVertexArrays(i32 1, i32* %vao)
  call void @glGenBuffers(i32 1, i32* %VBO)
  %12 = load i32, i32* %VBO, align 4, !tbaa !4
  call void @glBindBuffer(i32 34962, i32 %12)
  %arraydecay = getelementptr inbounds [24 x float], [24 x float]* %vertices, i32 0, i32 0
  %13 = bitcast float* %arraydecay to i8*
  call void @glBufferData(i32 34962, i64 96, i8* %13, i32 35044)
  %14 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %vao2 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %14, i32 0, i32 1
  %15 = load i32, i32* %vao2, align 4, !tbaa !89
  call void @glBindVertexArray(i32 %15)
  call void @glEnableVertexAttribArray(i32 0)
  call void @glEnableVertexAttribArray(i32 1)
  call void @glVertexAttribPointer(i32 0, i32 2, i32 5126, i8 zeroext 0, i32 16, i8* null)
  call void @glVertexAttribPointer(i32 1, i32 2, i32 5126, i8 zeroext 0, i32 16, i8* null)
  %call3 = call i32 @glCreateShader(i32 35633)
  store i32 %call3, i32* %vs, align 4, !tbaa !4
  %16 = bitcast i8** %vs_source to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #11
  store i8* getelementptr inbounds ([259 x i8], [259 x i8]* @tigr_upscale_gl_vs, i32 0, i32 0), i8** %vs_source, align 8, !tbaa !8
  %17 = load i32, i32* %vs, align 4, !tbaa !4
  call void @glShaderSource(i32 %17, i32 1, i8** %vs_source, i32* @tigr_upscale_gl_vs_size)
  %18 = load i32, i32* %vs, align 4, !tbaa !4
  call void @glCompileShader(i32 %18)
  %19 = load i32, i32* %vs, align 4, !tbaa !4
  call void @tigrCheckShaderErrors(i32 %19)
  %call4 = call i32 @glCreateShader(i32 35632)
  store i32 %call4, i32* %fs, align 4, !tbaa !4
  %20 = bitcast i8** %fs_source to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #11
  store i8* getelementptr inbounds ([444 x i8], [444 x i8]* @tigr_upscale_gl_fs, i32 0, i32 0), i8** %fs_source, align 8, !tbaa !8
  %21 = load i32, i32* %fs, align 4, !tbaa !4
  call void @glShaderSource(i32 %21, i32 1, i8** %fs_source, i32* @tigr_upscale_gl_fs_size)
  %22 = load i32, i32* %fs, align 4, !tbaa !4
  call void @glCompileShader(i32 %22)
  %23 = load i32, i32* %fs, align 4, !tbaa !4
  call void @tigrCheckShaderErrors(i32 %23)
  %call5 = call i32 @glCreateProgram()
  %24 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %24, i32 0, i32 2
  store i32 %call5, i32* %program, align 4, !tbaa !90
  %25 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program6 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %25, i32 0, i32 2
  %26 = load i32, i32* %program6, align 4, !tbaa !90
  %27 = load i32, i32* %vs, align 4, !tbaa !4
  call void @glAttachShader(i32 %26, i32 %27)
  %28 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program7 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %28, i32 0, i32 2
  %29 = load i32, i32* %program7, align 4, !tbaa !90
  %30 = load i32, i32* %fs, align 4, !tbaa !4
  call void @glAttachShader(i32 %29, i32 %30)
  %31 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program8 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %31, i32 0, i32 2
  %32 = load i32, i32* %program8, align 4, !tbaa !90
  call void @glLinkProgram(i32 %32)
  %33 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program9 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %33, i32 0, i32 2
  %34 = load i32, i32* %program9, align 4, !tbaa !90
  call void @tigrCheckProgramErrors(i32 %34)
  %35 = load i32, i32* %vs, align 4, !tbaa !4
  call void @glDeleteShader(i32 %35)
  %36 = load i32, i32* %fs, align 4, !tbaa !4
  call void @glDeleteShader(i32 %36)
  %37 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program10 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %37, i32 0, i32 2
  %38 = load i32, i32* %program10, align 4, !tbaa !90
  %call11 = call i32 @glGetUniformLocation(i32 %38, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.91, i32 0, i32 0))
  %39 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_projection = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %39, i32 0, i32 3
  store i32 %call11, i32* %uniform_projection, align 4, !tbaa !91
  %40 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program12 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %40, i32 0, i32 2
  %41 = load i32, i32* %program12, align 4, !tbaa !90
  %call13 = call i32 @glGetUniformLocation(i32 %41, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.92, i32 0, i32 0))
  %42 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_model = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %42, i32 0, i32 4
  store i32 %call13, i32* %uniform_model, align 4, !tbaa !92
  %43 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program14 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %43, i32 0, i32 2
  %44 = load i32, i32* %program14, align 4, !tbaa !90
  %call15 = call i32 @glGetUniformLocation(i32 %44, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.93, i32 0, i32 0))
  %45 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_parameters = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %45, i32 0, i32 5
  store i32 %call15, i32* %uniform_parameters, align 4, !tbaa !93
  %46 = bitcast i8** %fs_source to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #11
  %47 = bitcast i8** %vs_source to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %48 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy16 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %48, i32 0, i32 6
  %49 = load i32, i32* %gl_legacy16, align 4, !tbaa !88
  %tobool17 = icmp ne i32 %49, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  call void @glEnable(i32 3553)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end
  %50 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %tex = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %50, i32 0, i32 0
  %arraydecay20 = getelementptr inbounds [2 x i32], [2 x i32]* %tex, i32 0, i32 0
  call void @glGenTextures(i32 2, i32* %arraydecay20)
  %51 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %51) #11
  store i32 0, i32* %i, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %52 = load i32, i32* %i, align 4, !tbaa !4
  %cmp = icmp slt i32 %52, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %53 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %53) #11
  br label %for.end

for.body:                                         ; preds = %for.cond
  %54 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %tex21 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %54, i32 0, i32 0
  %55 = load i32, i32* %i, align 4, !tbaa !4
  %idxprom = sext i32 %55 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %tex21, i64 0, i64 %idxprom
  %56 = load i32, i32* %arrayidx, align 4, !tbaa !4
  call void @glBindTexture(i32 3553, i32 %56)
  %57 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy22 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %57, i32 0, i32 6
  %58 = load i32, i32* %gl_legacy22, align 4, !tbaa !88
  %tobool23 = icmp ne i32 %58, 0
  %59 = zext i1 %tobool23 to i64
  %cond = select i1 %tobool23, i32 9728, i32 9729
  call void @glTexParameteri(i32 3553, i32 10241, i32 %cond)
  %60 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy24 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %60, i32 0, i32 6
  %61 = load i32, i32* %gl_legacy24, align 4, !tbaa !88
  %tobool25 = icmp ne i32 %61, 0
  %62 = zext i1 %tobool25 to i64
  %cond26 = select i1 %tobool25, i32 9728, i32 9729
  call void @glTexParameteri(i32 3553, i32 10240, i32 %cond26)
  call void @glPixelStorei(i32 3314, i32 0)
  call void @glPixelStorei(i32 3317, i32 1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %63 = load i32, i32* %i, align 4, !tbaa !4
  %inc = add nsw i32 %63, 1
  store i32 %inc, i32* %i, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  call void @tigrCheckGLError(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.94, i32 0, i32 0))
  %64 = bitcast [24 x float]* %vertices to i8*
  call void @llvm.lifetime.end.p0i8(i64 96, i8* %64) #11
  %65 = bitcast i32* %VBO to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %65) #11
  %66 = bitcast %struct.GLStuff** %gl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %66) #11
  %67 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %67) #11
  %68 = bitcast i32* %fs to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %68) #11
  %69 = bitcast i32* %vs to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %69) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPIBegin(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPIResize(%struct.Tigr* %bmp, i32 %width, i32 %height) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %width, i32* %width.addr, align 4, !tbaa !4
  store i32 %height, i32* %height.addr, align 4, !tbaa !4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %1 = load i32, i32* %width.addr, align 4, !tbaa !4
  %2 = load i32, i32* %height.addr, align 4, !tbaa !4
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPIEnd(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPIDestroy(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %gl = alloca %struct.GLStuff*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %1)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %2 = bitcast %struct.GLStuff** %gl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %gl1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %3, i32 0, i32 2
  store %struct.GLStuff* %gl1, %struct.GLStuff** %gl, align 8, !tbaa !8
  %4 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %4, i32 0, i32 6
  %5 = load i32, i32* %gl_legacy, align 4, !tbaa !88
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %tex = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %tex, i32 0, i32 0
  call void @glDeleteTextures(i32 2, i32* %arraydecay)
  %7 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %7, i32 0, i32 2
  %8 = load i32, i32* %program, align 4, !tbaa !90
  call void @glDeleteProgram(i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @tigrCheckGLError(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.95, i32 0, i32 0))
  %9 = bitcast %struct.GLStuff** %gl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  %10 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define zeroext i8 @_tigrKeyFromOSX(i16 zeroext %key) #0 {
entry:
  %retval = alloca i8, align 1
  %key.addr = alloca i16, align 2
  store i16 %key, i16* %key.addr, align 2, !tbaa !94
  %0 = load i16, i16* %key.addr, align 2, !tbaa !94
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 12, label %sw.bb
    i32 13, label %sw.bb1
    i32 14, label %sw.bb2
    i32 15, label %sw.bb3
    i32 17, label %sw.bb4
    i32 16, label %sw.bb5
    i32 32, label %sw.bb6
    i32 34, label %sw.bb7
    i32 31, label %sw.bb8
    i32 35, label %sw.bb9
    i32 0, label %sw.bb10
    i32 1, label %sw.bb11
    i32 2, label %sw.bb12
    i32 3, label %sw.bb13
    i32 5, label %sw.bb14
    i32 4, label %sw.bb15
    i32 38, label %sw.bb16
    i32 40, label %sw.bb17
    i32 37, label %sw.bb18
    i32 6, label %sw.bb19
    i32 7, label %sw.bb20
    i32 8, label %sw.bb21
    i32 9, label %sw.bb22
    i32 11, label %sw.bb23
    i32 45, label %sw.bb24
    i32 46, label %sw.bb25
    i32 29, label %sw.bb26
    i32 18, label %sw.bb27
    i32 19, label %sw.bb28
    i32 20, label %sw.bb29
    i32 21, label %sw.bb30
    i32 23, label %sw.bb31
    i32 22, label %sw.bb32
    i32 26, label %sw.bb33
    i32 28, label %sw.bb34
    i32 25, label %sw.bb35
    i32 82, label %sw.bb36
    i32 83, label %sw.bb37
    i32 84, label %sw.bb38
    i32 85, label %sw.bb39
    i32 86, label %sw.bb40
    i32 87, label %sw.bb41
    i32 88, label %sw.bb42
    i32 89, label %sw.bb43
    i32 91, label %sw.bb44
    i32 92, label %sw.bb45
    i32 67, label %sw.bb46
    i32 69, label %sw.bb47
    i32 76, label %sw.bb48
    i32 78, label %sw.bb49
    i32 65, label %sw.bb50
    i32 75, label %sw.bb51
    i32 122, label %sw.bb52
    i32 120, label %sw.bb53
    i32 99, label %sw.bb54
    i32 118, label %sw.bb55
    i32 96, label %sw.bb56
    i32 97, label %sw.bb57
    i32 98, label %sw.bb58
    i32 100, label %sw.bb59
    i32 101, label %sw.bb60
    i32 109, label %sw.bb61
    i32 103, label %sw.bb62
    i32 111, label %sw.bb63
    i32 56, label %sw.bb64
    i32 59, label %sw.bb65
    i32 58, label %sw.bb66
    i32 57, label %sw.bb67
    i32 55, label %sw.bb68
    i32 54, label %sw.bb69
    i32 60, label %sw.bb70
    i32 62, label %sw.bb71
    i32 61, label %sw.bb72
    i32 51, label %sw.bb73
    i32 48, label %sw.bb74
    i32 36, label %sw.bb75
    i32 53, label %sw.bb76
    i32 49, label %sw.bb77
    i32 116, label %sw.bb78
    i32 121, label %sw.bb79
    i32 119, label %sw.bb80
    i32 115, label %sw.bb81
    i32 123, label %sw.bb82
    i32 126, label %sw.bb83
    i32 124, label %sw.bb84
    i32 125, label %sw.bb85
    i32 114, label %sw.bb86
    i32 117, label %sw.bb87
    i32 107, label %sw.bb88
    i32 113, label %sw.bb89
    i32 71, label %sw.bb90
    i32 41, label %sw.bb91
    i32 24, label %sw.bb92
    i32 43, label %sw.bb93
    i32 27, label %sw.bb94
    i32 44, label %sw.bb95
    i32 42, label %sw.bb96
    i32 50, label %sw.bb97
    i32 39, label %sw.bb98
    i32 33, label %sw.bb99
    i32 30, label %sw.bb100
    i32 47, label %sw.bb101
  ]

sw.bb:                                            ; preds = %entry
  store i8 81, i8* %retval, align 1
  br label %return

sw.bb1:                                           ; preds = %entry
  store i8 87, i8* %retval, align 1
  br label %return

sw.bb2:                                           ; preds = %entry
  store i8 69, i8* %retval, align 1
  br label %return

sw.bb3:                                           ; preds = %entry
  store i8 82, i8* %retval, align 1
  br label %return

sw.bb4:                                           ; preds = %entry
  store i8 84, i8* %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry
  store i8 89, i8* %retval, align 1
  br label %return

sw.bb6:                                           ; preds = %entry
  store i8 85, i8* %retval, align 1
  br label %return

sw.bb7:                                           ; preds = %entry
  store i8 73, i8* %retval, align 1
  br label %return

sw.bb8:                                           ; preds = %entry
  store i8 79, i8* %retval, align 1
  br label %return

sw.bb9:                                           ; preds = %entry
  store i8 80, i8* %retval, align 1
  br label %return

sw.bb10:                                          ; preds = %entry
  store i8 65, i8* %retval, align 1
  br label %return

sw.bb11:                                          ; preds = %entry
  store i8 83, i8* %retval, align 1
  br label %return

sw.bb12:                                          ; preds = %entry
  store i8 68, i8* %retval, align 1
  br label %return

sw.bb13:                                          ; preds = %entry
  store i8 70, i8* %retval, align 1
  br label %return

sw.bb14:                                          ; preds = %entry
  store i8 71, i8* %retval, align 1
  br label %return

sw.bb15:                                          ; preds = %entry
  store i8 72, i8* %retval, align 1
  br label %return

sw.bb16:                                          ; preds = %entry
  store i8 74, i8* %retval, align 1
  br label %return

sw.bb17:                                          ; preds = %entry
  store i8 75, i8* %retval, align 1
  br label %return

sw.bb18:                                          ; preds = %entry
  store i8 76, i8* %retval, align 1
  br label %return

sw.bb19:                                          ; preds = %entry
  store i8 90, i8* %retval, align 1
  br label %return

sw.bb20:                                          ; preds = %entry
  store i8 88, i8* %retval, align 1
  br label %return

sw.bb21:                                          ; preds = %entry
  store i8 67, i8* %retval, align 1
  br label %return

sw.bb22:                                          ; preds = %entry
  store i8 86, i8* %retval, align 1
  br label %return

sw.bb23:                                          ; preds = %entry
  store i8 66, i8* %retval, align 1
  br label %return

sw.bb24:                                          ; preds = %entry
  store i8 78, i8* %retval, align 1
  br label %return

sw.bb25:                                          ; preds = %entry
  store i8 77, i8* %retval, align 1
  br label %return

sw.bb26:                                          ; preds = %entry
  store i8 48, i8* %retval, align 1
  br label %return

sw.bb27:                                          ; preds = %entry
  store i8 49, i8* %retval, align 1
  br label %return

sw.bb28:                                          ; preds = %entry
  store i8 50, i8* %retval, align 1
  br label %return

sw.bb29:                                          ; preds = %entry
  store i8 51, i8* %retval, align 1
  br label %return

sw.bb30:                                          ; preds = %entry
  store i8 52, i8* %retval, align 1
  br label %return

sw.bb31:                                          ; preds = %entry
  store i8 53, i8* %retval, align 1
  br label %return

sw.bb32:                                          ; preds = %entry
  store i8 54, i8* %retval, align 1
  br label %return

sw.bb33:                                          ; preds = %entry
  store i8 55, i8* %retval, align 1
  br label %return

sw.bb34:                                          ; preds = %entry
  store i8 56, i8* %retval, align 1
  br label %return

sw.bb35:                                          ; preds = %entry
  store i8 57, i8* %retval, align 1
  br label %return

sw.bb36:                                          ; preds = %entry
  store i8 -128, i8* %retval, align 1
  br label %return

sw.bb37:                                          ; preds = %entry
  store i8 -127, i8* %retval, align 1
  br label %return

sw.bb38:                                          ; preds = %entry
  store i8 -126, i8* %retval, align 1
  br label %return

sw.bb39:                                          ; preds = %entry
  store i8 -125, i8* %retval, align 1
  br label %return

sw.bb40:                                          ; preds = %entry
  store i8 -124, i8* %retval, align 1
  br label %return

sw.bb41:                                          ; preds = %entry
  store i8 -123, i8* %retval, align 1
  br label %return

sw.bb42:                                          ; preds = %entry
  store i8 -122, i8* %retval, align 1
  br label %return

sw.bb43:                                          ; preds = %entry
  store i8 -121, i8* %retval, align 1
  br label %return

sw.bb44:                                          ; preds = %entry
  store i8 -120, i8* %retval, align 1
  br label %return

sw.bb45:                                          ; preds = %entry
  store i8 -119, i8* %retval, align 1
  br label %return

sw.bb46:                                          ; preds = %entry
  store i8 -118, i8* %retval, align 1
  br label %return

sw.bb47:                                          ; preds = %entry
  store i8 -117, i8* %retval, align 1
  br label %return

sw.bb48:                                          ; preds = %entry
  store i8 -116, i8* %retval, align 1
  br label %return

sw.bb49:                                          ; preds = %entry
  store i8 -115, i8* %retval, align 1
  br label %return

sw.bb50:                                          ; preds = %entry
  store i8 -114, i8* %retval, align 1
  br label %return

sw.bb51:                                          ; preds = %entry
  store i8 -113, i8* %retval, align 1
  br label %return

sw.bb52:                                          ; preds = %entry
  store i8 -112, i8* %retval, align 1
  br label %return

sw.bb53:                                          ; preds = %entry
  store i8 -111, i8* %retval, align 1
  br label %return

sw.bb54:                                          ; preds = %entry
  store i8 -110, i8* %retval, align 1
  br label %return

sw.bb55:                                          ; preds = %entry
  store i8 -109, i8* %retval, align 1
  br label %return

sw.bb56:                                          ; preds = %entry
  store i8 -108, i8* %retval, align 1
  br label %return

sw.bb57:                                          ; preds = %entry
  store i8 -107, i8* %retval, align 1
  br label %return

sw.bb58:                                          ; preds = %entry
  store i8 -106, i8* %retval, align 1
  br label %return

sw.bb59:                                          ; preds = %entry
  store i8 -105, i8* %retval, align 1
  br label %return

sw.bb60:                                          ; preds = %entry
  store i8 -104, i8* %retval, align 1
  br label %return

sw.bb61:                                          ; preds = %entry
  store i8 -103, i8* %retval, align 1
  br label %return

sw.bb62:                                          ; preds = %entry
  store i8 -102, i8* %retval, align 1
  br label %return

sw.bb63:                                          ; preds = %entry
  store i8 -101, i8* %retval, align 1
  br label %return

sw.bb64:                                          ; preds = %entry
  store i8 -76, i8* %retval, align 1
  br label %return

sw.bb65:                                          ; preds = %entry
  store i8 -74, i8* %retval, align 1
  br label %return

sw.bb66:                                          ; preds = %entry
  store i8 -72, i8* %retval, align 1
  br label %return

sw.bb67:                                          ; preds = %entry
  store i8 -93, i8* %retval, align 1
  br label %return

sw.bb68:                                          ; preds = %entry
  store i8 -80, i8* %retval, align 1
  br label %return

sw.bb69:                                          ; preds = %entry
  store i8 -79, i8* %retval, align 1
  br label %return

sw.bb70:                                          ; preds = %entry
  store i8 -75, i8* %retval, align 1
  br label %return

sw.bb71:                                          ; preds = %entry
  store i8 -73, i8* %retval, align 1
  br label %return

sw.bb72:                                          ; preds = %entry
  store i8 -71, i8* %retval, align 1
  br label %return

sw.bb73:                                          ; preds = %entry
  store i8 -100, i8* %retval, align 1
  br label %return

sw.bb74:                                          ; preds = %entry
  store i8 -99, i8* %retval, align 1
  br label %return

sw.bb75:                                          ; preds = %entry
  store i8 -98, i8* %retval, align 1
  br label %return

sw.bb76:                                          ; preds = %entry
  store i8 -92, i8* %retval, align 1
  br label %return

sw.bb77:                                          ; preds = %entry
  store i8 -91, i8* %retval, align 1
  br label %return

sw.bb78:                                          ; preds = %entry
  store i8 -90, i8* %retval, align 1
  br label %return

sw.bb79:                                          ; preds = %entry
  store i8 -89, i8* %retval, align 1
  br label %return

sw.bb80:                                          ; preds = %entry
  store i8 -88, i8* %retval, align 1
  br label %return

sw.bb81:                                          ; preds = %entry
  store i8 -87, i8* %retval, align 1
  br label %return

sw.bb82:                                          ; preds = %entry
  store i8 -86, i8* %retval, align 1
  br label %return

sw.bb83:                                          ; preds = %entry
  store i8 -85, i8* %retval, align 1
  br label %return

sw.bb84:                                          ; preds = %entry
  store i8 -84, i8* %retval, align 1
  br label %return

sw.bb85:                                          ; preds = %entry
  store i8 -83, i8* %retval, align 1
  br label %return

sw.bb86:                                          ; preds = %entry
  store i8 -82, i8* %retval, align 1
  br label %return

sw.bb87:                                          ; preds = %entry
  store i8 -81, i8* %retval, align 1
  br label %return

sw.bb88:                                          ; preds = %entry
  store i8 -77, i8* %retval, align 1
  br label %return

sw.bb89:                                          ; preds = %entry
  store i8 -94, i8* %retval, align 1
  br label %return

sw.bb90:                                          ; preds = %entry
  store i8 -78, i8* %retval, align 1
  br label %return

sw.bb91:                                          ; preds = %entry
  store i8 -70, i8* %retval, align 1
  br label %return

sw.bb92:                                          ; preds = %entry
  store i8 -69, i8* %retval, align 1
  br label %return

sw.bb93:                                          ; preds = %entry
  store i8 -68, i8* %retval, align 1
  br label %return

sw.bb94:                                          ; preds = %entry
  store i8 -67, i8* %retval, align 1
  br label %return

sw.bb95:                                          ; preds = %entry
  store i8 -65, i8* %retval, align 1
  br label %return

sw.bb96:                                          ; preds = %entry
  store i8 -62, i8* %retval, align 1
  br label %return

sw.bb97:                                          ; preds = %entry
  store i8 -64, i8* %retval, align 1
  br label %return

sw.bb98:                                          ; preds = %entry
  store i8 -60, i8* %retval, align 1
  br label %return

sw.bb99:                                          ; preds = %entry
  store i8 -63, i8* %retval, align 1
  br label %return

sw.bb100:                                         ; preds = %entry
  store i8 -61, i8* %retval, align 1
  br label %return

sw.bb101:                                         ; preds = %entry
  store i8 -66, i8* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i8 0, i8* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb101, %sw.bb100, %sw.bb99, %sw.bb98, %sw.bb97, %sw.bb96, %sw.bb95, %sw.bb94, %sw.bb93, %sw.bb92, %sw.bb91, %sw.bb90, %sw.bb89, %sw.bb88, %sw.bb87, %sw.bb86, %sw.bb85, %sw.bb84, %sw.bb83, %sw.bb82, %sw.bb81, %sw.bb80, %sw.bb79, %sw.bb78, %sw.bb77, %sw.bb76, %sw.bb75, %sw.bb74, %sw.bb73, %sw.bb72, %sw.bb71, %sw.bb70, %sw.bb69, %sw.bb68, %sw.bb67, %sw.bb66, %sw.bb65, %sw.bb64, %sw.bb63, %sw.bb62, %sw.bb61, %sw.bb60, %sw.bb59, %sw.bb58, %sw.bb57, %sw.bb56, %sw.bb55, %sw.bb54, %sw.bb53, %sw.bb52, %sw.bb51, %sw.bb50, %sw.bb49, %sw.bb48, %sw.bb47, %sw.bb46, %sw.bb45, %sw.bb44, %sw.bb43, %sw.bb42, %sw.bb41, %sw.bb40, %sw.bb39, %sw.bb38, %sw.bb37, %sw.bb36, %sw.bb35, %sw.bb34, %sw.bb33, %sw.bb32, %sw.bb31, %sw.bb30, %sw.bb29, %sw.bb28, %sw.bb27, %sw.bb26, %sw.bb25, %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb21, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load i8, i8* %retval, align 1
  ret i8 %1
}

; Function Attrs: nounwind ssp uwtable
define void @_tigrOnCocoaEvent(%struct.objc_object* %event, %struct.objc_object* %window) #0 {
entry:
  %event.addr = alloca %struct.objc_object*, align 8
  %window.addr = alloca %struct.objc_object*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %eventType = alloca i64, align 8
  %number = alloca i64, align 8
  %number23 = alloca i64, align 8
  %modifiers = alloca i64, align 8
  %keys = alloca %struct.anon, align 1
  %inputText = alloca %struct.objc_object*, align 8
  %inputTextUTF8 = alloca i8*, align 8
  %keyCode = alloca i16, align 2
  %keyCode72 = alloca i16, align 2
  store %struct.objc_object* %event, %struct.objc_object** %event.addr, align 8, !tbaa !8
  store %struct.objc_object* %window, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %0 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %tobool = icmp ne %struct.objc_object* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load %struct.objc_object*, %struct.objc_object** %window.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @_tigrInternalCocoa(%struct.objc_object* %2)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %tobool1 = icmp ne %struct.TigrInternal* %3, null
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %4 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.72, i32 0, i32 0))
  %5 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %4, %struct.objc_selector* %call3, %struct.objc_object* %5)
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %6 = bitcast i64* %eventType to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %7 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call5 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.73, i32 0, i32 0))
  %call6 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %7, %struct.objc_selector* %call5)
  store i64 %call6, i64* %eventType, align 8, !tbaa !26
  %8 = load i64, i64* %eventType, align 8, !tbaa !26
  switch i64 %8, label %sw.default [
    i64 1, label %sw.bb
    i64 2, label %sw.bb7
    i64 3, label %sw.bb9
    i64 4, label %sw.bb12
    i64 25, label %sw.bb15
    i64 26, label %sw.bb22
    i64 12, label %sw.bb31
    i64 10, label %sw.bb60
    i64 11, label %sw.bb71
  ]

sw.bb:                                            ; preds = %if.end4
  %9 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %9, i32 0, i32 18
  %10 = load i32, i32* %mouseButtons, align 8, !tbaa !69
  %or = or i32 %10, 1
  store i32 %or, i32* %mouseButtons, align 8, !tbaa !69
  br label %sw.epilog

sw.bb7:                                           ; preds = %if.end4
  %11 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons8 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %11, i32 0, i32 18
  %12 = load i32, i32* %mouseButtons8, align 8, !tbaa !69
  %and = and i32 %12, -2
  store i32 %and, i32* %mouseButtons8, align 8, !tbaa !69
  br label %sw.epilog

sw.bb9:                                           ; preds = %if.end4
  %13 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons10 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %13, i32 0, i32 18
  %14 = load i32, i32* %mouseButtons10, align 8, !tbaa !69
  %or11 = or i32 %14, 2
  store i32 %or11, i32* %mouseButtons10, align 8, !tbaa !69
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end4
  %15 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons13 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %15, i32 0, i32 18
  %16 = load i32, i32* %mouseButtons13, align 8, !tbaa !69
  %and14 = and i32 %16, -3
  store i32 %and14, i32* %mouseButtons13, align 8, !tbaa !69
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end4
  %17 = bitcast i64* %number to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #11
  %18 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call16 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0))
  %call17 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %18, %struct.objc_selector* %call16)
  store i64 %call17, i64* %number, align 8, !tbaa !26
  %19 = load i64, i64* %number, align 8, !tbaa !26
  %cmp = icmp eq i64 %19, 2
  br i1 %cmp, label %if.then18, label %if.end21

if.then18:                                        ; preds = %sw.bb15
  %20 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons19 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %20, i32 0, i32 18
  %21 = load i32, i32* %mouseButtons19, align 8, !tbaa !69
  %or20 = or i32 %21, 4
  store i32 %or20, i32* %mouseButtons19, align 8, !tbaa !69
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %sw.bb15
  store i32 2, i32* %cleanup.dest.slot, align 4
  %22 = bitcast i64* %number to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #11
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end4
  %23 = bitcast i64* %number23 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %23) #11
  %24 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call24 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0))
  %call25 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %24, %struct.objc_selector* %call24)
  store i64 %call25, i64* %number23, align 8, !tbaa !26
  %25 = load i64, i64* %number23, align 8, !tbaa !26
  %cmp26 = icmp eq i64 %25, 2
  br i1 %cmp26, label %if.then27, label %if.end30

if.then27:                                        ; preds = %sw.bb22
  %26 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons28 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %26, i32 0, i32 18
  %27 = load i32, i32* %mouseButtons28, align 8, !tbaa !69
  %and29 = and i32 %27, -5
  store i32 %and29, i32* %mouseButtons28, align 8, !tbaa !69
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %sw.bb22
  store i32 2, i32* %cleanup.dest.slot, align 4
  %28 = bitcast i64* %number23 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #11
  br label %sw.epilog

sw.bb31:                                          ; preds = %if.end4
  %29 = bitcast i64* %modifiers to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %29) #11
  %30 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call32 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.75, i32 0, i32 0))
  %call33 = call i64 bitcast (void ()* @objc_msgSend to i64 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %30, %struct.objc_selector* %call32)
  store i64 %call33, i64* %modifiers, align 8, !tbaa !26
  %31 = bitcast %struct.anon* %keys to i8*
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %31) #11
  %32 = load i64, i64* %modifiers, align 8, !tbaa !26
  %and34 = and i64 %32, 4294901760
  %shr = lshr i64 %and34, 16
  %conv = trunc i64 %shr to i8
  %33 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %mask = bitcast %union.anon* %33 to i8*
  store i8 %conv, i8* %mask, align 1, !tbaa !15
  %34 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %35 = bitcast %union.anon* %34 to %struct.anon.0*
  %36 = bitcast %struct.anon.0* %35 to i8*
  %bf.load = load i8, i8* %36, align 1
  %bf.clear = and i8 %bf.load, 1
  %37 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys35 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %37, i32 0, i32 16
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %keys35, i64 0, i64 160
  store i8 %bf.clear, i8* %arrayidx, align 8, !tbaa !15
  %38 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %39 = bitcast %union.anon* %38 to %struct.anon.0*
  %40 = bitcast %struct.anon.0* %39 to i8*
  %bf.load36 = load i8, i8* %40, align 1
  %bf.lshr = lshr i8 %bf.load36, 1
  %bf.clear37 = and i8 %bf.lshr, 1
  %41 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys38 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %41, i32 0, i32 16
  %arrayidx39 = getelementptr inbounds [256 x i8], [256 x i8]* %keys38, i64 0, i64 159
  store i8 %bf.clear37, i8* %arrayidx39, align 1, !tbaa !15
  %42 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %43 = bitcast %union.anon* %42 to %struct.anon.0*
  %44 = bitcast %struct.anon.0* %43 to i8*
  %bf.load40 = load i8, i8* %44, align 1
  %bf.lshr41 = lshr i8 %bf.load40, 2
  %bf.clear42 = and i8 %bf.lshr41, 1
  %45 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys43 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %45, i32 0, i32 16
  %arrayidx44 = getelementptr inbounds [256 x i8], [256 x i8]* %keys43, i64 0, i64 160
  store i8 %bf.clear42, i8* %arrayidx44, align 8, !tbaa !15
  %46 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %47 = bitcast %union.anon* %46 to %struct.anon.0*
  %48 = bitcast %struct.anon.0* %47 to i8*
  %bf.load45 = load i8, i8* %48, align 1
  %bf.lshr46 = lshr i8 %bf.load45, 3
  %bf.clear47 = and i8 %bf.lshr46, 1
  %49 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys48 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %49, i32 0, i32 16
  %arrayidx49 = getelementptr inbounds [256 x i8], [256 x i8]* %keys48, i64 0, i64 161
  store i8 %bf.clear47, i8* %arrayidx49, align 1, !tbaa !15
  %50 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %51 = bitcast %union.anon* %50 to %struct.anon.0*
  %52 = bitcast %struct.anon.0* %51 to i8*
  %bf.load50 = load i8, i8* %52, align 1
  %bf.lshr51 = lshr i8 %bf.load50, 4
  %bf.clear52 = and i8 %bf.lshr51, 1
  %53 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys53 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %53, i32 0, i32 16
  %arrayidx54 = getelementptr inbounds [256 x i8], [256 x i8]* %keys53, i64 0, i64 176
  store i8 %bf.clear52, i8* %arrayidx54, align 8, !tbaa !15
  %54 = getelementptr inbounds %struct.anon, %struct.anon* %keys, i32 0, i32 0
  %55 = bitcast %union.anon* %54 to %struct.anon.0*
  %56 = bitcast %struct.anon.0* %55 to i8*
  %bf.load55 = load i8, i8* %56, align 1
  %bf.lshr56 = lshr i8 %bf.load55, 4
  %bf.clear57 = and i8 %bf.lshr56, 1
  %57 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys58 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %57, i32 0, i32 16
  %arrayidx59 = getelementptr inbounds [256 x i8], [256 x i8]* %keys58, i64 0, i64 177
  store i8 %bf.clear57, i8* %arrayidx59, align 1, !tbaa !15
  store i32 2, i32* %cleanup.dest.slot, align 4
  %58 = bitcast %struct.anon* %keys to i8*
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %58) #11
  %59 = bitcast i64* %modifiers to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %59) #11
  br label %sw.epilog

sw.bb60:                                          ; preds = %if.end4
  %60 = bitcast %struct.objc_object** %inputText to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %60) #11
  %61 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call61 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.76, i32 0, i32 0))
  %call62 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %61, %struct.objc_selector* %call61)
  store %struct.objc_object* %call62, %struct.objc_object** %inputText, align 8, !tbaa !8
  %62 = bitcast i8** %inputTextUTF8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %62) #11
  %63 = load %struct.objc_object*, %struct.objc_object** %inputText, align 8, !tbaa !8
  %call63 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.77, i32 0, i32 0))
  %call64 = call i8* bitcast (void ()* @objc_msgSend to i8* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %63, %struct.objc_selector* %call63)
  store i8* %call64, i8** %inputTextUTF8, align 8, !tbaa !8
  %64 = load i8*, i8** %inputTextUTF8, align 8, !tbaa !8
  %65 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %65, i32 0, i32 15
  %call65 = call i8* @tigrDecodeUTF8(i8* %64, i32* %lastChar)
  %66 = bitcast i16* %keyCode to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %66) #11
  %67 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call66 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.78, i32 0, i32 0))
  %call67 = call zeroext i16 bitcast (void ()* @objc_msgSend to i16 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %67, %struct.objc_selector* %call66)
  store i16 %call67, i16* %keyCode, align 2, !tbaa !94
  %68 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys68 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %68, i32 0, i32 16
  %69 = load i16, i16* %keyCode, align 2, !tbaa !94
  %call69 = call zeroext i8 @_tigrKeyFromOSX(i16 zeroext %69)
  %idxprom = zext i8 %call69 to i64
  %arrayidx70 = getelementptr inbounds [256 x i8], [256 x i8]* %keys68, i64 0, i64 %idxprom
  store i8 1, i8* %arrayidx70, align 1, !tbaa !15
  store i32 2, i32* %cleanup.dest.slot, align 4
  %70 = bitcast i16* %keyCode to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %70) #11
  %71 = bitcast i8** %inputTextUTF8 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #11
  %72 = bitcast %struct.objc_object** %inputText to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %72) #11
  br label %sw.epilog

sw.bb71:                                          ; preds = %if.end4
  %73 = bitcast i16* %keyCode72 to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %73) #11
  %74 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  %call73 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.78, i32 0, i32 0))
  %call74 = call zeroext i16 bitcast (void ()* @objc_msgSend to i16 (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %74, %struct.objc_selector* %call73)
  store i16 %call74, i16* %keyCode72, align 2, !tbaa !94
  %75 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys75 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %75, i32 0, i32 16
  %76 = load i16, i16* %keyCode72, align 2, !tbaa !94
  %call76 = call zeroext i8 @_tigrKeyFromOSX(i16 zeroext %76)
  %idxprom77 = zext i8 %call76 to i64
  %arrayidx78 = getelementptr inbounds [256 x i8], [256 x i8]* %keys75, i64 0, i64 %idxprom77
  store i8 0, i8* %arrayidx78, align 1, !tbaa !15
  store i32 2, i32* %cleanup.dest.slot, align 4
  %77 = bitcast i16* %keyCode72 to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %77) #11
  br label %sw.epilog

sw.default:                                       ; preds = %if.end4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb71, %sw.bb60, %sw.bb31, %if.end30, %if.end21, %sw.bb12, %sw.bb9, %sw.bb7, %sw.bb
  %78 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call79 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.72, i32 0, i32 0))
  %79 = load %struct.objc_object*, %struct.objc_object** %event.addr, align 8, !tbaa !8
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*, %struct.objc_object*)*)(%struct.objc_object* %78, %struct.objc_selector* %call79, %struct.objc_object* %79)
  %80 = bitcast i64* %eventType to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %80) #11
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then2
  %81 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %81) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %if.then, %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define void @tigrUpdate(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %openGLContext = alloca %struct.objc_object*, align 8
  %window = alloca %struct.objc_object*, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  %distantPast = alloca %struct.objc_object*, align 8
  %event = alloca %struct.objc_object*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %windowSize = alloca %struct.CGSize, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast %struct.objc_object** %openGLContext to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %3)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %4 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %4, i32 0, i32 3
  %5 = load i8*, i8** %handle, align 8, !tbaa !41
  %6 = bitcast i8* %5 to %struct.objc_object*
  store %struct.objc_object* %6, %struct.objc_object** %window, align 8, !tbaa !8
  %7 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %glContext = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %7, i32 0, i32 3
  %8 = load i8*, i8** %glContext, align 8, !tbaa !63
  %9 = bitcast i8* %8 to %struct.objc_object*
  store %struct.objc_object* %9, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %10 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #11
  %11 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call2 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %11, %struct.objc_selector* %call1)
  store %struct.objc_object* %call2, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %12 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %13 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %cmp = icmp eq %struct.objc_object* %12, %13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %prev = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %14, i32 0, i32 17
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %prev, i32 0, i32 0
  %15 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %15, i32 0, i32 16
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i32 0, i32 0
  %16 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %prev4 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %16, i32 0, i32 17
  %arraydecay5 = getelementptr inbounds [256 x i8], [256 x i8]* %prev4, i32 0, i32 0
  %17 = call i64 @llvm.objectsize.i64.p0i8(i8* %arraydecay5, i1 false, i1 true)
  %call6 = call i8* @__memcpy_chk(i8* %arraydecay, i8* %arraydecay3, i64 256, i64 %17) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %18 = bitcast %struct.objc_object** %distantPast to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #11
  %call7 = call %struct.objc_class* @objc_getClass(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.80, i32 0, i32 0))
  %19 = bitcast %struct.objc_class* %call7 to %struct.objc_object*
  %call8 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.81, i32 0, i32 0))
  %call9 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %19, %struct.objc_selector* %call8)
  store %struct.objc_object* %call9, %struct.objc_object** %distantPast, align 8, !tbaa !8
  %20 = bitcast %struct.objc_object** %event to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #11
  %21 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call10 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.82, i32 0, i32 0))
  %22 = load %struct.objc_object*, %struct.objc_object** %distantPast, align 8, !tbaa !8
  %23 = load %struct.objc_object*, %struct.objc_object** @NSDefaultRunLoopMode, align 8, !tbaa !8
  %call11 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*, i64, %struct.objc_object*, %struct.objc_object*, i8)*)(%struct.objc_object* %21, %struct.objc_selector* %call10, i64 -1, %struct.objc_object* %22, %struct.objc_object* %23, i8 signext 1)
  store %struct.objc_object* %call11, %struct.objc_object** %event, align 8, !tbaa !8
  %24 = load %struct.objc_object*, %struct.objc_object** %event, align 8, !tbaa !8
  %25 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  call void @_tigrOnCocoaEvent(%struct.objc_object* %24, %struct.objc_object* %25)
  %26 = load i8, i8* @terminated, align 1, !tbaa !65, !range !67
  %tobool = trunc i8 %26 to i1
  br i1 %tobool, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %27 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call12 = call zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %27)
  br i1 %call12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false, %if.end
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %lor.lhs.false
  %28 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call15 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.83, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %28, %struct.objc_selector* %call15)
  %29 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %call16 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.84, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %29, %struct.objc_selector* %call16)
  %30 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %call17 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %30, %struct.objc_selector* %call17)
  %31 = bitcast %struct.CGSize* %windowSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %31) #11
  %32 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call18 = call { double, double } @_tigrCocoaWindowSize(%struct.objc_object* %32)
  %33 = bitcast %struct.CGSize* %windowSize to { double, double }*
  %34 = getelementptr inbounds { double, double }, { double, double }* %33, i32 0, i32 0
  %35 = extractvalue { double, double } %call18, 0
  store double %35, double* %34, align 8
  %36 = getelementptr inbounds { double, double }, { double, double }* %33, i32 0, i32 1
  %37 = extractvalue { double, double } %call18, 1
  store double %37, double* %36, align 8
  %38 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %flags = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %38, i32 0, i32 12
  %39 = load i32, i32* %flags, align 4, !tbaa !83
  %and = and i32 %39, 1
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end14
  %40 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %width = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %41 = load double, double* %width, align 8, !tbaa !77
  %42 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %42, i32 0, i32 13
  %43 = load i32, i32* %scale, align 8, !tbaa !82
  %conv = sitofp i32 %43 to double
  %div = fdiv double %41, %conv
  %conv21 = fptosi double %div to i32
  %height = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %44 = load double, double* %height, align 8, !tbaa !79
  %45 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale22 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %45, i32 0, i32 13
  %46 = load i32, i32* %scale22, align 8, !tbaa !82
  %conv23 = sitofp i32 %46 to double
  %div24 = fdiv double %44, %conv23
  %conv25 = fptosi double %div24 to i32
  call void @tigrResize(%struct.Tigr* %40, i32 %conv21, i32 %conv25)
  br label %if.end34

if.else:                                          ; preds = %if.end14
  %47 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %47, i32 0, i32 0
  %48 = load i32, i32* %w, align 8, !tbaa !10
  %49 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %49, i32 0, i32 1
  %50 = load i32, i32* %h, align 4, !tbaa !12
  %width26 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %51 = load double, double* %width26, align 8, !tbaa !77
  %conv27 = fptosi double %51 to i32
  %height28 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %52 = load double, double* %height28, align 8, !tbaa !79
  %conv29 = fptosi double %52 to i32
  %call30 = call i32 @tigrCalcScale(i32 %48, i32 %50, i32 %conv27, i32 %conv29)
  %53 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %flags31 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %53, i32 0, i32 12
  %54 = load i32, i32* %flags31, align 4, !tbaa !83
  %call32 = call i32 @tigrEnforceScale(i32 %call30, i32 %54)
  %55 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale33 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %55, i32 0, i32 13
  store i32 %call32, i32* %scale33, align 8, !tbaa !82
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then20
  %56 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %57 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale35 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %57, i32 0, i32 13
  %58 = load i32, i32* %scale35, align 8, !tbaa !82
  %width36 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %59 = load double, double* %width36, align 8, !tbaa !77
  %conv37 = fptosi double %59 to i32
  %height38 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %60 = load double, double* %height38, align 8, !tbaa !79
  %conv39 = fptosi double %60 to i32
  %61 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %61, i32 0, i32 14
  %arraydecay40 = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i32 0, i32 0
  call void @tigrPosition(%struct.Tigr* %56, i32 %58, i32 %conv37, i32 %conv39, i32* %arraydecay40)
  %62 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %width41 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %63 = load double, double* %width41, align 8, !tbaa !77
  %conv42 = fptosi double %63 to i32
  %height43 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %64 = load double, double* %height43, align 8, !tbaa !79
  %conv44 = fptosi double %64 to i32
  call void @tigrGAPIResize(%struct.Tigr* %62, i32 %conv42, i32 %conv44)
  %65 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %width45 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 0
  %66 = load double, double* %width45, align 8, !tbaa !77
  %conv46 = fptosi double %66 to i32
  %height47 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %windowSize, i32 0, i32 1
  %67 = load double, double* %height47, align 8, !tbaa !79
  %conv48 = fptosi double %67 to i32
  call void @tigrGAPIPresent(%struct.Tigr* %65, i32 %conv46, i32 %conv48)
  %68 = load %struct.objc_object*, %struct.objc_object** %openGLContext, align 8, !tbaa !8
  %call49 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.85, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend to void (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %68, %struct.objc_selector* %call49)
  %69 = bitcast %struct.CGSize* %windowSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %69) #11
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end34, %if.then13
  %70 = bitcast %struct.objc_object** %event to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %70) #11
  %71 = bitcast %struct.objc_object** %distantPast to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #11
  %72 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %72) #11
  %73 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %73) #11
  %74 = bitcast %struct.objc_object** %openGLContext to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %74) #11
  %75 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %75) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPIPresent(%struct.Tigr* %bmp, i32 %w, i32 %h) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %gl = alloca %struct.GLStuff*, align 8
  %projection = alloca [16 x float], align 16
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %1)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %2 = bitcast %struct.GLStuff** %gl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %gl1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %3, i32 0, i32 2
  store %struct.GLStuff* %gl1, %struct.GLStuff** %gl, align 8, !tbaa !8
  %4 = load i32, i32* %w.addr, align 4, !tbaa !4
  %5 = load i32, i32* %h.addr, align 4, !tbaa !4
  call void @glViewport(i32 0, i32 0, i32 %4, i32 %5)
  call void @glClearColor(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00)
  call void @glClear(i32 16384)
  %6 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %6, i32 0, i32 6
  %7 = load i32, i32* %gl_legacy, align 4, !tbaa !88
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %8 = bitcast [16 x float]* %projection to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %8) #11
  %arrayinit.begin = getelementptr inbounds [16 x float], [16 x float]* %projection, i64 0, i64 0
  %9 = load i32, i32* %w.addr, align 4, !tbaa !4
  %conv = sitofp i32 %9 to float
  %div = fdiv float 2.000000e+00, %conv
  store float %div, float* %arrayinit.begin, align 4, !tbaa !21
  %arrayinit.element = getelementptr inbounds float, float* %arrayinit.begin, i64 1
  store float 0.000000e+00, float* %arrayinit.element, align 4, !tbaa !21
  %arrayinit.element2 = getelementptr inbounds float, float* %arrayinit.element, i64 1
  store float 0.000000e+00, float* %arrayinit.element2, align 4, !tbaa !21
  %arrayinit.element3 = getelementptr inbounds float, float* %arrayinit.element2, i64 1
  store float 0.000000e+00, float* %arrayinit.element3, align 4, !tbaa !21
  %arrayinit.element4 = getelementptr inbounds float, float* %arrayinit.element3, i64 1
  store float 0.000000e+00, float* %arrayinit.element4, align 4, !tbaa !21
  %arrayinit.element5 = getelementptr inbounds float, float* %arrayinit.element4, i64 1
  %10 = load i32, i32* %h.addr, align 4, !tbaa !4
  %conv6 = sitofp i32 %10 to float
  %div7 = fdiv float -2.000000e+00, %conv6
  store float %div7, float* %arrayinit.element5, align 4, !tbaa !21
  %arrayinit.element8 = getelementptr inbounds float, float* %arrayinit.element5, i64 1
  store float 0.000000e+00, float* %arrayinit.element8, align 4, !tbaa !21
  %arrayinit.element9 = getelementptr inbounds float, float* %arrayinit.element8, i64 1
  store float 0.000000e+00, float* %arrayinit.element9, align 4, !tbaa !21
  %arrayinit.element10 = getelementptr inbounds float, float* %arrayinit.element9, i64 1
  store float 0.000000e+00, float* %arrayinit.element10, align 4, !tbaa !21
  %arrayinit.element11 = getelementptr inbounds float, float* %arrayinit.element10, i64 1
  store float 0.000000e+00, float* %arrayinit.element11, align 4, !tbaa !21
  %arrayinit.element12 = getelementptr inbounds float, float* %arrayinit.element11, i64 1
  store float 1.000000e+00, float* %arrayinit.element12, align 4, !tbaa !21
  %arrayinit.element13 = getelementptr inbounds float, float* %arrayinit.element12, i64 1
  store float 0.000000e+00, float* %arrayinit.element13, align 4, !tbaa !21
  %arrayinit.element14 = getelementptr inbounds float, float* %arrayinit.element13, i64 1
  store float -1.000000e+00, float* %arrayinit.element14, align 4, !tbaa !21
  %arrayinit.element15 = getelementptr inbounds float, float* %arrayinit.element14, i64 1
  store float 1.000000e+00, float* %arrayinit.element15, align 4, !tbaa !21
  %arrayinit.element16 = getelementptr inbounds float, float* %arrayinit.element15, i64 1
  store float 0.000000e+00, float* %arrayinit.element16, align 4, !tbaa !21
  %arrayinit.element17 = getelementptr inbounds float, float* %arrayinit.element16, i64 1
  store float 1.000000e+00, float* %arrayinit.element17, align 4, !tbaa !21
  call void @glActiveTexture(i32 33984)
  %11 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %vao = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %11, i32 0, i32 1
  %12 = load i32, i32* %vao, align 4, !tbaa !89
  call void @glBindVertexArray(i32 %12)
  %13 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %program = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %13, i32 0, i32 2
  %14 = load i32, i32* %program, align 4, !tbaa !90
  call void @glUseProgram(i32 %14)
  %15 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_projection = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %15, i32 0, i32 3
  %16 = load i32, i32* %uniform_projection, align 4, !tbaa !91
  %arraydecay = getelementptr inbounds [16 x float], [16 x float]* %projection, i32 0, i32 0
  call void @glUniformMatrix4fv(i32 %16, i32 1, i8 zeroext 0, float* %arraydecay)
  %17 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_parameters = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %17, i32 0, i32 5
  %18 = load i32, i32* %uniform_parameters, align 4, !tbaa !93
  %19 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %hblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %19, i32 0, i32 8
  %20 = load i32, i32* %hblur, align 4, !tbaa !35
  %tobool18 = icmp ne i32 %20, 0
  %21 = zext i1 %tobool18 to i64
  %cond = select i1 %tobool18, float 1.000000e+00, float 0.000000e+00
  %22 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %vblur = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %22, i32 0, i32 9
  %23 = load i32, i32* %vblur, align 8, !tbaa !38
  %tobool19 = icmp ne i32 %23, 0
  %24 = zext i1 %tobool19 to i64
  %cond20 = select i1 %tobool19, float 1.000000e+00, float 0.000000e+00
  %25 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scanlines = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %25, i32 0, i32 10
  %26 = load float, float* %scanlines, align 4, !tbaa !39
  %27 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %contrast = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %27, i32 0, i32 11
  %28 = load float, float* %contrast, align 8, !tbaa !40
  call void @glUniform4f(i32 %18, float %cond, float %cond20, float %26, float %28)
  %29 = bitcast [16 x float]* %projection to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %29) #11
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.tigrGAPIPresent, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3983, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.96, i32 0, i32 0)) #18
  unreachable

if.end:                                           ; preds = %if.then
  call void @glDisable(i32 3042)
  %30 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy21 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %30, i32 0, i32 6
  %31 = load i32, i32* %gl_legacy21, align 4, !tbaa !88
  %32 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_model = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %32, i32 0, i32 4
  %33 = load i32, i32* %uniform_model, align 4, !tbaa !92
  %34 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %tex = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %34, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %tex, i64 0, i64 0
  %35 = load i32, i32* %arrayidx, align 4, !tbaa !4
  %36 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %37 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %37, i32 0, i32 14
  %arrayidx22 = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i64 0, i64 0
  %38 = load i32, i32* %arrayidx22, align 4, !tbaa !4
  %39 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos23 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %39, i32 0, i32 14
  %arrayidx24 = getelementptr inbounds [4 x i32], [4 x i32]* %pos23, i64 0, i64 1
  %40 = load i32, i32* %arrayidx24, align 4, !tbaa !4
  %41 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos25 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %41, i32 0, i32 14
  %arrayidx26 = getelementptr inbounds [4 x i32], [4 x i32]* %pos25, i64 0, i64 2
  %42 = load i32, i32* %arrayidx26, align 4, !tbaa !4
  %43 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos27 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %43, i32 0, i32 14
  %arrayidx28 = getelementptr inbounds [4 x i32], [4 x i32]* %pos27, i64 0, i64 3
  %44 = load i32, i32* %arrayidx28, align 4, !tbaa !4
  call void @tigrGAPIDraw(i32 %31, i32 %33, i32 %35, %struct.Tigr* %36, i32 %38, i32 %40, i32 %42, i32 %44)
  %45 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgetsScale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %45, i32 0, i32 7
  %46 = load float, float* %widgetsScale, align 8, !tbaa !86
  %cmp = fcmp ogt float %46, 0.000000e+00
  br i1 %cmp, label %if.then30, label %if.end47

if.then30:                                        ; preds = %if.end
  call void @glEnable(i32 3042)
  call void @glBlendFunc(i32 770, i32 771)
  %47 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %gl_legacy31 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %47, i32 0, i32 6
  %48 = load i32, i32* %gl_legacy31, align 4, !tbaa !88
  %49 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %uniform_model32 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %49, i32 0, i32 4
  %50 = load i32, i32* %uniform_model32, align 4, !tbaa !92
  %51 = load %struct.GLStuff*, %struct.GLStuff** %gl, align 8, !tbaa !8
  %tex33 = getelementptr inbounds %struct.GLStuff, %struct.GLStuff* %51, i32 0, i32 0
  %arrayidx34 = getelementptr inbounds [2 x i32], [2 x i32]* %tex33, i64 0, i64 1
  %52 = load i32, i32* %arrayidx34, align 4, !tbaa !4
  %53 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgets = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %53, i32 0, i32 4
  %54 = load %struct.Tigr*, %struct.Tigr** %widgets, align 8, !tbaa !64
  %55 = load i32, i32* %w.addr, align 4, !tbaa !4
  %conv35 = sitofp i32 %55 to float
  %56 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgets36 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %56, i32 0, i32 4
  %57 = load %struct.Tigr*, %struct.Tigr** %widgets36, align 8, !tbaa !64
  %w37 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %57, i32 0, i32 0
  %58 = load i32, i32* %w37, align 8, !tbaa !10
  %conv38 = sitofp i32 %58 to float
  %59 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgetsScale39 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %59, i32 0, i32 7
  %60 = load float, float* %widgetsScale39, align 8, !tbaa !86
  %mul = fmul float %conv38, %60
  %sub = fsub float %conv35, %mul
  %conv40 = fptosi float %sub to i32
  %61 = load i32, i32* %w.addr, align 4, !tbaa !4
  %62 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgets41 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %62, i32 0, i32 4
  %63 = load %struct.Tigr*, %struct.Tigr** %widgets41, align 8, !tbaa !64
  %h42 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %63, i32 0, i32 1
  %64 = load i32, i32* %h42, align 4, !tbaa !12
  %conv43 = sitofp i32 %64 to float
  %65 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %widgetsScale44 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %65, i32 0, i32 7
  %66 = load float, float* %widgetsScale44, align 8, !tbaa !86
  %mul45 = fmul float %conv43, %66
  %conv46 = fptosi float %mul45 to i32
  call void @tigrGAPIDraw(i32 %48, i32 %50, i32 %52, %struct.Tigr* %54, i32 %conv40, i32 0, i32 %61, i32 %conv46)
  br label %if.end47

if.end47:                                         ; preds = %if.then30, %if.end
  call void @tigrCheckGLError(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.97, i32 0, i32 0))
  %67 = bitcast %struct.GLStuff** %gl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %67) #11
  %68 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %68) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrClosed(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = load i8, i8* @terminated, align 1, !tbaa !65, !range !67
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 3
  %2 = load i8*, i8** %handle, align 8, !tbaa !41
  %3 = bitcast i8* %2 to %struct.objc_object*
  %call = call zeroext i1 @_tigrCocoaIsWindowClosed(%struct.objc_object* %3)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %call, %lor.rhs ]
  %5 = zext i1 %4 to i64
  %cond = select i1 %4, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind ssp uwtable
define void @tigrMouse(%struct.Tigr* %bmp, i32* %x, i32* %y, i32* %buttons) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x.addr = alloca i32*, align 8
  %y.addr = alloca i32*, align 8
  %buttons.addr = alloca i32*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %window = alloca %struct.objc_object*, align 8
  %windowContentView = alloca %struct.objc_object*, align 8
  %adjustFrame = alloca %struct.CGRect, align 8
  %p = alloca %struct.CGPoint, align 8
  %r = alloca %struct.CGRect, align 8
  %tmp = alloca %struct.CGRect, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32* %x, i32** %x.addr, align 8, !tbaa !8
  store i32* %y, i32** %y.addr, align 8, !tbaa !8
  store i32* %buttons, i32** %buttons.addr, align 8, !tbaa !8
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %2)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i32 0, i32 3
  %4 = load i8*, i8** %handle, align 8, !tbaa !41
  %5 = bitcast i8* %4 to %struct.objc_object*
  store %struct.objc_object* %5, %struct.objc_object** %window, align 8, !tbaa !8
  %6 = bitcast %struct.objc_object** %windowContentView to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %7 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call1 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0))
  %call2 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %7, %struct.objc_selector* %call1)
  store %struct.objc_object* %call2, %struct.objc_object** %windowContentView, align 8, !tbaa !8
  %8 = bitcast %struct.CGRect* %adjustFrame to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %8) #11
  %9 = load %struct.objc_object*, %struct.objc_object** %windowContentView, align 8, !tbaa !8
  %call3 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.43, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*)*)(%struct.CGRect* sret %adjustFrame, %struct.objc_object* %9, %struct.objc_selector* %call3)
  %10 = bitcast %struct.CGPoint* %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %10) #11
  %11 = load %struct.objc_object*, %struct.objc_object** %window, align 8, !tbaa !8
  %call4 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.86, i32 0, i32 0))
  %call5 = call { double, double } bitcast (void ()* @objc_msgSend to { double, double } (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %11, %struct.objc_selector* %call4)
  %12 = bitcast %struct.CGPoint* %p to { double, double }*
  %13 = getelementptr inbounds { double, double }, { double, double }* %12, i32 0, i32 0
  %14 = extractvalue { double, double } %call5, 0
  store double %14, double* %13, align 8
  %15 = getelementptr inbounds { double, double }, { double, double }* %12, i32 0, i32 1
  %16 = extractvalue { double, double } %call5, 1
  store double %16, double* %15, align 8
  %x6 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %17 = load double, double* %x6, align 8, !tbaa !74
  %cmp = fcmp olt double %17, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %x7 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  store double 0.000000e+00, double* %x7, align 8, !tbaa !74
  br label %if.end14

if.else:                                          ; preds = %entry
  %x8 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %18 = load double, double* %x8, align 8, !tbaa !74
  %size = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %width = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size, i32 0, i32 0
  %19 = load double, double* %width, align 8, !tbaa !96
  %cmp9 = fcmp ogt double %18, %19
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %size11 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %width12 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size11, i32 0, i32 0
  %20 = load double, double* %width12, align 8, !tbaa !96
  %x13 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  store double %20, double* %x13, align 8, !tbaa !74
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %y15 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %21 = load double, double* %y15, align 8, !tbaa !76
  %cmp16 = fcmp olt double %21, 0.000000e+00
  br i1 %cmp16, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.end14
  %y18 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  store double 0.000000e+00, double* %y18, align 8, !tbaa !76
  br label %if.end28

if.else19:                                        ; preds = %if.end14
  %y20 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %22 = load double, double* %y20, align 8, !tbaa !76
  %size21 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %height = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size21, i32 0, i32 1
  %23 = load double, double* %height, align 8, !tbaa !98
  %cmp22 = fcmp ogt double %22, %23
  br i1 %cmp22, label %if.then23, label %if.end27

if.then23:                                        ; preds = %if.else19
  %size24 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %height25 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size24, i32 0, i32 1
  %24 = load double, double* %height25, align 8, !tbaa !98
  %y26 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  store double %24, double* %y26, align 8, !tbaa !76
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %if.else19
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then17
  %25 = bitcast %struct.CGRect* %r to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %25) #11
  %origin = getelementptr inbounds %struct.CGRect, %struct.CGRect* %r, i32 0, i32 0
  %x29 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 0
  %x30 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %26 = load double, double* %x30, align 8, !tbaa !74
  store double %26, double* %x29, align 8, !tbaa !74
  %y31 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %origin, i32 0, i32 1
  %y32 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %27 = load double, double* %y32, align 8, !tbaa !76
  store double %27, double* %y31, align 8, !tbaa !76
  %size33 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %r, i32 0, i32 1
  %width34 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size33, i32 0, i32 0
  store double 0.000000e+00, double* %width34, align 8, !tbaa !77
  %height35 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size33, i32 0, i32 1
  store double 0.000000e+00, double* %height35, align 8, !tbaa !79
  %28 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %28) #11
  %29 = load %struct.objc_object*, %struct.objc_object** %windowContentView, align 8, !tbaa !8
  %call36 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.44, i32 0, i32 0))
  call void bitcast (void ()* @objc_msgSend_stret to void (%struct.CGRect*, %struct.objc_object*, %struct.objc_selector*, %struct.CGRect*)*)(%struct.CGRect* sret %tmp, %struct.objc_object* %29, %struct.objc_selector* %call36, %struct.CGRect* byval align 8 %r)
  %30 = bitcast %struct.CGRect* %r to i8*
  %31 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %31, i64 32, i1 false), !tbaa.struct !70
  %32 = bitcast %struct.CGRect* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %32) #11
  %origin37 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %r, i32 0, i32 0
  %33 = bitcast %struct.CGPoint* %p to i8*
  %34 = bitcast %struct.CGPoint* %origin37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %34, i64 16, i1 false), !tbaa.struct !73
  %x38 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %35 = load double, double* %x38, align 8, !tbaa !74
  %36 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %36, i32 0, i32 14
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %pos, i64 0, i64 0
  %37 = load i32, i32* %arrayidx, align 4, !tbaa !4
  %conv = sitofp i32 %37 to double
  %sub = fsub double %35, %conv
  %38 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %38, i32 0, i32 13
  %39 = load i32, i32* %scale, align 8, !tbaa !82
  %conv39 = sitofp i32 %39 to double
  %div = fdiv double %sub, %conv39
  %x40 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  store double %div, double* %x40, align 8, !tbaa !74
  %size41 = getelementptr inbounds %struct.CGRect, %struct.CGRect* %adjustFrame, i32 0, i32 1
  %height42 = getelementptr inbounds %struct.CGSize, %struct.CGSize* %size41, i32 0, i32 1
  %40 = load double, double* %height42, align 8, !tbaa !98
  %y43 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %41 = load double, double* %y43, align 8, !tbaa !76
  %sub44 = fsub double %40, %41
  %42 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %pos45 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %42, i32 0, i32 14
  %arrayidx46 = getelementptr inbounds [4 x i32], [4 x i32]* %pos45, i64 0, i64 1
  %43 = load i32, i32* %arrayidx46, align 4, !tbaa !4
  %conv47 = sitofp i32 %43 to double
  %sub48 = fsub double %sub44, %conv47
  %44 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %scale49 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %44, i32 0, i32 13
  %45 = load i32, i32* %scale49, align 8, !tbaa !82
  %conv50 = sitofp i32 %45 to double
  %div51 = fdiv double %sub48, %conv50
  %y52 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  store double %div51, double* %y52, align 8, !tbaa !76
  %46 = load i32*, i32** %x.addr, align 8, !tbaa !8
  %tobool = icmp ne i32* %46, null
  br i1 %tobool, label %if.then53, label %if.end56

if.then53:                                        ; preds = %if.end28
  %x54 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 0
  %47 = load double, double* %x54, align 8, !tbaa !74
  %conv55 = fptosi double %47 to i32
  %48 = load i32*, i32** %x.addr, align 8, !tbaa !8
  store i32 %conv55, i32* %48, align 4, !tbaa !4
  br label %if.end56

if.end56:                                         ; preds = %if.then53, %if.end28
  %49 = load i32*, i32** %y.addr, align 8, !tbaa !8
  %tobool57 = icmp ne i32* %49, null
  br i1 %tobool57, label %if.then58, label %if.end61

if.then58:                                        ; preds = %if.end56
  %y59 = getelementptr inbounds %struct.CGPoint, %struct.CGPoint* %p, i32 0, i32 1
  %50 = load double, double* %y59, align 8, !tbaa !76
  %conv60 = fptosi double %50 to i32
  %51 = load i32*, i32** %y.addr, align 8, !tbaa !8
  store i32 %conv60, i32* %51, align 4, !tbaa !4
  br label %if.end61

if.end61:                                         ; preds = %if.then58, %if.end56
  %52 = load i32*, i32** %buttons.addr, align 8, !tbaa !8
  %tobool62 = icmp ne i32* %52, null
  br i1 %tobool62, label %if.then63, label %if.end69

if.then63:                                        ; preds = %if.end61
  %53 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %53) #11
  %54 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call64 = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call65 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %54, %struct.objc_selector* %call64)
  store %struct.objc_object* %call65, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %55 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %56 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle66 = getelementptr inbounds %struct.Tigr, %struct.Tigr* %56, i32 0, i32 3
  %57 = load i8*, i8** %handle66, align 8, !tbaa !41
  %58 = bitcast i8* %57 to %struct.objc_object*
  %cmp67 = icmp ne %struct.objc_object* %55, %58
  br i1 %cmp67, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then63
  br label %cond.end

cond.false:                                       ; preds = %if.then63
  %59 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %mouseButtons = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %59, i32 0, i32 18
  %60 = load i32, i32* %mouseButtons, align 8, !tbaa !69
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %60, %cond.false ]
  %61 = load i32*, i32** %buttons.addr, align 8, !tbaa !8
  store i32 %cond, i32* %61, align 4, !tbaa !4
  %62 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %62) #11
  br label %if.end69

if.end69:                                         ; preds = %cond.end, %if.end61
  %63 = bitcast %struct.CGRect* %r to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %63) #11
  %64 = bitcast %struct.CGPoint* %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %64) #11
  %65 = bitcast %struct.CGRect* %adjustFrame to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %65) #11
  %66 = bitcast %struct.objc_object** %windowContentView to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %66) #11
  %67 = bitcast %struct.objc_object** %window to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %67) #11
  %68 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %68) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrKeyDown(%struct.Tigr* %bmp, i32 %key) #0 {
entry:
  %retval = alloca i32, align 4
  %bmp.addr = alloca %struct.Tigr*, align 8
  %key.addr = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %key, i32* %key.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i32, i32* %key.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %1, 256
  %lnot = xor i1 %cmp, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrKeyDown, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3581, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.87, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %2
  %3 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %4, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %5 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 3
  %7 = load i8*, i8** %handle, align 8, !tbaa !41
  %8 = bitcast i8* %7 to %struct.objc_object*
  %cmp2 = icmp ne %struct.objc_object* %5, %8
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %cond.end
  %9 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call4 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %9)
  store %struct.TigrInternal* %call4, %struct.TigrInternal** %win, align 8, !tbaa !8
  %10 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %10, i32 0, i32 16
  %11 = load i32, i32* %key.addr, align 4, !tbaa !4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i64 0, i64 %idxprom
  %12 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv5 = sext i8 %12 to i32
  %tobool6 = icmp ne i32 %conv5, 0
  br i1 %tobool6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %13 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %prev = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %13, i32 0, i32 17
  %14 = load i32, i32* %key.addr, align 4, !tbaa !4
  %idxprom7 = sext i32 %14 to i64
  %arrayidx8 = getelementptr inbounds [256 x i8], [256 x i8]* %prev, i64 0, i64 %idxprom7
  %15 = load i8, i8* %arrayidx8, align 1, !tbaa !15
  %tobool9 = icmp ne i8 %15, 0
  %lnot10 = xor i1 %tobool9, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %16 = phi i1 [ false, %if.end ], [ %lnot10, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  store i32 %land.ext, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %land.end, %if.then
  %17 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #11
  %18 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #11
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrKeyHeld(%struct.Tigr* %bmp, i32 %key) #0 {
entry:
  %retval = alloca i32, align 4
  %bmp.addr = alloca %struct.Tigr*, align 8
  %key.addr = alloca i32, align 4
  %win = alloca %struct.TigrInternal*, align 8
  %keyWindow = alloca %struct.objc_object*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %key, i32* %key.addr, align 4, !tbaa !4
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i32, i32* %key.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %1, 256
  %lnot = xor i1 %cmp, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.tigrKeyHeld, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3592, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.87, i32 0, i32 0)) #18
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %2
  %3 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load %struct.objc_object*, %struct.objc_object** @NSApp, align 8, !tbaa !8
  %call = call %struct.objc_selector* @sel_registerName(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0))
  %call1 = call %struct.objc_object* bitcast (void ()* @objc_msgSend to %struct.objc_object* (%struct.objc_object*, %struct.objc_selector*)*)(%struct.objc_object* %4, %struct.objc_selector* %call)
  store %struct.objc_object* %call1, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %5 = load %struct.objc_object*, %struct.objc_object** %keyWindow, align 8, !tbaa !8
  %6 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %handle = getelementptr inbounds %struct.Tigr, %struct.Tigr* %6, i32 0, i32 3
  %7 = load i8*, i8** %handle, align 8, !tbaa !41
  %8 = bitcast i8* %7 to %struct.objc_object*
  %cmp2 = icmp ne %struct.objc_object* %5, %8
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %cond.end
  %9 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call4 = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %9)
  store %struct.TigrInternal* %call4, %struct.TigrInternal** %win, align 8, !tbaa !8
  %10 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %keys = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %10, i32 0, i32 16
  %11 = load i32, i32* %key.addr, align 4, !tbaa !4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %keys, i64 0, i64 %idxprom
  %12 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv5 = sext i8 %12 to i32
  store i32 %conv5, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %13 = bitcast %struct.objc_object** %keyWindow to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #11
  %14 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #11
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind ssp uwtable
define i32 @tigrReadChar(%struct.Tigr* %bmp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %win = alloca %struct.TigrInternal*, align 8
  %c = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %0 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %call = call %struct.TigrInternal* @tigrInternal(%struct.Tigr* %1)
  store %struct.TigrInternal* %call, %struct.TigrInternal** %win, align 8, !tbaa !8
  %2 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %lastChar = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %3, i32 0, i32 15
  %4 = load i32, i32* %lastChar, align 4, !tbaa !68
  store i32 %4, i32* %c, align 4, !tbaa !4
  %5 = load %struct.TigrInternal*, %struct.TigrInternal** %win, align 8, !tbaa !8
  %lastChar1 = getelementptr inbounds %struct.TigrInternal, %struct.TigrInternal* %5, i32 0, i32 15
  store i32 0, i32* %lastChar1, align 4, !tbaa !68
  %6 = load i32, i32* %c, align 4, !tbaa !4
  %7 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #11
  %8 = bitcast %struct.TigrInternal** %win to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #11
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define float @tigrTime() #0 {
entry:
  %retval = alloca float, align 4
  %current_time = alloca i64, align 8
  %elapsed = alloca double, align 8
  %0 = load i32, i32* getelementptr inbounds (%struct.mach_timebase_info, %struct.mach_timebase_info* @tigrTime.timebaseInfo, i32 0, i32 1), align 4, !tbaa !99
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @mach_timebase_info(%struct.mach_timebase_info* @tigrTime.timebaseInfo)
  %call1 = call i64 @mach_absolute_time()
  store i64 %call1, i64* @tigrTime.time, align 8, !tbaa !101
  store float 0.000000e+00, float* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i64* %current_time to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %call2 = call i64 @mach_absolute_time()
  store i64 %call2, i64* %current_time, align 8, !tbaa !101
  %2 = bitcast double* %elapsed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load i64, i64* %current_time, align 8, !tbaa !101
  %4 = load i64, i64* @tigrTime.time, align 8, !tbaa !101
  %sub = sub i64 %3, %4
  %conv = uitofp i64 %sub to double
  %5 = load i32, i32* getelementptr inbounds (%struct.mach_timebase_info, %struct.mach_timebase_info* @tigrTime.timebaseInfo, i32 0, i32 0), align 4, !tbaa !103
  %conv3 = uitofp i32 %5 to double
  %mul = fmul double %conv, %conv3
  %6 = load i32, i32* getelementptr inbounds (%struct.mach_timebase_info, %struct.mach_timebase_info* @tigrTime.timebaseInfo, i32 0, i32 1), align 4, !tbaa !99
  %conv4 = uitofp i32 %6 to double
  %mul5 = fmul double %conv4, 1.000000e+09
  %div = fdiv double %mul, %mul5
  store double %div, double* %elapsed, align 8, !tbaa !71
  %7 = load i64, i64* %current_time, align 8, !tbaa !101
  store i64 %7, i64* @tigrTime.time, align 8, !tbaa !101
  %8 = load double, double* %elapsed, align 8, !tbaa !71
  %conv6 = fptrunc double %8 to float
  store float %conv6, float* %retval, align 4
  %9 = bitcast double* %elapsed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  %10 = bitcast i64* %current_time to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load float, float* %retval, align 4
  ret float %11
}

declare i32 @mach_timebase_info(%struct.mach_timebase_info*) #5

declare i64 @mach_absolute_time() #5

; Function Attrs: nounwind ssp uwtable
define void @tigrCheckGLError(i8* %state) #0 {
entry:
  %state.addr = alloca i8*, align 8
  %err = alloca i32, align 4
  store i8* %state, i8** %state.addr, align 8, !tbaa !8
  %0 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %call = call i32 @glGetError()
  store i32 %call, i32* %err, align 4, !tbaa !4
  %1 = load i32, i32* %err, align 4, !tbaa !4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %err, align 4, !tbaa !4
  %3 = load i8*, i8** %state.addr, align 8, !tbaa !8
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.88, i32 0, i32 0), i32 %2, i8* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #11
  ret void
}

declare i32 @glGetError() #5

declare i32 @printf(i8*, ...) #5

; Function Attrs: nounwind ssp uwtable
define void @tigrCheckShaderErrors(i32 %object) #0 {
entry:
  %object.addr = alloca i32, align 4
  %success = alloca i32, align 4
  %info = alloca [2048 x i8], align 16
  store i32 %object, i32* %object.addr, align 4, !tbaa !4
  %0 = bitcast i32* %success to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast [2048 x i8]* %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 2048, i8* %1) #11
  %2 = load i32, i32* %object.addr, align 4, !tbaa !4
  call void @glGetShaderiv(i32 %2, i32 35713, i32* %success)
  %3 = load i32, i32* %success, align 4, !tbaa !4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %object.addr, align 4, !tbaa !4
  %arraydecay = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  call void @glGetShaderInfoLog(i32 %4, i32 2048, i32* null, i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.89, i32 0, i32 0), i8* %arraydecay1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = bitcast [2048 x i8]* %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 2048, i8* %5) #11
  %6 = bitcast i32* %success to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #11
  ret void
}

declare void @glGetShaderiv(i32, i32, i32*) #5

declare void @glGetShaderInfoLog(i32, i32, i32*, i8*) #5

; Function Attrs: nounwind ssp uwtable
define void @tigrCheckProgramErrors(i32 %object) #0 {
entry:
  %object.addr = alloca i32, align 4
  %success = alloca i32, align 4
  %info = alloca [2048 x i8], align 16
  store i32 %object, i32* %object.addr, align 4, !tbaa !4
  %0 = bitcast i32* %success to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast [2048 x i8]* %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 2048, i8* %1) #11
  %2 = load i32, i32* %object.addr, align 4, !tbaa !4
  call void @glGetProgramiv(i32 %2, i32 35714, i32* %success)
  %3 = load i32, i32* %success, align 4, !tbaa !4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %object.addr, align 4, !tbaa !4
  %arraydecay = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  call void @glGetProgramInfoLog(i32 %4, i32 2048, i32* null, i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [2048 x i8], [2048 x i8]* %info, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.90, i32 0, i32 0), i8* %arraydecay1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = bitcast [2048 x i8]* %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 2048, i8* %5) #11
  %6 = bitcast i32* %success to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #11
  ret void
}

declare void @glGetProgramiv(i32, i32, i32*) #5

declare void @glGetProgramInfoLog(i32, i32, i32*, i8*) #5

declare void @glGenVertexArrays(i32, i32*) #5

declare void @glGenBuffers(i32, i32*) #5

declare void @glBindBuffer(i32, i32) #5

declare void @glBufferData(i32, i64, i8*, i32) #5

declare void @glBindVertexArray(i32) #5

declare void @glEnableVertexAttribArray(i32) #5

declare void @glVertexAttribPointer(i32, i32, i32, i8 zeroext, i32, i8*) #5

declare i32 @glCreateShader(i32) #5

declare void @glShaderSource(i32, i32, i8**, i32*) #5

declare void @glCompileShader(i32) #5

declare i32 @glCreateProgram() #5

declare void @glAttachShader(i32, i32) #5

declare void @glLinkProgram(i32) #5

declare void @glDeleteShader(i32) #5

declare i32 @glGetUniformLocation(i32, i8*) #5

declare void @glEnable(i32) #5

declare void @glGenTextures(i32, i32*) #5

declare void @glBindTexture(i32, i32) #5

declare void @glTexParameteri(i32, i32, i32) #5

declare void @glPixelStorei(i32, i32) #5

declare void @glDeleteTextures(i32, i32*) #5

declare void @glDeleteProgram(i32) #5

; Function Attrs: nounwind ssp uwtable
define void @tigrGAPIDraw(i32 %legacy, i32 %uniform_model, i32 %tex, %struct.Tigr* %bmp, i32 %x1, i32 %y1, i32 %x2, i32 %y2) #0 {
entry:
  %legacy.addr = alloca i32, align 4
  %uniform_model.addr = alloca i32, align 4
  %tex.addr = alloca i32, align 4
  %bmp.addr = alloca %struct.Tigr*, align 8
  %x1.addr = alloca i32, align 4
  %y1.addr = alloca i32, align 4
  %x2.addr = alloca i32, align 4
  %y2.addr = alloca i32, align 4
  %sx = alloca float, align 4
  %sy = alloca float, align 4
  %tx = alloca float, align 4
  %ty = alloca float, align 4
  %model = alloca [16 x float], align 16
  store i32 %legacy, i32* %legacy.addr, align 4, !tbaa !4
  store i32 %uniform_model, i32* %uniform_model.addr, align 4, !tbaa !4
  store i32 %tex, i32* %tex.addr, align 4, !tbaa !4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %x1, i32* %x1.addr, align 4, !tbaa !4
  store i32 %y1, i32* %y1.addr, align 4, !tbaa !4
  store i32 %x2, i32* %x2.addr, align 4, !tbaa !4
  store i32 %y2, i32* %y2.addr, align 4, !tbaa !4
  %0 = load i32, i32* %tex.addr, align 4, !tbaa !4
  call void @glBindTexture(i32 3553, i32 %0)
  %1 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %1, i32 0, i32 0
  %2 = load i32, i32* %w, align 8, !tbaa !10
  %3 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %3, i32 0, i32 1
  %4 = load i32, i32* %h, align 4, !tbaa !12
  %5 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %pix = getelementptr inbounds %struct.Tigr, %struct.Tigr* %5, i32 0, i32 2
  %6 = load %struct.TPixel*, %struct.TPixel** %pix, align 8, !tbaa !13
  %7 = bitcast %struct.TPixel* %6 to i8*
  call void @glTexImage2D(i32 3553, i32 0, i32 32856, i32 %2, i32 %4, i32 0, i32 32993, i32 5121, i8* %7)
  %8 = load i32, i32* %legacy.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %9 = bitcast float* %sx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #11
  %10 = load i32, i32* %x2.addr, align 4, !tbaa !4
  %11 = load i32, i32* %x1.addr, align 4, !tbaa !4
  %sub = sub nsw i32 %10, %11
  %conv = sitofp i32 %sub to float
  store float %conv, float* %sx, align 4, !tbaa !21
  %12 = bitcast float* %sy to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %12) #11
  %13 = load i32, i32* %y2.addr, align 4, !tbaa !4
  %14 = load i32, i32* %y1.addr, align 4, !tbaa !4
  %sub1 = sub nsw i32 %13, %14
  %conv2 = sitofp i32 %sub1 to float
  store float %conv2, float* %sy, align 4, !tbaa !21
  %15 = bitcast float* %tx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %15) #11
  %16 = load i32, i32* %x1.addr, align 4, !tbaa !4
  %conv3 = sitofp i32 %16 to float
  store float %conv3, float* %tx, align 4, !tbaa !21
  %17 = bitcast float* %ty to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %17) #11
  %18 = load i32, i32* %y1.addr, align 4, !tbaa !4
  %conv4 = sitofp i32 %18 to float
  store float %conv4, float* %ty, align 4, !tbaa !21
  %19 = bitcast [16 x float]* %model to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %19) #11
  %arrayinit.begin = getelementptr inbounds [16 x float], [16 x float]* %model, i64 0, i64 0
  %20 = load float, float* %sx, align 4, !tbaa !21
  store float %20, float* %arrayinit.begin, align 4, !tbaa !21
  %arrayinit.element = getelementptr inbounds float, float* %arrayinit.begin, i64 1
  store float 0.000000e+00, float* %arrayinit.element, align 4, !tbaa !21
  %arrayinit.element5 = getelementptr inbounds float, float* %arrayinit.element, i64 1
  store float 0.000000e+00, float* %arrayinit.element5, align 4, !tbaa !21
  %arrayinit.element6 = getelementptr inbounds float, float* %arrayinit.element5, i64 1
  store float 0.000000e+00, float* %arrayinit.element6, align 4, !tbaa !21
  %arrayinit.element7 = getelementptr inbounds float, float* %arrayinit.element6, i64 1
  store float 0.000000e+00, float* %arrayinit.element7, align 4, !tbaa !21
  %arrayinit.element8 = getelementptr inbounds float, float* %arrayinit.element7, i64 1
  %21 = load float, float* %sy, align 4, !tbaa !21
  store float %21, float* %arrayinit.element8, align 4, !tbaa !21
  %arrayinit.element9 = getelementptr inbounds float, float* %arrayinit.element8, i64 1
  store float 0.000000e+00, float* %arrayinit.element9, align 4, !tbaa !21
  %arrayinit.element10 = getelementptr inbounds float, float* %arrayinit.element9, i64 1
  store float 0.000000e+00, float* %arrayinit.element10, align 4, !tbaa !21
  %arrayinit.element11 = getelementptr inbounds float, float* %arrayinit.element10, i64 1
  store float 0.000000e+00, float* %arrayinit.element11, align 4, !tbaa !21
  %arrayinit.element12 = getelementptr inbounds float, float* %arrayinit.element11, i64 1
  store float 0.000000e+00, float* %arrayinit.element12, align 4, !tbaa !21
  %arrayinit.element13 = getelementptr inbounds float, float* %arrayinit.element12, i64 1
  store float 1.000000e+00, float* %arrayinit.element13, align 4, !tbaa !21
  %arrayinit.element14 = getelementptr inbounds float, float* %arrayinit.element13, i64 1
  store float 0.000000e+00, float* %arrayinit.element14, align 4, !tbaa !21
  %arrayinit.element15 = getelementptr inbounds float, float* %arrayinit.element14, i64 1
  %22 = load float, float* %tx, align 4, !tbaa !21
  store float %22, float* %arrayinit.element15, align 4, !tbaa !21
  %arrayinit.element16 = getelementptr inbounds float, float* %arrayinit.element15, i64 1
  %23 = load float, float* %ty, align 4, !tbaa !21
  store float %23, float* %arrayinit.element16, align 4, !tbaa !21
  %arrayinit.element17 = getelementptr inbounds float, float* %arrayinit.element16, i64 1
  store float 0.000000e+00, float* %arrayinit.element17, align 4, !tbaa !21
  %arrayinit.element18 = getelementptr inbounds float, float* %arrayinit.element17, i64 1
  store float 1.000000e+00, float* %arrayinit.element18, align 4, !tbaa !21
  %24 = load i32, i32* %uniform_model.addr, align 4, !tbaa !4
  %arraydecay = getelementptr inbounds [16 x float], [16 x float]* %model, i32 0, i32 0
  call void @glUniformMatrix4fv(i32 %24, i32 1, i8 zeroext 0, float* %arraydecay)
  call void @glDrawArrays(i32 4, i32 0, i32 6)
  %25 = bitcast [16 x float]* %model to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %25) #11
  %26 = bitcast float* %ty to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #11
  %27 = bitcast float* %tx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %27) #11
  %28 = bitcast float* %sy to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %28) #11
  %29 = bitcast float* %sx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %29) #11
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.tigrGAPIDraw, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0), i32 3942, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.96, i32 0, i32 0)) #18
  unreachable

if.end:                                           ; preds = %if.then
  ret void
}

declare void @glTexImage2D(i32, i32, i32, i32, i32, i32, i32, i32, i8*) #5

declare void @glUniformMatrix4fv(i32, i32, i8 zeroext, float*) #5

declare void @glDrawArrays(i32, i32, i32) #5

declare void @glViewport(i32, i32, i32, i32) #5

declare void @glClearColor(float, float, float, float) #5

declare void @glClear(i32) #5

declare void @glActiveTexture(i32) #5

declare void @glUseProgram(i32) #5

declare void @glUniform4f(i32, float, float, float, float) #5

declare void @glDisable(i32) #5

declare void @glBlendFunc(i32, i32) #5

declare i32 @memcmp(i8*, i8*, i64) #5

; Function Attrs: nounwind ssp uwtable
define internal i8* @find(%struct.PNG* %png, i8* %chunk, i32 %minlen) #0 {
entry:
  %retval = alloca i8*, align 8
  %png.addr = alloca %struct.PNG*, align 8
  %chunk.addr = alloca i8*, align 8
  %minlen.addr = alloca i32, align 4
  %start = alloca i8*, align 8
  %len = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.PNG* %png, %struct.PNG** %png.addr, align 8, !tbaa !8
  store i8* %chunk, i8** %chunk.addr, align 8, !tbaa !8
  store i32 %minlen, i32* %minlen.addr, align 4, !tbaa !4
  %0 = bitcast i8** %start to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %entry
  %1 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p = getelementptr inbounds %struct.PNG, %struct.PNG* %1, i32 0, i32 0
  %2 = load i8*, i8** %p, align 8, !tbaa !23
  %3 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %end = getelementptr inbounds %struct.PNG, %struct.PNG* %3, i32 0, i32 1
  %4 = load i8*, i8** %end, align 8, !tbaa !25
  %cmp = icmp ult i8* %2, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  %6 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p1 = getelementptr inbounds %struct.PNG, %struct.PNG* %6, i32 0, i32 0
  %7 = load i8*, i8** %p1, align 8, !tbaa !23
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %call = call i32 @get32(i8* %add.ptr)
  store i32 %call, i32* %len, align 4, !tbaa !4
  %8 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p2 = getelementptr inbounds %struct.PNG, %struct.PNG* %8, i32 0, i32 0
  %9 = load i8*, i8** %p2, align 8, !tbaa !23
  store i8* %9, i8** %start, align 8, !tbaa !8
  %10 = load i32, i32* %len, align 4, !tbaa !4
  %add = add i32 %10, 12
  %11 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p3 = getelementptr inbounds %struct.PNG, %struct.PNG* %11, i32 0, i32 0
  %12 = load i8*, i8** %p3, align 8, !tbaa !23
  %idx.ext = zext i32 %add to i64
  %add.ptr4 = getelementptr inbounds i8, i8* %12, i64 %idx.ext
  store i8* %add.ptr4, i8** %p3, align 8, !tbaa !23
  %13 = load i8*, i8** %start, align 8, !tbaa !8
  %add.ptr5 = getelementptr inbounds i8, i8* %13, i64 4
  %14 = load i8*, i8** %chunk.addr, align 8, !tbaa !8
  %call6 = call i32 @memcmp(i8* %add.ptr5, i8* %14, i64 4)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %15 = load i32, i32* %len, align 4, !tbaa !4
  %16 = load i32, i32* %minlen.addr, align 4, !tbaa !4
  %cmp8 = icmp uge i32 %15, %16
  br i1 %cmp8, label %land.lhs.true9, label %if.end

land.lhs.true9:                                   ; preds = %land.lhs.true
  %17 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %p10 = getelementptr inbounds %struct.PNG, %struct.PNG* %17, i32 0, i32 0
  %18 = load i8*, i8** %p10, align 8, !tbaa !23
  %19 = load %struct.PNG*, %struct.PNG** %png.addr, align 8, !tbaa !8
  %end11 = getelementptr inbounds %struct.PNG, %struct.PNG* %19, i32 0, i32 1
  %20 = load i8*, i8** %end11, align 8, !tbaa !25
  %cmp12 = icmp ule i8* %18, %20
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true9
  %21 = load i8*, i8** %start, align 8, !tbaa !8
  %add.ptr13 = getelementptr inbounds i8, i8* %21, i64 8
  store i8* %add.ptr13, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true9, %land.lhs.true, %while.body
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %22 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %22) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup14 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i8* null, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup14

cleanup14:                                        ; preds = %while.end, %cleanup
  %23 = bitcast i8** %start to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #11
  %24 = load i8*, i8** %retval, align 8
  ret i8* %24
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @get32(i8* %v) #0 {
entry:
  %v.addr = alloca i8*, align 8
  store i8* %v, i8** %v.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %v.addr, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 24
  %2 = load i8*, i8** %v.addr, align 8, !tbaa !8
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 1
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !15
  %conv2 = zext i8 %3 to i32
  %shl3 = shl i32 %conv2, 16
  %or = or i32 %shl, %shl3
  %4 = load i8*, i8** %v.addr, align 8, !tbaa !8
  %arrayidx4 = getelementptr inbounds i8, i8* %4, i64 2
  %5 = load i8, i8* %arrayidx4, align 1, !tbaa !15
  %conv5 = zext i8 %5 to i32
  %shl6 = shl i32 %conv5, 8
  %or7 = or i32 %or, %shl6
  %6 = load i8*, i8** %v.addr, align 8, !tbaa !8
  %arrayidx8 = getelementptr inbounds i8, i8* %6, i64 3
  %7 = load i8, i8* %arrayidx8, align 1, !tbaa !15
  %conv9 = zext i8 %7 to i32
  %or10 = or i32 %or7, %conv9
  ret i32 %or10
}

; Function Attrs: allocsize(1)
declare i8* @realloc(i8*, i64) #14

; Function Attrs: nounwind ssp uwtable
define internal i32 @outsize(%struct.Tigr* %bmp, i32 %bpp) #0 {
entry:
  %bmp.addr = alloca %struct.Tigr*, align 8
  %bpp.addr = alloca i32, align 4
  store %struct.Tigr* %bmp, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  store i32 %bpp, i32* %bpp.addr, align 4, !tbaa !4
  %0 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %w = getelementptr inbounds %struct.Tigr, %struct.Tigr* %0, i32 0, i32 0
  %1 = load i32, i32* %w, align 8, !tbaa !10
  %add = add nsw i32 %1, 1
  %2 = load %struct.Tigr*, %struct.Tigr** %bmp.addr, align 8, !tbaa !8
  %h = getelementptr inbounds %struct.Tigr, %struct.Tigr* %2, i32 0, i32 1
  %3 = load i32, i32* %h, align 4, !tbaa !12
  %mul = mul nsw i32 %add, %3
  %4 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %mul1 = mul nsw i32 %mul, %4
  ret i32 %mul1
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @unfilter(i32 %w, i32 %h, i32 %bpp, i8* %raw) #0 {
entry:
  %retval = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %bpp.addr = alloca i32, align 4
  %raw.addr = alloca i8*, align 8
  %len = alloca i32, align 4
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %prev = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  store i32 %bpp, i32* %bpp.addr, align 4, !tbaa !4
  store i8* %raw, i8** %raw.addr, align 8, !tbaa !8
  %0 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load i32, i32* %w.addr, align 4, !tbaa !4
  %2 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %mul = mul nsw i32 %1, %2
  store i32 %mul, i32* %len, align 4, !tbaa !4
  %3 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = bitcast i32* %y to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast i8** %prev to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #11
  %6 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  store i8* %6, i8** %prev, align 8, !tbaa !8
  store i32 0, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc127, %entry
  %7 = load i32, i32* %y, align 4, !tbaa !4
  %8 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end129

for.body:                                         ; preds = %for.cond
  %9 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %incdec.ptr = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr, i8** %raw.addr, align 8, !tbaa !8
  %10 = load i8, i8* %9, align 1, !tbaa !15
  %conv = zext i8 %10 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.epilog
    i32 1, label %sw.bb
    i32 2, label %sw.bb22
    i32 3, label %sw.bb53
    i32 4, label %sw.bb90
  ]

sw.bb:                                            ; preds = %for.body
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %sw.bb
  %11 = load i32, i32* %x, align 4, !tbaa !4
  %12 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %cmp2 = icmp slt i32 %11, %12
  br i1 %cmp2, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %13 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %14 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom = sext i32 %14 to i64
  %arrayidx = getelementptr inbounds i8, i8* %13, i64 %idxprom
  %15 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv5 = zext i8 %15 to i32
  %add = add nsw i32 %conv5, 0
  %conv6 = trunc i32 %add to i8
  store i8 %conv6, i8* %arrayidx, align 1, !tbaa !15
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %16 = load i32, i32* %x, align 4, !tbaa !4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %x, align 4, !tbaa !4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc19, %for.end
  %17 = load i32, i32* %x, align 4, !tbaa !4
  %18 = load i32, i32* %len, align 4, !tbaa !4
  %cmp8 = icmp slt i32 %17, %18
  br i1 %cmp8, label %for.body10, label %for.end21

for.body10:                                       ; preds = %for.cond7
  %19 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %20 = load i32, i32* %x, align 4, !tbaa !4
  %21 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %sub = sub nsw i32 %20, %21
  %idxprom11 = sext i32 %sub to i64
  %arrayidx12 = getelementptr inbounds i8, i8* %19, i64 %idxprom11
  %22 = load i8, i8* %arrayidx12, align 1, !tbaa !15
  %conv13 = zext i8 %22 to i32
  %23 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %24 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom14 = sext i32 %24 to i64
  %arrayidx15 = getelementptr inbounds i8, i8* %23, i64 %idxprom14
  %25 = load i8, i8* %arrayidx15, align 1, !tbaa !15
  %conv16 = zext i8 %25 to i32
  %add17 = add nsw i32 %conv16, %conv13
  %conv18 = trunc i32 %add17 to i8
  store i8 %conv18, i8* %arrayidx15, align 1, !tbaa !15
  br label %for.inc19

for.inc19:                                        ; preds = %for.body10
  %26 = load i32, i32* %x, align 4, !tbaa !4
  %inc20 = add nsw i32 %26, 1
  store i32 %inc20, i32* %x, align 4, !tbaa !4
  br label %for.cond7

for.end21:                                        ; preds = %for.cond7
  br label %sw.epilog

sw.bb22:                                          ; preds = %for.body
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc35, %sw.bb22
  %27 = load i32, i32* %x, align 4, !tbaa !4
  %28 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %cmp24 = icmp slt i32 %27, %28
  br i1 %cmp24, label %for.body26, label %for.end37

for.body26:                                       ; preds = %for.cond23
  %29 = load i8*, i8** %prev, align 8, !tbaa !8
  %30 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom27 = sext i32 %30 to i64
  %arrayidx28 = getelementptr inbounds i8, i8* %29, i64 %idxprom27
  %31 = load i8, i8* %arrayidx28, align 1, !tbaa !15
  %conv29 = zext i8 %31 to i32
  %32 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %33 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom30 = sext i32 %33 to i64
  %arrayidx31 = getelementptr inbounds i8, i8* %32, i64 %idxprom30
  %34 = load i8, i8* %arrayidx31, align 1, !tbaa !15
  %conv32 = zext i8 %34 to i32
  %add33 = add nsw i32 %conv32, %conv29
  %conv34 = trunc i32 %add33 to i8
  store i8 %conv34, i8* %arrayidx31, align 1, !tbaa !15
  br label %for.inc35

for.inc35:                                        ; preds = %for.body26
  %35 = load i32, i32* %x, align 4, !tbaa !4
  %inc36 = add nsw i32 %35, 1
  store i32 %inc36, i32* %x, align 4, !tbaa !4
  br label %for.cond23

for.end37:                                        ; preds = %for.cond23
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc50, %for.end37
  %36 = load i32, i32* %x, align 4, !tbaa !4
  %37 = load i32, i32* %len, align 4, !tbaa !4
  %cmp39 = icmp slt i32 %36, %37
  br i1 %cmp39, label %for.body41, label %for.end52

for.body41:                                       ; preds = %for.cond38
  %38 = load i8*, i8** %prev, align 8, !tbaa !8
  %39 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom42 = sext i32 %39 to i64
  %arrayidx43 = getelementptr inbounds i8, i8* %38, i64 %idxprom42
  %40 = load i8, i8* %arrayidx43, align 1, !tbaa !15
  %conv44 = zext i8 %40 to i32
  %41 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %42 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom45 = sext i32 %42 to i64
  %arrayidx46 = getelementptr inbounds i8, i8* %41, i64 %idxprom45
  %43 = load i8, i8* %arrayidx46, align 1, !tbaa !15
  %conv47 = zext i8 %43 to i32
  %add48 = add nsw i32 %conv47, %conv44
  %conv49 = trunc i32 %add48 to i8
  store i8 %conv49, i8* %arrayidx46, align 1, !tbaa !15
  br label %for.inc50

for.inc50:                                        ; preds = %for.body41
  %44 = load i32, i32* %x, align 4, !tbaa !4
  %inc51 = add nsw i32 %44, 1
  store i32 %inc51, i32* %x, align 4, !tbaa !4
  br label %for.cond38

for.end52:                                        ; preds = %for.cond38
  br label %sw.epilog

sw.bb53:                                          ; preds = %for.body
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond54

for.cond54:                                       ; preds = %for.inc66, %sw.bb53
  %45 = load i32, i32* %x, align 4, !tbaa !4
  %46 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %cmp55 = icmp slt i32 %45, %46
  br i1 %cmp55, label %for.body57, label %for.end68

for.body57:                                       ; preds = %for.cond54
  %47 = load i8*, i8** %prev, align 8, !tbaa !8
  %48 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom58 = sext i32 %48 to i64
  %arrayidx59 = getelementptr inbounds i8, i8* %47, i64 %idxprom58
  %49 = load i8, i8* %arrayidx59, align 1, !tbaa !15
  %conv60 = zext i8 %49 to i32
  %div = sdiv i32 %conv60, 2
  %50 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %51 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom61 = sext i32 %51 to i64
  %arrayidx62 = getelementptr inbounds i8, i8* %50, i64 %idxprom61
  %52 = load i8, i8* %arrayidx62, align 1, !tbaa !15
  %conv63 = zext i8 %52 to i32
  %add64 = add nsw i32 %conv63, %div
  %conv65 = trunc i32 %add64 to i8
  store i8 %conv65, i8* %arrayidx62, align 1, !tbaa !15
  br label %for.inc66

for.inc66:                                        ; preds = %for.body57
  %53 = load i32, i32* %x, align 4, !tbaa !4
  %inc67 = add nsw i32 %53, 1
  store i32 %inc67, i32* %x, align 4, !tbaa !4
  br label %for.cond54

for.end68:                                        ; preds = %for.cond54
  br label %for.cond69

for.cond69:                                       ; preds = %for.inc87, %for.end68
  %54 = load i32, i32* %x, align 4, !tbaa !4
  %55 = load i32, i32* %len, align 4, !tbaa !4
  %cmp70 = icmp slt i32 %54, %55
  br i1 %cmp70, label %for.body72, label %for.end89

for.body72:                                       ; preds = %for.cond69
  %56 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %57 = load i32, i32* %x, align 4, !tbaa !4
  %58 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %sub73 = sub nsw i32 %57, %58
  %idxprom74 = sext i32 %sub73 to i64
  %arrayidx75 = getelementptr inbounds i8, i8* %56, i64 %idxprom74
  %59 = load i8, i8* %arrayidx75, align 1, !tbaa !15
  %conv76 = zext i8 %59 to i32
  %60 = load i8*, i8** %prev, align 8, !tbaa !8
  %61 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom77 = sext i32 %61 to i64
  %arrayidx78 = getelementptr inbounds i8, i8* %60, i64 %idxprom77
  %62 = load i8, i8* %arrayidx78, align 1, !tbaa !15
  %conv79 = zext i8 %62 to i32
  %add80 = add nsw i32 %conv76, %conv79
  %div81 = sdiv i32 %add80, 2
  %63 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %64 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom82 = sext i32 %64 to i64
  %arrayidx83 = getelementptr inbounds i8, i8* %63, i64 %idxprom82
  %65 = load i8, i8* %arrayidx83, align 1, !tbaa !15
  %conv84 = zext i8 %65 to i32
  %add85 = add nsw i32 %conv84, %div81
  %conv86 = trunc i32 %add85 to i8
  store i8 %conv86, i8* %arrayidx83, align 1, !tbaa !15
  br label %for.inc87

for.inc87:                                        ; preds = %for.body72
  %66 = load i32, i32* %x, align 4, !tbaa !4
  %inc88 = add nsw i32 %66, 1
  store i32 %inc88, i32* %x, align 4, !tbaa !4
  br label %for.cond69

for.end89:                                        ; preds = %for.cond69
  br label %sw.epilog

sw.bb90:                                          ; preds = %for.body
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond91

for.cond91:                                       ; preds = %for.inc103, %sw.bb90
  %67 = load i32, i32* %x, align 4, !tbaa !4
  %68 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %cmp92 = icmp slt i32 %67, %68
  br i1 %cmp92, label %for.body94, label %for.end105

for.body94:                                       ; preds = %for.cond91
  %69 = load i8*, i8** %prev, align 8, !tbaa !8
  %70 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom95 = sext i32 %70 to i64
  %arrayidx96 = getelementptr inbounds i8, i8* %69, i64 %idxprom95
  %71 = load i8, i8* %arrayidx96, align 1, !tbaa !15
  %conv97 = zext i8 %71 to i32
  %72 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %73 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom98 = sext i32 %73 to i64
  %arrayidx99 = getelementptr inbounds i8, i8* %72, i64 %idxprom98
  %74 = load i8, i8* %arrayidx99, align 1, !tbaa !15
  %conv100 = zext i8 %74 to i32
  %add101 = add nsw i32 %conv100, %conv97
  %conv102 = trunc i32 %add101 to i8
  store i8 %conv102, i8* %arrayidx99, align 1, !tbaa !15
  br label %for.inc103

for.inc103:                                       ; preds = %for.body94
  %75 = load i32, i32* %x, align 4, !tbaa !4
  %inc104 = add nsw i32 %75, 1
  store i32 %inc104, i32* %x, align 4, !tbaa !4
  br label %for.cond91

for.end105:                                       ; preds = %for.cond91
  br label %for.cond106

for.cond106:                                      ; preds = %for.inc124, %for.end105
  %76 = load i32, i32* %x, align 4, !tbaa !4
  %77 = load i32, i32* %len, align 4, !tbaa !4
  %cmp107 = icmp slt i32 %76, %77
  br i1 %cmp107, label %for.body109, label %for.end126

for.body109:                                      ; preds = %for.cond106
  %78 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %79 = load i32, i32* %x, align 4, !tbaa !4
  %80 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %sub110 = sub nsw i32 %79, %80
  %idxprom111 = sext i32 %sub110 to i64
  %arrayidx112 = getelementptr inbounds i8, i8* %78, i64 %idxprom111
  %81 = load i8, i8* %arrayidx112, align 1, !tbaa !15
  %82 = load i8*, i8** %prev, align 8, !tbaa !8
  %83 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom113 = sext i32 %83 to i64
  %arrayidx114 = getelementptr inbounds i8, i8* %82, i64 %idxprom113
  %84 = load i8, i8* %arrayidx114, align 1, !tbaa !15
  %85 = load i8*, i8** %prev, align 8, !tbaa !8
  %86 = load i32, i32* %x, align 4, !tbaa !4
  %87 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %sub115 = sub nsw i32 %86, %87
  %idxprom116 = sext i32 %sub115 to i64
  %arrayidx117 = getelementptr inbounds i8, i8* %85, i64 %idxprom116
  %88 = load i8, i8* %arrayidx117, align 1, !tbaa !15
  %call = call zeroext i8 @paeth(i8 zeroext %81, i8 zeroext %84, i8 zeroext %88)
  %conv118 = zext i8 %call to i32
  %89 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %90 = load i32, i32* %x, align 4, !tbaa !4
  %idxprom119 = sext i32 %90 to i64
  %arrayidx120 = getelementptr inbounds i8, i8* %89, i64 %idxprom119
  %91 = load i8, i8* %arrayidx120, align 1, !tbaa !15
  %conv121 = zext i8 %91 to i32
  %add122 = add nsw i32 %conv121, %conv118
  %conv123 = trunc i32 %add122 to i8
  store i8 %conv123, i8* %arrayidx120, align 1, !tbaa !15
  br label %for.inc124

for.inc124:                                       ; preds = %for.body109
  %92 = load i32, i32* %x, align 4, !tbaa !4
  %inc125 = add nsw i32 %92, 1
  store i32 %inc125, i32* %x, align 4, !tbaa !4
  br label %for.cond106

for.end126:                                       ; preds = %for.cond106
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

sw.epilog:                                        ; preds = %for.end126, %for.end89, %for.end52, %for.end21, %for.body
  br label %for.inc127

for.inc127:                                       ; preds = %sw.epilog
  %93 = load i32, i32* %y, align 4, !tbaa !4
  %inc128 = add nsw i32 %93, 1
  store i32 %inc128, i32* %y, align 4, !tbaa !4
  %94 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  store i8* %94, i8** %prev, align 8, !tbaa !8
  %95 = load i32, i32* %len, align 4, !tbaa !4
  %96 = load i8*, i8** %raw.addr, align 8, !tbaa !8
  %idx.ext = sext i32 %95 to i64
  %add.ptr = getelementptr inbounds i8, i8* %96, i64 %idx.ext
  store i8* %add.ptr, i8** %raw.addr, align 8, !tbaa !8
  br label %for.cond

for.end129:                                       ; preds = %for.cond
  store i32 1, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end129, %sw.default
  %97 = bitcast i8** %prev to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %97) #11
  %98 = bitcast i32* %y to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %98) #11
  %99 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %99) #11
  %100 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %100) #11
  %101 = load i32, i32* %retval, align 4
  ret i32 %101
}

; Function Attrs: nounwind ssp uwtable
define internal void @depalette(i32 %w, i32 %h, i8* %src, %struct.TPixel* %dest, i8* %plte) #0 {
entry:
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %src.addr = alloca i8*, align 8
  %dest.addr = alloca %struct.TPixel*, align 8
  %plte.addr = alloca i8*, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %c = alloca i32, align 4
  %tmp = alloca %struct.TPixel, align 1
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  store i8* %src, i8** %src.addr, align 8, !tbaa !8
  store %struct.TPixel* %dest, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  store i8* %plte, i8** %plte.addr, align 8, !tbaa !8
  %0 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %y to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  store i32 0, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %3 = load i32, i32* %y, align 4, !tbaa !4
  %4 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  %5 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %incdec.ptr = getelementptr inbounds i8, i8* %5, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8, !tbaa !8
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %6 = load i32, i32* %x, align 4, !tbaa !4
  %7 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp2 = icmp slt i32 %6, %7
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %8 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i8, i8* %8, i64 0
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv = zext i8 %9 to i32
  store i32 %conv, i32* %c, align 4, !tbaa !4
  %10 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %incdec.ptr4 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %10, i32 1
  store %struct.TPixel* %incdec.ptr4, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %11 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %11) #11
  %12 = load i8*, i8** %plte.addr, align 8, !tbaa !8
  %13 = load i32, i32* %c, align 4, !tbaa !4
  %mul = mul nsw i32 %13, 3
  %add = add nsw i32 %mul, 0
  %idxprom = sext i32 %add to i64
  %arrayidx5 = getelementptr inbounds i8, i8* %12, i64 %idxprom
  %14 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %15 = load i8*, i8** %plte.addr, align 8, !tbaa !8
  %16 = load i32, i32* %c, align 4, !tbaa !4
  %mul6 = mul nsw i32 %16, 3
  %add7 = add nsw i32 %mul6, 1
  %idxprom8 = sext i32 %add7 to i64
  %arrayidx9 = getelementptr inbounds i8, i8* %15, i64 %idxprom8
  %17 = load i8, i8* %arrayidx9, align 1, !tbaa !15
  %18 = load i8*, i8** %plte.addr, align 8, !tbaa !8
  %19 = load i32, i32* %c, align 4, !tbaa !4
  %mul10 = mul nsw i32 %19, 3
  %add11 = add nsw i32 %mul10, 2
  %idxprom12 = sext i32 %add11 to i64
  %arrayidx13 = getelementptr inbounds i8, i8* %18, i64 %idxprom12
  %20 = load i8, i8* %arrayidx13, align 1, !tbaa !15
  %21 = load i32, i32* %c, align 4, !tbaa !4
  %tobool = icmp ne i32 %21, 0
  %22 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 255, i32 0
  %conv14 = trunc i32 %cond to i8
  %call = call i32 @tigrRGBA(i8 zeroext %14, i8 zeroext %17, i8 zeroext %20, i8 zeroext %conv14)
  %23 = bitcast %struct.TPixel* %tmp to i32*
  store i32 %call, i32* %23, align 1
  %24 = bitcast %struct.TPixel* %10 to i8*
  %25 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %24, i8* align 1 %25, i64 4, i1 false), !tbaa.struct !14
  %26 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %27 = load i32, i32* %x, align 4, !tbaa !4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %x, align 4, !tbaa !4
  %28 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %incdec.ptr15 = getelementptr inbounds i8, i8* %28, i32 1
  store i8* %incdec.ptr15, i8** %src.addr, align 8, !tbaa !8
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %29 = load i32, i32* %y, align 4, !tbaa !4
  %inc17 = add nsw i32 %29, 1
  store i32 %inc17, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  %30 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #11
  %31 = bitcast i32* %y to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #11
  %32 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @convert(i32 %bpp, i32 %w, i32 %h, i8* %src, %struct.TPixel* %dest) #0 {
entry:
  %bpp.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %src.addr = alloca i8*, align 8
  %dest.addr = alloca %struct.TPixel*, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %tmp = alloca %struct.TPixel, align 1
  %tmp9 = alloca %struct.TPixel, align 1
  %tmp17 = alloca %struct.TPixel, align 1
  %tmp24 = alloca %struct.TPixel, align 1
  store i32 %bpp, i32* %bpp.addr, align 4, !tbaa !4
  store i32 %w, i32* %w.addr, align 4, !tbaa !4
  store i32 %h, i32* %h.addr, align 4, !tbaa !4
  store i8* %src, i8** %src.addr, align 8, !tbaa !8
  store %struct.TPixel* %dest, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %0 = bitcast i32* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %y to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  store i32 0, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc30, %entry
  %2 = load i32, i32* %y, align 4, !tbaa !4
  %3 = load i32, i32* %h.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end32

for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8, !tbaa !8
  store i32 0, i32* %x, align 4, !tbaa !4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %5 = load i32, i32* %x, align 4, !tbaa !4
  %6 = load i32, i32* %w.addr, align 4, !tbaa !4
  %cmp2 = icmp slt i32 %5, %6
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  switch i32 %7, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb7
    i32 3, label %sw.bb15
    i32 4, label %sw.bb22
  ]

sw.bb:                                            ; preds = %for.body3
  %8 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %incdec.ptr4 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %8, i32 1
  store %struct.TPixel* %incdec.ptr4, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %9 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #11
  %10 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i8, i8* %10, i64 0
  %11 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %12 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx5 = getelementptr inbounds i8, i8* %12, i64 0
  %13 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %14 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx6 = getelementptr inbounds i8, i8* %14, i64 0
  %15 = load i8, i8* %arrayidx6, align 1, !tbaa !15
  %call = call i32 @tigrRGB(i8 zeroext %11, i8 zeroext %13, i8 zeroext %15)
  %16 = bitcast %struct.TPixel* %tmp to i32*
  store i32 %call, i32* %16, align 1
  %17 = bitcast %struct.TPixel* %8 to i8*
  %18 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %17, i8* align 1 %18, i64 4, i1 false), !tbaa.struct !14
  %19 = bitcast %struct.TPixel* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %19) #11
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body3
  %20 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %incdec.ptr8 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %20, i32 1
  store %struct.TPixel* %incdec.ptr8, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %21 = bitcast %struct.TPixel* %tmp9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %21) #11
  %22 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx10 = getelementptr inbounds i8, i8* %22, i64 0
  %23 = load i8, i8* %arrayidx10, align 1, !tbaa !15
  %24 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx11 = getelementptr inbounds i8, i8* %24, i64 0
  %25 = load i8, i8* %arrayidx11, align 1, !tbaa !15
  %26 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx12 = getelementptr inbounds i8, i8* %26, i64 0
  %27 = load i8, i8* %arrayidx12, align 1, !tbaa !15
  %28 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx13 = getelementptr inbounds i8, i8* %28, i64 1
  %29 = load i8, i8* %arrayidx13, align 1, !tbaa !15
  %call14 = call i32 @tigrRGBA(i8 zeroext %23, i8 zeroext %25, i8 zeroext %27, i8 zeroext %29)
  %30 = bitcast %struct.TPixel* %tmp9 to i32*
  store i32 %call14, i32* %30, align 1
  %31 = bitcast %struct.TPixel* %20 to i8*
  %32 = bitcast %struct.TPixel* %tmp9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %31, i8* align 1 %32, i64 4, i1 false), !tbaa.struct !14
  %33 = bitcast %struct.TPixel* %tmp9 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #11
  br label %sw.epilog

sw.bb15:                                          ; preds = %for.body3
  %34 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %incdec.ptr16 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %34, i32 1
  store %struct.TPixel* %incdec.ptr16, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %35 = bitcast %struct.TPixel* %tmp17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %35) #11
  %36 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx18 = getelementptr inbounds i8, i8* %36, i64 0
  %37 = load i8, i8* %arrayidx18, align 1, !tbaa !15
  %38 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx19 = getelementptr inbounds i8, i8* %38, i64 1
  %39 = load i8, i8* %arrayidx19, align 1, !tbaa !15
  %40 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx20 = getelementptr inbounds i8, i8* %40, i64 2
  %41 = load i8, i8* %arrayidx20, align 1, !tbaa !15
  %call21 = call i32 @tigrRGB(i8 zeroext %37, i8 zeroext %39, i8 zeroext %41)
  %42 = bitcast %struct.TPixel* %tmp17 to i32*
  store i32 %call21, i32* %42, align 1
  %43 = bitcast %struct.TPixel* %34 to i8*
  %44 = bitcast %struct.TPixel* %tmp17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %43, i8* align 1 %44, i64 4, i1 false), !tbaa.struct !14
  %45 = bitcast %struct.TPixel* %tmp17 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %45) #11
  br label %sw.epilog

sw.bb22:                                          ; preds = %for.body3
  %46 = load %struct.TPixel*, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %incdec.ptr23 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %46, i32 1
  store %struct.TPixel* %incdec.ptr23, %struct.TPixel** %dest.addr, align 8, !tbaa !8
  %47 = bitcast %struct.TPixel* %tmp24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %47) #11
  %48 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx25 = getelementptr inbounds i8, i8* %48, i64 0
  %49 = load i8, i8* %arrayidx25, align 1, !tbaa !15
  %50 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx26 = getelementptr inbounds i8, i8* %50, i64 1
  %51 = load i8, i8* %arrayidx26, align 1, !tbaa !15
  %52 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx27 = getelementptr inbounds i8, i8* %52, i64 2
  %53 = load i8, i8* %arrayidx27, align 1, !tbaa !15
  %54 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %arrayidx28 = getelementptr inbounds i8, i8* %54, i64 3
  %55 = load i8, i8* %arrayidx28, align 1, !tbaa !15
  %call29 = call i32 @tigrRGBA(i8 zeroext %49, i8 zeroext %51, i8 zeroext %53, i8 zeroext %55)
  %56 = bitcast %struct.TPixel* %tmp24 to i32*
  store i32 %call29, i32* %56, align 1
  %57 = bitcast %struct.TPixel* %46 to i8*
  %58 = bitcast %struct.TPixel* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 1 %58, i64 4, i1 false), !tbaa.struct !14
  %59 = bitcast %struct.TPixel* %tmp24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %59) #11
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body3, %sw.bb22, %sw.bb15, %sw.bb7, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %60 = load i32, i32* %x, align 4, !tbaa !4
  %inc = add nsw i32 %60, 1
  store i32 %inc, i32* %x, align 4, !tbaa !4
  %61 = load i32, i32* %bpp.addr, align 4, !tbaa !4
  %62 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %idx.ext = sext i32 %61 to i64
  %add.ptr = getelementptr inbounds i8, i8* %62, i64 %idx.ext
  store i8* %add.ptr, i8** %src.addr, align 8, !tbaa !8
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc30

for.inc30:                                        ; preds = %for.end
  %63 = load i32, i32* %y, align 4, !tbaa !4
  %inc31 = add nsw i32 %63, 1
  store i32 %inc31, i32* %y, align 4, !tbaa !4
  br label %for.cond

for.end32:                                        ; preds = %for.cond
  %64 = bitcast i32* %y to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %64) #11
  %65 = bitcast i32* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %65) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i8 @paeth(i8 zeroext %a, i8 zeroext %b, i8 zeroext %c) #0 {
entry:
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %c.addr = alloca i8, align 1
  %p = alloca i32, align 4
  %pa = alloca i32, align 4
  %pb = alloca i32, align 4
  %pc = alloca i32, align 4
  store i8 %a, i8* %a.addr, align 1, !tbaa !15
  store i8 %b, i8* %b.addr, align 1, !tbaa !15
  store i8 %c, i8* %c.addr, align 1, !tbaa !15
  %0 = bitcast i32* %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load i8, i8* %a.addr, align 1, !tbaa !15
  %conv = zext i8 %1 to i32
  %2 = load i8, i8* %b.addr, align 1, !tbaa !15
  %conv1 = zext i8 %2 to i32
  %add = add nsw i32 %conv, %conv1
  %3 = load i8, i8* %c.addr, align 1, !tbaa !15
  %conv2 = zext i8 %3 to i32
  %sub = sub nsw i32 %add, %conv2
  store i32 %sub, i32* %p, align 4, !tbaa !4
  %4 = bitcast i32* %pa to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = load i32, i32* %p, align 4, !tbaa !4
  %6 = load i8, i8* %a.addr, align 1, !tbaa !15
  %conv3 = zext i8 %6 to i32
  %sub4 = sub nsw i32 %5, %conv3
  %call = call i32 @abs(i32 %sub4) #12
  store i32 %call, i32* %pa, align 4, !tbaa !4
  %7 = bitcast i32* %pb to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #11
  %8 = load i32, i32* %p, align 4, !tbaa !4
  %9 = load i8, i8* %b.addr, align 1, !tbaa !15
  %conv5 = zext i8 %9 to i32
  %sub6 = sub nsw i32 %8, %conv5
  %call7 = call i32 @abs(i32 %sub6) #12
  store i32 %call7, i32* %pb, align 4, !tbaa !4
  %10 = bitcast i32* %pc to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %10) #11
  %11 = load i32, i32* %p, align 4, !tbaa !4
  %12 = load i8, i8* %c.addr, align 1, !tbaa !15
  %conv8 = zext i8 %12 to i32
  %sub9 = sub nsw i32 %11, %conv8
  %call10 = call i32 @abs(i32 %sub9) #12
  store i32 %call10, i32* %pc, align 4, !tbaa !4
  %13 = load i32, i32* %pa, align 4, !tbaa !4
  %14 = load i32, i32* %pb, align 4, !tbaa !4
  %cmp = icmp sle i32 %13, %14
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %15 = load i32, i32* %pa, align 4, !tbaa !4
  %16 = load i32, i32* %pc, align 4, !tbaa !4
  %cmp12 = icmp sle i32 %15, %16
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %17 = load i8, i8* %a.addr, align 1, !tbaa !15
  %conv14 = zext i8 %17 to i32
  br label %cond.end21

cond.false:                                       ; preds = %land.lhs.true, %entry
  %18 = load i32, i32* %pb, align 4, !tbaa !4
  %19 = load i32, i32* %pc, align 4, !tbaa !4
  %cmp15 = icmp sle i32 %18, %19
  br i1 %cmp15, label %cond.true17, label %cond.false19

cond.true17:                                      ; preds = %cond.false
  %20 = load i8, i8* %b.addr, align 1, !tbaa !15
  %conv18 = zext i8 %20 to i32
  br label %cond.end

cond.false19:                                     ; preds = %cond.false
  %21 = load i8, i8* %c.addr, align 1, !tbaa !15
  %conv20 = zext i8 %21 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false19, %cond.true17
  %cond = phi i32 [ %conv18, %cond.true17 ], [ %conv20, %cond.false19 ]
  br label %cond.end21

cond.end21:                                       ; preds = %cond.end, %cond.true
  %cond22 = phi i32 [ %conv14, %cond.true ], [ %cond, %cond.end ]
  %conv23 = trunc i32 %cond22 to i8
  %22 = bitcast i32* %pc to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %22) #11
  %23 = bitcast i32* %pb to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #11
  %24 = bitcast i32* %pa to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %24) #11
  %25 = bitcast i32* %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %25) #11
  ret i8 %conv23
}

; Function Attrs: inlinehint nounwind ssp uwtable
define internal i32 @tigrRGB(i8 zeroext %r, i8 zeroext %g, i8 zeroext %b) #7 {
entry:
  %retval = alloca %struct.TPixel, align 1
  %r.addr = alloca i8, align 1
  %g.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  store i8 %r, i8* %r.addr, align 1, !tbaa !15
  store i8 %g, i8* %g.addr, align 1, !tbaa !15
  store i8 %b, i8* %b.addr, align 1, !tbaa !15
  %0 = load i8, i8* %r.addr, align 1, !tbaa !15
  %r1 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 2
  store i8 %0, i8* %r1, align 1, !tbaa !18
  %1 = load i8, i8* %g.addr, align 1, !tbaa !15
  %g2 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 1
  store i8 %1, i8* %g2, align 1, !tbaa !19
  %2 = load i8, i8* %b.addr, align 1, !tbaa !15
  %b3 = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 0
  store i8 %2, i8* %b3, align 1, !tbaa !20
  %a = getelementptr inbounds %struct.TPixel, %struct.TPixel* %retval, i32 0, i32 3
  store i8 -1, i8* %a, align 1, !tbaa !16
  %3 = bitcast %struct.TPixel* %retval to i32*
  %4 = load i32, i32* %3, align 1
  ret i32 %4
}

declare i32 @fputc(i32, %struct.__sFILE*) #5

declare i64 @"\01_fwrite"(i8*, i64, i64, %struct.__sFILE*) #5

; Function Attrs: nounwind ssp uwtable
define internal void @encodeByte(%struct.Save* %s, i8 zeroext %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i8, align 1
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i8 %v, i8* %v.addr, align 1, !tbaa !15
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %1 = load i8, i8* %v.addr, align 1, !tbaa !15
  %conv = zext i8 %1 to i32
  call void @updateAdler(%struct.Save* %0, i32 %conv)
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %prev = getelementptr inbounds %struct.Save, %struct.Save* %2, i32 0, i32 3
  %3 = load i32, i32* %prev, align 4, !tbaa !33
  %4 = load i8, i8* %v.addr, align 1, !tbaa !15
  %conv1 = zext i8 %4 to i32
  %cmp = icmp eq i32 %3, %conv1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen = getelementptr inbounds %struct.Save, %struct.Save* %5, i32 0, i32 4
  %6 = load i32, i32* %runlen, align 8, !tbaa !34
  %cmp3 = icmp ult i32 %6, 115
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen5 = getelementptr inbounds %struct.Save, %struct.Save* %7, i32 0, i32 4
  %8 = load i32, i32* %runlen5, align 8, !tbaa !34
  %inc = add i32 %8, 1
  store i32 %inc, i32* %runlen5, align 8, !tbaa !34
  br label %if.end11

if.else:                                          ; preds = %land.lhs.true, %entry
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen6 = getelementptr inbounds %struct.Save, %struct.Save* %9, i32 0, i32 4
  %10 = load i32, i32* %runlen6, align 8, !tbaa !34
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.else
  %11 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @endrun(%struct.Save* %11)
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.else
  %12 = load i8, i8* %v.addr, align 1, !tbaa !15
  %conv8 = zext i8 %12 to i32
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %prev9 = getelementptr inbounds %struct.Save, %struct.Save* %13, i32 0, i32 3
  store i32 %conv8, i32* %prev9, align 4, !tbaa !33
  %14 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen10 = getelementptr inbounds %struct.Save, %struct.Save* %14, i32 0, i32 4
  store i32 1, i32* %runlen10, align 8, !tbaa !34
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @endrun(%struct.Save* %s) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen = getelementptr inbounds %struct.Save, %struct.Save* %0, i32 0, i32 4
  %1 = load i32, i32* %runlen, align 8, !tbaa !34
  %dec = add i32 %1, -1
  store i32 %dec, i32* %runlen, align 8, !tbaa !34
  %2 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %3 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %prev = getelementptr inbounds %struct.Save, %struct.Save* %3, i32 0, i32 3
  %4 = load i32, i32* %prev, align 4, !tbaa !33
  call void @literal(%struct.Save* %2, i32 %4)
  %5 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen1 = getelementptr inbounds %struct.Save, %struct.Save* %5, i32 0, i32 4
  %6 = load i32, i32* %runlen1, align 8, !tbaa !34
  %cmp = icmp uge i32 %6, 67
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %8 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen2 = getelementptr inbounds %struct.Save, %struct.Save* %8, i32 0, i32 4
  %9 = load i32, i32* %runlen2, align 8, !tbaa !34
  %sub = sub i32 %9, 67
  call void @encodelen(%struct.Save* %7, i32 277, i32 4, i32 %sub)
  br label %if.end33

if.else:                                          ; preds = %entry
  %10 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen3 = getelementptr inbounds %struct.Save, %struct.Save* %10, i32 0, i32 4
  %11 = load i32, i32* %runlen3, align 8, !tbaa !34
  %cmp4 = icmp uge i32 %11, 35
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %13 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen6 = getelementptr inbounds %struct.Save, %struct.Save* %13, i32 0, i32 4
  %14 = load i32, i32* %runlen6, align 8, !tbaa !34
  %sub7 = sub i32 %14, 35
  call void @encodelen(%struct.Save* %12, i32 273, i32 3, i32 %sub7)
  br label %if.end32

if.else8:                                         ; preds = %if.else
  %15 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen9 = getelementptr inbounds %struct.Save, %struct.Save* %15, i32 0, i32 4
  %16 = load i32, i32* %runlen9, align 8, !tbaa !34
  %cmp10 = icmp uge i32 %16, 19
  br i1 %cmp10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.else8
  %17 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %18 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen12 = getelementptr inbounds %struct.Save, %struct.Save* %18, i32 0, i32 4
  %19 = load i32, i32* %runlen12, align 8, !tbaa !34
  %sub13 = sub i32 %19, 19
  call void @encodelen(%struct.Save* %17, i32 269, i32 2, i32 %sub13)
  br label %if.end31

if.else14:                                        ; preds = %if.else8
  %20 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen15 = getelementptr inbounds %struct.Save, %struct.Save* %20, i32 0, i32 4
  %21 = load i32, i32* %runlen15, align 8, !tbaa !34
  %cmp16 = icmp uge i32 %21, 11
  br i1 %cmp16, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.else14
  %22 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %23 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen18 = getelementptr inbounds %struct.Save, %struct.Save* %23, i32 0, i32 4
  %24 = load i32, i32* %runlen18, align 8, !tbaa !34
  %sub19 = sub i32 %24, 11
  call void @encodelen(%struct.Save* %22, i32 265, i32 1, i32 %sub19)
  br label %if.end30

if.else20:                                        ; preds = %if.else14
  %25 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen21 = getelementptr inbounds %struct.Save, %struct.Save* %25, i32 0, i32 4
  %26 = load i32, i32* %runlen21, align 8, !tbaa !34
  %cmp22 = icmp uge i32 %26, 3
  br i1 %cmp22, label %if.then23, label %if.else26

if.then23:                                        ; preds = %if.else20
  %27 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %28 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen24 = getelementptr inbounds %struct.Save, %struct.Save* %28, i32 0, i32 4
  %29 = load i32, i32* %runlen24, align 8, !tbaa !34
  %sub25 = sub i32 %29, 3
  call void @encodelen(%struct.Save* %27, i32 257, i32 0, i32 %sub25)
  br label %if.end

if.else26:                                        ; preds = %if.else20
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else26
  %30 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %runlen27 = getelementptr inbounds %struct.Save, %struct.Save* %30, i32 0, i32 4
  %31 = load i32, i32* %runlen27, align 8, !tbaa !34
  %dec28 = add i32 %31, -1
  store i32 %dec28, i32* %runlen27, align 8, !tbaa !34
  %tobool = icmp ne i32 %31, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %32 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %33 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %prev29 = getelementptr inbounds %struct.Save, %struct.Save* %33, i32 0, i32 3
  %34 = load i32, i32* %prev29, align 4, !tbaa !33
  call void @literal(%struct.Save* %32, i32 %34)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end

if.end:                                           ; preds = %while.end, %if.then23
  br label %if.end30

if.end30:                                         ; preds = %if.end, %if.then17
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then11
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then5
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @literal(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %v, i32* %v.addr, align 4, !tbaa !4
  %0 = load i32, i32* %v.addr, align 4, !tbaa !4
  %cmp = icmp ult i32 %0, 144
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %2 = load i32, i32* %v.addr, align 4, !tbaa !4
  %add = add i32 48, %2
  %sub = sub i32 %add, 0
  call void @putbitsr(%struct.Save* %1, i32 %sub, i32 8)
  br label %if.end14

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %v.addr, align 4, !tbaa !4
  %cmp1 = icmp ult i32 %3, 256
  br i1 %cmp1, label %if.then2, label %if.else5

if.then2:                                         ; preds = %if.else
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %5 = load i32, i32* %v.addr, align 4, !tbaa !4
  %add3 = add i32 400, %5
  %sub4 = sub i32 %add3, 144
  call void @putbitsr(%struct.Save* %4, i32 %sub4, i32 9)
  br label %if.end13

if.else5:                                         ; preds = %if.else
  %6 = load i32, i32* %v.addr, align 4, !tbaa !4
  %cmp6 = icmp ult i32 %6, 280
  br i1 %cmp6, label %if.then7, label %if.else10

if.then7:                                         ; preds = %if.else5
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %8 = load i32, i32* %v.addr, align 4, !tbaa !4
  %add8 = add i32 0, %8
  %sub9 = sub i32 %add8, 256
  call void @putbitsr(%struct.Save* %7, i32 %sub9, i32 7)
  br label %if.end

if.else10:                                        ; preds = %if.else5
  %9 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %10 = load i32, i32* %v.addr, align 4, !tbaa !4
  %add11 = add i32 192, %10
  %sub12 = sub i32 %add11, 280
  call void @putbitsr(%struct.Save* %9, i32 %sub12, i32 8)
  br label %if.end

if.end:                                           ; preds = %if.else10, %if.then7
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then2
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @updateAdler(%struct.Save* %s, i32 %v) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %v.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %v, i32* %v.addr, align 4, !tbaa !4
  %0 = bitcast i32* %s1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %adler = getelementptr inbounds %struct.Save, %struct.Save* %1, i32 0, i32 1
  %2 = load i32, i32* %adler, align 4, !tbaa !32
  %and = and i32 %2, 65535
  store i32 %and, i32* %s1, align 4, !tbaa !4
  %3 = bitcast i32* %s2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %adler1 = getelementptr inbounds %struct.Save, %struct.Save* %4, i32 0, i32 1
  %5 = load i32, i32* %adler1, align 4, !tbaa !32
  %shr = lshr i32 %5, 16
  %and2 = and i32 %shr, 65535
  store i32 %and2, i32* %s2, align 4, !tbaa !4
  %6 = load i32, i32* %s1, align 4, !tbaa !4
  %7 = load i32, i32* %v.addr, align 4, !tbaa !4
  %add = add i32 %6, %7
  %rem = urem i32 %add, 65521
  store i32 %rem, i32* %s1, align 4, !tbaa !4
  %8 = load i32, i32* %s2, align 4, !tbaa !4
  %9 = load i32, i32* %s1, align 4, !tbaa !4
  %add3 = add i32 %8, %9
  %rem4 = urem i32 %add3, 65521
  store i32 %rem4, i32* %s2, align 4, !tbaa !4
  %10 = load i32, i32* %s2, align 4, !tbaa !4
  %shl = shl i32 %10, 16
  %11 = load i32, i32* %s1, align 4, !tbaa !4
  %add5 = add i32 %shl, %11
  %12 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %adler6 = getelementptr inbounds %struct.Save, %struct.Save* %12, i32 0, i32 1
  store i32 %add5, i32* %adler6, align 4, !tbaa !32
  %13 = bitcast i32* %s2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #11
  %14 = bitcast i32* %s1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @encodelen(%struct.Save* %s, i32 %code, i32 %bits, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.Save*, align 8
  %code.addr = alloca i32, align 4
  %bits.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  store %struct.Save* %s, %struct.Save** %s.addr, align 8, !tbaa !8
  store i32 %code, i32* %code.addr, align 4, !tbaa !4
  store i32 %bits, i32* %bits.addr, align 4, !tbaa !4
  store i32 %len, i32* %len.addr, align 4, !tbaa !4
  %0 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %1 = load i32, i32* %code.addr, align 4, !tbaa !4
  %2 = load i32, i32* %len.addr, align 4, !tbaa !4
  %3 = load i32, i32* %bits.addr, align 4, !tbaa !4
  %shr = lshr i32 %2, %3
  %add = add i32 %1, %shr
  call void @literal(%struct.Save* %0, i32 %add)
  %4 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  %5 = load i32, i32* %len.addr, align 4, !tbaa !4
  %6 = load i32, i32* %bits.addr, align 4, !tbaa !4
  call void @putbits(%struct.Save* %4, i32 %5, i32 %6)
  %7 = load %struct.Save*, %struct.Save** %s.addr, align 8, !tbaa !8
  call void @putbits(%struct.Save* %7, i32 0, i32 5)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @copy(%struct.State* %s, i8* %src, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %src.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  %dest = alloca i8*, align 8
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  store i8* %src, i8** %src.addr, align 8, !tbaa !8
  store i32 %len, i32* %len.addr, align 4, !tbaa !4
  %0 = bitcast i8** %dest to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %2 = load i32, i32* %len.addr, align 4, !tbaa !4
  %call = call i8* @emit(%struct.State* %1, i32 %2)
  store i8* %call, i8** %dest, align 8, !tbaa !8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load i32, i32* %len.addr, align 4, !tbaa !4
  %dec = add nsw i32 %3, -1
  store i32 %dec, i32* %len.addr, align 4, !tbaa !4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8*, i8** %src.addr, align 8, !tbaa !8
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8, !tbaa !8
  %5 = load i8, i8* %4, align 1, !tbaa !15
  %6 = load i8*, i8** %dest, align 8, !tbaa !8
  %incdec.ptr1 = getelementptr inbounds i8, i8* %6, i32 1
  store i8* %incdec.ptr1, i8** %dest, align 8, !tbaa !8
  store i8 %5, i8* %6, align 1, !tbaa !15
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = bitcast i8** %dest to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @emit(%struct.State* %s, i32 %len) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %len.addr = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  store i32 %len, i32* %len.addr, align 4, !tbaa !4
  %0 = load i32, i32* %len.addr, align 4, !tbaa !4
  %1 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %out = getelementptr inbounds %struct.State, %struct.State* %1, i32 0, i32 4
  %2 = load i8*, i8** %out, align 8, !tbaa !45
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  store i8* %add.ptr, i8** %out, align 8, !tbaa !45
  %3 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %out1 = getelementptr inbounds %struct.State, %struct.State* %3, i32 0, i32 4
  %4 = load i8*, i8** %out1, align 8, !tbaa !45
  %5 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %outend = getelementptr inbounds %struct.State, %struct.State* %5, i32 0, i32 5
  %6 = load i8*, i8** %outend, align 8, !tbaa !46
  %cmp = icmp ule i8* %4, %6
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %7, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #20
  unreachable

if.end:                                           ; preds = %entry
  %8 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %out2 = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 4
  %9 = load i8*, i8** %out2, align 8, !tbaa !45
  %10 = load i32, i32* %len.addr, align 4, !tbaa !4
  %idx.ext3 = sext i32 %10 to i64
  %idx.neg = sub i64 0, %idx.ext3
  %add.ptr4 = getelementptr inbounds i8, i8* %9, i64 %idx.neg
  ret i8* %add.ptr4
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @build(%struct.State* %s, i32* %tree, i8* %lens, i32 %symcount) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %tree.addr = alloca i32*, align 8
  %lens.addr = alloca i8*, align 8
  %symcount.addr = alloca i32, align 4
  %n = alloca i32, align 4
  %codes = alloca [16 x i32], align 16
  %first = alloca [16 x i32], align 16
  %counts = alloca [16 x i32], align 16
  %len = alloca i32, align 4
  %code = alloca i32, align 4
  %slot = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  store i32* %tree, i32** %tree.addr, align 8, !tbaa !8
  store i8* %lens, i8** %lens.addr, align 8, !tbaa !8
  store i32 %symcount, i32* %symcount.addr, align 4, !tbaa !4
  %0 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast [16 x i32]* %codes to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %1) #11
  %2 = bitcast [16 x i32]* %first to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %2) #11
  %3 = bitcast [16 x i32]* %counts to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %3) #11
  %4 = bitcast [16 x i32]* %counts to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %4, i8 0, i64 64, i1 false)
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %n, align 4, !tbaa !4
  %6 = load i32, i32* %symcount.addr, align 4, !tbaa !4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i8*, i8** %lens.addr, align 8, !tbaa !8
  %8 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds i8, i8* %7, i64 %idxprom
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %idxprom1 = zext i8 %9 to i64
  %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 %idxprom1
  %10 = load i32, i32* %arrayidx2, align 4, !tbaa !4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %arrayidx2, align 4, !tbaa !4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %n, align 4, !tbaa !4
  %inc3 = add nsw i32 %11, 1
  store i32 %inc3, i32* %n, align 4, !tbaa !4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arrayidx4 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 0
  store i32 0, i32* %arrayidx4, align 16, !tbaa !4
  %arrayidx5 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 0
  store i32 0, i32* %arrayidx5, align 16, !tbaa !4
  %arrayidx6 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 0
  store i32 0, i32* %arrayidx6, align 16, !tbaa !4
  store i32 1, i32* %n, align 4, !tbaa !4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc26, %for.end
  %12 = load i32, i32* %n, align 4, !tbaa !4
  %cmp8 = icmp sle i32 %12, 15
  br i1 %cmp8, label %for.body9, label %for.end28

for.body9:                                        ; preds = %for.cond7
  %13 = load i32, i32* %n, align 4, !tbaa !4
  %sub = sub nsw i32 %13, 1
  %idxprom10 = sext i32 %sub to i64
  %arrayidx11 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 %idxprom10
  %14 = load i32, i32* %arrayidx11, align 4, !tbaa !4
  %15 = load i32, i32* %n, align 4, !tbaa !4
  %sub12 = sub nsw i32 %15, 1
  %idxprom13 = sext i32 %sub12 to i64
  %arrayidx14 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 %idxprom13
  %16 = load i32, i32* %arrayidx14, align 4, !tbaa !4
  %add = add nsw i32 %14, %16
  %shl = shl i32 %add, 1
  %17 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom15 = sext i32 %17 to i64
  %arrayidx16 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 %idxprom15
  store i32 %shl, i32* %arrayidx16, align 4, !tbaa !4
  %18 = load i32, i32* %n, align 4, !tbaa !4
  %sub17 = sub nsw i32 %18, 1
  %idxprom18 = sext i32 %sub17 to i64
  %arrayidx19 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 %idxprom18
  %19 = load i32, i32* %arrayidx19, align 4, !tbaa !4
  %20 = load i32, i32* %n, align 4, !tbaa !4
  %sub20 = sub nsw i32 %20, 1
  %idxprom21 = sext i32 %sub20 to i64
  %arrayidx22 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 %idxprom21
  %21 = load i32, i32* %arrayidx22, align 4, !tbaa !4
  %add23 = add nsw i32 %19, %21
  %22 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom24 = sext i32 %22 to i64
  %arrayidx25 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 %idxprom24
  store i32 %add23, i32* %arrayidx25, align 4, !tbaa !4
  br label %for.inc26

for.inc26:                                        ; preds = %for.body9
  %23 = load i32, i32* %n, align 4, !tbaa !4
  %inc27 = add nsw i32 %23, 1
  store i32 %inc27, i32* %n, align 4, !tbaa !4
  br label %for.cond7

for.end28:                                        ; preds = %for.cond7
  %arrayidx29 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 15
  %24 = load i32, i32* %arrayidx29, align 4, !tbaa !4
  %arrayidx30 = getelementptr inbounds [16 x i32], [16 x i32]* %counts, i64 0, i64 15
  %25 = load i32, i32* %arrayidx30, align 4, !tbaa !4
  %add31 = add nsw i32 %24, %25
  %26 = load i32, i32* %symcount.addr, align 4, !tbaa !4
  %cmp32 = icmp sle i32 %add31, %26
  br i1 %cmp32, label %if.end, label %if.then

if.then:                                          ; preds = %for.end28
  %27 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %27, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #20
  unreachable

if.end:                                           ; preds = %for.end28
  store i32 0, i32* %n, align 4, !tbaa !4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc54, %if.end
  %28 = load i32, i32* %n, align 4, !tbaa !4
  %29 = load i32, i32* %symcount.addr, align 4, !tbaa !4
  %cmp34 = icmp slt i32 %28, %29
  br i1 %cmp34, label %for.body35, label %for.end56

for.body35:                                       ; preds = %for.cond33
  %30 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %30) #11
  %31 = load i8*, i8** %lens.addr, align 8, !tbaa !8
  %32 = load i32, i32* %n, align 4, !tbaa !4
  %idxprom36 = sext i32 %32 to i64
  %arrayidx37 = getelementptr inbounds i8, i8* %31, i64 %idxprom36
  %33 = load i8, i8* %arrayidx37, align 1, !tbaa !15
  %conv = zext i8 %33 to i32
  store i32 %conv, i32* %len, align 4, !tbaa !4
  %34 = load i32, i32* %len, align 4, !tbaa !4
  %cmp38 = icmp ne i32 %34, 0
  br i1 %cmp38, label %if.then40, label %if.end53

if.then40:                                        ; preds = %for.body35
  %35 = bitcast i32* %code to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %35) #11
  %36 = load i32, i32* %len, align 4, !tbaa !4
  %idxprom41 = sext i32 %36 to i64
  %arrayidx42 = getelementptr inbounds [16 x i32], [16 x i32]* %codes, i64 0, i64 %idxprom41
  %37 = load i32, i32* %arrayidx42, align 4, !tbaa !4
  %inc43 = add nsw i32 %37, 1
  store i32 %inc43, i32* %arrayidx42, align 4, !tbaa !4
  store i32 %37, i32* %code, align 4, !tbaa !4
  %38 = bitcast i32* %slot to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %38) #11
  %39 = load i32, i32* %len, align 4, !tbaa !4
  %idxprom44 = sext i32 %39 to i64
  %arrayidx45 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 %idxprom44
  %40 = load i32, i32* %arrayidx45, align 4, !tbaa !4
  %inc46 = add nsw i32 %40, 1
  store i32 %inc46, i32* %arrayidx45, align 4, !tbaa !4
  store i32 %40, i32* %slot, align 4, !tbaa !4
  %41 = load i32, i32* %code, align 4, !tbaa !4
  %42 = load i32, i32* %len, align 4, !tbaa !4
  %sub47 = sub nsw i32 32, %42
  %shl48 = shl i32 %41, %sub47
  %43 = load i32, i32* %n, align 4, !tbaa !4
  %shl49 = shl i32 %43, 4
  %or = or i32 %shl48, %shl49
  %44 = load i32, i32* %len, align 4, !tbaa !4
  %or50 = or i32 %or, %44
  %45 = load i32*, i32** %tree.addr, align 8, !tbaa !8
  %46 = load i32, i32* %slot, align 4, !tbaa !4
  %idxprom51 = sext i32 %46 to i64
  %arrayidx52 = getelementptr inbounds i32, i32* %45, i64 %idxprom51
  store i32 %or50, i32* %arrayidx52, align 4, !tbaa !4
  %47 = bitcast i32* %slot to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %47) #11
  %48 = bitcast i32* %code to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %48) #11
  br label %if.end53

if.end53:                                         ; preds = %if.then40, %for.body35
  %49 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %49) #11
  br label %for.inc54

for.inc54:                                        ; preds = %if.end53
  %50 = load i32, i32* %n, align 4, !tbaa !4
  %inc55 = add nsw i32 %50, 1
  store i32 %inc55, i32* %n, align 4, !tbaa !4
  br label %for.cond33

for.end56:                                        ; preds = %for.cond33
  %arrayidx57 = getelementptr inbounds [16 x i32], [16 x i32]* %first, i64 0, i64 15
  %51 = load i32, i32* %arrayidx57, align 4, !tbaa !4
  %52 = bitcast [16 x i32]* %counts to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %52) #11
  %53 = bitcast [16 x i32]* %first to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %53) #11
  %54 = bitcast [16 x i32]* %codes to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %54) #11
  %55 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %55) #11
  ret i32 %51
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @decode(%struct.State* %s, i32* %tree, i32 %max) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %tree.addr = alloca i32*, align 8
  %max.addr = alloca i32, align 4
  %lo = alloca i32, align 4
  %hi = alloca i32, align 4
  %key = alloca i32, align 4
  %search = alloca i32, align 4
  %guess = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  store i32* %tree, i32** %tree.addr, align 8, !tbaa !8
  store i32 %max, i32* %max.addr, align 4, !tbaa !4
  %0 = bitcast i32* %lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  store i32 0, i32* %lo, align 4, !tbaa !4
  %1 = bitcast i32* %hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #11
  %2 = load i32, i32* %max.addr, align 4, !tbaa !4
  store i32 %2, i32* %hi, align 4, !tbaa !4
  %3 = bitcast i32* %key to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = bitcast i32* %search to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %bits = getelementptr inbounds %struct.State, %struct.State* %5, i32 0, i32 0
  %6 = load i32, i32* %bits, align 8, !tbaa !47
  %call = call i32 @rev16(i32 %6)
  %shl = shl i32 %call, 16
  %or = or i32 %shl, 65535
  store i32 %or, i32* %search, align 4, !tbaa !4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %7 = load i32, i32* %lo, align 4, !tbaa !4
  %8 = load i32, i32* %hi, align 4, !tbaa !4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = bitcast i32* %guess to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #11
  %10 = load i32, i32* %lo, align 4, !tbaa !4
  %11 = load i32, i32* %hi, align 4, !tbaa !4
  %add = add i32 %10, %11
  %div = udiv i32 %add, 2
  store i32 %div, i32* %guess, align 4, !tbaa !4
  %12 = load i32, i32* %search, align 4, !tbaa !4
  %13 = load i32*, i32** %tree.addr, align 8, !tbaa !8
  %14 = load i32, i32* %guess, align 4, !tbaa !4
  %idxprom = zext i32 %14 to i64
  %arrayidx = getelementptr inbounds i32, i32* %13, i64 %idxprom
  %15 = load i32, i32* %arrayidx, align 4, !tbaa !4
  %cmp1 = icmp ult i32 %12, %15
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %16 = load i32, i32* %guess, align 4, !tbaa !4
  store i32 %16, i32* %hi, align 4, !tbaa !4
  br label %if.end

if.else:                                          ; preds = %while.body
  %17 = load i32, i32* %guess, align 4, !tbaa !4
  %add2 = add i32 %17, 1
  store i32 %add2, i32* %lo, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %18 = bitcast i32* %guess to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %18) #11
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %19 = load i32*, i32** %tree.addr, align 8, !tbaa !8
  %20 = load i32, i32* %lo, align 4, !tbaa !4
  %sub = sub i32 %20, 1
  %idxprom3 = zext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds i32, i32* %19, i64 %idxprom3
  %21 = load i32, i32* %arrayidx4, align 4, !tbaa !4
  store i32 %21, i32* %key, align 4, !tbaa !4
  %22 = load i32, i32* %search, align 4, !tbaa !4
  %23 = load i32, i32* %key, align 4, !tbaa !4
  %xor = xor i32 %22, %23
  %24 = load i32, i32* %key, align 4, !tbaa !4
  %and = and i32 %24, 15
  %sub5 = sub i32 32, %and
  %shr = lshr i32 %xor, %sub5
  %cmp6 = icmp eq i32 %shr, 0
  br i1 %cmp6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %while.end
  %25 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %jmp = getelementptr inbounds %struct.State, %struct.State* %25, i32 0, i32 6
  %arraydecay = getelementptr inbounds [37 x i32], [37 x i32]* %jmp, i32 0, i32 0
  call void @longjmp(i32* %arraydecay, i32 1) #20
  unreachable

if.end8:                                          ; preds = %while.end
  %26 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %27 = load i32, i32* %key, align 4, !tbaa !4
  %and9 = and i32 %27, 15
  %call10 = call i32 @bits(%struct.State* %26, i32 %and9)
  %28 = load i32, i32* %key, align 4, !tbaa !4
  %shr11 = lshr i32 %28, 4
  %and12 = and i32 %shr11, 4095
  %29 = bitcast i32* %search to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %29) #11
  %30 = bitcast i32* %key to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #11
  %31 = bitcast i32* %hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #11
  %32 = bitcast i32* %lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #11
  ret i32 %and12
}

; Function Attrs: nounwind ssp uwtable
define internal void @run(%struct.State* %s, i32 %sym) #0 {
entry:
  %s.addr = alloca %struct.State*, align 8
  %sym.addr = alloca i32, align 4
  %length = alloca i32, align 4
  %dsym = alloca i32, align 4
  %offs = alloca i32, align 4
  store %struct.State* %s, %struct.State** %s.addr, align 8, !tbaa !8
  store i32 %sym, i32* %sym.addr, align 4, !tbaa !4
  %0 = bitcast i32* %length to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %2 = load i32, i32* %sym.addr, align 4, !tbaa !4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* @lenBits, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv = sext i8 %3 to i32
  %call = call i32 @bits(%struct.State* %1, i32 %conv)
  %4 = load i32, i32* %sym.addr, align 4, !tbaa !4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds [31 x i32], [31 x i32]* @lenBase, i64 0, i64 %idxprom1
  %5 = load i32, i32* %arrayidx2, align 4, !tbaa !4
  %add = add nsw i32 %call, %5
  store i32 %add, i32* %length, align 4, !tbaa !4
  %6 = bitcast i32* %dsym to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #11
  %7 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %8 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %distcodes = getelementptr inbounds %struct.State, %struct.State* %8, i32 0, i32 8
  %arraydecay = getelementptr inbounds [32 x i32], [32 x i32]* %distcodes, i32 0, i32 0
  %9 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %tdist = getelementptr inbounds %struct.State, %struct.State* %9, i32 0, i32 11
  %10 = load i32, i32* %tdist, align 4, !tbaa !50
  %call3 = call i32 @decode(%struct.State* %7, i32* %arraydecay, i32 %10)
  store i32 %call3, i32* %dsym, align 4, !tbaa !4
  %11 = bitcast i32* %offs to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %11) #11
  %12 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %13 = load i32, i32* %dsym, align 4, !tbaa !4
  %idxprom4 = sext i32 %13 to i64
  %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @distBits, i64 0, i64 %idxprom4
  %14 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %conv6 = sext i8 %14 to i32
  %call7 = call i32 @bits(%struct.State* %12, i32 %conv6)
  %15 = load i32, i32* %dsym, align 4, !tbaa !4
  %idxprom8 = sext i32 %15 to i64
  %arrayidx9 = getelementptr inbounds [32 x i32], [32 x i32]* @distBase, i64 0, i64 %idxprom8
  %16 = load i32, i32* %arrayidx9, align 4, !tbaa !4
  %add10 = add nsw i32 %call7, %16
  store i32 %add10, i32* %offs, align 4, !tbaa !4
  %17 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %18 = load %struct.State*, %struct.State** %s.addr, align 8, !tbaa !8
  %out = getelementptr inbounds %struct.State, %struct.State* %18, i32 0, i32 4
  %19 = load i8*, i8** %out, align 8, !tbaa !45
  %20 = load i32, i32* %offs, align 4, !tbaa !4
  %idx.ext = sext i32 %20 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %19, i64 %idx.neg
  %21 = load i32, i32* %length, align 4, !tbaa !4
  call void @copy(%struct.State* %17, i8* %add.ptr, i32 %21)
  %22 = bitcast i32* %offs to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %22) #11
  %23 = bitcast i32* %dsym to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #11
  %24 = bitcast i32* %length to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %24) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @rev16(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4, !tbaa !4
  %0 = load i32, i32* %n.addr, align 4, !tbaa !4
  %and = and i32 %0, 255
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* @reverseTable, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !15
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 8
  %2 = load i32, i32* %n.addr, align 4, !tbaa !4
  %shr = lshr i32 %2, 8
  %and1 = and i32 %shr, 255
  %idxprom2 = zext i32 %and1 to i64
  %arrayidx3 = getelementptr inbounds [256 x i8], [256 x i8]* @reverseTable, i64 0, i64 %idxprom2
  %3 = load i8, i8* %arrayidx3, align 1, !tbaa !15
  %conv4 = zext i8 %3 to i32
  %or = or i32 %shl, %conv4
  ret i32 %or
}

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { allocsize(0,1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone speculatable }
attributes #5 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { inlinehint nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { returns_twice "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { nounwind }
attributes #12 = { nounwind readnone }
attributes #13 = { cold noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="true" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #14 = { allocsize(1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #15 = { allocsize(0,1) }
attributes #16 = { allocsize(1) }
attributes #17 = { allocsize(0) }
attributes #18 = { cold noreturn }
attributes #19 = { returns_twice }
attributes #20 = { noreturn }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 2, !"SDK Version", [3 x i32] [i32 10, i32 15, i32 4]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"PIC Level", i32 2}
!3 = !{!"clang version 8.0.1 (https://github.com/llvm-mirror/clang.git 2e4c9c5fc864c2c432e4c262a67c42d824b265c6) (https://github.com/llvm-mirror/llvm.git ea28a67e47fd87c6b78597d90eba543bad4d7468)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!9, !9, i64 0}
!9 = !{!"any pointer", !6, i64 0}
!10 = !{!11, !5, i64 0}
!11 = !{!"Tigr", !5, i64 0, !5, i64 4, !9, i64 8, !9, i64 16}
!12 = !{!11, !5, i64 4}
!13 = !{!11, !9, i64 8}
!14 = !{i64 0, i64 1, !15, i64 1, i64 1, !15, i64 2, i64 1, !15, i64 3, i64 1, !15}
!15 = !{!6, !6, i64 0}
!16 = !{!17, !6, i64 3}
!17 = !{!"", !6, i64 0, !6, i64 1, !6, i64 2, !6, i64 3}
!18 = !{!17, !6, i64 2}
!19 = !{!17, !6, i64 1}
!20 = !{!17, !6, i64 0}
!21 = !{!22, !22, i64 0}
!22 = !{!"float", !6, i64 0}
!23 = !{!24, !9, i64 0}
!24 = !{!"", !9, i64 0, !9, i64 8}
!25 = !{!24, !9, i64 8}
!26 = !{!27, !27, i64 0}
!27 = !{!"long", !6, i64 0}
!28 = !{!29, !5, i64 8}
!29 = !{!"", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !5, i64 16, !9, i64 24, !6, i64 32}
!30 = !{!29, !9, i64 24}
!31 = !{!29, !5, i64 0}
!32 = !{!29, !5, i64 4}
!33 = !{!29, !5, i64 12}
!34 = !{!29, !5, i64 16}
!35 = !{!36, !5, i64 68}
!36 = !{!"", !5, i64 0, !5, i64 4, !37, i64 8, !9, i64 40, !9, i64 48, !5, i64 56, !6, i64 60, !22, i64 64, !5, i64 68, !5, i64 72, !22, i64 76, !22, i64 80, !5, i64 84, !5, i64 88, !6, i64 92, !5, i64 108, !6, i64 112, !6, i64 368, !5, i64 624}
!37 = !{!"", !6, i64 0, !5, i64 8, !5, i64 12, !5, i64 16, !5, i64 20, !5, i64 24, !5, i64 28}
!38 = !{!36, !5, i64 72}
!39 = !{!36, !22, i64 76}
!40 = !{!36, !22, i64 80}
!41 = !{!11, !9, i64 16}
!42 = !{!43, !9, i64 8}
!43 = !{!"", !5, i64 0, !5, i64 4, !9, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !6, i64 40, !6, i64 188, !6, i64 1340, !6, i64 1468, !5, i64 1544, !5, i64 1548, !5, i64 1552}
!44 = !{!43, !9, i64 16}
!45 = !{!43, !9, i64 24}
!46 = !{!43, !9, i64 32}
!47 = !{!43, !5, i64 0}
!48 = !{!43, !5, i64 4}
!49 = !{!43, !5, i64 1544}
!50 = !{!43, !5, i64 1548}
!51 = !{!43, !5, i64 1552}
!52 = !{!53, !5, i64 8}
!53 = !{!"", !9, i64 0, !5, i64 8, !9, i64 16}
!54 = !{!53, !9, i64 16}
!55 = !{!53, !9, i64 0}
!56 = !{!57, !5, i64 0}
!57 = !{!"", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !5, i64 16}
!58 = !{!57, !5, i64 4}
!59 = !{!57, !5, i64 8}
!60 = !{!57, !5, i64 12}
!61 = !{!57, !5, i64 16}
!62 = !{i64 0, i64 4, !4, i64 4, i64 4, !4, i64 8, i64 4, !4, i64 12, i64 4, !4, i64 16, i64 4, !4}
!63 = !{!36, !9, i64 40}
!64 = !{!36, !9, i64 48}
!65 = !{!66, !66, i64 0}
!66 = !{!"_Bool", !6, i64 0}
!67 = !{i8 0, i8 2}
!68 = !{!36, !5, i64 108}
!69 = !{!36, !5, i64 624}
!70 = !{i64 0, i64 8, !71, i64 8, i64 8, !71, i64 16, i64 8, !71, i64 24, i64 8, !71}
!71 = !{!72, !72, i64 0}
!72 = !{!"double", !6, i64 0}
!73 = !{i64 0, i64 8, !71, i64 8, i64 8, !71}
!74 = !{!75, !72, i64 0}
!75 = !{!"CGPoint", !72, i64 0, !72, i64 8}
!76 = !{!75, !72, i64 8}
!77 = !{!78, !72, i64 0}
!78 = !{!"CGSize", !72, i64 0, !72, i64 8}
!79 = !{!78, !72, i64 8}
!80 = !{!36, !5, i64 0}
!81 = !{!36, !5, i64 4}
!82 = !{!36, !5, i64 88}
!83 = !{!36, !5, i64 84}
!84 = !{!36, !5, i64 56}
!85 = !{!36, !6, i64 60}
!86 = !{!36, !22, i64 64}
!87 = !{!36, !5, i64 36}
!88 = !{!37, !5, i64 28}
!89 = !{!37, !5, i64 8}
!90 = !{!37, !5, i64 12}
!91 = !{!37, !5, i64 16}
!92 = !{!37, !5, i64 20}
!93 = !{!37, !5, i64 24}
!94 = !{!95, !95, i64 0}
!95 = !{!"short", !6, i64 0}
!96 = !{!97, !72, i64 16}
!97 = !{!"CGRect", !75, i64 0, !78, i64 16}
!98 = !{!97, !72, i64 24}
!99 = !{!100, !5, i64 4}
!100 = !{!"mach_timebase_info", !5, i64 0, !5, i64 4}
!101 = !{!102, !102, i64 0}
!102 = !{!"long long", !6, i64 0}
!103 = !{!100, !5, i64 0}
