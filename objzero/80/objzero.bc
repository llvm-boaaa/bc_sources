; ModuleID = 'objzero.c'
source_filename = "objzero.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.VertexFormat = type { i64, i64, i64, i64 }
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.MaterialProperty = type { i8*, i32, i64, i32 }
%struct.MaterialMapArg = type { i8*, i32 }
%struct.File = type { i8*, i64, i64 }
%struct.objzModel = type { i32, i8*, i32, %struct.objzMaterial*, i32, %struct.objzMesh*, i32, %struct.objzObject*, i32, i8*, i32 }
%struct.objzMaterial = type { [64 x i8], [3 x float], [3 x float], [3 x float], [3 x float], float, float, [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8] }
%struct.objzMesh = type { i32, i32, i32 }
%struct.objzObject = type { [64 x i8], i32, i32, i32, i32, i32, i32 }
%struct.Array = type { i8*, i32, i32, i32, i32 }
%struct.ChunkedArray = type { %struct.Array, i32, i64, i32 }
%struct.Lexer = type { i8*, i32, i32 }
%struct.Token = type { [256 x i8], i32, i32 }
%struct.TempObject = type { [64 x i8], i32, i32 }
%struct.IndexTriplet = type { i32, i32, i32 }
%struct.Face = type { i16, i16, [3 x %struct.IndexTriplet] }
%struct.vec3 = type { float, float, float }
%struct.VertexHashMap = type { i32*, i32, %struct.Array }
%struct.NormalHashMap = type { i32*, i32, %struct.Array, %struct.ChunkedArray* }
%struct.HashedVertex = type { i32, i32, i32, i32, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.HashedNormal = type { i32, i32 }

@.str = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.1 = private unnamed_addr constant [10 x i8] c"objzero.c\00", align 1
@s_realloc = internal global i8* (i8*, i64)* null, align 8
@s_indexFormat = internal global i32 0, align 4
@s_vertexDecl = internal global %struct.VertexFormat { i64 32, i64 0, i64 12, i64 20 }, align 8
@s_error = internal global [1024 x i8] zeroinitializer, align 16
@.str.2 = private unnamed_addr constant [25 x i8] c"Failed to read file '%s'\00", align 1
@.str.3 = private unnamed_addr constant [43 x i8] c"UTF-32 encoding not supported in file '%s'\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"UTF-16 encoding not supported in file '%s'\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.6 = private unnamed_addr constant [29 x i8] c"(%u:%u) Failed to parse face\00", align 1
@.str.7 = private unnamed_addr constant [39 x i8] c"(%u:%u) Face needs at least 3 vertices\00", align 1
@.str.8 = private unnamed_addr constant [2 x i8] c"g\00", align 1
@.str.9 = private unnamed_addr constant [2 x i8] c"o\00", align 1
@.str.10 = private unnamed_addr constant [32 x i8] c"(%u:%u) Expected name after 'o'\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"mtllib\00", align 1
@.str.13 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'mtllib'\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@.str.15 = private unnamed_addr constant [33 x i8] c"(%u:%u) Expected value after 's'\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.17 = private unnamed_addr constant [7 x i8] c"usemtl\00", align 1
@.str.18 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'usemtl'\00", align 1
@.str.19 = private unnamed_addr constant [2 x i8] c"v\00", align 1
@.str.20 = private unnamed_addr constant [3 x i8] c"vn\00", align 1
@.str.21 = private unnamed_addr constant [3 x i8] c"vt\00", align 1
@__stderrp = external global %struct.__sFILE*, align 8
@.str.22 = private unnamed_addr constant [32 x i8] c"Memory allocation failed %s %d\0A\00", align 1
@.str.23 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.24 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@__const.triangulate.axes = private unnamed_addr constant [2 x i32] [i32 1, i32 2], align 4
@.str.25 = private unnamed_addr constant [34 x i8] c"Failed to read material file '%s'\00", align 1
@.str.26 = private unnamed_addr constant [7 x i8] c"newmtl\00", align 1
@.str.27 = private unnamed_addr constant [37 x i8] c"(%u:%u) Expected name after 'newmtl'\00", align 1
@s_materialProperties = internal global [14 x %struct.MaterialProperty] [%struct.MaterialProperty { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.29, i32 0, i32 0), i32 1, i64 116, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.30, i32 0, i32 0), i32 1, i64 64, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.31, i32 0, i32 0), i32 1, i64 76, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i32 1, i64 88, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.33, i32 0, i32 0), i32 1, i64 100, i32 3 }, %struct.MaterialProperty { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0), i32 1, i64 112, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i32 0, i64 184, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.36, i32 0, i32 0), i32 0, i64 184, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.37, i32 0, i32 0), i32 0, i64 120, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.38, i32 0, i32 0), i32 0, i64 248, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.39, i32 0, i32 0), i32 0, i64 312, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i32 0, i64 376, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i32 0, i64 440, i32 1 }, %struct.MaterialProperty { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.42, i32 0, i32 0), i32 0, i64 504, i32 1 }], align 16
@.str.28 = private unnamed_addr constant [34 x i8] c"(%u:%u) Expected token after '%s'\00", align 1
@s_materialMapArgs = internal global [12 x %struct.MaterialMapArg] [%struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.45, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.46, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.49, i32 0, i32 0), i32 2 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.50, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.51, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 3 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.53, i32 0, i32 0), i32 1 }, %struct.MaterialMapArg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54, i32 0, i32 0), i32 1 }], align 16
@.str.29 = private unnamed_addr constant [2 x i8] c"d\00", align 1
@.str.30 = private unnamed_addr constant [3 x i8] c"Ka\00", align 1
@.str.31 = private unnamed_addr constant [3 x i8] c"Kd\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"Ke\00", align 1
@.str.33 = private unnamed_addr constant [3 x i8] c"Ks\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"Ns\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"bump\00", align 1
@.str.36 = private unnamed_addr constant [9 x i8] c"map_Bump\00", align 1
@.str.37 = private unnamed_addr constant [7 x i8] c"map_Ka\00", align 1
@.str.38 = private unnamed_addr constant [7 x i8] c"map_Kd\00", align 1
@.str.39 = private unnamed_addr constant [7 x i8] c"map_Ke\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"map_Ks\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"map_Ns\00", align 1
@.str.42 = private unnamed_addr constant [6 x i8] c"map_d\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"-blendu\00", align 1
@.str.44 = private unnamed_addr constant [8 x i8] c"-blendv\00", align 1
@.str.45 = private unnamed_addr constant [4 x i8] c"-bm\00", align 1
@.str.46 = private unnamed_addr constant [7 x i8] c"-boost\00", align 1
@.str.47 = private unnamed_addr constant [7 x i8] c"-clamp\00", align 1
@.str.48 = private unnamed_addr constant [9 x i8] c"-imfchan\00", align 1
@.str.49 = private unnamed_addr constant [4 x i8] c"-mm\00", align 1
@.str.50 = private unnamed_addr constant [3 x i8] c"-o\00", align 1
@.str.51 = private unnamed_addr constant [3 x i8] c"-s\00", align 1
@.str.52 = private unnamed_addr constant [3 x i8] c"-t\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"-texres\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c"-type\00", align 1
@.str.55 = private unnamed_addr constant [30 x i8] c"(%u:%u) Error skipping tokens\00", align 1
@.str.56 = private unnamed_addr constant [28 x i8] c"(%u:%u) Error parsing float\00", align 1

; Function Attrs: nounwind ssp uwtable
define zeroext i1 @fileOpen(%struct.File* %_file, i8* %_filename) #0 {
entry:
  %retval = alloca i1, align 1
  %_file.addr = alloca %struct.File*, align 8
  %_filename.addr = alloca i8*, align 8
  %handle = alloca %struct.__sFILE*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %bytesRead = alloca i64, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8, !tbaa !4
  store i8* %_filename, i8** %_filename.addr, align 8, !tbaa !4
  %0 = bitcast %struct.__sFILE** %handle to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i8*, i8** %_filename.addr, align 8, !tbaa !4
  %call = call %struct.__sFILE* @"\01_fopen"(i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  store %struct.__sFILE* %call, %struct.__sFILE** %handle, align 8, !tbaa !4
  %2 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %tobool = icmp ne %struct.__sFILE* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup22

if.end:                                           ; preds = %entry
  %3 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %call1 = call i32 @fseek(%struct.__sFILE* %3, i64 0, i32 2)
  %4 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %call2 = call i64 @ftell(%struct.__sFILE* %4)
  %5 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.File, %struct.File* %5, i32 0, i32 1
  store i64 %call2, i64* %length, align 8, !tbaa !8
  %6 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %call3 = call i32 @fseek(%struct.__sFILE* %6, i64 0, i32 0)
  %7 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %length4 = getelementptr inbounds %struct.File, %struct.File* %7, i32 0, i32 1
  %8 = load i64, i64* %length4, align 8, !tbaa !8
  %cmp = icmp eq i64 %8, 0
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %9 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %call6 = call i32 @fclose(%struct.__sFILE* %9)
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup22

if.end7:                                          ; preds = %if.end
  %10 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %pos = getelementptr inbounds %struct.File, %struct.File* %10, i32 0, i32 2
  store i64 0, i64* %pos, align 8, !tbaa !11
  %11 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %length8 = getelementptr inbounds %struct.File, %struct.File* %11, i32 0, i32 1
  %12 = load i64, i64* %length8, align 8, !tbaa !8
  %add = add i64 %12, 1
  %call9 = call i8* @objz_realloc(i8* null, i64 %add, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 338)
  %13 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.File, %struct.File* %13, i32 0, i32 0
  store i8* %call9, i8** %buffer, align 8, !tbaa !12
  %14 = bitcast i64* %bytesRead to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #7
  %15 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer10 = getelementptr inbounds %struct.File, %struct.File* %15, i32 0, i32 0
  %16 = load i8*, i8** %buffer10, align 8, !tbaa !12
  %17 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %length11 = getelementptr inbounds %struct.File, %struct.File* %17, i32 0, i32 1
  %18 = load i64, i64* %length11, align 8, !tbaa !8
  %19 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %call12 = call i64 @fread(i8* %16, i64 1, i64 %18, %struct.__sFILE* %19)
  store i64 %call12, i64* %bytesRead, align 8, !tbaa !13
  %20 = load %struct.__sFILE*, %struct.__sFILE** %handle, align 8, !tbaa !4
  %call13 = call i32 @fclose(%struct.__sFILE* %20)
  %21 = load i64, i64* %bytesRead, align 8, !tbaa !13
  %22 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %length14 = getelementptr inbounds %struct.File, %struct.File* %22, i32 0, i32 1
  %23 = load i64, i64* %length14, align 8, !tbaa !8
  %cmp15 = icmp ult i64 %21, %23
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end7
  %24 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer17 = getelementptr inbounds %struct.File, %struct.File* %24, i32 0, i32 0
  %25 = load i8*, i8** %buffer17, align 8, !tbaa !12
  %call18 = call i8* @objz_realloc(i8* %25, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 342)
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end19:                                         ; preds = %if.end7
  %26 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer20 = getelementptr inbounds %struct.File, %struct.File* %26, i32 0, i32 0
  %27 = load i8*, i8** %buffer20, align 8, !tbaa !12
  %28 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %length21 = getelementptr inbounds %struct.File, %struct.File* %28, i32 0, i32 1
  %29 = load i64, i64* %length21, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds i8, i8* %27, i64 %29
  store i8 0, i8* %arrayidx, align 1, !tbaa !14
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then16
  %30 = bitcast i64* %bytesRead to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) #7
  br label %cleanup22

cleanup22:                                        ; preds = %cleanup, %if.then5, %if.then
  %31 = bitcast %struct.__sFILE** %handle to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #7
  %32 = load i1, i1* %retval, align 1
  ret i1 %32
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #2

declare i32 @fseek(%struct.__sFILE*, i64, i32) #2

declare i64 @ftell(%struct.__sFILE*) #2

declare i32 @fclose(%struct.__sFILE*) #2

; Function Attrs: nounwind ssp uwtable
define internal i8* @objz_realloc(i8* %_ptr, i64 %_size, i8* %_file, i32 %_line) #0 {
entry:
  %retval = alloca i8*, align 8
  %_ptr.addr = alloca i8*, align 8
  %_size.addr = alloca i64, align 8
  %_file.addr = alloca i8*, align 8
  %_line.addr = alloca i32, align 4
  %result = alloca i8*, align 8
  store i8* %_ptr, i8** %_ptr.addr, align 8, !tbaa !4
  store i64 %_size, i64* %_size.addr, align 8, !tbaa !13
  store i8* %_file, i8** %_file.addr, align 8, !tbaa !4
  store i32 %_line, i32* %_line.addr, align 4, !tbaa !15
  %0 = load i8*, i8** %_ptr.addr, align 8, !tbaa !4
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %_size.addr, align 8, !tbaa !13
  %tobool1 = icmp ne i64 %1, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = bitcast i8** %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = load i8* (i8*, i64)*, i8* (i8*, i64)** @s_realloc, align 8, !tbaa !4
  %tobool2 = icmp ne i8* (i8*, i64)* %3, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %4 = load i8* (i8*, i64)*, i8* (i8*, i64)** @s_realloc, align 8, !tbaa !4
  %5 = load i8*, i8** %_ptr.addr, align 8, !tbaa !4
  %6 = load i64, i64* %_size.addr, align 8, !tbaa !13
  %call = call i8* %4(i8* %5, i64 %6)
  store i8* %call, i8** %result, align 8, !tbaa !4
  br label %if.end5

if.else:                                          ; preds = %if.end
  %7 = load i8*, i8** %_ptr.addr, align 8, !tbaa !4
  %8 = load i64, i64* %_size.addr, align 8, !tbaa !13
  %call4 = call i8* @realloc(i8* %7, i64 %8) #8
  store i8* %call4, i8** %result, align 8, !tbaa !4
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then3
  %9 = load i64, i64* %_size.addr, align 8, !tbaa !13
  %cmp = icmp ugt i64 %9, 0
  br i1 %cmp, label %land.lhs.true6, label %if.end10

land.lhs.true6:                                   ; preds = %if.end5
  %10 = load i8*, i8** %result, align 8, !tbaa !4
  %tobool7 = icmp ne i8* %10, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true6
  %11 = load %struct.__sFILE*, %struct.__sFILE** @__stderrp, align 8, !tbaa !4
  %12 = load i8*, i8** %_file.addr, align 8, !tbaa !4
  %13 = load i32, i32* %_line.addr, align 4, !tbaa !15
  %call9 = call i32 (%struct.__sFILE*, i8*, ...) @fprintf(%struct.__sFILE* %11, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.22, i32 0, i32 0), i8* %12, i32 %13)
  call void @abort() #9
  unreachable

if.end10:                                         ; preds = %land.lhs.true6, %if.end5
  %14 = load i8*, i8** %result, align 8, !tbaa !4
  store i8* %14, i8** %retval, align 8
  %15 = bitcast i8** %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #7
  br label %return

return:                                           ; preds = %if.end10, %if.then
  %16 = load i8*, i8** %retval, align 8
  ret i8* %16
}

declare i64 @fread(i8*, i64, i64, %struct.__sFILE*) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind ssp uwtable
define void @fileClose(%struct.File* %_file) #0 {
entry:
  %_file.addr = alloca %struct.File*, align 8
  store %struct.File* %_file, %struct.File** %_file.addr, align 8, !tbaa !4
  %0 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.File, %struct.File* %0, i32 0, i32 0
  %1 = load i8*, i8** %buffer, align 8, !tbaa !12
  %call = call i8* @objz_realloc(i8* %1, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 350)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i8* @fileReadLine(%struct.File* %_file) #0 {
entry:
  %retval = alloca i8*, align 8
  %_file.addr = alloca %struct.File*, align 8
  %start = alloca i8*, align 8
  %c = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.File* %_file, %struct.File** %_file.addr, align 8, !tbaa !4
  %0 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.File, %struct.File* %0, i32 0, i32 0
  %1 = load i8*, i8** %buffer, align 8, !tbaa !12
  %2 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %pos = getelementptr inbounds %struct.File, %struct.File* %2, i32 0, i32 2
  %3 = load i64, i64* %pos, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %3
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !14
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = bitcast i8** %start to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %6 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer2 = getelementptr inbounds %struct.File, %struct.File* %6, i32 0, i32 0
  %7 = load i8*, i8** %buffer2, align 8, !tbaa !12
  %8 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %pos3 = getelementptr inbounds %struct.File, %struct.File* %8, i32 0, i32 2
  %9 = load i64, i64* %pos3, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds i8, i8* %7, i64 %9
  store i8* %arrayidx4, i8** %start, align 8, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end
  %10 = bitcast i8** %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #7
  %11 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %buffer5 = getelementptr inbounds %struct.File, %struct.File* %11, i32 0, i32 0
  %12 = load i8*, i8** %buffer5, align 8, !tbaa !12
  %13 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %pos6 = getelementptr inbounds %struct.File, %struct.File* %13, i32 0, i32 2
  %14 = load i64, i64* %pos6, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds i8, i8* %12, i64 %14
  store i8* %arrayidx7, i8** %c, align 8, !tbaa !4
  %15 = load i8*, i8** %c, align 8, !tbaa !4
  %16 = load i8, i8* %15, align 1, !tbaa !14
  %conv8 = sext i8 %16 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.cond
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end12:                                         ; preds = %for.cond
  %17 = load i8*, i8** %c, align 8, !tbaa !4
  %18 = load i8, i8* %17, align 1, !tbaa !14
  %conv13 = sext i8 %18 to i32
  %cmp14 = icmp eq i32 %conv13, 13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end12
  %19 = load i8*, i8** %c, align 8, !tbaa !4
  store i8 0, i8* %19, align 1, !tbaa !14
  br label %if.end23

if.else:                                          ; preds = %if.end12
  %20 = load i8*, i8** %c, align 8, !tbaa !4
  %21 = load i8, i8* %20, align 1, !tbaa !14
  %conv17 = sext i8 %21 to i32
  %cmp18 = icmp eq i32 %conv17, 10
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.else
  %22 = load i8*, i8** %c, align 8, !tbaa !4
  store i8 0, i8* %22, align 1, !tbaa !14
  %23 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %pos21 = getelementptr inbounds %struct.File, %struct.File* %23, i32 0, i32 2
  %24 = load i64, i64* %pos21, align 8, !tbaa !11
  %inc = add i64 %24, 1
  store i64 %inc, i64* %pos21, align 8, !tbaa !11
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end22:                                         ; preds = %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then16
  %25 = load %struct.File*, %struct.File** %_file.addr, align 8, !tbaa !4
  %pos24 = getelementptr inbounds %struct.File, %struct.File* %25, i32 0, i32 2
  %26 = load i64, i64* %pos24, align 8, !tbaa !11
  %inc25 = add i64 %26, 1
  store i64 %inc25, i64* %pos24, align 8, !tbaa !11
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %if.then20, %if.then11
  %27 = bitcast i8** %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %27) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 2, label %for.end
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.cond

for.end:                                          ; preds = %cleanup
  %28 = load i8*, i8** %start, align 8, !tbaa !4
  store i8* %28, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  %29 = bitcast i8** %start to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %29) #7
  br label %return

return:                                           ; preds = %for.end, %if.then
  %30 = load i8*, i8** %retval, align 8
  ret i8* %30

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define void @objz_setRealloc(i8* (i8*, i64)* %_realloc) #0 {
entry:
  %_realloc.addr = alloca i8* (i8*, i64)*, align 8
  store i8* (i8*, i64)* %_realloc, i8* (i8*, i64)** %_realloc.addr, align 8, !tbaa !4
  %0 = load i8* (i8*, i64)*, i8* (i8*, i64)** %_realloc.addr, align 8, !tbaa !4
  store i8* (i8*, i64)* %0, i8* (i8*, i64)** @s_realloc, align 8, !tbaa !4
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @objz_setIndexFormat(i32 %_format) #0 {
entry:
  %_format.addr = alloca i32, align 4
  store i32 %_format, i32* %_format.addr, align 4, !tbaa !15
  %0 = load i32, i32* %_format.addr, align 4, !tbaa !15
  store i32 %0, i32* @s_indexFormat, align 4, !tbaa !15
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @objz_setVertexFormat(i64 %_stride, i64 %_positionOffset, i64 %_texcoordOffset, i64 %_normalOffset) #0 {
entry:
  %_stride.addr = alloca i64, align 8
  %_positionOffset.addr = alloca i64, align 8
  %_texcoordOffset.addr = alloca i64, align 8
  %_normalOffset.addr = alloca i64, align 8
  store i64 %_stride, i64* %_stride.addr, align 8, !tbaa !13
  store i64 %_positionOffset, i64* %_positionOffset.addr, align 8, !tbaa !13
  store i64 %_texcoordOffset, i64* %_texcoordOffset.addr, align 8, !tbaa !13
  store i64 %_normalOffset, i64* %_normalOffset.addr, align 8, !tbaa !13
  %0 = load i64, i64* %_stride.addr, align 8, !tbaa !13
  store i64 %0, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8, !tbaa !17
  %1 = load i64, i64* %_positionOffset.addr, align 8, !tbaa !13
  store i64 %1, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8, !tbaa !19
  %2 = load i64, i64* %_texcoordOffset.addr, align 8, !tbaa !13
  store i64 %2, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8, !tbaa !20
  %3 = load i64, i64* %_normalOffset.addr, align 8, !tbaa !13
  store i64 %3, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  ret void
}

; Function Attrs: nounwind ssp uwtable
define %struct.objzModel* @objz_load(i8* %_filename) #0 {
entry:
  %retval = alloca %struct.objzModel*, align 8
  %_filename.addr = alloca i8*, align 8
  %file = alloca %struct.File, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %bom32 = alloca i32*, align 8
  %bom16 = alloca i16*, align 8
  %materialLibs = alloca %struct.Array, align 8
  %materials = alloca %struct.Array, align 8
  %tempObjects = alloca %struct.Array, align 8
  %positions = alloca %struct.ChunkedArray, align 8
  %texcoords = alloca %struct.ChunkedArray, align 8
  %normals = alloca %struct.ChunkedArray, align 8
  %faces = alloca %struct.ChunkedArray, align 8
  %faceIndices = alloca %struct.Array, align 8
  %tempFaceIndices = alloca %struct.Array, align 8
  %generateNormals = alloca i8, align 1
  %currentGroupName = alloca [64 x i8], align 16
  %currentObjectName = alloca [64 x i8], align 16
  %currentMaterialIndex = alloca i32, align 4
  %currentSmoothingGroup = alloca i16, align 2
  %flags = alloca i32, align 4
  %lexer = alloca %struct.Lexer, align 8
  %token = alloca %struct.Token, align 4
  %line = alloca i8*, align 8
  %o = alloca %struct.TempObject, align 4
  %object = alloca %struct.TempObject*, align 8
  %tripletToken = alloca %struct.Token, align 4
  %rawTriplet = alloca [3 x i32], align 4
  %triplet = alloca %struct.IndexTriplet, align 4
  %face = alloca %struct.Face, align 4
  %i = alloca i32, align 4
  %prevFacesLength = alloca i32, align 4
  %isGroup = alloca i8, align 1
  %o146 = alloca %struct.TempObject, align 4
  %alreadyLoaded = alloca i8, align 1
  %i202 = alloca i32, align 4
  %i282 = alloca i32, align 4
  %mat = alloca %struct.objzMaterial*, align 8
  %pos = alloca [3 x float], align 4
  %normal = alloca [3 x float], align 4
  %texcoord = alloca [2 x float], align 4
  %faceNormals = alloca %struct.Array, align 8
  %i376 = alloca i32, align 4
  %tempObject = alloca %struct.TempObject*, align 8
  %j = alloca i32, align 4
  %face394 = alloca %struct.Face*, align 8
  %edge0 = alloca %struct.vec3, align 4
  %edge1 = alloca %struct.vec3, align 4
  %normal398 = alloca %struct.vec3, align 4
  %p0 = alloca %struct.vec3*, align 8
  %p1 = alloca %struct.vec3*, align 8
  %p2 = alloca %struct.vec3*, align 8
  %meshes = alloca %struct.Array, align 8
  %objects = alloca %struct.Array, align 8
  %indices465 = alloca %struct.Array, align 8
  %vertexHashMap = alloca %struct.VertexHashMap, align 8
  %normalHashMap = alloca %struct.NormalHashMap, align 8
  %maxObjectFaces = alloca i32, align 4
  %i475 = alloca i32, align 4
  %tempObject482 = alloca %struct.TempObject*, align 8
  %i503 = alloca i32, align 4
  %tempObject510 = alloca %struct.TempObject*, align 8
  %object520 = alloca %struct.objzObject, align 4
  %material = alloca i32, align 4
  %mesh = alloca %struct.objzMesh, align 4
  %j540 = alloca i32, align 4
  %face547 = alloca %struct.Face*, align 8
  %faceNormalIndex = alloca i32, align 4
  %k = alloca i32, align 4
  %k594 = alloca i32, align 4
  %triplet600 = alloca %struct.IndexTriplet*, align 8
  %vn604 = alloca i32, align 4
  %normal613 = alloca %struct.vec3, align 4
  %tmp = alloca { <2 x float>, float }, align 8
  %index = alloca i32, align 4
  %prev = alloca %struct.objzObject*, align 8
  %model = alloca %struct.objzModel*, align 8
  %i712 = alloca i32, align 4
  %index719 = alloca i32*, align 8
  %i752 = alloca i32, align 4
  %vOut = alloca i8*, align 8
  %vIn = alloca %struct.HashedVertex*, align 8
  store i8* %_filename, i8** %_filename.addr, align 8, !tbaa !4
  store i8 0, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16, !tbaa !14
  %0 = bitcast %struct.File* %file to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #7
  %1 = load i8*, i8** %_filename.addr, align 8, !tbaa !4
  %call = call zeroext i1 @fileOpen(%struct.File* %file, i8* %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i8*, i8** %_filename.addr, align 8, !tbaa !4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.2, i32 0, i32 0), i8* %2)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup842

if.end:                                           ; preds = %entry
  %3 = bitcast i32** %bom32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %buffer = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %4 = load i8*, i8** %buffer, align 8, !tbaa !12
  %5 = bitcast i8* %4 to i32*
  store i32* %5, i32** %bom32, align 8, !tbaa !4
  %6 = load i32*, i32** %bom32, align 8, !tbaa !4
  %7 = load i32, i32* %6, align 4, !tbaa !15
  %cmp = icmp eq i32 %7, 65279
  br i1 %cmp, label %if.then2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %8 = load i32*, i32** %bom32, align 8, !tbaa !4
  %9 = load i32, i32* %8, align 4, !tbaa !15
  %cmp1 = icmp eq i32 %9, -131072
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %10 = load i8*, i8** %_filename.addr, align 8, !tbaa !4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i8* %10)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup841

if.end3:                                          ; preds = %lor.lhs.false
  %11 = bitcast i16** %bom16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #7
  %buffer4 = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %12 = load i8*, i8** %buffer4, align 8, !tbaa !12
  %13 = bitcast i8* %12 to i16*
  store i16* %13, i16** %bom16, align 8, !tbaa !4
  %14 = load i16*, i16** %bom16, align 8, !tbaa !4
  %15 = load i16, i16* %14, align 2, !tbaa !22
  %conv = zext i16 %15 to i32
  %cmp5 = icmp eq i32 %conv, 65534
  br i1 %cmp5, label %if.then11, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end3
  %16 = load i16*, i16** %bom16, align 8, !tbaa !4
  %17 = load i16, i16* %16, align 2, !tbaa !22
  %conv8 = zext i16 %17 to i32
  %cmp9 = icmp eq i32 %conv8, 65279
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false7, %if.end3
  %18 = load i8*, i8** %_filename.addr, align 8, !tbaa !4
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i8* %18)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup840

if.end12:                                         ; preds = %lor.lhs.false7
  %19 = bitcast %struct.Array* %materialLibs to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %19) #7
  %20 = bitcast %struct.Array* %materials to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %20) #7
  %21 = bitcast %struct.Array* %tempObjects to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %21) #7
  %22 = bitcast %struct.ChunkedArray* %positions to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %22) #7
  %23 = bitcast %struct.ChunkedArray* %texcoords to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %23) #7
  %24 = bitcast %struct.ChunkedArray* %normals to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %24) #7
  %25 = bitcast %struct.ChunkedArray* %faces to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %25) #7
  %26 = bitcast %struct.Array* %faceIndices to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %26) #7
  %27 = bitcast %struct.Array* %tempFaceIndices to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %27) #7
  call void @arrayInit(%struct.Array* %materialLibs, i64 256, i32 1)
  call void @arrayInit(%struct.Array* %materials, i64 568, i32 16)
  call void @arrayInit(%struct.Array* %tempObjects, i64 72, i32 64)
  call void @chunkedArrayInit(%struct.ChunkedArray* %positions, i64 12, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %texcoords, i64 8, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %normals, i64 12, i32 100000)
  call void @chunkedArrayInit(%struct.ChunkedArray* %faces, i64 40, i32 100000)
  call void @arrayInit(%struct.Array* %faceIndices, i64 12, i32 8)
  call void @arrayInit(%struct.Array* %tempFaceIndices, i64 12, i32 8)
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %generateNormals) #7
  store i8 0, i8* %generateNormals, align 1, !tbaa !24
  %28 = bitcast [64 x i8]* %currentGroupName to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %28) #7
  %29 = bitcast [64 x i8]* %currentGroupName to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %29, i8 0, i64 64, i1 false)
  %30 = bitcast [64 x i8]* %currentObjectName to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %30) #7
  %31 = bitcast [64 x i8]* %currentObjectName to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %31, i8 0, i64 64, i1 false)
  %32 = bitcast i32* %currentMaterialIndex to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %32) #7
  store i32 -1, i32* %currentMaterialIndex, align 4, !tbaa !15
  %33 = bitcast i16* %currentSmoothingGroup to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %33) #7
  store i16 0, i16* %currentSmoothingGroup, align 2, !tbaa !22
  %34 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %34) #7
  store i32 0, i32* %flags, align 4, !tbaa !15
  %35 = bitcast %struct.Lexer* %lexer to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %35) #7
  call void @initLexer(%struct.Lexer* %lexer)
  %36 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %36) #7
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont366, %if.end12
  %37 = bitcast i8** %line to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %37) #7
  %call13 = call i8* @fileReadLine(%struct.File* %file)
  store i8* %call13, i8** %line, align 8, !tbaa !4
  %38 = load i8*, i8** %line, align 8, !tbaa !4
  %tobool = icmp ne i8* %38, null
  br i1 %tobool, label %if.end15, label %if.then14

if.then14:                                        ; preds = %for.cond
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup364

if.end15:                                         ; preds = %for.cond
  %39 = load i8*, i8** %line, align 8, !tbaa !4
  call void @lexerSetLine(%struct.Lexer* %lexer, i8* %39)
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call16 = call i32 @strcasecmp(i8* %arraydecay, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.else96

if.then19:                                        ; preds = %if.end15
  %length = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %40 = load i32, i32* %length, align 8, !tbaa !26
  %cmp20 = icmp eq i32 %40, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then19
  %41 = bitcast %struct.TempObject* %o to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* %41) #7
  %name = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 0
  %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* %name, i64 0, i64 0
  store i8 0, i8* %arrayidx, align 4, !tbaa !14
  %numFaces = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 2
  store i32 0, i32* %numFaces, align 4, !tbaa !28
  %firstFace = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o, i32 0, i32 1
  store i32 0, i32* %firstFace, align 4, !tbaa !30
  %42 = bitcast %struct.TempObject* %o to i8*
  call void @arrayAppend(%struct.Array* %tempObjects, i8* %42)
  %43 = bitcast %struct.TempObject* %o to i8*
  call void @llvm.lifetime.end.p0i8(i64 72, i8* %43) #7
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then19
  %44 = bitcast %struct.TempObject** %object to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %44) #7
  %data = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %45 = load i8*, i8** %data, align 8, !tbaa !31
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %46 = load i32, i32* %elementSize, align 8, !tbaa !32
  %length24 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %47 = load i32, i32* %length24, align 8, !tbaa !26
  %sub = sub i32 %47, 1
  %mul = mul i32 %46, %sub
  %idxprom = zext i32 %mul to i64
  %arrayidx25 = getelementptr inbounds i8, i8* %45, i64 %idxprom
  %48 = bitcast i8* %arrayidx25 to %struct.TempObject*
  store %struct.TempObject* %48, %struct.TempObject** %object, align 8, !tbaa !4
  %length26 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  store i32 0, i32* %length26, align 8, !tbaa !26
  br label %for.cond27

for.cond27:                                       ; preds = %cleanup.cont, %if.end23
  %49 = bitcast %struct.Token* %tripletToken to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %49) #7
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %tripletToken, i1 zeroext false)
  %text28 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 0
  %arrayidx29 = getelementptr inbounds [256 x i8], [256 x i8]* %text28, i64 0, i64 0
  %50 = load i8, i8* %arrayidx29, align 4, !tbaa !14
  %conv30 = sext i8 %50 to i32
  %cmp31 = icmp eq i32 %conv30, 0
  br i1 %cmp31, label %if.then33, label %if.end38

if.then33:                                        ; preds = %for.cond27
  %call34 = call zeroext i1 @isEol(%struct.Lexer* %lexer)
  br i1 %call34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then33
  store i32 4, i32* %cleanup.dest.slot, align 4
  br label %cleanup61

if.end36:                                         ; preds = %if.then33
  %line37 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 1
  %51 = load i32, i32* %line37, align 4, !tbaa !33
  %column = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 2
  %52 = load i32, i32* %column, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6, i32 0, i32 0), i32 %51, i32 %52)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup61

if.end38:                                         ; preds = %for.cond27
  %53 = bitcast [3 x i32]* %rawTriplet to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %53) #7
  %arraydecay39 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i32 0, i32 0
  %call40 = call zeroext i1 @parseVertexAttribIndices(%struct.Token* %tripletToken, i32* %arraydecay39)
  br i1 %call40, label %if.end44, label %if.then41

if.then41:                                        ; preds = %if.end38
  %line42 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 1
  %54 = load i32, i32* %line42, align 4, !tbaa !33
  %column43 = getelementptr inbounds %struct.Token, %struct.Token* %tripletToken, i32 0, i32 2
  %55 = load i32, i32* %column43, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6, i32 0, i32 0), i32 %54, i32 %55)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end44:                                         ; preds = %if.end38
  %56 = bitcast %struct.IndexTriplet* %triplet to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %56) #7
  %arrayidx45 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 0
  %57 = load i32, i32* %arrayidx45, align 4, !tbaa !15
  %length46 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %positions, i32 0, i32 3
  %58 = load i32, i32* %length46, align 8, !tbaa !36
  %call47 = call i32 @fixVertexAttribIndex(i32 %57, i32 %58)
  %v = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 0
  store i32 %call47, i32* %v, align 4, !tbaa !38
  %arrayidx48 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 1
  %59 = load i32, i32* %arrayidx48, align 4, !tbaa !15
  %length49 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %texcoords, i32 0, i32 3
  %60 = load i32, i32* %length49, align 8, !tbaa !36
  %call50 = call i32 @fixVertexAttribIndex(i32 %59, i32 %60)
  %vt = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 1
  store i32 %call50, i32* %vt, align 4, !tbaa !40
  %arrayidx51 = getelementptr inbounds [3 x i32], [3 x i32]* %rawTriplet, i64 0, i64 2
  %61 = load i32, i32* %arrayidx51, align 4, !tbaa !15
  %length52 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %62 = load i32, i32* %length52, align 8, !tbaa !36
  %call53 = call i32 @fixVertexAttribIndex(i32 %61, i32 %62)
  %vn = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 2
  store i32 %call53, i32* %vn, align 4, !tbaa !41
  %63 = bitcast %struct.IndexTriplet* %triplet to i8*
  call void @arrayAppend(%struct.Array* %faceIndices, i8* %63)
  %vn54 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %triplet, i32 0, i32 2
  %64 = load i32, i32* %vn54, align 4, !tbaa !41
  %cmp55 = icmp eq i32 %64, -1
  br i1 %cmp55, label %land.lhs.true, label %if.end60

land.lhs.true:                                    ; preds = %if.end44
  %65 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  %cmp57 = icmp ne i64 %65, -1
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %land.lhs.true
  store i8 1, i8* %generateNormals, align 1, !tbaa !24
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %land.lhs.true, %if.end44
  %66 = bitcast %struct.IndexTriplet* %triplet to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %66) #7
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then41, %if.end60
  %67 = bitcast [3 x i32]* %rawTriplet to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %67) #7
  br label %cleanup61

cleanup61:                                        ; preds = %if.end36, %cleanup, %if.then35
  %68 = bitcast %struct.Token* %tripletToken to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %68) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup93 [
    i32 0, label %cleanup.cont
    i32 4, label %for.end
  ]

cleanup.cont:                                     ; preds = %cleanup61
  br label %for.cond27

for.end:                                          ; preds = %cleanup61
  %length62 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  %69 = load i32, i32* %length62, align 8, !tbaa !26
  %cmp63 = icmp ult i32 %69, 3
  br i1 %cmp63, label %if.then65, label %if.end68

if.then65:                                        ; preds = %for.end
  %line66 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %70 = load i32, i32* %line66, align 4, !tbaa !33
  %column67 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %71 = load i32, i32* %column67, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.7, i32 0, i32 0), i32 %70, i32 %71)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup93

if.end68:                                         ; preds = %for.end
  %length69 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 1
  %72 = load i32, i32* %length69, align 8, !tbaa !26
  %cmp70 = icmp eq i32 %72, 3
  br i1 %cmp70, label %if.then72, label %if.else

if.then72:                                        ; preds = %if.end68
  %73 = bitcast %struct.Face* %face to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %73) #7
  %74 = load i32, i32* %currentMaterialIndex, align 4, !tbaa !15
  %conv73 = trunc i32 %74 to i16
  %materialIndex = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 0
  store i16 %conv73, i16* %materialIndex, align 4, !tbaa !42
  %75 = load i16, i16* %currentSmoothingGroup, align 2, !tbaa !22
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 1
  store i16 %75, i16* %smoothingGroup, align 2, !tbaa !44
  %76 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %76) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc, %if.then72
  %77 = load i32, i32* %i, align 4, !tbaa !15
  %cmp75 = icmp slt i32 %77, 3
  br i1 %cmp75, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond74
  store i32 7, i32* %cleanup.dest.slot, align 4
  %78 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %78) #7
  br label %for.end85

for.body:                                         ; preds = %for.cond74
  %indices = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 2
  %79 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom77 = sext i32 %79 to i64
  %arrayidx78 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices, i64 0, i64 %idxprom77
  %data79 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 0
  %80 = load i8*, i8** %data79, align 8, !tbaa !31
  %elementSize80 = getelementptr inbounds %struct.Array, %struct.Array* %faceIndices, i32 0, i32 3
  %81 = load i32, i32* %elementSize80, align 8, !tbaa !32
  %82 = load i32, i32* %i, align 4, !tbaa !15
  %mul81 = mul i32 %81, %82
  %idxprom82 = zext i32 %mul81 to i64
  %arrayidx83 = getelementptr inbounds i8, i8* %80, i64 %idxprom82
  %83 = bitcast i8* %arrayidx83 to %struct.IndexTriplet*
  %84 = bitcast %struct.IndexTriplet* %arrayidx78 to i8*
  %85 = bitcast %struct.IndexTriplet* %83 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %84, i8* align 4 %85, i64 12, i1 false), !tbaa.struct !45
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %86 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add nsw i32 %86, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond74

for.end85:                                        ; preds = %for.cond.cleanup
  %87 = bitcast %struct.Face* %face to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %faces, i8* %87)
  %88 = load %struct.TempObject*, %struct.TempObject** %object, align 8, !tbaa !4
  %numFaces86 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %88, i32 0, i32 2
  %89 = load i32, i32* %numFaces86, align 4, !tbaa !28
  %inc87 = add i32 %89, 1
  store i32 %inc87, i32* %numFaces86, align 4, !tbaa !28
  %90 = bitcast %struct.Face* %face to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %90) #7
  br label %if.end92

if.else:                                          ; preds = %if.end68
  %91 = bitcast i32* %prevFacesLength to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %91) #7
  %length88 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %92 = load i32, i32* %length88, align 8, !tbaa !36
  store i32 %92, i32* %prevFacesLength, align 4, !tbaa !15
  %93 = load i32, i32* %currentMaterialIndex, align 4, !tbaa !15
  %94 = load i16, i16* %currentSmoothingGroup, align 2, !tbaa !22
  call void @triangulate(%struct.Array* %faceIndices, %struct.ChunkedArray* %positions, %struct.Array* %tempFaceIndices, %struct.ChunkedArray* %faces, i32 %93, i16 zeroext %94)
  %length89 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %95 = load i32, i32* %length89, align 8, !tbaa !36
  %96 = load i32, i32* %prevFacesLength, align 4, !tbaa !15
  %sub90 = sub i32 %95, %96
  %97 = load %struct.TempObject*, %struct.TempObject** %object, align 8, !tbaa !4
  %numFaces91 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %97, i32 0, i32 2
  %98 = load i32, i32* %numFaces91, align 4, !tbaa !28
  %add = add i32 %98, %sub90
  store i32 %add, i32* %numFaces91, align 4, !tbaa !28
  %99 = bitcast i32* %prevFacesLength to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %99) #7
  br label %if.end92

if.end92:                                         ; preds = %if.else, %for.end85
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup93

cleanup93:                                        ; preds = %if.then65, %if.end92, %cleanup61
  %100 = bitcast %struct.TempObject** %object to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %100) #7
  %cleanup.dest94 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest94, label %cleanup364 [
    i32 0, label %cleanup.cont95
  ]

cleanup.cont95:                                   ; preds = %cleanup93
  br label %if.end363

if.else96:                                        ; preds = %if.end15
  %text97 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay98 = getelementptr inbounds [256 x i8], [256 x i8]* %text97, i32 0, i32 0
  %call99 = call i32 @strcasecmp(i8* %arraydecay98, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  %cmp100 = icmp eq i32 %call99, 0
  br i1 %cmp100, label %if.then108, label %lor.lhs.false102

lor.lhs.false102:                                 ; preds = %if.else96
  %text103 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay104 = getelementptr inbounds [256 x i8], [256 x i8]* %text103, i32 0, i32 0
  %call105 = call i32 @strcasecmp(i8* %arraydecay104, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0))
  %cmp106 = icmp eq i32 %call105, 0
  br i1 %cmp106, label %if.then108, label %if.else186

if.then108:                                       ; preds = %lor.lhs.false102, %if.else96
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %isGroup) #7
  %text109 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay110 = getelementptr inbounds [256 x i8], [256 x i8]* %text109, i32 0, i32 0
  %call111 = call i32 @strcasecmp(i8* %arraydecay110, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  %cmp112 = icmp eq i32 %call111, 0
  %frombool = zext i1 %cmp112 to i8
  store i8 %frombool, i8* %isGroup, align 1, !tbaa !24
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext true)
  %101 = load i8, i8* %isGroup, align 1, !tbaa !24, !range !46
  %tobool114 = trunc i8 %101 to i1
  br i1 %tobool114, label %if.then115, label %if.else129

if.then115:                                       ; preds = %if.then108
  %text116 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx117 = getelementptr inbounds [256 x i8], [256 x i8]* %text116, i64 0, i64 0
  %102 = load i8, i8* %arrayidx117, align 4, !tbaa !14
  %conv118 = sext i8 %102 to i32
  %cmp119 = icmp ne i32 %conv118, 0
  br i1 %cmp119, label %if.then121, label %if.end128

if.then121:                                       ; preds = %if.then115
  %arraydecay122 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %text123 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay124 = getelementptr inbounds [256 x i8], [256 x i8]* %text123, i32 0, i32 0
  %text125 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay126 = getelementptr inbounds [256 x i8], [256 x i8]* %text125, i32 0, i32 0
  %call127 = call i64 @strLength(i8* %arraydecay126, i64 256)
  call void @strCopy(i8* %arraydecay122, i64 64, i8* %arraydecay124, i64 %call127)
  br label %if.end128

if.end128:                                        ; preds = %if.then121, %if.then115
  br label %if.end145

if.else129:                                       ; preds = %if.then108
  %text130 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx131 = getelementptr inbounds [256 x i8], [256 x i8]* %text130, i64 0, i64 0
  %103 = load i8, i8* %arrayidx131, align 4, !tbaa !14
  %conv132 = sext i8 %103 to i32
  %cmp133 = icmp eq i32 %conv132, 0
  br i1 %cmp133, label %if.then135, label %if.end138

if.then135:                                       ; preds = %if.else129
  %line136 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %104 = load i32, i32* %line136, align 4, !tbaa !33
  %column137 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %105 = load i32, i32* %column137, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.10, i32 0, i32 0), i32 %104, i32 %105)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup183

if.end138:                                        ; preds = %if.else129
  %arraydecay139 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %text140 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay141 = getelementptr inbounds [256 x i8], [256 x i8]* %text140, i32 0, i32 0
  %text142 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay143 = getelementptr inbounds [256 x i8], [256 x i8]* %text142, i32 0, i32 0
  %call144 = call i64 @strLength(i8* %arraydecay143, i64 256)
  call void @strCopy(i8* %arraydecay139, i64 64, i8* %arraydecay141, i64 %call144)
  br label %if.end145

if.end145:                                        ; preds = %if.end138, %if.end128
  %106 = bitcast %struct.TempObject* %o146 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* %106) #7
  %name147 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 0
  %arrayidx148 = getelementptr inbounds [64 x i8], [64 x i8]* %name147, i64 0, i64 0
  store i8 0, i8* %arrayidx148, align 4, !tbaa !14
  %arrayidx149 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i64 0, i64 0
  %107 = load i8, i8* %arrayidx149, align 16, !tbaa !14
  %conv150 = sext i8 %107 to i32
  %cmp151 = icmp ne i32 %conv150, 0
  br i1 %cmp151, label %if.then153, label %if.end159

if.then153:                                       ; preds = %if.end145
  %name154 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 0
  %arraydecay155 = getelementptr inbounds [64 x i8], [64 x i8]* %name154, i32 0, i32 0
  %arraydecay156 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %arraydecay157 = getelementptr inbounds [64 x i8], [64 x i8]* %currentGroupName, i32 0, i32 0
  %call158 = call i64 @strLength(i8* %arraydecay157, i64 64)
  call void @strCopy(i8* %arraydecay155, i64 64, i8* %arraydecay156, i64 %call158)
  br label %if.end159

if.end159:                                        ; preds = %if.then153, %if.end145
  %arrayidx160 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i64 0, i64 0
  %108 = load i8, i8* %arrayidx160, align 16, !tbaa !14
  %conv161 = sext i8 %108 to i32
  %cmp162 = icmp ne i32 %conv161, 0
  br i1 %cmp162, label %if.then164, label %if.end179

if.then164:                                       ; preds = %if.end159
  %name165 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 0
  %arraydecay166 = getelementptr inbounds [64 x i8], [64 x i8]* %name165, i32 0, i32 0
  %call167 = call i64 @strLength(i8* %arraydecay166, i64 64)
  %cmp168 = icmp ugt i64 %call167, 0
  br i1 %cmp168, label %if.then170, label %if.end173

if.then170:                                       ; preds = %if.then164
  %name171 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 0
  %arraydecay172 = getelementptr inbounds [64 x i8], [64 x i8]* %name171, i32 0, i32 0
  call void @strConcat(i8* %arraydecay172, i64 64, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0), i64 1)
  br label %if.end173

if.end173:                                        ; preds = %if.then170, %if.then164
  %name174 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 0
  %arraydecay175 = getelementptr inbounds [64 x i8], [64 x i8]* %name174, i32 0, i32 0
  %arraydecay176 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %arraydecay177 = getelementptr inbounds [64 x i8], [64 x i8]* %currentObjectName, i32 0, i32 0
  %call178 = call i64 @strLength(i8* %arraydecay177, i64 64)
  call void @strConcat(i8* %arraydecay175, i64 64, i8* %arraydecay176, i64 %call178)
  br label %if.end179

if.end179:                                        ; preds = %if.end173, %if.end159
  %length180 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %109 = load i32, i32* %length180, align 8, !tbaa !36
  %firstFace181 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 1
  store i32 %109, i32* %firstFace181, align 4, !tbaa !30
  %numFaces182 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %o146, i32 0, i32 2
  store i32 0, i32* %numFaces182, align 4, !tbaa !28
  %110 = bitcast %struct.TempObject* %o146 to i8*
  call void @arrayAppend(%struct.Array* %tempObjects, i8* %110)
  %111 = bitcast %struct.TempObject* %o146 to i8*
  call void @llvm.lifetime.end.p0i8(i64 72, i8* %111) #7
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup183

cleanup183:                                       ; preds = %if.then135, %if.end179
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %isGroup) #7
  %cleanup.dest184 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest184, label %cleanup364 [
    i32 0, label %cleanup.cont185
  ]

cleanup.cont185:                                  ; preds = %cleanup183
  br label %if.end362

if.else186:                                       ; preds = %lor.lhs.false102
  %text187 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay188 = getelementptr inbounds [256 x i8], [256 x i8]* %text187, i32 0, i32 0
  %call189 = call i32 @strcasecmp(i8* %arraydecay188, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0))
  %cmp190 = icmp eq i32 %call189, 0
  br i1 %cmp190, label %if.then192, label %if.else238

if.then192:                                       ; preds = %if.else186
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext true)
  %text193 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx194 = getelementptr inbounds [256 x i8], [256 x i8]* %text193, i64 0, i64 0
  %112 = load i8, i8* %arrayidx194, align 4, !tbaa !14
  %conv195 = sext i8 %112 to i32
  %cmp196 = icmp eq i32 %conv195, 0
  br i1 %cmp196, label %if.then198, label %if.end201

if.then198:                                       ; preds = %if.then192
  %line199 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %113 = load i32, i32* %line199, align 4, !tbaa !33
  %column200 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %114 = load i32, i32* %column200, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.13, i32 0, i32 0), i32 %113, i32 %114)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup364

if.end201:                                        ; preds = %if.then192
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %alreadyLoaded) #7
  store i8 0, i8* %alreadyLoaded, align 1, !tbaa !24
  %115 = bitcast i32* %i202 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %115) #7
  store i32 0, i32* %i202, align 4, !tbaa !15
  br label %for.cond203

for.cond203:                                      ; preds = %for.inc221, %if.end201
  %116 = load i32, i32* %i202, align 4, !tbaa !15
  %length204 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 1
  %117 = load i32, i32* %length204, align 8, !tbaa !26
  %cmp205 = icmp ult i32 %116, %117
  br i1 %cmp205, label %for.body208, label %for.cond.cleanup207

for.cond.cleanup207:                              ; preds = %for.cond203
  store i32 10, i32* %cleanup.dest.slot, align 4
  br label %cleanup223

for.body208:                                      ; preds = %for.cond203
  %text209 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay210 = getelementptr inbounds [256 x i8], [256 x i8]* %text209, i32 0, i32 0
  %data211 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 0
  %118 = load i8*, i8** %data211, align 8, !tbaa !31
  %elementSize212 = getelementptr inbounds %struct.Array, %struct.Array* %materialLibs, i32 0, i32 3
  %119 = load i32, i32* %elementSize212, align 8, !tbaa !32
  %120 = load i32, i32* %i202, align 4, !tbaa !15
  %mul213 = mul i32 %119, %120
  %idxprom214 = zext i32 %mul213 to i64
  %arrayidx215 = getelementptr inbounds i8, i8* %118, i64 %idxprom214
  %call216 = call i32 @strcasecmp(i8* %arraydecay210, i8* %arrayidx215)
  %cmp217 = icmp eq i32 %call216, 0
  br i1 %cmp217, label %if.then219, label %if.end220

if.then219:                                       ; preds = %for.body208
  store i8 1, i8* %alreadyLoaded, align 1, !tbaa !24
  store i32 10, i32* %cleanup.dest.slot, align 4
  br label %cleanup223

if.end220:                                        ; preds = %for.body208
  br label %for.inc221

for.inc221:                                       ; preds = %if.end220
  %121 = load i32, i32* %i202, align 4, !tbaa !15
  %inc222 = add i32 %121, 1
  store i32 %inc222, i32* %i202, align 4, !tbaa !15
  br label %for.cond203

cleanup223:                                       ; preds = %if.then219, %for.cond.cleanup207
  %122 = bitcast i32* %i202 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %122) #7
  br label %for.end224

for.end224:                                       ; preds = %cleanup223
  %123 = load i8, i8* %alreadyLoaded, align 1, !tbaa !24, !range !46
  %tobool225 = trunc i8 %123 to i1
  br i1 %tobool225, label %if.end234, label %if.then226

if.then226:                                       ; preds = %for.end224
  %124 = load i8*, i8** %_filename.addr, align 8, !tbaa !4
  %text227 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay228 = getelementptr inbounds [256 x i8], [256 x i8]* %text227, i32 0, i32 0
  %call229 = call zeroext i1 @loadMaterialFile(i8* %124, i8* %arraydecay228, %struct.Array* %materials)
  br i1 %call229, label %if.end231, label %if.then230

if.then230:                                       ; preds = %if.then226
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup235

if.end231:                                        ; preds = %if.then226
  %text232 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay233 = getelementptr inbounds [256 x i8], [256 x i8]* %text232, i32 0, i32 0
  call void @arrayAppend(%struct.Array* %materialLibs, i8* %arraydecay233)
  br label %if.end234

if.end234:                                        ; preds = %if.end231, %for.end224
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup235

cleanup235:                                       ; preds = %if.then230, %if.end234
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %alreadyLoaded) #7
  %cleanup.dest236 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest236, label %cleanup364 [
    i32 0, label %cleanup.cont237
  ]

cleanup.cont237:                                  ; preds = %cleanup235
  br label %if.end361

if.else238:                                       ; preds = %if.else186
  %text239 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay240 = getelementptr inbounds [256 x i8], [256 x i8]* %text239, i32 0, i32 0
  %call241 = call i32 @strcasecmp(i8* %arraydecay240, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  %cmp242 = icmp eq i32 %call241, 0
  br i1 %cmp242, label %if.then244, label %if.else266

if.then244:                                       ; preds = %if.else238
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text245 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx246 = getelementptr inbounds [256 x i8], [256 x i8]* %text245, i64 0, i64 0
  %125 = load i8, i8* %arrayidx246, align 4, !tbaa !14
  %conv247 = sext i8 %125 to i32
  %cmp248 = icmp eq i32 %conv247, 0
  br i1 %cmp248, label %if.then250, label %if.end253

if.then250:                                       ; preds = %if.then244
  %line251 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %126 = load i32, i32* %line251, align 4, !tbaa !33
  %column252 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %127 = load i32, i32* %column252, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.15, i32 0, i32 0), i32 %126, i32 %127)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup364

if.end253:                                        ; preds = %if.then244
  %text254 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay255 = getelementptr inbounds [256 x i8], [256 x i8]* %text254, i32 0, i32 0
  %call256 = call i32 @strcasecmp(i8* %arraydecay255, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0))
  %cmp257 = icmp eq i32 %call256, 0
  br i1 %cmp257, label %if.then259, label %if.else260

if.then259:                                       ; preds = %if.end253
  store i16 0, i16* %currentSmoothingGroup, align 2, !tbaa !22
  br label %if.end265

if.else260:                                       ; preds = %if.end253
  %text261 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay262 = getelementptr inbounds [256 x i8], [256 x i8]* %text261, i32 0, i32 0
  %call263 = call i32 @atoi(i8* %arraydecay262)
  %conv264 = trunc i32 %call263 to i16
  store i16 %conv264, i16* %currentSmoothingGroup, align 2, !tbaa !22
  br label %if.end265

if.end265:                                        ; preds = %if.else260, %if.then259
  br label %if.end360

if.else266:                                       ; preds = %if.else238
  %text267 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay268 = getelementptr inbounds [256 x i8], [256 x i8]* %text267, i32 0, i32 0
  %call269 = call i32 @strcasecmp(i8* %arraydecay268, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i32 0, i32 0))
  %cmp270 = icmp eq i32 %call269, 0
  br i1 %cmp270, label %if.then272, label %if.else310

if.then272:                                       ; preds = %if.else266
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text273 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx274 = getelementptr inbounds [256 x i8], [256 x i8]* %text273, i64 0, i64 0
  %128 = load i8, i8* %arrayidx274, align 4, !tbaa !14
  %conv275 = sext i8 %128 to i32
  %cmp276 = icmp eq i32 %conv275, 0
  br i1 %cmp276, label %if.then278, label %if.end281

if.then278:                                       ; preds = %if.then272
  %line279 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %129 = load i32, i32* %line279, align 4, !tbaa !33
  %column280 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %130 = load i32, i32* %column280, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.18, i32 0, i32 0), i32 %129, i32 %130)
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup364

if.end281:                                        ; preds = %if.then272
  store i32 -1, i32* %currentMaterialIndex, align 4, !tbaa !15
  %131 = bitcast i32* %i282 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %131) #7
  store i32 0, i32* %i282, align 4, !tbaa !15
  br label %for.cond283

for.cond283:                                      ; preds = %for.inc306, %if.end281
  %132 = load i32, i32* %i282, align 4, !tbaa !15
  %length284 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %133 = load i32, i32* %length284, align 8, !tbaa !26
  %cmp285 = icmp ult i32 %132, %133
  br i1 %cmp285, label %for.body288, label %for.cond.cleanup287

for.cond.cleanup287:                              ; preds = %for.cond283
  store i32 13, i32* %cleanup.dest.slot, align 4
  br label %cleanup308

for.body288:                                      ; preds = %for.cond283
  %134 = bitcast %struct.objzMaterial** %mat to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %134) #7
  %data289 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 0
  %135 = load i8*, i8** %data289, align 8, !tbaa !31
  %elementSize290 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 3
  %136 = load i32, i32* %elementSize290, align 8, !tbaa !32
  %137 = load i32, i32* %i282, align 4, !tbaa !15
  %mul291 = mul i32 %136, %137
  %idxprom292 = zext i32 %mul291 to i64
  %arrayidx293 = getelementptr inbounds i8, i8* %135, i64 %idxprom292
  %138 = bitcast i8* %arrayidx293 to %struct.objzMaterial*
  store %struct.objzMaterial* %138, %struct.objzMaterial** %mat, align 8, !tbaa !4
  %139 = load %struct.objzMaterial*, %struct.objzMaterial** %mat, align 8, !tbaa !4
  %name294 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %139, i32 0, i32 0
  %arraydecay295 = getelementptr inbounds [64 x i8], [64 x i8]* %name294, i32 0, i32 0
  %text296 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay297 = getelementptr inbounds [256 x i8], [256 x i8]* %text296, i32 0, i32 0
  %call298 = call i32 @strcasecmp(i8* %arraydecay295, i8* %arraydecay297)
  %cmp299 = icmp eq i32 %call298, 0
  br i1 %cmp299, label %if.then301, label %if.end302

if.then301:                                       ; preds = %for.body288
  %140 = load i32, i32* %i282, align 4, !tbaa !15
  store i32 %140, i32* %currentMaterialIndex, align 4, !tbaa !15
  store i32 13, i32* %cleanup.dest.slot, align 4
  br label %cleanup303

if.end302:                                        ; preds = %for.body288
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup303

cleanup303:                                       ; preds = %if.end302, %if.then301
  %141 = bitcast %struct.objzMaterial** %mat to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %141) #7
  %cleanup.dest304 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest304, label %cleanup308 [
    i32 0, label %cleanup.cont305
  ]

cleanup.cont305:                                  ; preds = %cleanup303
  br label %for.inc306

for.inc306:                                       ; preds = %cleanup.cont305
  %142 = load i32, i32* %i282, align 4, !tbaa !15
  %inc307 = add i32 %142, 1
  store i32 %inc307, i32* %i282, align 4, !tbaa !15
  br label %for.cond283

cleanup308:                                       ; preds = %cleanup303, %for.cond.cleanup287
  %143 = bitcast i32* %i282 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %143) #7
  br label %for.end309

for.end309:                                       ; preds = %cleanup308
  br label %if.end359

if.else310:                                       ; preds = %if.else266
  %text311 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay312 = getelementptr inbounds [256 x i8], [256 x i8]* %text311, i32 0, i32 0
  %call313 = call i32 @strcasecmp(i8* %arraydecay312, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.19, i32 0, i32 0))
  %cmp314 = icmp eq i32 %call313, 0
  br i1 %cmp314, label %if.then316, label %if.else325

if.then316:                                       ; preds = %if.else310
  %144 = bitcast [3 x float]* %pos to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %144) #7
  %arraydecay317 = getelementptr inbounds [3 x float], [3 x float]* %pos, i32 0, i32 0
  %call318 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay317, i32 3)
  br i1 %call318, label %if.end320, label %if.then319

if.then319:                                       ; preds = %if.then316
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup322

if.end320:                                        ; preds = %if.then316
  %arraydecay321 = getelementptr inbounds [3 x float], [3 x float]* %pos, i32 0, i32 0
  %145 = bitcast float* %arraydecay321 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %positions, i8* %145)
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup322

cleanup322:                                       ; preds = %if.then319, %if.end320
  %146 = bitcast [3 x float]* %pos to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %146) #7
  %cleanup.dest323 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest323, label %cleanup364 [
    i32 0, label %cleanup.cont324
  ]

cleanup.cont324:                                  ; preds = %cleanup322
  br label %if.end358

if.else325:                                       ; preds = %if.else310
  %text326 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay327 = getelementptr inbounds [256 x i8], [256 x i8]* %text326, i32 0, i32 0
  %call328 = call i32 @strcasecmp(i8* %arraydecay327, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0))
  %cmp329 = icmp eq i32 %call328, 0
  br i1 %cmp329, label %if.then331, label %if.else340

if.then331:                                       ; preds = %if.else325
  %147 = bitcast [3 x float]* %normal to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %147) #7
  %arraydecay332 = getelementptr inbounds [3 x float], [3 x float]* %normal, i32 0, i32 0
  %call333 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay332, i32 3)
  br i1 %call333, label %if.end335, label %if.then334

if.then334:                                       ; preds = %if.then331
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup337

if.end335:                                        ; preds = %if.then331
  %arraydecay336 = getelementptr inbounds [3 x float], [3 x float]* %normal, i32 0, i32 0
  %148 = bitcast float* %arraydecay336 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %normals, i8* %148)
  %149 = load i32, i32* %flags, align 4, !tbaa !15
  %or = or i32 %149, 2
  store i32 %or, i32* %flags, align 4, !tbaa !15
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup337

cleanup337:                                       ; preds = %if.then334, %if.end335
  %150 = bitcast [3 x float]* %normal to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %150) #7
  %cleanup.dest338 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest338, label %cleanup364 [
    i32 0, label %cleanup.cont339
  ]

cleanup.cont339:                                  ; preds = %cleanup337
  br label %if.end357

if.else340:                                       ; preds = %if.else325
  %text341 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay342 = getelementptr inbounds [256 x i8], [256 x i8]* %text341, i32 0, i32 0
  %call343 = call i32 @strcasecmp(i8* %arraydecay342, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0))
  %cmp344 = icmp eq i32 %call343, 0
  br i1 %cmp344, label %if.then346, label %if.end356

if.then346:                                       ; preds = %if.else340
  %151 = bitcast [2 x float]* %texcoord to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %151) #7
  %arraydecay347 = getelementptr inbounds [2 x float], [2 x float]* %texcoord, i32 0, i32 0
  %call348 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %arraydecay347, i32 2)
  br i1 %call348, label %if.end350, label %if.then349

if.then349:                                       ; preds = %if.then346
  store i32 6, i32* %cleanup.dest.slot, align 4
  br label %cleanup353

if.end350:                                        ; preds = %if.then346
  %arraydecay351 = getelementptr inbounds [2 x float], [2 x float]* %texcoord, i32 0, i32 0
  %152 = bitcast float* %arraydecay351 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %texcoords, i8* %152)
  %153 = load i32, i32* %flags, align 4, !tbaa !15
  %or352 = or i32 %153, 1
  store i32 %or352, i32* %flags, align 4, !tbaa !15
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup353

cleanup353:                                       ; preds = %if.then349, %if.end350
  %154 = bitcast [2 x float]* %texcoord to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %154) #7
  %cleanup.dest354 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest354, label %cleanup364 [
    i32 0, label %cleanup.cont355
  ]

cleanup.cont355:                                  ; preds = %cleanup353
  br label %if.end356

if.end356:                                        ; preds = %cleanup.cont355, %if.else340
  br label %if.end357

if.end357:                                        ; preds = %if.end356, %cleanup.cont339
  br label %if.end358

if.end358:                                        ; preds = %if.end357, %cleanup.cont324
  br label %if.end359

if.end359:                                        ; preds = %if.end358, %for.end309
  br label %if.end360

if.end360:                                        ; preds = %if.end359, %if.end265
  br label %if.end361

if.end361:                                        ; preds = %if.end360, %cleanup.cont237
  br label %if.end362

if.end362:                                        ; preds = %if.end361, %cleanup.cont185
  br label %if.end363

if.end363:                                        ; preds = %if.end362, %cleanup.cont95
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup364

cleanup364:                                       ; preds = %if.then278, %if.then250, %if.then198, %if.end363, %cleanup353, %cleanup337, %cleanup322, %cleanup235, %cleanup183, %cleanup93, %if.then14
  %155 = bitcast i8** %line to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %155) #7
  %cleanup.dest365 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest365, label %cleanup823 [
    i32 0, label %cleanup.cont366
    i32 2, label %for.end367
    i32 6, label %error
  ]

cleanup.cont366:                                  ; preds = %cleanup364
  br label %for.cond

for.end367:                                       ; preds = %cleanup364
  %length368 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %156 = load i32, i32* %length368, align 8, !tbaa !36
  %cmp369 = icmp eq i32 %156, 0
  br i1 %cmp369, label %if.then371, label %if.end372

if.then371:                                       ; preds = %for.end367
  store i8 1, i8* %generateNormals, align 1, !tbaa !24
  br label %if.end372

if.end372:                                        ; preds = %if.then371, %for.end367
  call void @arrayDestroy(%struct.Array* %materialLibs)
  call void @arrayDestroy(%struct.Array* %faceIndices)
  call void @arrayDestroy(%struct.Array* %tempFaceIndices)
  call void @fileClose(%struct.File* %file)
  %length373 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %157 = load i32, i32* %length373, align 8, !tbaa !36
  call void @arrayInit(%struct.Array* %faceNormals, i64 12, i32 %157)
  %158 = load i8, i8* %generateNormals, align 1, !tbaa !24, !range !46
  %tobool374 = trunc i8 %158 to i1
  br i1 %tobool374, label %if.then375, label %if.end464

if.then375:                                       ; preds = %if.end372
  %159 = bitcast i32* %i376 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %159) #7
  store i32 0, i32* %i376, align 4, !tbaa !15
  br label %for.cond377

for.cond377:                                      ; preds = %for.inc460, %if.then375
  %160 = load i32, i32* %i376, align 4, !tbaa !15
  %length378 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %161 = load i32, i32* %length378, align 8, !tbaa !26
  %cmp379 = icmp ult i32 %160, %161
  br i1 %cmp379, label %for.body382, label %for.cond.cleanup381

for.cond.cleanup381:                              ; preds = %for.cond377
  store i32 16, i32* %cleanup.dest.slot, align 4
  %162 = bitcast i32* %i376 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %162) #7
  br label %for.end463

for.body382:                                      ; preds = %for.cond377
  %163 = bitcast %struct.TempObject** %tempObject to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %163) #7
  %data383 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %164 = load i8*, i8** %data383, align 8, !tbaa !31
  %elementSize384 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %165 = load i32, i32* %elementSize384, align 8, !tbaa !32
  %166 = load i32, i32* %i376, align 4, !tbaa !15
  %mul385 = mul i32 %165, %166
  %idxprom386 = zext i32 %mul385 to i64
  %arrayidx387 = getelementptr inbounds i8, i8* %164, i64 %idxprom386
  %167 = bitcast i8* %arrayidx387 to %struct.TempObject*
  store %struct.TempObject* %167, %struct.TempObject** %tempObject, align 8, !tbaa !4
  %168 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %168) #7
  store i32 0, i32* %j, align 4, !tbaa !15
  br label %for.cond388

for.cond388:                                      ; preds = %for.inc456, %for.body382
  %169 = load i32, i32* %j, align 4, !tbaa !15
  %170 = load %struct.TempObject*, %struct.TempObject** %tempObject, align 8, !tbaa !4
  %numFaces389 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %170, i32 0, i32 2
  %171 = load i32, i32* %numFaces389, align 4, !tbaa !28
  %cmp390 = icmp ult i32 %169, %171
  br i1 %cmp390, label %for.body393, label %for.cond.cleanup392

for.cond.cleanup392:                              ; preds = %for.cond388
  store i32 19, i32* %cleanup.dest.slot, align 4
  %172 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %172) #7
  br label %for.end459

for.body393:                                      ; preds = %for.cond388
  %173 = bitcast %struct.Face** %face394 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %173) #7
  %174 = load %struct.TempObject*, %struct.TempObject** %tempObject, align 8, !tbaa !4
  %firstFace395 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %174, i32 0, i32 1
  %175 = load i32, i32* %firstFace395, align 4, !tbaa !30
  %176 = load i32, i32* %j, align 4, !tbaa !15
  %add396 = add i32 %175, %176
  %call397 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %faces, i32 %add396)
  %177 = bitcast i8* %call397 to %struct.Face*
  store %struct.Face* %177, %struct.Face** %face394, align 8, !tbaa !4
  %178 = bitcast %struct.vec3* %edge0 to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %178) #7
  %179 = bitcast %struct.vec3* %edge1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %179) #7
  %180 = bitcast %struct.vec3* %normal398 to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %180) #7
  %181 = bitcast %struct.vec3** %p0 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %181) #7
  %182 = load %struct.Face*, %struct.Face** %face394, align 8, !tbaa !4
  %indices399 = getelementptr inbounds %struct.Face, %struct.Face* %182, i32 0, i32 2
  %arrayidx400 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices399, i64 0, i64 0
  %v401 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx400, i32 0, i32 0
  %183 = load i32, i32* %v401, align 4, !tbaa !38
  %call402 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %183)
  %184 = bitcast i8* %call402 to %struct.vec3*
  store %struct.vec3* %184, %struct.vec3** %p0, align 8, !tbaa !4
  %185 = bitcast %struct.vec3** %p1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %185) #7
  %186 = load %struct.Face*, %struct.Face** %face394, align 8, !tbaa !4
  %indices403 = getelementptr inbounds %struct.Face, %struct.Face* %186, i32 0, i32 2
  %arrayidx404 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices403, i64 0, i64 1
  %v405 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx404, i32 0, i32 0
  %187 = load i32, i32* %v405, align 4, !tbaa !38
  %call406 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %187)
  %188 = bitcast i8* %call406 to %struct.vec3*
  store %struct.vec3* %188, %struct.vec3** %p1, align 8, !tbaa !4
  %189 = bitcast %struct.vec3** %p2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %189) #7
  %190 = load %struct.Face*, %struct.Face** %face394, align 8, !tbaa !4
  %indices407 = getelementptr inbounds %struct.Face, %struct.Face* %190, i32 0, i32 2
  %arrayidx408 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices407, i64 0, i64 2
  %v409 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx408, i32 0, i32 0
  %191 = load i32, i32* %v409, align 4, !tbaa !38
  %call410 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %191)
  %192 = bitcast i8* %call410 to %struct.vec3*
  store %struct.vec3* %192, %struct.vec3** %p2, align 8, !tbaa !4
  %193 = load %struct.vec3*, %struct.vec3** %p1, align 8, !tbaa !4
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %193, i32 0, i32 0
  %194 = load float, float* %x, align 4, !tbaa !47
  %195 = load %struct.vec3*, %struct.vec3** %p0, align 8, !tbaa !4
  %x411 = getelementptr inbounds %struct.vec3, %struct.vec3* %195, i32 0, i32 0
  %196 = load float, float* %x411, align 4, !tbaa !47
  %sub412 = fsub float %194, %196
  %x413 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  store float %sub412, float* %x413, align 4, !tbaa !47
  %197 = load %struct.vec3*, %struct.vec3** %p1, align 8, !tbaa !4
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %197, i32 0, i32 1
  %198 = load float, float* %y, align 4, !tbaa !50
  %199 = load %struct.vec3*, %struct.vec3** %p0, align 8, !tbaa !4
  %y414 = getelementptr inbounds %struct.vec3, %struct.vec3* %199, i32 0, i32 1
  %200 = load float, float* %y414, align 4, !tbaa !50
  %sub415 = fsub float %198, %200
  %y416 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  store float %sub415, float* %y416, align 4, !tbaa !50
  %201 = load %struct.vec3*, %struct.vec3** %p1, align 8, !tbaa !4
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %201, i32 0, i32 2
  %202 = load float, float* %z, align 4, !tbaa !51
  %203 = load %struct.vec3*, %struct.vec3** %p0, align 8, !tbaa !4
  %z417 = getelementptr inbounds %struct.vec3, %struct.vec3* %203, i32 0, i32 2
  %204 = load float, float* %z417, align 4, !tbaa !51
  %sub418 = fsub float %202, %204
  %z419 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  store float %sub418, float* %z419, align 4, !tbaa !51
  %205 = load %struct.vec3*, %struct.vec3** %p2, align 8, !tbaa !4
  %x420 = getelementptr inbounds %struct.vec3, %struct.vec3* %205, i32 0, i32 0
  %206 = load float, float* %x420, align 4, !tbaa !47
  %207 = load %struct.vec3*, %struct.vec3** %p0, align 8, !tbaa !4
  %x421 = getelementptr inbounds %struct.vec3, %struct.vec3* %207, i32 0, i32 0
  %208 = load float, float* %x421, align 4, !tbaa !47
  %sub422 = fsub float %206, %208
  %x423 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  store float %sub422, float* %x423, align 4, !tbaa !47
  %209 = load %struct.vec3*, %struct.vec3** %p2, align 8, !tbaa !4
  %y424 = getelementptr inbounds %struct.vec3, %struct.vec3* %209, i32 0, i32 1
  %210 = load float, float* %y424, align 4, !tbaa !50
  %211 = load %struct.vec3*, %struct.vec3** %p0, align 8, !tbaa !4
  %y425 = getelementptr inbounds %struct.vec3, %struct.vec3* %211, i32 0, i32 1
  %212 = load float, float* %y425, align 4, !tbaa !50
  %sub426 = fsub float %210, %212
  %y427 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  store float %sub426, float* %y427, align 4, !tbaa !50
  %213 = load %struct.vec3*, %struct.vec3** %p2, align 8, !tbaa !4
  %z428 = getelementptr inbounds %struct.vec3, %struct.vec3* %213, i32 0, i32 2
  %214 = load float, float* %z428, align 4, !tbaa !51
  %215 = load %struct.vec3*, %struct.vec3** %p0, align 8, !tbaa !4
  %z429 = getelementptr inbounds %struct.vec3, %struct.vec3* %215, i32 0, i32 2
  %216 = load float, float* %z429, align 4, !tbaa !51
  %sub430 = fsub float %214, %216
  %z431 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  store float %sub430, float* %z431, align 4, !tbaa !51
  %y432 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  %217 = load float, float* %y432, align 4, !tbaa !50
  %z433 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  %218 = load float, float* %z433, align 4, !tbaa !51
  %mul434 = fmul float %217, %218
  %z435 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  %219 = load float, float* %z435, align 4, !tbaa !51
  %y436 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  %220 = load float, float* %y436, align 4, !tbaa !50
  %mul437 = fmul float %219, %220
  %sub438 = fsub float %mul434, %mul437
  %x439 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal398, i32 0, i32 0
  store float %sub438, float* %x439, align 4, !tbaa !47
  %z440 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 2
  %221 = load float, float* %z440, align 4, !tbaa !51
  %x441 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  %222 = load float, float* %x441, align 4, !tbaa !47
  %mul442 = fmul float %221, %222
  %x443 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  %223 = load float, float* %x443, align 4, !tbaa !47
  %z444 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 2
  %224 = load float, float* %z444, align 4, !tbaa !51
  %mul445 = fmul float %223, %224
  %sub446 = fsub float %mul442, %mul445
  %y447 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal398, i32 0, i32 1
  store float %sub446, float* %y447, align 4, !tbaa !50
  %x448 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 0
  %225 = load float, float* %x448, align 4, !tbaa !47
  %y449 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 1
  %226 = load float, float* %y449, align 4, !tbaa !50
  %mul450 = fmul float %225, %226
  %y451 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge0, i32 0, i32 1
  %227 = load float, float* %y451, align 4, !tbaa !50
  %x452 = getelementptr inbounds %struct.vec3, %struct.vec3* %edge1, i32 0, i32 0
  %228 = load float, float* %x452, align 4, !tbaa !47
  %mul453 = fmul float %227, %228
  %sub454 = fsub float %mul450, %mul453
  %z455 = getelementptr inbounds %struct.vec3, %struct.vec3* %normal398, i32 0, i32 2
  store float %sub454, float* %z455, align 4, !tbaa !51
  call void @vec3Normalize(%struct.vec3* %normal398, %struct.vec3* %normal398)
  %229 = bitcast %struct.vec3* %normal398 to i8*
  call void @arrayAppend(%struct.Array* %faceNormals, i8* %229)
  %230 = bitcast %struct.vec3** %p2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %230) #7
  %231 = bitcast %struct.vec3** %p1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %231) #7
  %232 = bitcast %struct.vec3** %p0 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %232) #7
  %233 = bitcast %struct.vec3* %normal398 to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %233) #7
  %234 = bitcast %struct.vec3* %edge1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %234) #7
  %235 = bitcast %struct.vec3* %edge0 to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %235) #7
  %236 = bitcast %struct.Face** %face394 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %236) #7
  br label %for.inc456

for.inc456:                                       ; preds = %for.body393
  %237 = load i32, i32* %j, align 4, !tbaa !15
  %inc457 = add i32 %237, 1
  store i32 %inc457, i32* %j, align 4, !tbaa !15
  br label %for.cond388

for.end459:                                       ; preds = %for.cond.cleanup392
  %238 = bitcast %struct.TempObject** %tempObject to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %238) #7
  br label %for.inc460

for.inc460:                                       ; preds = %for.end459
  %239 = load i32, i32* %i376, align 4, !tbaa !15
  %inc461 = add i32 %239, 1
  store i32 %inc461, i32* %i376, align 4, !tbaa !15
  br label %for.cond377

for.end463:                                       ; preds = %for.cond.cleanup381
  br label %if.end464

if.end464:                                        ; preds = %for.end463, %if.end372
  %length466 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %240 = load i32, i32* %length466, align 8, !tbaa !26
  %mul467 = mul i32 %240, 4
  call void @arrayInit(%struct.Array* %meshes, i64 12, i32 %mul467)
  %length468 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %241 = load i32, i32* %length468, align 8, !tbaa !26
  call void @arrayInit(%struct.Array* %objects, i64 88, i32 %241)
  %length469 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %faces, i32 0, i32 3
  %242 = load i32, i32* %length469, align 8, !tbaa !36
  %mul470 = mul i32 %242, 3
  call void @arrayInit(%struct.Array* %indices465, i64 4, i32 %mul470)
  %length471 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %positions, i32 0, i32 3
  %243 = load i32, i32* %length471, align 8, !tbaa !36
  %mul472 = mul i32 %243, 2
  call void @vertexHashMapInit(%struct.VertexHashMap* %vertexHashMap, i32 %mul472)
  %244 = load i8, i8* %generateNormals, align 1, !tbaa !24, !range !46
  %tobool473 = trunc i8 %244 to i1
  br i1 %tobool473, label %if.then474, label %if.end502

if.then474:                                       ; preds = %if.end464
  %245 = bitcast i32* %maxObjectFaces to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %245) #7
  store i32 0, i32* %maxObjectFaces, align 4, !tbaa !15
  %246 = bitcast i32* %i475 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %246) #7
  store i32 0, i32* %i475, align 4, !tbaa !15
  br label %for.cond476

for.cond476:                                      ; preds = %for.inc492, %if.then474
  %247 = load i32, i32* %i475, align 4, !tbaa !15
  %length477 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %248 = load i32, i32* %length477, align 8, !tbaa !26
  %cmp478 = icmp ult i32 %247, %248
  br i1 %cmp478, label %for.body481, label %for.cond.cleanup480

for.cond.cleanup480:                              ; preds = %for.cond476
  store i32 22, i32* %cleanup.dest.slot, align 4
  %249 = bitcast i32* %i475 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %249) #7
  br label %for.end495

for.body481:                                      ; preds = %for.cond476
  %250 = bitcast %struct.TempObject** %tempObject482 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %250) #7
  %data483 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %251 = load i8*, i8** %data483, align 8, !tbaa !31
  %elementSize484 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %252 = load i32, i32* %elementSize484, align 8, !tbaa !32
  %253 = load i32, i32* %i475, align 4, !tbaa !15
  %mul485 = mul i32 %252, %253
  %idxprom486 = zext i32 %mul485 to i64
  %arrayidx487 = getelementptr inbounds i8, i8* %251, i64 %idxprom486
  %254 = bitcast i8* %arrayidx487 to %struct.TempObject*
  store %struct.TempObject* %254, %struct.TempObject** %tempObject482, align 8, !tbaa !4
  %255 = load i32, i32* %maxObjectFaces, align 4, !tbaa !15
  %256 = load %struct.TempObject*, %struct.TempObject** %tempObject482, align 8, !tbaa !4
  %numFaces488 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %256, i32 0, i32 2
  %257 = load i32, i32* %numFaces488, align 4, !tbaa !28
  %cmp489 = icmp ugt i32 %255, %257
  br i1 %cmp489, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body481
  %258 = load i32, i32* %maxObjectFaces, align 4, !tbaa !15
  br label %cond.end

cond.false:                                       ; preds = %for.body481
  %259 = load %struct.TempObject*, %struct.TempObject** %tempObject482, align 8, !tbaa !4
  %numFaces491 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %259, i32 0, i32 2
  %260 = load i32, i32* %numFaces491, align 4, !tbaa !28
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %258, %cond.true ], [ %260, %cond.false ]
  store i32 %cond, i32* %maxObjectFaces, align 4, !tbaa !15
  %261 = bitcast %struct.TempObject** %tempObject482 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %261) #7
  br label %for.inc492

for.inc492:                                       ; preds = %cond.end
  %262 = load i32, i32* %i475, align 4, !tbaa !15
  %inc493 = add i32 %262, 1
  store i32 %inc493, i32* %i475, align 4, !tbaa !15
  br label %for.cond476

for.end495:                                       ; preds = %for.cond.cleanup480
  %263 = load i32, i32* %maxObjectFaces, align 4, !tbaa !15
  %cmp496 = icmp ugt i32 %263, 32
  br i1 %cmp496, label %cond.true498, label %cond.false499

cond.true498:                                     ; preds = %for.end495
  %264 = load i32, i32* %maxObjectFaces, align 4, !tbaa !15
  br label %cond.end500

cond.false499:                                    ; preds = %for.end495
  br label %cond.end500

cond.end500:                                      ; preds = %cond.false499, %cond.true498
  %cond501 = phi i32 [ %264, %cond.true498 ], [ 32, %cond.false499 ]
  call void @normalHashMapInit(%struct.NormalHashMap* %normalHashMap, i32 %cond501, %struct.ChunkedArray* %normals)
  %265 = bitcast i32* %maxObjectFaces to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %265) #7
  br label %if.end502

if.end502:                                        ; preds = %cond.end500, %if.end464
  %266 = bitcast i32* %i503 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %266) #7
  store i32 0, i32* %i503, align 4, !tbaa !15
  br label %for.cond504

for.cond504:                                      ; preds = %for.inc689, %if.end502
  %267 = load i32, i32* %i503, align 4, !tbaa !15
  %length505 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 1
  %268 = load i32, i32* %length505, align 8, !tbaa !26
  %cmp506 = icmp ult i32 %267, %268
  br i1 %cmp506, label %for.body509, label %for.cond.cleanup508

for.cond.cleanup508:                              ; preds = %for.cond504
  store i32 25, i32* %cleanup.dest.slot, align 4
  %269 = bitcast i32* %i503 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %269) #7
  br label %for.end692

for.body509:                                      ; preds = %for.cond504
  %270 = bitcast %struct.TempObject** %tempObject510 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %270) #7
  %data511 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 0
  %271 = load i8*, i8** %data511, align 8, !tbaa !31
  %elementSize512 = getelementptr inbounds %struct.Array, %struct.Array* %tempObjects, i32 0, i32 3
  %272 = load i32, i32* %elementSize512, align 8, !tbaa !32
  %273 = load i32, i32* %i503, align 4, !tbaa !15
  %mul513 = mul i32 %272, %273
  %idxprom514 = zext i32 %mul513 to i64
  %arrayidx515 = getelementptr inbounds i8, i8* %271, i64 %idxprom514
  %274 = bitcast i8* %arrayidx515 to %struct.TempObject*
  store %struct.TempObject* %274, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %275 = load %struct.TempObject*, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %numFaces516 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %275, i32 0, i32 2
  %276 = load i32, i32* %numFaces516, align 4, !tbaa !28
  %tobool517 = icmp ne i32 %276, 0
  br i1 %tobool517, label %if.end519, label %if.then518

if.then518:                                       ; preds = %for.body509
  store i32 27, i32* %cleanup.dest.slot, align 4
  br label %cleanup686

if.end519:                                        ; preds = %for.body509
  %277 = bitcast %struct.objzObject* %object520 to i8*
  call void @llvm.lifetime.start.p0i8(i64 88, i8* %277) #7
  %name521 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 0
  %arraydecay522 = getelementptr inbounds [64 x i8], [64 x i8]* %name521, i32 0, i32 0
  %278 = load %struct.TempObject*, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %name523 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %278, i32 0, i32 0
  %arraydecay524 = getelementptr inbounds [64 x i8], [64 x i8]* %name523, i32 0, i32 0
  %279 = load %struct.TempObject*, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %name525 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %279, i32 0, i32 0
  %arraydecay526 = getelementptr inbounds [64 x i8], [64 x i8]* %name525, i32 0, i32 0
  %call527 = call i64 @strLength(i8* %arraydecay526, i64 64)
  call void @strCopy(i8* %arraydecay522, i64 64, i8* %arraydecay524, i64 %call527)
  %280 = load i8, i8* %generateNormals, align 1, !tbaa !24, !range !46
  %tobool528 = trunc i8 %280 to i1
  br i1 %tobool528, label %if.then529, label %if.end530

if.then529:                                       ; preds = %if.end519
  call void @normalHashMapClear(%struct.NormalHashMap* %normalHashMap)
  br label %if.end530

if.end530:                                        ; preds = %if.then529, %if.end519
  %length531 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 1
  %281 = load i32, i32* %length531, align 8, !tbaa !26
  %firstMesh = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 1
  store i32 %281, i32* %firstMesh, align 4, !tbaa !52
  %numMeshes = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 2
  store i32 0, i32* %numMeshes, align 4, !tbaa !54
  %282 = bitcast i32* %material to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %282) #7
  store i32 -1, i32* %material, align 4, !tbaa !15
  br label %for.cond532

for.cond532:                                      ; preds = %for.inc653, %if.end530
  %283 = load i32, i32* %material, align 4, !tbaa !15
  %length533 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %284 = load i32, i32* %length533, align 8, !tbaa !26
  %cmp534 = icmp slt i32 %283, %284
  br i1 %cmp534, label %for.body537, label %for.cond.cleanup536

for.cond.cleanup536:                              ; preds = %for.cond532
  store i32 28, i32* %cleanup.dest.slot, align 4
  %285 = bitcast i32* %material to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %285) #7
  br label %for.end656

for.body537:                                      ; preds = %for.cond532
  %286 = bitcast %struct.objzMesh* %mesh to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %286) #7
  %length538 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 1
  %287 = load i32, i32* %length538, align 8, !tbaa !26
  %firstIndex = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 1
  store i32 %287, i32* %firstIndex, align 4, !tbaa !40
  %numIndices = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  store i32 0, i32* %numIndices, align 4, !tbaa !41
  %288 = load i32, i32* %material, align 4, !tbaa !15
  %materialIndex539 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 0
  store i32 %288, i32* %materialIndex539, align 4, !tbaa !38
  %289 = bitcast i32* %j540 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %289) #7
  store i32 0, i32* %j540, align 4, !tbaa !15
  br label %for.cond541

for.cond541:                                      ; preds = %for.inc642, %for.body537
  %290 = load i32, i32* %j540, align 4, !tbaa !15
  %291 = load %struct.TempObject*, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %numFaces542 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %291, i32 0, i32 2
  %292 = load i32, i32* %numFaces542, align 4, !tbaa !28
  %cmp543 = icmp ult i32 %290, %292
  br i1 %cmp543, label %for.body546, label %for.cond.cleanup545

for.cond.cleanup545:                              ; preds = %for.cond541
  store i32 31, i32* %cleanup.dest.slot, align 4
  %293 = bitcast i32* %j540 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %293) #7
  br label %for.end645

for.body546:                                      ; preds = %for.cond541
  %294 = bitcast %struct.Face** %face547 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %294) #7
  %295 = load %struct.TempObject*, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %firstFace548 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %295, i32 0, i32 1
  %296 = load i32, i32* %firstFace548, align 4, !tbaa !30
  %297 = load i32, i32* %j540, align 4, !tbaa !15
  %add549 = add i32 %296, %297
  %call550 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %faces, i32 %add549)
  %298 = bitcast i8* %call550 to %struct.Face*
  store %struct.Face* %298, %struct.Face** %face547, align 8, !tbaa !4
  %299 = load %struct.Face*, %struct.Face** %face547, align 8, !tbaa !4
  %materialIndex551 = getelementptr inbounds %struct.Face, %struct.Face* %299, i32 0, i32 0
  %300 = load i16, i16* %materialIndex551, align 4, !tbaa !42
  %conv552 = sext i16 %300 to i32
  %301 = load i32, i32* %material, align 4, !tbaa !15
  %conv553 = trunc i32 %301 to i16
  %conv554 = sext i16 %conv553 to i32
  %cmp555 = icmp ne i32 %conv552, %conv554
  br i1 %cmp555, label %if.then557, label %if.end558

if.then557:                                       ; preds = %for.body546
  store i32 33, i32* %cleanup.dest.slot, align 4
  br label %cleanup639

if.end558:                                        ; preds = %for.body546
  %302 = bitcast i32* %faceNormalIndex to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %302) #7
  store i32 -1, i32* %faceNormalIndex, align 4, !tbaa !15
  %303 = load i8, i8* %generateNormals, align 1, !tbaa !24, !range !46
  %tobool559 = trunc i8 %303 to i1
  br i1 %tobool559, label %land.lhs.true561, label %if.end593

land.lhs.true561:                                 ; preds = %if.end558
  %304 = load %struct.Face*, %struct.Face** %face547, align 8, !tbaa !4
  %smoothingGroup562 = getelementptr inbounds %struct.Face, %struct.Face* %304, i32 0, i32 1
  %305 = load i16, i16* %smoothingGroup562, align 2, !tbaa !44
  %conv563 = zext i16 %305 to i32
  %cmp564 = icmp eq i32 %conv563, 0
  br i1 %cmp564, label %if.then566, label %if.end593

if.then566:                                       ; preds = %land.lhs.true561
  %306 = bitcast i32* %k to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %306) #7
  store i32 0, i32* %k, align 4, !tbaa !15
  br label %for.cond567

for.cond567:                                      ; preds = %for.inc589, %if.then566
  %307 = load i32, i32* %k, align 4, !tbaa !15
  %cmp568 = icmp slt i32 %307, 3
  br i1 %cmp568, label %for.body571, label %for.cond.cleanup570

for.cond.cleanup570:                              ; preds = %for.cond567
  store i32 34, i32* %cleanup.dest.slot, align 4
  br label %cleanup591

for.body571:                                      ; preds = %for.cond567
  %308 = load %struct.Face*, %struct.Face** %face547, align 8, !tbaa !4
  %indices572 = getelementptr inbounds %struct.Face, %struct.Face* %308, i32 0, i32 2
  %309 = load i32, i32* %k, align 4, !tbaa !15
  %idxprom573 = sext i32 %309 to i64
  %arrayidx574 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices572, i64 0, i64 %idxprom573
  %vn575 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx574, i32 0, i32 2
  %310 = load i32, i32* %vn575, align 4, !tbaa !41
  %length576 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %normals, i32 0, i32 3
  %311 = load i32, i32* %length576, align 8, !tbaa !36
  %cmp577 = icmp uge i32 %310, %311
  br i1 %cmp577, label %if.then579, label %if.end588

if.then579:                                       ; preds = %for.body571
  %data580 = getelementptr inbounds %struct.Array, %struct.Array* %faceNormals, i32 0, i32 0
  %312 = load i8*, i8** %data580, align 8, !tbaa !31
  %elementSize581 = getelementptr inbounds %struct.Array, %struct.Array* %faceNormals, i32 0, i32 3
  %313 = load i32, i32* %elementSize581, align 8, !tbaa !32
  %314 = load %struct.TempObject*, %struct.TempObject** %tempObject510, align 8, !tbaa !4
  %firstFace582 = getelementptr inbounds %struct.TempObject, %struct.TempObject* %314, i32 0, i32 1
  %315 = load i32, i32* %firstFace582, align 4, !tbaa !30
  %316 = load i32, i32* %j540, align 4, !tbaa !15
  %add583 = add i32 %315, %316
  %mul584 = mul i32 %313, %add583
  %idxprom585 = zext i32 %mul584 to i64
  %arrayidx586 = getelementptr inbounds i8, i8* %312, i64 %idxprom585
  %317 = bitcast i8* %arrayidx586 to %struct.vec3*
  %call587 = call i32 @normalHashMapInsert(%struct.NormalHashMap* %normalHashMap, %struct.vec3* %317)
  store i32 %call587, i32* %faceNormalIndex, align 4, !tbaa !15
  store i32 34, i32* %cleanup.dest.slot, align 4
  br label %cleanup591

if.end588:                                        ; preds = %for.body571
  br label %for.inc589

for.inc589:                                       ; preds = %if.end588
  %318 = load i32, i32* %k, align 4, !tbaa !15
  %inc590 = add nsw i32 %318, 1
  store i32 %inc590, i32* %k, align 4, !tbaa !15
  br label %for.cond567

cleanup591:                                       ; preds = %if.then579, %for.cond.cleanup570
  %319 = bitcast i32* %k to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %319) #7
  br label %for.end592

for.end592:                                       ; preds = %cleanup591
  br label %if.end593

if.end593:                                        ; preds = %for.end592, %land.lhs.true561, %if.end558
  %320 = bitcast i32* %k594 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %320) #7
  store i32 0, i32* %k594, align 4, !tbaa !15
  br label %for.cond595

for.cond595:                                      ; preds = %for.inc635, %if.end593
  %321 = load i32, i32* %k594, align 4, !tbaa !15
  %cmp596 = icmp slt i32 %321, 3
  br i1 %cmp596, label %for.body599, label %for.cond.cleanup598

for.cond.cleanup598:                              ; preds = %for.cond595
  store i32 37, i32* %cleanup.dest.slot, align 4
  %322 = bitcast i32* %k594 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %322) #7
  br label %for.end638

for.body599:                                      ; preds = %for.cond595
  %323 = bitcast %struct.IndexTriplet** %triplet600 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %323) #7
  %324 = load %struct.Face*, %struct.Face** %face547, align 8, !tbaa !4
  %indices601 = getelementptr inbounds %struct.Face, %struct.Face* %324, i32 0, i32 2
  %325 = load i32, i32* %k594, align 4, !tbaa !15
  %idxprom602 = sext i32 %325 to i64
  %arrayidx603 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices601, i64 0, i64 %idxprom602
  store %struct.IndexTriplet* %arrayidx603, %struct.IndexTriplet** %triplet600, align 8, !tbaa !4
  %326 = bitcast i32* %vn604 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %326) #7
  %327 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet600, align 8, !tbaa !4
  %vn605 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %327, i32 0, i32 2
  %328 = load i32, i32* %vn605, align 4, !tbaa !41
  store i32 %328, i32* %vn604, align 4, !tbaa !15
  %329 = load i8, i8* %generateNormals, align 1, !tbaa !24, !range !46
  %tobool606 = trunc i8 %329 to i1
  br i1 %tobool606, label %if.then607, label %if.end624

if.then607:                                       ; preds = %for.body599
  %330 = load %struct.Face*, %struct.Face** %face547, align 8, !tbaa !4
  %smoothingGroup608 = getelementptr inbounds %struct.Face, %struct.Face* %330, i32 0, i32 1
  %331 = load i16, i16* %smoothingGroup608, align 2, !tbaa !44
  %conv609 = zext i16 %331 to i32
  %cmp610 = icmp sgt i32 %conv609, 0
  br i1 %cmp610, label %if.then612, label %if.else618

if.then612:                                       ; preds = %if.then607
  %332 = bitcast %struct.vec3* %normal613 to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %332) #7
  %333 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet600, align 8, !tbaa !4
  %v614 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %333, i32 0, i32 0
  %334 = load i32, i32* %v614, align 4, !tbaa !38
  %335 = load %struct.Face*, %struct.Face** %face547, align 8, !tbaa !4
  %smoothingGroup615 = getelementptr inbounds %struct.Face, %struct.Face* %335, i32 0, i32 1
  %336 = load i16, i16* %smoothingGroup615, align 2, !tbaa !44
  %call616 = call { <2 x float>, float } @calculateSmoothNormal(i32 %334, %struct.ChunkedArray* %faces, %struct.Array* %faceNormals, i16 zeroext %336)
  store { <2 x float>, float } %call616, { <2 x float>, float }* %tmp, align 8
  %337 = bitcast { <2 x float>, float }* %tmp to i8*
  %338 = bitcast %struct.vec3* %normal613 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %338, i8* align 8 %337, i64 12, i1 false)
  %call617 = call i32 @normalHashMapInsert(%struct.NormalHashMap* %normalHashMap, %struct.vec3* %normal613)
  store i32 %call617, i32* %vn604, align 4, !tbaa !15
  %339 = bitcast %struct.vec3* %normal613 to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %339) #7
  br label %if.end623

if.else618:                                       ; preds = %if.then607
  %340 = load i32, i32* %faceNormalIndex, align 4, !tbaa !15
  %cmp619 = icmp ne i32 %340, -1
  br i1 %cmp619, label %if.then621, label %if.end622

if.then621:                                       ; preds = %if.else618
  %341 = load i32, i32* %faceNormalIndex, align 4, !tbaa !15
  store i32 %341, i32* %vn604, align 4, !tbaa !15
  br label %if.end622

if.end622:                                        ; preds = %if.then621, %if.else618
  br label %if.end623

if.end623:                                        ; preds = %if.end622, %if.then612
  br label %if.end624

if.end624:                                        ; preds = %if.end623, %for.body599
  %342 = bitcast i32* %index to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %342) #7
  %343 = load i32, i32* %i503, align 4, !tbaa !15
  %344 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet600, align 8, !tbaa !4
  %v625 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %344, i32 0, i32 0
  %345 = load i32, i32* %v625, align 4, !tbaa !38
  %346 = load %struct.IndexTriplet*, %struct.IndexTriplet** %triplet600, align 8, !tbaa !4
  %vt626 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %346, i32 0, i32 1
  %347 = load i32, i32* %vt626, align 4, !tbaa !40
  %348 = load i32, i32* %vn604, align 4, !tbaa !15
  %call627 = call i32 @vertexHashMapInsert(%struct.VertexHashMap* %vertexHashMap, i32 %343, i32 %345, i32 %347, i32 %348)
  store i32 %call627, i32* %index, align 4, !tbaa !15
  %349 = load i32, i32* %index, align 4, !tbaa !15
  %cmp628 = icmp ugt i32 %349, 65535
  br i1 %cmp628, label %if.then630, label %if.end632

if.then630:                                       ; preds = %if.end624
  %350 = load i32, i32* %flags, align 4, !tbaa !15
  %or631 = or i32 %350, 4
  store i32 %or631, i32* %flags, align 4, !tbaa !15
  br label %if.end632

if.end632:                                        ; preds = %if.then630, %if.end624
  %351 = bitcast i32* %index to i8*
  call void @arrayAppend(%struct.Array* %indices465, i8* %351)
  %numIndices633 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  %352 = load i32, i32* %numIndices633, align 4, !tbaa !41
  %inc634 = add i32 %352, 1
  store i32 %inc634, i32* %numIndices633, align 4, !tbaa !41
  %353 = bitcast i32* %index to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %353) #7
  %354 = bitcast i32* %vn604 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %354) #7
  %355 = bitcast %struct.IndexTriplet** %triplet600 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %355) #7
  br label %for.inc635

for.inc635:                                       ; preds = %if.end632
  %356 = load i32, i32* %k594, align 4, !tbaa !15
  %inc636 = add nsw i32 %356, 1
  store i32 %inc636, i32* %k594, align 4, !tbaa !15
  br label %for.cond595

for.end638:                                       ; preds = %for.cond.cleanup598
  %357 = bitcast i32* %faceNormalIndex to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %357) #7
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup639

cleanup639:                                       ; preds = %for.end638, %if.then557
  %358 = bitcast %struct.Face** %face547 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %358) #7
  %cleanup.dest640 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest640, label %unreachable [
    i32 0, label %cleanup.cont641
    i32 33, label %for.inc642
  ]

cleanup.cont641:                                  ; preds = %cleanup639
  br label %for.inc642

for.inc642:                                       ; preds = %cleanup.cont641, %cleanup639
  %359 = load i32, i32* %j540, align 4, !tbaa !15
  %inc643 = add i32 %359, 1
  store i32 %inc643, i32* %j540, align 4, !tbaa !15
  br label %for.cond541

for.end645:                                       ; preds = %for.cond.cleanup545
  %numIndices646 = getelementptr inbounds %struct.objzMesh, %struct.objzMesh* %mesh, i32 0, i32 2
  %360 = load i32, i32* %numIndices646, align 4, !tbaa !41
  %cmp647 = icmp ugt i32 %360, 0
  br i1 %cmp647, label %if.then649, label %if.end652

if.then649:                                       ; preds = %for.end645
  %361 = bitcast %struct.objzMesh* %mesh to i8*
  call void @arrayAppend(%struct.Array* %meshes, i8* %361)
  %numMeshes650 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 2
  %362 = load i32, i32* %numMeshes650, align 4, !tbaa !54
  %inc651 = add i32 %362, 1
  store i32 %inc651, i32* %numMeshes650, align 4, !tbaa !54
  br label %if.end652

if.end652:                                        ; preds = %if.then649, %for.end645
  %363 = bitcast %struct.objzMesh* %mesh to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %363) #7
  br label %for.inc653

for.inc653:                                       ; preds = %if.end652
  %364 = load i32, i32* %material, align 4, !tbaa !15
  %inc654 = add nsw i32 %364, 1
  store i32 %inc654, i32* %material, align 4, !tbaa !15
  br label %for.cond532

for.end656:                                       ; preds = %for.cond.cleanup536
  %length657 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %365 = load i32, i32* %length657, align 8, !tbaa !26
  %cmp658 = icmp ugt i32 %365, 0
  br i1 %cmp658, label %if.then660, label %if.else674

if.then660:                                       ; preds = %for.end656
  %366 = bitcast %struct.objzObject** %prev to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %366) #7
  %data661 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 0
  %367 = load i8*, i8** %data661, align 8, !tbaa !31
  %elementSize662 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 3
  %368 = load i32, i32* %elementSize662, align 8, !tbaa !32
  %length663 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %369 = load i32, i32* %length663, align 8, !tbaa !26
  %sub664 = sub i32 %369, 1
  %mul665 = mul i32 %368, %sub664
  %idxprom666 = zext i32 %mul665 to i64
  %arrayidx667 = getelementptr inbounds i8, i8* %367, i64 %idxprom666
  %370 = bitcast i8* %arrayidx667 to %struct.objzObject*
  store %struct.objzObject* %370, %struct.objzObject** %prev, align 8, !tbaa !4
  %371 = load %struct.objzObject*, %struct.objzObject** %prev, align 8, !tbaa !4
  %firstIndex668 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %371, i32 0, i32 3
  %372 = load i32, i32* %firstIndex668, align 4, !tbaa !55
  %373 = load %struct.objzObject*, %struct.objzObject** %prev, align 8, !tbaa !4
  %numIndices669 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %373, i32 0, i32 4
  %374 = load i32, i32* %numIndices669, align 4, !tbaa !56
  %add670 = add i32 %372, %374
  %firstIndex671 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 3
  store i32 %add670, i32* %firstIndex671, align 4, !tbaa !55
  %375 = load %struct.objzObject*, %struct.objzObject** %prev, align 8, !tbaa !4
  %firstVertex = getelementptr inbounds %struct.objzObject, %struct.objzObject* %375, i32 0, i32 5
  %376 = load i32, i32* %firstVertex, align 4, !tbaa !57
  %377 = load %struct.objzObject*, %struct.objzObject** %prev, align 8, !tbaa !4
  %numVertices = getelementptr inbounds %struct.objzObject, %struct.objzObject* %377, i32 0, i32 6
  %378 = load i32, i32* %numVertices, align 4, !tbaa !58
  %add672 = add i32 %376, %378
  %firstVertex673 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 5
  store i32 %add672, i32* %firstVertex673, align 4, !tbaa !57
  %379 = bitcast %struct.objzObject** %prev to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %379) #7
  br label %if.end677

if.else674:                                       ; preds = %for.end656
  %firstIndex675 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 3
  store i32 0, i32* %firstIndex675, align 4, !tbaa !55
  %firstVertex676 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 5
  store i32 0, i32* %firstVertex676, align 4, !tbaa !57
  br label %if.end677

if.end677:                                        ; preds = %if.else674, %if.then660
  %length678 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 1
  %380 = load i32, i32* %length678, align 8, !tbaa !26
  %firstIndex679 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 3
  %381 = load i32, i32* %firstIndex679, align 4, !tbaa !55
  %sub680 = sub i32 %380, %381
  %numIndices681 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 4
  store i32 %sub680, i32* %numIndices681, align 4, !tbaa !56
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length682 = getelementptr inbounds %struct.Array, %struct.Array* %vertices, i32 0, i32 1
  %382 = load i32, i32* %length682, align 8, !tbaa !59
  %firstVertex683 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 5
  %383 = load i32, i32* %firstVertex683, align 4, !tbaa !57
  %sub684 = sub i32 %382, %383
  %numVertices685 = getelementptr inbounds %struct.objzObject, %struct.objzObject* %object520, i32 0, i32 6
  store i32 %sub684, i32* %numVertices685, align 4, !tbaa !58
  %384 = bitcast %struct.objzObject* %object520 to i8*
  call void @arrayAppend(%struct.Array* %objects, i8* %384)
  %385 = bitcast %struct.objzObject* %object520 to i8*
  call void @llvm.lifetime.end.p0i8(i64 88, i8* %385) #7
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup686

cleanup686:                                       ; preds = %if.end677, %if.then518
  %386 = bitcast %struct.TempObject** %tempObject510 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %386) #7
  %cleanup.dest687 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest687, label %unreachable [
    i32 0, label %cleanup.cont688
    i32 27, label %for.inc689
  ]

cleanup.cont688:                                  ; preds = %cleanup686
  br label %for.inc689

for.inc689:                                       ; preds = %cleanup.cont688, %cleanup686
  %387 = load i32, i32* %i503, align 4, !tbaa !15
  %inc690 = add i32 %387, 1
  store i32 %inc690, i32* %i503, align 4, !tbaa !15
  br label %for.cond504

for.end692:                                       ; preds = %for.cond.cleanup508
  %388 = load i8, i8* %generateNormals, align 1, !tbaa !24, !range !46
  %tobool693 = trunc i8 %388 to i1
  br i1 %tobool693, label %if.then694, label %if.end695

if.then694:                                       ; preds = %for.end692
  call void @normalHashMapDestroy(%struct.NormalHashMap* %normalHashMap)
  br label %if.end695

if.end695:                                        ; preds = %if.then694, %for.end692
  call void @arrayDestroy(%struct.Array* %tempObjects)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %faces)
  call void @arrayDestroy(%struct.Array* %faceNormals)
  %call696 = call i8* @objz_realloc(i8* null, i64 88, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1181)
  %389 = bitcast i8* %call696 to %struct.objzModel*
  store %struct.objzModel* %389, %struct.objzModel** %model, align 8, !tbaa !4
  %390 = load i32, i32* %flags, align 4, !tbaa !15
  %391 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %flags697 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %391, i32 0, i32 0
  store i32 %390, i32* %flags697, align 8, !tbaa !61
  %392 = load i32, i32* @s_indexFormat, align 4, !tbaa !15
  %cmp698 = icmp eq i32 %392, 1
  br i1 %cmp698, label %if.then702, label %lor.lhs.false700

lor.lhs.false700:                                 ; preds = %if.end695
  %393 = load i32, i32* %flags, align 4, !tbaa !15
  %and = and i32 %393, 4
  %tobool701 = icmp ne i32 %and, 0
  br i1 %tobool701, label %if.then702, label %if.else705

if.then702:                                       ; preds = %lor.lhs.false700, %if.end695
  %data703 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 0
  %394 = load i8*, i8** %data703, align 8, !tbaa !31
  %395 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %indices704 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %395, i32 0, i32 1
  store i8* %394, i8** %indices704, align 8, !tbaa !63
  br label %if.end733

if.else705:                                       ; preds = %lor.lhs.false700
  %396 = load i32, i32* %flags, align 4, !tbaa !15
  %and706 = and i32 %396, -5
  store i32 %and706, i32* %flags, align 4, !tbaa !15
  %length707 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 1
  %397 = load i32, i32* %length707, align 8, !tbaa !26
  %conv708 = zext i32 %397 to i64
  %mul709 = mul i64 2, %conv708
  %call710 = call i8* @objz_realloc(i8* null, i64 %mul709, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1187)
  %398 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %indices711 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %398, i32 0, i32 1
  store i8* %call710, i8** %indices711, align 8, !tbaa !63
  %399 = bitcast i32* %i712 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %399) #7
  store i32 0, i32* %i712, align 4, !tbaa !15
  br label %for.cond713

for.cond713:                                      ; preds = %for.inc729, %if.else705
  %400 = load i32, i32* %i712, align 4, !tbaa !15
  %length714 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 1
  %401 = load i32, i32* %length714, align 8, !tbaa !26
  %cmp715 = icmp ult i32 %400, %401
  br i1 %cmp715, label %for.body718, label %for.cond.cleanup717

for.cond.cleanup717:                              ; preds = %for.cond713
  store i32 40, i32* %cleanup.dest.slot, align 4
  %402 = bitcast i32* %i712 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %402) #7
  br label %for.end732

for.body718:                                      ; preds = %for.cond713
  %403 = bitcast i32** %index719 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %403) #7
  %data720 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 0
  %404 = load i8*, i8** %data720, align 8, !tbaa !31
  %elementSize721 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 3
  %405 = load i32, i32* %elementSize721, align 8, !tbaa !32
  %406 = load i32, i32* %i712, align 4, !tbaa !15
  %mul722 = mul i32 %405, %406
  %idxprom723 = zext i32 %mul722 to i64
  %arrayidx724 = getelementptr inbounds i8, i8* %404, i64 %idxprom723
  %407 = bitcast i8* %arrayidx724 to i32*
  store i32* %407, i32** %index719, align 8, !tbaa !4
  %408 = load i32*, i32** %index719, align 8, !tbaa !4
  %409 = load i32, i32* %408, align 4, !tbaa !15
  %conv725 = trunc i32 %409 to i16
  %410 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %indices726 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %410, i32 0, i32 1
  %411 = load i8*, i8** %indices726, align 8, !tbaa !63
  %412 = bitcast i8* %411 to i16*
  %413 = load i32, i32* %i712, align 4, !tbaa !15
  %idxprom727 = zext i32 %413 to i64
  %arrayidx728 = getelementptr inbounds i16, i16* %412, i64 %idxprom727
  store i16 %conv725, i16* %arrayidx728, align 2, !tbaa !22
  %414 = bitcast i32** %index719 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %414) #7
  br label %for.inc729

for.inc729:                                       ; preds = %for.body718
  %415 = load i32, i32* %i712, align 4, !tbaa !15
  %inc730 = add i32 %415, 1
  store i32 %inc730, i32* %i712, align 4, !tbaa !15
  br label %for.cond713

for.end732:                                       ; preds = %for.cond.cleanup717
  call void @arrayDestroy(%struct.Array* %indices465)
  br label %if.end733

if.end733:                                        ; preds = %for.end732, %if.then702
  %length734 = getelementptr inbounds %struct.Array, %struct.Array* %indices465, i32 0, i32 1
  %416 = load i32, i32* %length734, align 8, !tbaa !26
  %417 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %numIndices735 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %417, i32 0, i32 2
  store i32 %416, i32* %numIndices735, align 8, !tbaa !64
  %data736 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 0
  %418 = load i8*, i8** %data736, align 8, !tbaa !31
  %419 = bitcast i8* %418 to %struct.objzMaterial*
  %420 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %materials737 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %420, i32 0, i32 3
  store %struct.objzMaterial* %419, %struct.objzMaterial** %materials737, align 8, !tbaa !65
  %length738 = getelementptr inbounds %struct.Array, %struct.Array* %materials, i32 0, i32 1
  %421 = load i32, i32* %length738, align 8, !tbaa !26
  %422 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %numMaterials = getelementptr inbounds %struct.objzModel, %struct.objzModel* %422, i32 0, i32 4
  store i32 %421, i32* %numMaterials, align 8, !tbaa !66
  %data739 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 0
  %423 = load i8*, i8** %data739, align 8, !tbaa !31
  %424 = bitcast i8* %423 to %struct.objzMesh*
  %425 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %meshes740 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %425, i32 0, i32 5
  store %struct.objzMesh* %424, %struct.objzMesh** %meshes740, align 8, !tbaa !67
  %length741 = getelementptr inbounds %struct.Array, %struct.Array* %meshes, i32 0, i32 1
  %426 = load i32, i32* %length741, align 8, !tbaa !26
  %427 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %numMeshes742 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %427, i32 0, i32 6
  store i32 %426, i32* %numMeshes742, align 8, !tbaa !68
  %data743 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 0
  %428 = load i8*, i8** %data743, align 8, !tbaa !31
  %429 = bitcast i8* %428 to %struct.objzObject*
  %430 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %objects744 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %430, i32 0, i32 7
  store %struct.objzObject* %429, %struct.objzObject** %objects744, align 8, !tbaa !69
  %length745 = getelementptr inbounds %struct.Array, %struct.Array* %objects, i32 0, i32 1
  %431 = load i32, i32* %length745, align 8, !tbaa !26
  %432 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %numObjects = getelementptr inbounds %struct.objzModel, %struct.objzModel* %432, i32 0, i32 8
  store i32 %431, i32* %numObjects, align 8, !tbaa !70
  %433 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8, !tbaa !17
  %vertices746 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length747 = getelementptr inbounds %struct.Array, %struct.Array* %vertices746, i32 0, i32 1
  %434 = load i32, i32* %length747, align 8, !tbaa !59
  %conv748 = zext i32 %434 to i64
  %mul749 = mul i64 %433, %conv748
  %call750 = call i8* @objz_realloc(i8* null, i64 %mul749, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1201)
  %435 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %vertices751 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %435, i32 0, i32 9
  store i8* %call750, i8** %vertices751, align 8, !tbaa !71
  %436 = bitcast i32* %i752 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %436) #7
  store i32 0, i32* %i752, align 4, !tbaa !15
  br label %for.cond753

for.cond753:                                      ; preds = %for.inc816, %if.end733
  %437 = load i32, i32* %i752, align 4, !tbaa !15
  %vertices754 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length755 = getelementptr inbounds %struct.Array, %struct.Array* %vertices754, i32 0, i32 1
  %438 = load i32, i32* %length755, align 8, !tbaa !59
  %cmp756 = icmp ult i32 %437, %438
  br i1 %cmp756, label %for.body759, label %for.cond.cleanup758

for.cond.cleanup758:                              ; preds = %for.cond753
  store i32 43, i32* %cleanup.dest.slot, align 4
  %439 = bitcast i32* %i752 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %439) #7
  br label %for.end819

for.body759:                                      ; preds = %for.cond753
  %440 = bitcast i8** %vOut to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %440) #7
  %441 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %vertices760 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %441, i32 0, i32 9
  %442 = load i8*, i8** %vertices760, align 8, !tbaa !71
  %443 = load i32, i32* %i752, align 4, !tbaa !15
  %conv761 = zext i32 %443 to i64
  %444 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 0), align 8, !tbaa !17
  %mul762 = mul i64 %conv761, %444
  %arrayidx763 = getelementptr inbounds i8, i8* %442, i64 %mul762
  store i8* %arrayidx763, i8** %vOut, align 8, !tbaa !4
  %445 = bitcast %struct.HashedVertex** %vIn to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %445) #7
  %vertices764 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %data765 = getelementptr inbounds %struct.Array, %struct.Array* %vertices764, i32 0, i32 0
  %446 = load i8*, i8** %data765, align 8, !tbaa !72
  %vertices766 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %elementSize767 = getelementptr inbounds %struct.Array, %struct.Array* %vertices766, i32 0, i32 3
  %447 = load i32, i32* %elementSize767, align 8, !tbaa !73
  %448 = load i32, i32* %i752, align 4, !tbaa !15
  %mul768 = mul i32 %447, %448
  %idxprom769 = zext i32 %mul768 to i64
  %arrayidx770 = getelementptr inbounds i8, i8* %446, i64 %idxprom769
  %449 = bitcast i8* %arrayidx770 to %struct.HashedVertex*
  store %struct.HashedVertex* %449, %struct.HashedVertex** %vIn, align 8, !tbaa !4
  %450 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8, !tbaa !19
  %cmp771 = icmp ne i64 %450, -1
  br i1 %cmp771, label %if.then773, label %if.end779

if.then773:                                       ; preds = %for.body759
  %451 = load i8*, i8** %vOut, align 8, !tbaa !4
  %452 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8, !tbaa !19
  %arrayidx774 = getelementptr inbounds i8, i8* %451, i64 %452
  %453 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8, !tbaa !4
  %pos775 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %453, i32 0, i32 1
  %454 = load i32, i32* %pos775, align 4, !tbaa !74
  %call776 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %positions, i32 %454)
  %455 = load i8*, i8** %vOut, align 8, !tbaa !4
  %456 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 1), align 8, !tbaa !19
  %arrayidx777 = getelementptr inbounds i8, i8* %455, i64 %456
  %457 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx777, i1 false, i1 true)
  %call778 = call i8* @__memcpy_chk(i8* %arrayidx774, i8* %call776, i64 12, i64 %457) #7
  br label %if.end779

if.end779:                                        ; preds = %if.then773, %for.body759
  %458 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8, !tbaa !20
  %cmp780 = icmp ne i64 %458, -1
  br i1 %cmp780, label %if.then782, label %if.end797

if.then782:                                       ; preds = %if.end779
  %459 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8, !tbaa !4
  %texcoord783 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %459, i32 0, i32 2
  %460 = load i32, i32* %texcoord783, align 4, !tbaa !76
  %cmp784 = icmp eq i32 %460, -1
  br i1 %cmp784, label %if.then786, label %if.else790

if.then786:                                       ; preds = %if.then782
  %461 = load i8*, i8** %vOut, align 8, !tbaa !4
  %462 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8, !tbaa !20
  %arrayidx787 = getelementptr inbounds i8, i8* %461, i64 %462
  %463 = load i8*, i8** %vOut, align 8, !tbaa !4
  %464 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8, !tbaa !20
  %arrayidx788 = getelementptr inbounds i8, i8* %463, i64 %464
  %465 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx788, i1 false, i1 true)
  %call789 = call i8* @__memset_chk(i8* %arrayidx787, i32 0, i64 8, i64 %465) #7
  br label %if.end796

if.else790:                                       ; preds = %if.then782
  %466 = load i8*, i8** %vOut, align 8, !tbaa !4
  %467 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8, !tbaa !20
  %arrayidx791 = getelementptr inbounds i8, i8* %466, i64 %467
  %468 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8, !tbaa !4
  %texcoord792 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %468, i32 0, i32 2
  %469 = load i32, i32* %texcoord792, align 4, !tbaa !76
  %call793 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %texcoords, i32 %469)
  %470 = load i8*, i8** %vOut, align 8, !tbaa !4
  %471 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 2), align 8, !tbaa !20
  %arrayidx794 = getelementptr inbounds i8, i8* %470, i64 %471
  %472 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx794, i1 false, i1 true)
  %call795 = call i8* @__memcpy_chk(i8* %arrayidx791, i8* %call793, i64 8, i64 %472) #7
  br label %if.end796

if.end796:                                        ; preds = %if.else790, %if.then786
  br label %if.end797

if.end797:                                        ; preds = %if.end796, %if.end779
  %473 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  %cmp798 = icmp ne i64 %473, -1
  br i1 %cmp798, label %if.then800, label %if.end815

if.then800:                                       ; preds = %if.end797
  %474 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8, !tbaa !4
  %normal801 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %474, i32 0, i32 3
  %475 = load i32, i32* %normal801, align 4, !tbaa !77
  %cmp802 = icmp eq i32 %475, -1
  br i1 %cmp802, label %if.then804, label %if.else808

if.then804:                                       ; preds = %if.then800
  %476 = load i8*, i8** %vOut, align 8, !tbaa !4
  %477 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  %arrayidx805 = getelementptr inbounds i8, i8* %476, i64 %477
  %478 = load i8*, i8** %vOut, align 8, !tbaa !4
  %479 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  %arrayidx806 = getelementptr inbounds i8, i8* %478, i64 %479
  %480 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx806, i1 false, i1 true)
  %call807 = call i8* @__memset_chk(i8* %arrayidx805, i32 0, i64 12, i64 %480) #7
  br label %if.end814

if.else808:                                       ; preds = %if.then800
  %481 = load i8*, i8** %vOut, align 8, !tbaa !4
  %482 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  %arrayidx809 = getelementptr inbounds i8, i8* %481, i64 %482
  %483 = load %struct.HashedVertex*, %struct.HashedVertex** %vIn, align 8, !tbaa !4
  %normal810 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %483, i32 0, i32 3
  %484 = load i32, i32* %normal810, align 4, !tbaa !77
  %call811 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %normals, i32 %484)
  %485 = load i8*, i8** %vOut, align 8, !tbaa !4
  %486 = load i64, i64* getelementptr inbounds (%struct.VertexFormat, %struct.VertexFormat* @s_vertexDecl, i32 0, i32 3), align 8, !tbaa !21
  %arrayidx812 = getelementptr inbounds i8, i8* %485, i64 %486
  %487 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx812, i1 false, i1 true)
  %call813 = call i8* @__memcpy_chk(i8* %arrayidx809, i8* %call811, i64 12, i64 %487) #7
  br label %if.end814

if.end814:                                        ; preds = %if.else808, %if.then804
  br label %if.end815

if.end815:                                        ; preds = %if.end814, %if.end797
  %488 = bitcast %struct.HashedVertex** %vIn to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %488) #7
  %489 = bitcast i8** %vOut to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %489) #7
  br label %for.inc816

for.inc816:                                       ; preds = %if.end815
  %490 = load i32, i32* %i752, align 4, !tbaa !15
  %inc817 = add i32 %490, 1
  store i32 %inc817, i32* %i752, align 4, !tbaa !15
  br label %for.cond753

for.end819:                                       ; preds = %for.cond.cleanup758
  %vertices820 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %vertexHashMap, i32 0, i32 2
  %length821 = getelementptr inbounds %struct.Array, %struct.Array* %vertices820, i32 0, i32 1
  %491 = load i32, i32* %length821, align 8, !tbaa !59
  %492 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  %numVertices822 = getelementptr inbounds %struct.objzModel, %struct.objzModel* %492, i32 0, i32 10
  store i32 %491, i32* %numVertices822, align 8, !tbaa !78
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %positions)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %texcoords)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %normals)
  call void @vertexHashMapDestroy(%struct.VertexHashMap* %vertexHashMap)
  %493 = load %struct.objzModel*, %struct.objzModel** %model, align 8, !tbaa !4
  store %struct.objzModel* %493, %struct.objzModel** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup823

error:                                            ; preds = %cleanup364
  call void @fileClose(%struct.File* %file)
  call void @arrayDestroy(%struct.Array* %materialLibs)
  call void @arrayDestroy(%struct.Array* %materials)
  call void @arrayDestroy(%struct.Array* %tempObjects)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %positions)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %texcoords)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %normals)
  call void @chunkedArrayDestroy(%struct.ChunkedArray* %faces)
  call void @arrayDestroy(%struct.Array* %faceIndices)
  call void @arrayDestroy(%struct.Array* %tempFaceIndices)
  store %struct.objzModel* null, %struct.objzModel** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup823

cleanup823:                                       ; preds = %error, %for.end819, %cleanup364
  %494 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %494) #7
  %495 = bitcast %struct.Lexer* %lexer to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %495) #7
  %496 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %496) #7
  %497 = bitcast i16* %currentSmoothingGroup to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %497) #7
  %498 = bitcast i32* %currentMaterialIndex to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %498) #7
  %499 = bitcast [64 x i8]* %currentObjectName to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %499) #7
  %500 = bitcast [64 x i8]* %currentGroupName to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %500) #7
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %generateNormals) #7
  %501 = bitcast %struct.Array* %tempFaceIndices to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %501) #7
  %502 = bitcast %struct.Array* %faceIndices to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %502) #7
  %503 = bitcast %struct.ChunkedArray* %faces to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %503) #7
  %504 = bitcast %struct.ChunkedArray* %normals to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %504) #7
  %505 = bitcast %struct.ChunkedArray* %texcoords to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %505) #7
  %506 = bitcast %struct.ChunkedArray* %positions to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %506) #7
  %507 = bitcast %struct.Array* %tempObjects to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %507) #7
  %508 = bitcast %struct.Array* %materials to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %508) #7
  %509 = bitcast %struct.Array* %materialLibs to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %509) #7
  br label %cleanup840

cleanup840:                                       ; preds = %cleanup823, %if.then11
  %510 = bitcast i16** %bom16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %510) #7
  br label %cleanup841

cleanup841:                                       ; preds = %cleanup840, %if.then2
  %511 = bitcast i32** %bom32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %511) #7
  br label %cleanup842

cleanup842:                                       ; preds = %cleanup841, %if.then
  %512 = bitcast %struct.File* %file to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %512) #7
  %513 = load %struct.objzModel*, %struct.objzModel** %retval, align 8
  ret %struct.objzModel* %513

unreachable:                                      ; preds = %cleanup686, %cleanup639
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal void @appendError(i8* %_format, ...) #0 {
entry:
  %_format.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %buffer = alloca [1024 x i8], align 16
  %newline = alloca i8*, align 8
  store i8* %_format, i8** %_format.addr, align 8, !tbaa !4
  %0 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #7
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = bitcast [1024 x i8]* %buffer to i8*
  call void @llvm.lifetime.start.p0i8(i64 1024, i8* %1) #7
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %2 = load i8*, i8** %_format.addr, align 8, !tbaa !4
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %call = call i32 @__vsnprintf_chk(i8* %arraydecay2, i64 1024, i32 0, i64 1024, i8* %2, %struct.__va_list_tag* %arraydecay3)
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  %3 = load i8, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16, !tbaa !14
  %tobool = icmp ne i8 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = bitcast i8** %newline to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23, i32 0, i32 0), i8** %newline, align 8, !tbaa !4
  %5 = load i8*, i8** %newline, align 8, !tbaa !4
  call void @strConcat(i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i64 1024, i8* %5, i64 1)
  %6 = bitcast i8** %newline to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %arraydecay6 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [1024 x i8], [1024 x i8]* %buffer, i32 0, i32 0
  %call8 = call i64 @strLength(i8* %arraydecay7, i64 1024)
  call void @strConcat(i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i64 1024, i8* %arraydecay6, i64 %call8)
  %7 = bitcast [1024 x i8]* %buffer to i8*
  call void @llvm.lifetime.end.p0i8(i64 1024, i8* %7) #7
  %8 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %8) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @arrayInit(%struct.Array* %_array, i64 %_elementSize, i32 %_initialCapacity) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  %_elementSize.addr = alloca i64, align 8
  %_initialCapacity.addr = alloca i32, align 4
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8, !tbaa !4
  store i64 %_elementSize, i64* %_elementSize.addr, align 8, !tbaa !13
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4, !tbaa !15
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  store i8* null, i8** %data, align 8, !tbaa !31
  %1 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %capacity = getelementptr inbounds %struct.Array, %struct.Array* %1, i32 0, i32 2
  store i32 0, i32* %capacity, align 4, !tbaa !79
  %2 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 1
  store i32 0, i32* %length, align 8, !tbaa !26
  %3 = load i64, i64* %_elementSize.addr, align 8, !tbaa !13
  %conv = trunc i64 %3 to i32
  %4 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 3
  store i32 %conv, i32* %elementSize, align 8, !tbaa !32
  %5 = load i32, i32* %_initialCapacity.addr, align 4, !tbaa !15
  %6 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %initialCapacity = getelementptr inbounds %struct.Array, %struct.Array* %6, i32 0, i32 4
  store i32 %5, i32* %initialCapacity, align 4, !tbaa !80
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @chunkedArrayInit(%struct.ChunkedArray* %_array, i64 %_elementSize, i32 %_chunkLength) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_elementSize.addr = alloca i64, align 8
  %_chunkLength.addr = alloca i32, align 4
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  store i64 %_elementSize, i64* %_elementSize.addr, align 8, !tbaa !13
  store i32 %_chunkLength, i32* %_chunkLength.addr, align 4, !tbaa !15
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 0
  call void @arrayInit(%struct.Array* %chunks, i64 8, i32 32)
  %1 = load i32, i32* %_chunkLength.addr, align 4, !tbaa !15
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 1
  store i32 %1, i32* %elementsPerChunk, align 8, !tbaa !81
  %3 = load i64, i64* %_elementSize.addr, align 8, !tbaa !13
  %4 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementSize = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %4, i32 0, i32 2
  store i64 %3, i64* %elementSize, align 8, !tbaa !82
  %5 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %5, i32 0, i32 3
  store i32 0, i32* %length, align 8, !tbaa !36
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #1

; Function Attrs: nounwind ssp uwtable
define internal void @initLexer(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  store i8* null, i8** %buf, align 8, !tbaa !83
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 2
  store i32 1, i32* %column, align 4, !tbaa !85
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 1
  store i32 0, i32* %line, align 8, !tbaa !86
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @lexerSetLine(%struct.Lexer* %_lexer, i8* %_buf) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_buf.addr = alloca i8*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  store i8* %_buf, i8** %_buf.addr, align 8, !tbaa !4
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 2
  store i32 1, i32* %column, align 4, !tbaa !85
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %1, i32 0, i32 1
  %2 = load i32, i32* %line, align 8, !tbaa !86
  %inc = add i32 %2, 1
  store i32 %inc, i32* %line, align 8, !tbaa !86
  %3 = load i8*, i8** %_buf.addr, align 8, !tbaa !4
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 0
  store i8* %3, i8** %buf, align 8, !tbaa !83
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @tokenize(%struct.Lexer* %_lexer, %struct.Token* %_token, i1 zeroext %includeWhitespace) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_token.addr = alloca %struct.Token*, align 8
  %includeWhitespace.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  store %struct.Token* %_token, %struct.Token** %_token.addr, align 8, !tbaa !4
  %frombool = zext i1 %includeWhitespace to i8
  store i8 %frombool, i8* %includeWhitespace.addr, align 1, !tbaa !24
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  call void @skipWhitespace(%struct.Lexer* %1)
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %line = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 1
  %3 = load i32, i32* %line, align 8, !tbaa !86
  %4 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %line1 = getelementptr inbounds %struct.Token, %struct.Token* %4, i32 0, i32 1
  store i32 %3, i32* %line1, align 4, !tbaa !33
  %5 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %5, i32 0, i32 2
  %6 = load i32, i32* %column, align 4, !tbaa !85
  %7 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %column2 = getelementptr inbounds %struct.Token, %struct.Token* %7, i32 0, i32 2
  store i32 %6, i32* %column2, align 4, !tbaa !35
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %8 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %call = call zeroext i1 @isEol(%struct.Lexer* %8)
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %9 = load i8, i8* %includeWhitespace.addr, align 1, !tbaa !24, !range !46
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %10 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %call3 = call zeroext i1 @isWhitespace(%struct.Lexer* %10)
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %for.cond
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %11 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %11, i32 0, i32 0
  %12 = load i8*, i8** %buf, align 8, !tbaa !83
  %arrayidx = getelementptr inbounds i8, i8* %12, i64 0
  %13 = load i8, i8* %arrayidx, align 1, !tbaa !14
  %14 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text = getelementptr inbounds %struct.Token, %struct.Token* %14, i32 0, i32 0
  %15 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  %idxprom = zext i32 %15 to i64
  %arrayidx4 = getelementptr inbounds [256 x i8], [256 x i8]* %text, i64 0, i64 %idxprom
  store i8 %13, i8* %arrayidx4, align 1, !tbaa !14
  %16 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf5 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %16, i32 0, i32 0
  %17 = load i8*, i8** %buf5, align 8, !tbaa !83
  %incdec.ptr = getelementptr inbounds i8, i8* %17, i32 1
  store i8* %incdec.ptr, i8** %buf5, align 8, !tbaa !83
  %18 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %column6 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %18, i32 0, i32 2
  %19 = load i32, i32* %column6, align 4, !tbaa !85
  %inc7 = add i32 %19, 1
  store i32 %inc7, i32* %column6, align 4, !tbaa !85
  br label %for.cond

for.end:                                          ; preds = %if.then
  %20 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text8 = getelementptr inbounds %struct.Token, %struct.Token* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom9 = zext i32 %21 to i64
  %arrayidx10 = getelementptr inbounds [256 x i8], [256 x i8]* %text8, i64 0, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1, !tbaa !14
  %22 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %22) #7
  ret void
}

declare i32 @strcasecmp(i8*, i8*) #2

; Function Attrs: nounwind ssp uwtable
define internal void @arrayAppend(%struct.Array* %_array, i8* %_element) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  %_element.addr = alloca i8*, align 8
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8, !tbaa !4
  store i8* %_element, i8** %_element.addr, align 8, !tbaa !4
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !31
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %2, i32 0, i32 3
  %3 = load i32, i32* %elementSize, align 8, !tbaa !32
  %4 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %initialCapacity = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 4
  %5 = load i32, i32* %initialCapacity, align 4, !tbaa !80
  %mul = mul i32 %3, %5
  %conv = zext i32 %mul to i64
  %call = call i8* @objz_realloc(i8* null, i64 %conv, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 187)
  %6 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data1 = getelementptr inbounds %struct.Array, %struct.Array* %6, i32 0, i32 0
  store i8* %call, i8** %data1, align 8, !tbaa !31
  %7 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %initialCapacity2 = getelementptr inbounds %struct.Array, %struct.Array* %7, i32 0, i32 4
  %8 = load i32, i32* %initialCapacity2, align 4, !tbaa !80
  %9 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %capacity = getelementptr inbounds %struct.Array, %struct.Array* %9, i32 0, i32 2
  store i32 %8, i32* %capacity, align 4, !tbaa !79
  br label %if.end15

if.else:                                          ; preds = %entry
  %10 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.Array, %struct.Array* %10, i32 0, i32 1
  %11 = load i32, i32* %length, align 8, !tbaa !26
  %12 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %capacity3 = getelementptr inbounds %struct.Array, %struct.Array* %12, i32 0, i32 2
  %13 = load i32, i32* %capacity3, align 4, !tbaa !79
  %cmp = icmp eq i32 %11, %13
  br i1 %cmp, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %14 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %capacity6 = getelementptr inbounds %struct.Array, %struct.Array* %14, i32 0, i32 2
  %15 = load i32, i32* %capacity6, align 4, !tbaa !79
  %mul7 = mul i32 %15, 2
  store i32 %mul7, i32* %capacity6, align 4, !tbaa !79
  %16 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data8 = getelementptr inbounds %struct.Array, %struct.Array* %16, i32 0, i32 0
  %17 = load i8*, i8** %data8, align 8, !tbaa !31
  %18 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %capacity9 = getelementptr inbounds %struct.Array, %struct.Array* %18, i32 0, i32 2
  %19 = load i32, i32* %capacity9, align 4, !tbaa !79
  %20 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %elementSize10 = getelementptr inbounds %struct.Array, %struct.Array* %20, i32 0, i32 3
  %21 = load i32, i32* %elementSize10, align 8, !tbaa !32
  %mul11 = mul i32 %19, %21
  %conv12 = zext i32 %mul11 to i64
  %call13 = call i8* @objz_realloc(i8* %17, i64 %conv12, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 191)
  %22 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data14 = getelementptr inbounds %struct.Array, %struct.Array* %22, i32 0, i32 0
  store i8* %call13, i8** %data14, align 8, !tbaa !31
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then
  %23 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data16 = getelementptr inbounds %struct.Array, %struct.Array* %23, i32 0, i32 0
  %24 = load i8*, i8** %data16, align 8, !tbaa !31
  %25 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %length17 = getelementptr inbounds %struct.Array, %struct.Array* %25, i32 0, i32 1
  %26 = load i32, i32* %length17, align 8, !tbaa !26
  %27 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %elementSize18 = getelementptr inbounds %struct.Array, %struct.Array* %27, i32 0, i32 3
  %28 = load i32, i32* %elementSize18, align 8, !tbaa !32
  %mul19 = mul i32 %26, %28
  %idxprom = zext i32 %mul19 to i64
  %arrayidx = getelementptr inbounds i8, i8* %24, i64 %idxprom
  %29 = load i8*, i8** %_element.addr, align 8, !tbaa !4
  %30 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %elementSize20 = getelementptr inbounds %struct.Array, %struct.Array* %30, i32 0, i32 3
  %31 = load i32, i32* %elementSize20, align 8, !tbaa !32
  %conv21 = zext i32 %31 to i64
  %32 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data22 = getelementptr inbounds %struct.Array, %struct.Array* %32, i32 0, i32 0
  %33 = load i8*, i8** %data22, align 8, !tbaa !31
  %34 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %length23 = getelementptr inbounds %struct.Array, %struct.Array* %34, i32 0, i32 1
  %35 = load i32, i32* %length23, align 8, !tbaa !26
  %36 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %elementSize24 = getelementptr inbounds %struct.Array, %struct.Array* %36, i32 0, i32 3
  %37 = load i32, i32* %elementSize24, align 8, !tbaa !32
  %mul25 = mul i32 %35, %37
  %idxprom26 = zext i32 %mul25 to i64
  %arrayidx27 = getelementptr inbounds i8, i8* %33, i64 %idxprom26
  %38 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx27, i1 false, i1 true)
  %call28 = call i8* @__memcpy_chk(i8* %arrayidx, i8* %29, i64 %conv21, i64 %38) #7
  %39 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %length29 = getelementptr inbounds %struct.Array, %struct.Array* %39, i32 0, i32 1
  %40 = load i32, i32* %length29, align 8, !tbaa !26
  %inc = add i32 %40, 1
  store i32 %inc, i32* %length29, align 8, !tbaa !26
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @isEol(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  %1 = load i8*, i8** %buf, align 8, !tbaa !83
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !14
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 0
  ret i1 %cmp
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @parseVertexAttribIndices(%struct.Token* %_token, i32* %_out) #0 {
entry:
  %retval = alloca i1, align 1
  %_token.addr = alloca %struct.Token*, align 8
  %_out.addr = alloca i32*, align 8
  %v = alloca i32*, align 8
  %vt = alloca i32*, align 8
  %vn = alloca i32*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %delim = alloca i8*, align 8
  %start = alloca i8*, align 8
  %eol = alloca i8, align 1
  %end = alloca i8*, align 8
  %skipNormal = alloca i8, align 1
  store %struct.Token* %_token, %struct.Token** %_token.addr, align 8, !tbaa !4
  store i32* %_out, i32** %_out.addr, align 8, !tbaa !4
  %0 = bitcast i32** %v to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i32*, i32** %_out.addr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i32, i32* %1, i64 0
  store i32* %arrayidx, i32** %v, align 8, !tbaa !4
  %2 = bitcast i32** %vt to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = load i32*, i32** %_out.addr, align 8, !tbaa !4
  %arrayidx1 = getelementptr inbounds i32, i32* %3, i64 1
  store i32* %arrayidx1, i32** %vt, align 8, !tbaa !4
  %4 = bitcast i32** %vn to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = load i32*, i32** %_out.addr, align 8, !tbaa !4
  %arrayidx2 = getelementptr inbounds i32, i32* %5, i64 2
  store i32* %arrayidx2, i32** %vn, align 8, !tbaa !4
  %6 = load i32*, i32** %vn, align 8, !tbaa !4
  store i32 2147483647, i32* %6, align 4, !tbaa !15
  %7 = load i32*, i32** %vt, align 8, !tbaa !4
  store i32 2147483647, i32* %7, align 4, !tbaa !15
  %8 = load i32*, i32** %v, align 8, !tbaa !4
  store i32 2147483647, i32* %8, align 4, !tbaa !15
  %9 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text = getelementptr inbounds %struct.Token, %struct.Token* %9, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup52

if.end:                                           ; preds = %entry
  %10 = bitcast i8** %delim to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #7
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.24, i32 0, i32 0), i8** %delim, align 8, !tbaa !4
  %11 = bitcast i8** %start to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #7
  %12 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text3 = getelementptr inbounds %struct.Token, %struct.Token* %12, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %text3, i32 0, i32 0
  store i8* %arraydecay4, i8** %start, align 8, !tbaa !4
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %eol) #7
  store i8 0, i8* %eol, align 1, !tbaa !24
  %13 = bitcast i8** %end to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #7
  %14 = load i8*, i8** %start, align 8, !tbaa !4
  %15 = load i8*, i8** %delim, align 8, !tbaa !4
  %call5 = call i8* @strstr(i8* %14, i8* %15)
  store i8* %call5, i8** %end, align 8, !tbaa !4
  %16 = load i8*, i8** %end, align 8, !tbaa !4
  %tobool = icmp ne i8* %16, null
  br i1 %tobool, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %17 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text7 = getelementptr inbounds %struct.Token, %struct.Token* %17, i32 0, i32 0
  %18 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text8 = getelementptr inbounds %struct.Token, %struct.Token* %18, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [256 x i8], [256 x i8]* %text8, i32 0, i32 0
  %call10 = call i64 @strLength(i8* %arraydecay9, i64 256)
  %arrayidx11 = getelementptr inbounds [256 x i8], [256 x i8]* %text7, i64 0, i64 %call10
  store i8* %arrayidx11, i8** %end, align 8, !tbaa !4
  store i8 1, i8* %eol, align 1, !tbaa !24
  br label %if.end15

if.else:                                          ; preds = %if.end
  %19 = load i8*, i8** %end, align 8, !tbaa !4
  %20 = load i8*, i8** %start, align 8, !tbaa !4
  %cmp12 = icmp eq i8* %19, %20
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.else
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup48

if.end14:                                         ; preds = %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then6
  %21 = load i8*, i8** %end, align 8, !tbaa !4
  store i8 0, i8* %21, align 1, !tbaa !14
  %22 = load i8*, i8** %start, align 8, !tbaa !4
  %call16 = call i32 @atoi(i8* %22)
  %23 = load i32*, i32** %v, align 8, !tbaa !4
  store i32 %call16, i32* %23, align 4, !tbaa !15
  %24 = load i8, i8* %eol, align 1, !tbaa !24, !range !46
  %tobool17 = trunc i8 %24 to i1
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup48

if.end19:                                         ; preds = %if.end15
  %25 = load i8*, i8** %end, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %25, i64 1
  store i8* %add.ptr, i8** %start, align 8, !tbaa !4
  %26 = load i8*, i8** %start, align 8, !tbaa !4
  %27 = load i8, i8* %26, align 1, !tbaa !14
  %conv = sext i8 %27 to i32
  %cmp20 = icmp eq i32 %conv, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end19
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup48

if.end23:                                         ; preds = %if.end19
  %28 = load i8*, i8** %start, align 8, !tbaa !4
  %29 = load i8*, i8** %delim, align 8, !tbaa !4
  %call24 = call i8* @strstr(i8* %28, i8* %29)
  store i8* %call24, i8** %end, align 8, !tbaa !4
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %skipNormal) #7
  store i8 0, i8* %skipNormal, align 1, !tbaa !24
  %30 = load i8*, i8** %end, align 8, !tbaa !4
  %tobool25 = icmp ne i8* %30, null
  br i1 %tobool25, label %if.end32, label %if.then26

if.then26:                                        ; preds = %if.end23
  store i8 1, i8* %skipNormal, align 1, !tbaa !24
  %31 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text27 = getelementptr inbounds %struct.Token, %struct.Token* %31, i32 0, i32 0
  %32 = load %struct.Token*, %struct.Token** %_token.addr, align 8, !tbaa !4
  %text28 = getelementptr inbounds %struct.Token, %struct.Token* %32, i32 0, i32 0
  %arraydecay29 = getelementptr inbounds [256 x i8], [256 x i8]* %text28, i32 0, i32 0
  %call30 = call i64 @strLength(i8* %arraydecay29, i64 256)
  %sub = sub i64 %call30, 1
  %arrayidx31 = getelementptr inbounds [256 x i8], [256 x i8]* %text27, i64 0, i64 %sub
  store i8* %arrayidx31, i8** %end, align 8, !tbaa !4
  br label %if.end32

if.end32:                                         ; preds = %if.then26, %if.end23
  %33 = load i8*, i8** %end, align 8, !tbaa !4
  store i8 0, i8* %33, align 1, !tbaa !14
  %34 = load i8*, i8** %start, align 8, !tbaa !4
  %35 = load i8*, i8** %end, align 8, !tbaa !4
  %cmp33 = icmp ne i8* %34, %35
  br i1 %cmp33, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end32
  %36 = load i8*, i8** %start, align 8, !tbaa !4
  %call36 = call i32 @atoi(i8* %36)
  %37 = load i32*, i32** %vt, align 8, !tbaa !4
  store i32 %call36, i32* %37, align 4, !tbaa !15
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end32
  %38 = load i8, i8* %skipNormal, align 1, !tbaa !24, !range !46
  %tobool38 = trunc i8 %38 to i1
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end37
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end40:                                         ; preds = %if.end37
  %39 = load i8*, i8** %end, align 8, !tbaa !4
  %add.ptr41 = getelementptr inbounds i8, i8* %39, i64 1
  store i8* %add.ptr41, i8** %start, align 8, !tbaa !4
  %40 = load i8*, i8** %start, align 8, !tbaa !4
  %41 = load i8, i8* %40, align 1, !tbaa !14
  %conv42 = sext i8 %41 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end40
  %42 = load i8*, i8** %start, align 8, !tbaa !4
  %call46 = call i32 @atoi(i8* %42)
  %43 = load i32*, i32** %vn, align 8, !tbaa !4
  store i32 %call46, i32* %43, align 4, !tbaa !15
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end40
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.then39
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %skipNormal) #7
  br label %cleanup48

cleanup48:                                        ; preds = %cleanup, %if.then22, %if.then18, %if.then13
  %44 = bitcast i8** %end to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %44) #7
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %eol) #7
  %45 = bitcast i8** %start to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #7
  %46 = bitcast i8** %delim to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #7
  br label %cleanup52

cleanup52:                                        ; preds = %cleanup48, %if.then
  %47 = bitcast i32** %vn to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #7
  %48 = bitcast i32** %vt to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #7
  %49 = bitcast i32** %v to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #7
  %50 = load i1, i1* %retval, align 1
  ret i1 %50
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @fixVertexAttribIndex(i32 %_index, i32 %_n) #0 {
entry:
  %retval = alloca i32, align 4
  %_index.addr = alloca i32, align 4
  %_n.addr = alloca i32, align 4
  store i32 %_index, i32* %_index.addr, align 4, !tbaa !15
  store i32 %_n, i32* %_n.addr, align 4, !tbaa !15
  %0 = load i32, i32* %_index.addr, align 4, !tbaa !15
  %cmp = icmp eq i32 %0, 2147483647
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %_index.addr, align 4, !tbaa !15
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load i32, i32* %_index.addr, align 4, !tbaa !15
  %3 = load i32, i32* %_n.addr, align 4, !tbaa !15
  %add = add i32 %2, %3
  store i32 %add, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i32, i32* %_index.addr, align 4, !tbaa !15
  %sub = sub nsw i32 %4, 1
  store i32 %sub, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #1

; Function Attrs: nounwind ssp uwtable
define internal void @chunkedArrayAppend(%struct.ChunkedArray* %_array, i8* %_element) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_element.addr = alloca i8*, align 8
  %newChunk = alloca i8*, align 8
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  store i8* %_element, i8** %_element.addr, align 8, !tbaa !4
  %0 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %0, i32 0, i32 3
  %1 = load i32, i32* %length, align 8, !tbaa !36
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 0
  %length1 = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 1
  %3 = load i32, i32* %length1, align 8, !tbaa !87
  %4 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %4, i32 0, i32 1
  %5 = load i32, i32* %elementsPerChunk, align 8, !tbaa !81
  %mul = mul i32 %3, %5
  %cmp = icmp uge i32 %1, %mul
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = bitcast i8** %newChunk to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %7 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %7, i32 0, i32 1
  %8 = load i32, i32* %elementsPerChunk2, align 8, !tbaa !81
  %conv = zext i32 %8 to i64
  %9 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementSize = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %9, i32 0, i32 2
  %10 = load i64, i64* %elementSize, align 8, !tbaa !82
  %mul3 = mul i64 %conv, %10
  %call = call i8* @objz_realloc(i8* null, i64 %mul3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 225)
  store i8* %call, i8** %newChunk, align 8, !tbaa !4
  %11 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks4 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %11, i32 0, i32 0
  %12 = bitcast i8** %newChunk to i8*
  call void @arrayAppend(%struct.Array* %chunks4, i8* %12)
  %13 = bitcast i8** %newChunk to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %14 = bitcast i8*** %chunk to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #7
  %15 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks5 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %15, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks5, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8, !tbaa !88
  %17 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks6 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %17, i32 0, i32 0
  %elementSize7 = getelementptr inbounds %struct.Array, %struct.Array* %chunks6, i32 0, i32 3
  %18 = load i32, i32* %elementSize7, align 8, !tbaa !89
  %19 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %length8 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %19, i32 0, i32 3
  %20 = load i32, i32* %length8, align 8, !tbaa !36
  %21 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk9 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %21, i32 0, i32 1
  %22 = load i32, i32* %elementsPerChunk9, align 8, !tbaa !81
  %div = udiv i32 %20, %22
  %mul10 = mul i32 %18, %div
  %idxprom = zext i32 %mul10 to i64
  %arrayidx = getelementptr inbounds i8, i8* %16, i64 %idxprom
  %23 = bitcast i8* %arrayidx to i8**
  store i8** %23, i8*** %chunk, align 8, !tbaa !4
  %24 = load i8**, i8*** %chunk, align 8, !tbaa !4
  %25 = load i8*, i8** %24, align 8, !tbaa !4
  %26 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementSize11 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %26, i32 0, i32 2
  %27 = load i64, i64* %elementSize11, align 8, !tbaa !82
  %28 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %length12 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %28, i32 0, i32 3
  %29 = load i32, i32* %length12, align 8, !tbaa !36
  %30 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk13 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %30, i32 0, i32 1
  %31 = load i32, i32* %elementsPerChunk13, align 8, !tbaa !81
  %rem = urem i32 %29, %31
  %conv14 = zext i32 %rem to i64
  %mul15 = mul i64 %27, %conv14
  %arrayidx16 = getelementptr inbounds i8, i8* %25, i64 %mul15
  %32 = load i8*, i8** %_element.addr, align 8, !tbaa !4
  %33 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementSize17 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %33, i32 0, i32 2
  %34 = load i64, i64* %elementSize17, align 8, !tbaa !82
  %35 = load i8**, i8*** %chunk, align 8, !tbaa !4
  %36 = load i8*, i8** %35, align 8, !tbaa !4
  %37 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementSize18 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %37, i32 0, i32 2
  %38 = load i64, i64* %elementSize18, align 8, !tbaa !82
  %39 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %length19 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %39, i32 0, i32 3
  %40 = load i32, i32* %length19, align 8, !tbaa !36
  %41 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk20 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %41, i32 0, i32 1
  %42 = load i32, i32* %elementsPerChunk20, align 8, !tbaa !81
  %rem21 = urem i32 %40, %42
  %conv22 = zext i32 %rem21 to i64
  %mul23 = mul i64 %38, %conv22
  %arrayidx24 = getelementptr inbounds i8, i8* %36, i64 %mul23
  %43 = call i64 @llvm.objectsize.i64.p0i8(i8* %arrayidx24, i1 false, i1 true)
  %call25 = call i8* @__memcpy_chk(i8* %arrayidx16, i8* %32, i64 %34, i64 %43) #7
  %44 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %length26 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %44, i32 0, i32 3
  %45 = load i32, i32* %length26, align 8, !tbaa !36
  %inc = add i32 %45, 1
  store i32 %inc, i32* %length26, align 8, !tbaa !36
  %46 = bitcast i8*** %chunk to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @triangulate(%struct.Array* %_indices, %struct.ChunkedArray* %_positions, %struct.Array* %_tempIndices, %struct.ChunkedArray* %_faces, i32 %_materialIndex, i16 zeroext %_smoothingGroup) #0 {
entry:
  %_indices.addr = alloca %struct.Array*, align 8
  %_positions.addr = alloca %struct.ChunkedArray*, align 8
  %_tempIndices.addr = alloca %struct.Array*, align 8
  %_faces.addr = alloca %struct.ChunkedArray*, align 8
  %_materialIndex.addr = alloca i32, align 4
  %_smoothingGroup.addr = alloca i16, align 2
  %axes = alloca [2 x i32], align 4
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %indices = alloca %struct.IndexTriplet*, align 8
  %v = alloca [3 x %struct.vec3], align 16
  %j = alloca i32, align 4
  %edges = alloca [2 x %struct.vec3], align 16
  %corner = alloca %struct.vec3, align 4
  %area = alloca float, align 4
  %i121 = alloca i32, align 4
  %i0 = alloca %struct.IndexTriplet*, align 8
  %i1 = alloca %struct.IndexTriplet*, align 8
  %v0 = alloca float*, align 8
  %v1 = alloca float*, align 8
  %remainingIndices = alloca %struct.Array*, align 8
  %i168 = alloca i32, align 4
  %remainingIterations = alloca i32, align 4
  %previousRemainingIndices = alloca i32, align 4
  %guess_vert = alloca i32, align 4
  %ind = alloca [3 x %struct.IndexTriplet*], align 16
  %vx = alloca [3 x float], align 4
  %vy = alloca [3 x float], align 4
  %i200 = alloca i32, align 4
  %pos = alloca float*, align 8
  %edge0 = alloca [2 x float], align 4
  %edge1 = alloca [2 x float], align 4
  %cross = alloca float, align 4
  %overlap = alloca i8, align 1
  %otherVert = alloca i32, align 4
  %idx = alloca i32, align 4
  %ovi = alloca i32, align 4
  %tx = alloca float, align 4
  %ty = alloca float, align 4
  %face = alloca %struct.Face, align 4
  %i305 = alloca i32, align 4
  %removed_vert_index = alloca i32, align 4
  %remainingIndicesData = alloca %struct.IndexTriplet*, align 8
  %face351 = alloca %struct.Face, align 4
  %i352 = alloca i32, align 4
  store %struct.Array* %_indices, %struct.Array** %_indices.addr, align 8, !tbaa !4
  store %struct.ChunkedArray* %_positions, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  store %struct.Array* %_tempIndices, %struct.Array** %_tempIndices.addr, align 8, !tbaa !4
  store %struct.ChunkedArray* %_faces, %struct.ChunkedArray** %_faces.addr, align 8, !tbaa !4
  store i32 %_materialIndex, i32* %_materialIndex.addr, align 4, !tbaa !15
  store i16 %_smoothingGroup, i16* %_smoothingGroup.addr, align 2, !tbaa !22
  %0 = bitcast [2 x i32]* %axes to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast [2 x i32]* %axes to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %1, i8* align 4 bitcast ([2 x i32]* @__const.triangulate.axes to i8*), i64 8, i1 false)
  %2 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc117, %entry
  %3 = load i32, i32* %i, align 4, !tbaa !15
  %4 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.Array, %struct.Array* %4, i32 0, i32 1
  %5 = load i32, i32* %length, align 8, !tbaa !26
  %cmp = icmp ult i32 %3, %5
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup119

for.body:                                         ; preds = %for.cond
  %6 = bitcast %struct.IndexTriplet** %indices to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %7 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %data = getelementptr inbounds %struct.Array, %struct.Array* %7, i32 0, i32 0
  %8 = load i8*, i8** %data, align 8, !tbaa !31
  %9 = bitcast i8* %8 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %9, %struct.IndexTriplet** %indices, align 8, !tbaa !4
  %10 = bitcast [3 x %struct.vec3]* %v to i8*
  call void @llvm.lifetime.start.p0i8(i64 36, i8* %10) #7
  %11 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %11) #7
  store i32 0, i32* %j, align 4, !tbaa !15
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %12 = load i32, i32* %j, align 4, !tbaa !15
  %cmp2 = icmp slt i32 %12, 3
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup3

for.cond.cleanup3:                                ; preds = %for.cond1
  store i32 5, i32* %cleanup.dest.slot, align 4
  %13 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #7
  br label %for.end

for.body4:                                        ; preds = %for.cond1
  %14 = load i32, i32* %j, align 4, !tbaa !15
  %idxprom = sext i32 %14 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 %idxprom
  %15 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  %16 = load %struct.IndexTriplet*, %struct.IndexTriplet** %indices, align 8, !tbaa !4
  %17 = load i32, i32* %i, align 4, !tbaa !15
  %18 = load i32, i32* %j, align 4, !tbaa !15
  %add = add i32 %17, %18
  %19 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %length5 = getelementptr inbounds %struct.Array, %struct.Array* %19, i32 0, i32 1
  %20 = load i32, i32* %length5, align 8, !tbaa !26
  %rem = urem i32 %add, %20
  %idxprom6 = zext i32 %rem to i64
  %arrayidx7 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %16, i64 %idxprom6
  %v8 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx7, i32 0, i32 0
  %21 = load i32, i32* %v8, align 4, !tbaa !38
  %call = call i8* @chunkedArrayElement(%struct.ChunkedArray* %15, i32 %21)
  %22 = bitcast i8* %call to %struct.vec3*
  %23 = bitcast %struct.vec3* %arrayidx to i8*
  %24 = bitcast %struct.vec3* %22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %23, i8* align 4 %24, i64 12, i1 false), !tbaa.struct !90
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %25 = load i32, i32* %j, align 4, !tbaa !15
  %inc = add nsw i32 %25, 1
  store i32 %inc, i32* %j, align 4, !tbaa !15
  br label %for.cond1

for.end:                                          ; preds = %for.cond.cleanup3
  %26 = bitcast [2 x %struct.vec3]* %edges to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %26) #7
  %arrayidx9 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx9, i32 0, i32 0
  %27 = load float, float* %x, align 4, !tbaa !47
  %arrayidx10 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %x11 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx10, i32 0, i32 0
  %28 = load float, float* %x11, align 16, !tbaa !47
  %sub = fsub float %27, %28
  %arrayidx12 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x13 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx12, i32 0, i32 0
  store float %sub, float* %x13, align 16, !tbaa !47
  %arrayidx14 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx14, i32 0, i32 1
  %29 = load float, float* %y, align 4, !tbaa !50
  %arrayidx15 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %y16 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx15, i32 0, i32 1
  %30 = load float, float* %y16, align 4, !tbaa !50
  %sub17 = fsub float %29, %30
  %arrayidx18 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y19 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx18, i32 0, i32 1
  store float %sub17, float* %y19, align 4, !tbaa !50
  %arrayidx20 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx20, i32 0, i32 2
  %31 = load float, float* %z, align 4, !tbaa !51
  %arrayidx21 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 0
  %z22 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx21, i32 0, i32 2
  %32 = load float, float* %z22, align 8, !tbaa !51
  %sub23 = fsub float %31, %32
  %arrayidx24 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z25 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx24, i32 0, i32 2
  store float %sub23, float* %z25, align 8, !tbaa !51
  %arrayidx26 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %x27 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx26, i32 0, i32 0
  %33 = load float, float* %x27, align 8, !tbaa !47
  %arrayidx28 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %x29 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx28, i32 0, i32 0
  %34 = load float, float* %x29, align 4, !tbaa !47
  %sub30 = fsub float %33, %34
  %arrayidx31 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x32 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx31, i32 0, i32 0
  store float %sub30, float* %x32, align 4, !tbaa !47
  %arrayidx33 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %y34 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx33, i32 0, i32 1
  %35 = load float, float* %y34, align 4, !tbaa !50
  %arrayidx35 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %y36 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx35, i32 0, i32 1
  %36 = load float, float* %y36, align 4, !tbaa !50
  %sub37 = fsub float %35, %36
  %arrayidx38 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y39 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx38, i32 0, i32 1
  store float %sub37, float* %y39, align 4, !tbaa !50
  %arrayidx40 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 2
  %z41 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx40, i32 0, i32 2
  %37 = load float, float* %z41, align 8, !tbaa !51
  %arrayidx42 = getelementptr inbounds [3 x %struct.vec3], [3 x %struct.vec3]* %v, i64 0, i64 1
  %z43 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx42, i32 0, i32 2
  %38 = load float, float* %z43, align 4, !tbaa !51
  %sub44 = fsub float %37, %38
  %arrayidx45 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z46 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx45, i32 0, i32 2
  store float %sub44, float* %z46, align 4, !tbaa !51
  %39 = bitcast %struct.vec3* %corner to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %39) #7
  %arrayidx47 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y48 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx47, i32 0, i32 1
  %40 = load float, float* %y48, align 4, !tbaa !50
  %arrayidx49 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z50 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx49, i32 0, i32 2
  %41 = load float, float* %z50, align 4, !tbaa !51
  %mul = fmul float %40, %41
  %arrayidx51 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z52 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx51, i32 0, i32 2
  %42 = load float, float* %z52, align 8, !tbaa !51
  %arrayidx53 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y54 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx53, i32 0, i32 1
  %43 = load float, float* %y54, align 4, !tbaa !50
  %mul55 = fmul float %42, %43
  %sub56 = fsub float %mul, %mul55
  %x57 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  store float %sub56, float* %x57, align 4, !tbaa !47
  %arrayidx58 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %z59 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx58, i32 0, i32 2
  %44 = load float, float* %z59, align 8, !tbaa !51
  %arrayidx60 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x61 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx60, i32 0, i32 0
  %45 = load float, float* %x61, align 4, !tbaa !47
  %mul62 = fmul float %44, %45
  %arrayidx63 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x64 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx63, i32 0, i32 0
  %46 = load float, float* %x64, align 16, !tbaa !47
  %arrayidx65 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %z66 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx65, i32 0, i32 2
  %47 = load float, float* %z66, align 4, !tbaa !51
  %mul67 = fmul float %46, %47
  %sub68 = fsub float %mul62, %mul67
  %y69 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  store float %sub68, float* %y69, align 4, !tbaa !50
  %arrayidx70 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %x71 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx70, i32 0, i32 0
  %48 = load float, float* %x71, align 16, !tbaa !47
  %arrayidx72 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %y73 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx72, i32 0, i32 1
  %49 = load float, float* %y73, align 4, !tbaa !50
  %mul74 = fmul float %48, %49
  %arrayidx75 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 0
  %y76 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx75, i32 0, i32 1
  %50 = load float, float* %y76, align 4, !tbaa !50
  %arrayidx77 = getelementptr inbounds [2 x %struct.vec3], [2 x %struct.vec3]* %edges, i64 0, i64 1
  %x78 = getelementptr inbounds %struct.vec3, %struct.vec3* %arrayidx77, i32 0, i32 0
  %51 = load float, float* %x78, align 4, !tbaa !47
  %mul79 = fmul float %50, %51
  %sub80 = fsub float %mul74, %mul79
  %z81 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  store float %sub80, float* %z81, align 4, !tbaa !51
  %x82 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %52 = load float, float* %x82, align 4, !tbaa !47
  %53 = call float @llvm.fabs.f32(float %52)
  %x83 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  store float %53, float* %x83, align 4, !tbaa !47
  %y84 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %54 = load float, float* %y84, align 4, !tbaa !50
  %55 = call float @llvm.fabs.f32(float %54)
  %y85 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  store float %55, float* %y85, align 4, !tbaa !50
  %z86 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %56 = load float, float* %z86, align 4, !tbaa !51
  %57 = call float @llvm.fabs.f32(float %56)
  %z87 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  store float %57, float* %z87, align 4, !tbaa !51
  %x88 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %58 = load float, float* %x88, align 4, !tbaa !47
  %cmp89 = fcmp ogt float %58, 0x3E80000000000000
  br i1 %cmp89, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %y90 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %59 = load float, float* %y90, align 4, !tbaa !50
  %cmp91 = fcmp ogt float %59, 0x3E80000000000000
  br i1 %cmp91, label %if.then, label %lor.lhs.false92

lor.lhs.false92:                                  ; preds = %lor.lhs.false
  %z93 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %60 = load float, float* %z93, align 4, !tbaa !51
  %cmp94 = fcmp ogt float %60, 0x3E80000000000000
  br i1 %cmp94, label %if.then, label %if.end113

if.then:                                          ; preds = %lor.lhs.false92, %lor.lhs.false, %for.end
  %x95 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %61 = load float, float* %x95, align 4, !tbaa !47
  %y96 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %62 = load float, float* %y96, align 4, !tbaa !50
  %cmp97 = fcmp ogt float %61, %62
  br i1 %cmp97, label %land.lhs.true, label %if.then101

land.lhs.true:                                    ; preds = %if.then
  %x98 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %63 = load float, float* %x98, align 4, !tbaa !47
  %z99 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %64 = load float, float* %z99, align 4, !tbaa !51
  %cmp100 = fcmp ogt float %63, %64
  br i1 %cmp100, label %if.end112, label %if.then101

if.then101:                                       ; preds = %land.lhs.true, %if.then
  %arrayidx102 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  store i32 0, i32* %arrayidx102, align 4, !tbaa !15
  %z103 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %65 = load float, float* %z103, align 4, !tbaa !51
  %x104 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 0
  %66 = load float, float* %x104, align 4, !tbaa !47
  %cmp105 = fcmp ogt float %65, %66
  br i1 %cmp105, label %land.lhs.true106, label %if.end

land.lhs.true106:                                 ; preds = %if.then101
  %z107 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 2
  %67 = load float, float* %z107, align 4, !tbaa !51
  %y108 = getelementptr inbounds %struct.vec3, %struct.vec3* %corner, i32 0, i32 1
  %68 = load float, float* %y108, align 4, !tbaa !50
  %cmp109 = fcmp ogt float %67, %68
  br i1 %cmp109, label %if.then110, label %if.end

if.then110:                                       ; preds = %land.lhs.true106
  %arrayidx111 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  store i32 1, i32* %arrayidx111, align 4, !tbaa !15
  br label %if.end

if.end:                                           ; preds = %if.then110, %land.lhs.true106, %if.then101
  br label %if.end112

if.end112:                                        ; preds = %if.end, %land.lhs.true
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end113:                                        ; preds = %lor.lhs.false92
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end113, %if.end112
  %69 = bitcast %struct.vec3* %corner to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %69) #7
  %70 = bitcast [2 x %struct.vec3]* %edges to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %70) #7
  %71 = bitcast [3 x %struct.vec3]* %v to i8*
  call void @llvm.lifetime.end.p0i8(i64 36, i8* %71) #7
  %72 = bitcast %struct.IndexTriplet** %indices to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %72) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup119 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc117

for.inc117:                                       ; preds = %cleanup.cont
  %73 = load i32, i32* %i, align 4, !tbaa !15
  %inc118 = add i32 %73, 1
  store i32 %inc118, i32* %i, align 4, !tbaa !15
  br label %for.cond

cleanup119:                                       ; preds = %cleanup, %for.cond.cleanup
  %74 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %74) #7
  br label %for.end120

for.end120:                                       ; preds = %cleanup119
  %75 = bitcast float* %area to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %75) #7
  store float 0.000000e+00, float* %area, align 4, !tbaa !91
  %76 = bitcast i32* %i121 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %76) #7
  store i32 0, i32* %i121, align 4, !tbaa !15
  br label %for.cond122

for.cond122:                                      ; preds = %for.inc163, %for.end120
  %77 = load i32, i32* %i121, align 4, !tbaa !15
  %78 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %length123 = getelementptr inbounds %struct.Array, %struct.Array* %78, i32 0, i32 1
  %79 = load i32, i32* %length123, align 8, !tbaa !26
  %cmp124 = icmp ult i32 %77, %79
  br i1 %cmp124, label %for.body126, label %for.cond.cleanup125

for.cond.cleanup125:                              ; preds = %for.cond122
  store i32 8, i32* %cleanup.dest.slot, align 4
  %80 = bitcast i32* %i121 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %80) #7
  br label %for.end166

for.body126:                                      ; preds = %for.cond122
  %81 = bitcast %struct.IndexTriplet** %i0 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %81) #7
  %82 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %data127 = getelementptr inbounds %struct.Array, %struct.Array* %82, i32 0, i32 0
  %83 = load i8*, i8** %data127, align 8, !tbaa !31
  %84 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %84, i32 0, i32 3
  %85 = load i32, i32* %elementSize, align 8, !tbaa !32
  %86 = load i32, i32* %i121, align 4, !tbaa !15
  %add128 = add i32 %86, 0
  %87 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %length129 = getelementptr inbounds %struct.Array, %struct.Array* %87, i32 0, i32 1
  %88 = load i32, i32* %length129, align 8, !tbaa !26
  %rem130 = urem i32 %add128, %88
  %mul131 = mul i32 %85, %rem130
  %idxprom132 = zext i32 %mul131 to i64
  %arrayidx133 = getelementptr inbounds i8, i8* %83, i64 %idxprom132
  %89 = bitcast i8* %arrayidx133 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %89, %struct.IndexTriplet** %i0, align 8, !tbaa !4
  %90 = bitcast %struct.IndexTriplet** %i1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %90) #7
  %91 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %data134 = getelementptr inbounds %struct.Array, %struct.Array* %91, i32 0, i32 0
  %92 = load i8*, i8** %data134, align 8, !tbaa !31
  %93 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %elementSize135 = getelementptr inbounds %struct.Array, %struct.Array* %93, i32 0, i32 3
  %94 = load i32, i32* %elementSize135, align 8, !tbaa !32
  %95 = load i32, i32* %i121, align 4, !tbaa !15
  %add136 = add i32 %95, 1
  %96 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %length137 = getelementptr inbounds %struct.Array, %struct.Array* %96, i32 0, i32 1
  %97 = load i32, i32* %length137, align 8, !tbaa !26
  %rem138 = urem i32 %add136, %97
  %mul139 = mul i32 %94, %rem138
  %idxprom140 = zext i32 %mul139 to i64
  %arrayidx141 = getelementptr inbounds i8, i8* %92, i64 %idxprom140
  %98 = bitcast i8* %arrayidx141 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %98, %struct.IndexTriplet** %i1, align 8, !tbaa !4
  %99 = bitcast float** %v0 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %99) #7
  %100 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  %101 = load %struct.IndexTriplet*, %struct.IndexTriplet** %i0, align 8, !tbaa !4
  %v142 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %101, i32 0, i32 0
  %102 = load i32, i32* %v142, align 4, !tbaa !38
  %call143 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %100, i32 %102)
  %103 = bitcast i8* %call143 to float*
  store float* %103, float** %v0, align 8, !tbaa !4
  %104 = bitcast float** %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %104) #7
  %105 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  %106 = load %struct.IndexTriplet*, %struct.IndexTriplet** %i1, align 8, !tbaa !4
  %v144 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %106, i32 0, i32 0
  %107 = load i32, i32* %v144, align 4, !tbaa !38
  %call145 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %105, i32 %107)
  %108 = bitcast i8* %call145 to float*
  store float* %108, float** %v1, align 8, !tbaa !4
  %109 = load float*, float** %v0, align 8, !tbaa !4
  %arrayidx146 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %110 = load i32, i32* %arrayidx146, align 4, !tbaa !15
  %idxprom147 = zext i32 %110 to i64
  %arrayidx148 = getelementptr inbounds float, float* %109, i64 %idxprom147
  %111 = load float, float* %arrayidx148, align 4, !tbaa !91
  %112 = load float*, float** %v1, align 8, !tbaa !4
  %arrayidx149 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %113 = load i32, i32* %arrayidx149, align 4, !tbaa !15
  %idxprom150 = zext i32 %113 to i64
  %arrayidx151 = getelementptr inbounds float, float* %112, i64 %idxprom150
  %114 = load float, float* %arrayidx151, align 4, !tbaa !91
  %mul152 = fmul float %111, %114
  %115 = load float*, float** %v0, align 8, !tbaa !4
  %arrayidx153 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %116 = load i32, i32* %arrayidx153, align 4, !tbaa !15
  %idxprom154 = zext i32 %116 to i64
  %arrayidx155 = getelementptr inbounds float, float* %115, i64 %idxprom154
  %117 = load float, float* %arrayidx155, align 4, !tbaa !91
  %118 = load float*, float** %v1, align 8, !tbaa !4
  %arrayidx156 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %119 = load i32, i32* %arrayidx156, align 4, !tbaa !15
  %idxprom157 = zext i32 %119 to i64
  %arrayidx158 = getelementptr inbounds float, float* %118, i64 %idxprom157
  %120 = load float, float* %arrayidx158, align 4, !tbaa !91
  %mul159 = fmul float %117, %120
  %sub160 = fsub float %mul152, %mul159
  %mul161 = fmul float %sub160, 5.000000e-01
  %121 = load float, float* %area, align 4, !tbaa !91
  %add162 = fadd float %121, %mul161
  store float %add162, float* %area, align 4, !tbaa !91
  %122 = bitcast float** %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %122) #7
  %123 = bitcast float** %v0 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %123) #7
  %124 = bitcast %struct.IndexTriplet** %i1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %124) #7
  %125 = bitcast %struct.IndexTriplet** %i0 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %125) #7
  br label %for.inc163

for.inc163:                                       ; preds = %for.body126
  %126 = load i32, i32* %i121, align 4, !tbaa !15
  %inc164 = add i32 %126, 1
  store i32 %inc164, i32* %i121, align 4, !tbaa !15
  br label %for.cond122

for.end166:                                       ; preds = %for.cond.cleanup125
  %127 = bitcast %struct.Array** %remainingIndices to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %127) #7
  %128 = load %struct.Array*, %struct.Array** %_tempIndices.addr, align 8, !tbaa !4
  store %struct.Array* %128, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %129 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length167 = getelementptr inbounds %struct.Array, %struct.Array* %129, i32 0, i32 1
  store i32 0, i32* %length167, align 8, !tbaa !26
  %130 = bitcast i32* %i168 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %130) #7
  store i32 0, i32* %i168, align 4, !tbaa !15
  br label %for.cond169

for.cond169:                                      ; preds = %for.inc179, %for.end166
  %131 = load i32, i32* %i168, align 4, !tbaa !15
  %132 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %length170 = getelementptr inbounds %struct.Array, %struct.Array* %132, i32 0, i32 1
  %133 = load i32, i32* %length170, align 8, !tbaa !26
  %cmp171 = icmp ult i32 %131, %133
  br i1 %cmp171, label %for.body173, label %for.cond.cleanup172

for.cond.cleanup172:                              ; preds = %for.cond169
  store i32 11, i32* %cleanup.dest.slot, align 4
  %134 = bitcast i32* %i168 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %134) #7
  br label %for.end182

for.body173:                                      ; preds = %for.cond169
  %135 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %136 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %data174 = getelementptr inbounds %struct.Array, %struct.Array* %136, i32 0, i32 0
  %137 = load i8*, i8** %data174, align 8, !tbaa !31
  %138 = load %struct.Array*, %struct.Array** %_indices.addr, align 8, !tbaa !4
  %elementSize175 = getelementptr inbounds %struct.Array, %struct.Array* %138, i32 0, i32 3
  %139 = load i32, i32* %elementSize175, align 8, !tbaa !32
  %140 = load i32, i32* %i168, align 4, !tbaa !15
  %mul176 = mul i32 %139, %140
  %idxprom177 = zext i32 %mul176 to i64
  %arrayidx178 = getelementptr inbounds i8, i8* %137, i64 %idxprom177
  call void @arrayAppend(%struct.Array* %135, i8* %arrayidx178)
  br label %for.inc179

for.inc179:                                       ; preds = %for.body173
  %141 = load i32, i32* %i168, align 4, !tbaa !15
  %inc180 = add i32 %141, 1
  store i32 %inc180, i32* %i168, align 4, !tbaa !15
  br label %for.cond169

for.end182:                                       ; preds = %for.cond.cleanup172
  %142 = bitcast i32* %remainingIterations to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %142) #7
  %143 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length183 = getelementptr inbounds %struct.Array, %struct.Array* %143, i32 0, i32 1
  %144 = load i32, i32* %length183, align 8, !tbaa !26
  store i32 %144, i32* %remainingIterations, align 4, !tbaa !15
  %145 = bitcast i32* %previousRemainingIndices to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %145) #7
  %146 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length184 = getelementptr inbounds %struct.Array, %struct.Array* %146, i32 0, i32 1
  %147 = load i32, i32* %length184, align 8, !tbaa !26
  store i32 %147, i32* %previousRemainingIndices, align 4, !tbaa !15
  %148 = bitcast i32* %guess_vert to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %148) #7
  store i32 0, i32* %guess_vert, align 4, !tbaa !15
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont345, %cleanup338, %for.end182
  %149 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length185 = getelementptr inbounds %struct.Array, %struct.Array* %149, i32 0, i32 1
  %150 = load i32, i32* %length185, align 8, !tbaa !26
  %cmp186 = icmp ugt i32 %150, 3
  br i1 %cmp186, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %151 = load i32, i32* %remainingIterations, align 4, !tbaa !15
  %cmp187 = icmp ugt i32 %151, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %152 = phi i1 [ false, %while.cond ], [ %cmp187, %land.rhs ]
  br i1 %152, label %while.body, label %while.end346

while.body:                                       ; preds = %land.end
  %153 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %154 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length188 = getelementptr inbounds %struct.Array, %struct.Array* %154, i32 0, i32 1
  %155 = load i32, i32* %length188, align 8, !tbaa !26
  %cmp189 = icmp uge i32 %153, %155
  br i1 %cmp189, label %if.then190, label %if.end193

if.then190:                                       ; preds = %while.body
  %156 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length191 = getelementptr inbounds %struct.Array, %struct.Array* %156, i32 0, i32 1
  %157 = load i32, i32* %length191, align 8, !tbaa !26
  %158 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %sub192 = sub i32 %158, %157
  store i32 %sub192, i32* %guess_vert, align 4, !tbaa !15
  br label %if.end193

if.end193:                                        ; preds = %if.then190, %while.body
  %159 = load i32, i32* %previousRemainingIndices, align 4, !tbaa !15
  %160 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length194 = getelementptr inbounds %struct.Array, %struct.Array* %160, i32 0, i32 1
  %161 = load i32, i32* %length194, align 8, !tbaa !26
  %cmp195 = icmp ne i32 %159, %161
  br i1 %cmp195, label %if.then196, label %if.else

if.then196:                                       ; preds = %if.end193
  %162 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length197 = getelementptr inbounds %struct.Array, %struct.Array* %162, i32 0, i32 1
  %163 = load i32, i32* %length197, align 8, !tbaa !26
  store i32 %163, i32* %previousRemainingIndices, align 4, !tbaa !15
  %164 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length198 = getelementptr inbounds %struct.Array, %struct.Array* %164, i32 0, i32 1
  %165 = load i32, i32* %length198, align 8, !tbaa !26
  store i32 %165, i32* %remainingIterations, align 4, !tbaa !15
  br label %if.end199

if.else:                                          ; preds = %if.end193
  %166 = load i32, i32* %remainingIterations, align 4, !tbaa !15
  %dec = add i32 %166, -1
  store i32 %dec, i32* %remainingIterations, align 4, !tbaa !15
  br label %if.end199

if.end199:                                        ; preds = %if.else, %if.then196
  %167 = bitcast [3 x %struct.IndexTriplet*]* %ind to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %167) #7
  %168 = bitcast [3 x float]* %vx to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %168) #7
  %169 = bitcast [3 x float]* %vy to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %169) #7
  %170 = bitcast i32* %i200 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %170) #7
  store i32 0, i32* %i200, align 4, !tbaa !15
  br label %for.cond201

for.cond201:                                      ; preds = %for.inc229, %if.end199
  %171 = load i32, i32* %i200, align 4, !tbaa !15
  %cmp202 = icmp ult i32 %171, 3
  br i1 %cmp202, label %for.body204, label %for.cond.cleanup203

for.cond.cleanup203:                              ; preds = %for.cond201
  store i32 16, i32* %cleanup.dest.slot, align 4
  %172 = bitcast i32* %i200 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %172) #7
  br label %for.end232

for.body204:                                      ; preds = %for.cond201
  %173 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %data205 = getelementptr inbounds %struct.Array, %struct.Array* %173, i32 0, i32 0
  %174 = load i8*, i8** %data205, align 8, !tbaa !31
  %175 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %elementSize206 = getelementptr inbounds %struct.Array, %struct.Array* %175, i32 0, i32 3
  %176 = load i32, i32* %elementSize206, align 8, !tbaa !32
  %177 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %178 = load i32, i32* %i200, align 4, !tbaa !15
  %add207 = add i32 %177, %178
  %179 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length208 = getelementptr inbounds %struct.Array, %struct.Array* %179, i32 0, i32 1
  %180 = load i32, i32* %length208, align 8, !tbaa !26
  %rem209 = urem i32 %add207, %180
  %mul210 = mul i32 %176, %rem209
  %idxprom211 = zext i32 %mul210 to i64
  %arrayidx212 = getelementptr inbounds i8, i8* %174, i64 %idxprom211
  %181 = bitcast i8* %arrayidx212 to %struct.IndexTriplet*
  %182 = load i32, i32* %i200, align 4, !tbaa !15
  %idxprom213 = zext i32 %182 to i64
  %arrayidx214 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom213
  store %struct.IndexTriplet* %181, %struct.IndexTriplet** %arrayidx214, align 8, !tbaa !4
  %183 = bitcast float** %pos to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %183) #7
  %184 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  %185 = load i32, i32* %i200, align 4, !tbaa !15
  %idxprom215 = zext i32 %185 to i64
  %arrayidx216 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom215
  %186 = load %struct.IndexTriplet*, %struct.IndexTriplet** %arrayidx216, align 8, !tbaa !4
  %v217 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %186, i32 0, i32 0
  %187 = load i32, i32* %v217, align 4, !tbaa !38
  %call218 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %184, i32 %187)
  %188 = bitcast i8* %call218 to float*
  store float* %188, float** %pos, align 8, !tbaa !4
  %189 = load float*, float** %pos, align 8, !tbaa !4
  %arrayidx219 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %190 = load i32, i32* %arrayidx219, align 4, !tbaa !15
  %idxprom220 = zext i32 %190 to i64
  %arrayidx221 = getelementptr inbounds float, float* %189, i64 %idxprom220
  %191 = load float, float* %arrayidx221, align 4, !tbaa !91
  %192 = load i32, i32* %i200, align 4, !tbaa !15
  %idxprom222 = zext i32 %192 to i64
  %arrayidx223 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 %idxprom222
  store float %191, float* %arrayidx223, align 4, !tbaa !91
  %193 = load float*, float** %pos, align 8, !tbaa !4
  %arrayidx224 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %194 = load i32, i32* %arrayidx224, align 4, !tbaa !15
  %idxprom225 = zext i32 %194 to i64
  %arrayidx226 = getelementptr inbounds float, float* %193, i64 %idxprom225
  %195 = load float, float* %arrayidx226, align 4, !tbaa !91
  %196 = load i32, i32* %i200, align 4, !tbaa !15
  %idxprom227 = zext i32 %196 to i64
  %arrayidx228 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 %idxprom227
  store float %195, float* %arrayidx228, align 4, !tbaa !91
  %197 = bitcast float** %pos to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %197) #7
  br label %for.inc229

for.inc229:                                       ; preds = %for.body204
  %198 = load i32, i32* %i200, align 4, !tbaa !15
  %inc230 = add i32 %198, 1
  store i32 %inc230, i32* %i200, align 4, !tbaa !15
  br label %for.cond201

for.end232:                                       ; preds = %for.cond.cleanup203
  %199 = bitcast [2 x float]* %edge0 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %199) #7
  %200 = bitcast [2 x float]* %edge1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %200) #7
  %arrayidx233 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 1
  %201 = load float, float* %arrayidx233, align 4, !tbaa !91
  %arrayidx234 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 0
  %202 = load float, float* %arrayidx234, align 4, !tbaa !91
  %sub235 = fsub float %201, %202
  %arrayidx236 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 0
  store float %sub235, float* %arrayidx236, align 4, !tbaa !91
  %arrayidx237 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 1
  %203 = load float, float* %arrayidx237, align 4, !tbaa !91
  %arrayidx238 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 0
  %204 = load float, float* %arrayidx238, align 4, !tbaa !91
  %sub239 = fsub float %203, %204
  %arrayidx240 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 1
  store float %sub239, float* %arrayidx240, align 4, !tbaa !91
  %arrayidx241 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 2
  %205 = load float, float* %arrayidx241, align 4, !tbaa !91
  %arrayidx242 = getelementptr inbounds [3 x float], [3 x float]* %vx, i64 0, i64 1
  %206 = load float, float* %arrayidx242, align 4, !tbaa !91
  %sub243 = fsub float %205, %206
  %arrayidx244 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 0
  store float %sub243, float* %arrayidx244, align 4, !tbaa !91
  %arrayidx245 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 2
  %207 = load float, float* %arrayidx245, align 4, !tbaa !91
  %arrayidx246 = getelementptr inbounds [3 x float], [3 x float]* %vy, i64 0, i64 1
  %208 = load float, float* %arrayidx246, align 4, !tbaa !91
  %sub247 = fsub float %207, %208
  %arrayidx248 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 1
  store float %sub247, float* %arrayidx248, align 4, !tbaa !91
  %209 = bitcast float* %cross to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %209) #7
  %arrayidx249 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 0
  %210 = load float, float* %arrayidx249, align 4, !tbaa !91
  %arrayidx250 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 1
  %211 = load float, float* %arrayidx250, align 4, !tbaa !91
  %mul251 = fmul float %210, %211
  %arrayidx252 = getelementptr inbounds [2 x float], [2 x float]* %edge0, i64 0, i64 1
  %212 = load float, float* %arrayidx252, align 4, !tbaa !91
  %arrayidx253 = getelementptr inbounds [2 x float], [2 x float]* %edge1, i64 0, i64 0
  %213 = load float, float* %arrayidx253, align 4, !tbaa !91
  %mul254 = fmul float %212, %213
  %sub255 = fsub float %mul251, %mul254
  store float %sub255, float* %cross, align 4, !tbaa !91
  %214 = load float, float* %cross, align 4, !tbaa !91
  %215 = load float, float* %area, align 4, !tbaa !91
  %mul256 = fmul float %214, %215
  %cmp257 = fcmp olt float %mul256, 0.000000e+00
  br i1 %cmp257, label %if.then258, label %if.end260

if.then258:                                       ; preds = %for.end232
  %216 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %add259 = add i32 %216, 1
  store i32 %add259, i32* %guess_vert, align 4, !tbaa !15
  store i32 14, i32* %cleanup.dest.slot, align 4
  br label %cleanup338

if.end260:                                        ; preds = %for.end232
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %overlap) #7
  store i8 0, i8* %overlap, align 1, !tbaa !24
  %217 = bitcast i32* %otherVert to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %217) #7
  store i32 3, i32* %otherVert, align 4, !tbaa !15
  br label %for.cond261

for.cond261:                                      ; preds = %for.inc297, %if.end260
  %218 = load i32, i32* %otherVert, align 4, !tbaa !15
  %219 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length262 = getelementptr inbounds %struct.Array, %struct.Array* %219, i32 0, i32 1
  %220 = load i32, i32* %length262, align 8, !tbaa !26
  %cmp263 = icmp ult i32 %218, %220
  br i1 %cmp263, label %for.body265, label %for.cond.cleanup264

for.cond.cleanup264:                              ; preds = %for.cond261
  store i32 19, i32* %cleanup.dest.slot, align 4
  br label %cleanup299

for.body265:                                      ; preds = %for.cond261
  %221 = bitcast i32* %idx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %221) #7
  %222 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %223 = load i32, i32* %otherVert, align 4, !tbaa !15
  %add266 = add i32 %222, %223
  %224 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length267 = getelementptr inbounds %struct.Array, %struct.Array* %224, i32 0, i32 1
  %225 = load i32, i32* %length267, align 8, !tbaa !26
  %rem268 = urem i32 %add266, %225
  store i32 %rem268, i32* %idx, align 4, !tbaa !15
  %226 = load i32, i32* %idx, align 4, !tbaa !15
  %227 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length269 = getelementptr inbounds %struct.Array, %struct.Array* %227, i32 0, i32 1
  %228 = load i32, i32* %length269, align 8, !tbaa !26
  %cmp270 = icmp uge i32 %226, %228
  br i1 %cmp270, label %if.then271, label %if.end272

if.then271:                                       ; preds = %for.body265
  store i32 21, i32* %cleanup.dest.slot, align 4
  br label %cleanup294

if.end272:                                        ; preds = %for.body265
  %229 = bitcast i32* %ovi to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %229) #7
  %230 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %data273 = getelementptr inbounds %struct.Array, %struct.Array* %230, i32 0, i32 0
  %231 = load i8*, i8** %data273, align 8, !tbaa !31
  %232 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %elementSize274 = getelementptr inbounds %struct.Array, %struct.Array* %232, i32 0, i32 3
  %233 = load i32, i32* %elementSize274, align 8, !tbaa !32
  %234 = load i32, i32* %idx, align 4, !tbaa !15
  %mul275 = mul i32 %233, %234
  %idxprom276 = zext i32 %mul275 to i64
  %arrayidx277 = getelementptr inbounds i8, i8* %231, i64 %idxprom276
  %235 = bitcast i8* %arrayidx277 to %struct.IndexTriplet*
  %v278 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %235, i32 0, i32 0
  %236 = load i32, i32* %v278, align 4, !tbaa !38
  store i32 %236, i32* %ovi, align 4, !tbaa !15
  %237 = bitcast float* %tx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %237) #7
  %238 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  %239 = load i32, i32* %ovi, align 4, !tbaa !15
  %call279 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %238, i32 %239)
  %240 = bitcast i8* %call279 to float*
  %arrayidx280 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 0
  %241 = load i32, i32* %arrayidx280, align 4, !tbaa !15
  %idxprom281 = zext i32 %241 to i64
  %arrayidx282 = getelementptr inbounds float, float* %240, i64 %idxprom281
  %242 = load float, float* %arrayidx282, align 4, !tbaa !91
  store float %242, float* %tx, align 4, !tbaa !91
  %243 = bitcast float* %ty to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %243) #7
  %244 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_positions.addr, align 8, !tbaa !4
  %245 = load i32, i32* %ovi, align 4, !tbaa !15
  %call283 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %244, i32 %245)
  %246 = bitcast i8* %call283 to float*
  %arrayidx284 = getelementptr inbounds [2 x i32], [2 x i32]* %axes, i64 0, i64 1
  %247 = load i32, i32* %arrayidx284, align 4, !tbaa !15
  %idxprom285 = zext i32 %247 to i64
  %arrayidx286 = getelementptr inbounds float, float* %246, i64 %idxprom285
  %248 = load float, float* %arrayidx286, align 4, !tbaa !91
  store float %248, float* %ty, align 4, !tbaa !91
  %arraydecay = getelementptr inbounds [3 x float], [3 x float]* %vx, i32 0, i32 0
  %arraydecay287 = getelementptr inbounds [3 x float], [3 x float]* %vy, i32 0, i32 0
  %249 = load float, float* %tx, align 4, !tbaa !91
  %250 = load float, float* %ty, align 4, !tbaa !91
  %call288 = call i32 @pnpoly(i32 3, float* %arraydecay, float* %arraydecay287, float %249, float %250)
  %tobool = icmp ne i32 %call288, 0
  br i1 %tobool, label %if.then289, label %if.end290

if.then289:                                       ; preds = %if.end272
  store i8 1, i8* %overlap, align 1, !tbaa !24
  store i32 19, i32* %cleanup.dest.slot, align 4
  br label %cleanup291

if.end290:                                        ; preds = %if.end272
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup291

cleanup291:                                       ; preds = %if.end290, %if.then289
  %251 = bitcast float* %ty to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %251) #7
  %252 = bitcast float* %tx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %252) #7
  %253 = bitcast i32* %ovi to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %253) #7
  br label %cleanup294

cleanup294:                                       ; preds = %cleanup291, %if.then271
  %254 = bitcast i32* %idx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %254) #7
  %cleanup.dest295 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest295, label %cleanup299 [
    i32 0, label %cleanup.cont296
    i32 21, label %for.inc297
  ]

cleanup.cont296:                                  ; preds = %cleanup294
  br label %for.inc297

for.inc297:                                       ; preds = %cleanup.cont296, %cleanup294
  %255 = load i32, i32* %otherVert, align 4, !tbaa !15
  %inc298 = add i32 %255, 1
  store i32 %inc298, i32* %otherVert, align 4, !tbaa !15
  br label %for.cond261

cleanup299:                                       ; preds = %cleanup294, %for.cond.cleanup264
  %256 = bitcast i32* %otherVert to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %256) #7
  br label %for.end300

for.end300:                                       ; preds = %cleanup299
  %257 = load i8, i8* %overlap, align 1, !tbaa !24, !range !46
  %tobool301 = trunc i8 %257 to i1
  br i1 %tobool301, label %if.then302, label %if.end304

if.then302:                                       ; preds = %for.end300
  %258 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %add303 = add i32 %258, 1
  store i32 %add303, i32* %guess_vert, align 4, !tbaa !15
  store i32 14, i32* %cleanup.dest.slot, align 4
  br label %cleanup337

if.end304:                                        ; preds = %for.end300
  %259 = bitcast %struct.Face* %face to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %259) #7
  %260 = bitcast i32* %i305 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %260) #7
  store i32 0, i32* %i305, align 4, !tbaa !15
  br label %for.cond306

for.cond306:                                      ; preds = %for.inc315, %if.end304
  %261 = load i32, i32* %i305, align 4, !tbaa !15
  %cmp307 = icmp slt i32 %261, 3
  br i1 %cmp307, label %for.body309, label %for.cond.cleanup308

for.cond.cleanup308:                              ; preds = %for.cond306
  store i32 22, i32* %cleanup.dest.slot, align 4
  %262 = bitcast i32* %i305 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %262) #7
  br label %for.end318

for.body309:                                      ; preds = %for.cond306
  %indices310 = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 2
  %263 = load i32, i32* %i305, align 4, !tbaa !15
  %idxprom311 = sext i32 %263 to i64
  %arrayidx312 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices310, i64 0, i64 %idxprom311
  %264 = load i32, i32* %i305, align 4, !tbaa !15
  %idxprom313 = sext i32 %264 to i64
  %arrayidx314 = getelementptr inbounds [3 x %struct.IndexTriplet*], [3 x %struct.IndexTriplet*]* %ind, i64 0, i64 %idxprom313
  %265 = load %struct.IndexTriplet*, %struct.IndexTriplet** %arrayidx314, align 8, !tbaa !4
  %266 = bitcast %struct.IndexTriplet* %arrayidx312 to i8*
  %267 = bitcast %struct.IndexTriplet* %265 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %266, i8* align 4 %267, i64 12, i1 false), !tbaa.struct !45
  br label %for.inc315

for.inc315:                                       ; preds = %for.body309
  %268 = load i32, i32* %i305, align 4, !tbaa !15
  %inc316 = add nsw i32 %268, 1
  store i32 %inc316, i32* %i305, align 4, !tbaa !15
  br label %for.cond306

for.end318:                                       ; preds = %for.cond.cleanup308
  %269 = load i32, i32* %_materialIndex.addr, align 4, !tbaa !15
  %conv = trunc i32 %269 to i16
  %materialIndex = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 0
  store i16 %conv, i16* %materialIndex, align 4, !tbaa !42
  %270 = load i16, i16* %_smoothingGroup.addr, align 2, !tbaa !22
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %face, i32 0, i32 1
  store i16 %270, i16* %smoothingGroup, align 2, !tbaa !44
  %271 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8, !tbaa !4
  %272 = bitcast %struct.Face* %face to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %271, i8* %272)
  %273 = bitcast i32* %removed_vert_index to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %273) #7
  %274 = load i32, i32* %guess_vert, align 4, !tbaa !15
  %add319 = add i32 %274, 1
  %275 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length320 = getelementptr inbounds %struct.Array, %struct.Array* %275, i32 0, i32 1
  %276 = load i32, i32* %length320, align 8, !tbaa !26
  %rem321 = urem i32 %add319, %276
  store i32 %rem321, i32* %removed_vert_index, align 4, !tbaa !15
  br label %while.cond322

while.cond322:                                    ; preds = %while.body327, %for.end318
  %277 = load i32, i32* %removed_vert_index, align 4, !tbaa !15
  %add323 = add i32 %277, 1
  %278 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length324 = getelementptr inbounds %struct.Array, %struct.Array* %278, i32 0, i32 1
  %279 = load i32, i32* %length324, align 8, !tbaa !26
  %cmp325 = icmp ult i32 %add323, %279
  br i1 %cmp325, label %while.body327, label %while.end

while.body327:                                    ; preds = %while.cond322
  %280 = bitcast %struct.IndexTriplet** %remainingIndicesData to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %280) #7
  %281 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %data328 = getelementptr inbounds %struct.Array, %struct.Array* %281, i32 0, i32 0
  %282 = load i8*, i8** %data328, align 8, !tbaa !31
  %283 = bitcast i8* %282 to %struct.IndexTriplet*
  store %struct.IndexTriplet* %283, %struct.IndexTriplet** %remainingIndicesData, align 8, !tbaa !4
  %284 = load %struct.IndexTriplet*, %struct.IndexTriplet** %remainingIndicesData, align 8, !tbaa !4
  %285 = load i32, i32* %removed_vert_index, align 4, !tbaa !15
  %idxprom329 = zext i32 %285 to i64
  %arrayidx330 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %284, i64 %idxprom329
  %286 = load %struct.IndexTriplet*, %struct.IndexTriplet** %remainingIndicesData, align 8, !tbaa !4
  %287 = load i32, i32* %removed_vert_index, align 4, !tbaa !15
  %add331 = add i32 %287, 1
  %idxprom332 = zext i32 %add331 to i64
  %arrayidx333 = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %286, i64 %idxprom332
  %288 = bitcast %struct.IndexTriplet* %arrayidx330 to i8*
  %289 = bitcast %struct.IndexTriplet* %arrayidx333 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %288, i8* align 4 %289, i64 12, i1 false), !tbaa.struct !45
  %290 = load i32, i32* %removed_vert_index, align 4, !tbaa !15
  %add334 = add i32 %290, 1
  store i32 %add334, i32* %removed_vert_index, align 4, !tbaa !15
  %291 = bitcast %struct.IndexTriplet** %remainingIndicesData to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %291) #7
  br label %while.cond322

while.end:                                        ; preds = %while.cond322
  %292 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length335 = getelementptr inbounds %struct.Array, %struct.Array* %292, i32 0, i32 1
  %293 = load i32, i32* %length335, align 8, !tbaa !26
  %dec336 = add i32 %293, -1
  store i32 %dec336, i32* %length335, align 8, !tbaa !26
  %294 = bitcast i32* %removed_vert_index to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %294) #7
  %295 = bitcast %struct.Face* %face to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %295) #7
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup337

cleanup337:                                       ; preds = %while.end, %if.then302
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %overlap) #7
  br label %cleanup338

cleanup338:                                       ; preds = %cleanup337, %if.then258
  %296 = bitcast float* %cross to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %296) #7
  %297 = bitcast [2 x float]* %edge1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %297) #7
  %298 = bitcast [2 x float]* %edge0 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %298) #7
  %299 = bitcast [3 x float]* %vy to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %299) #7
  %300 = bitcast [3 x float]* %vx to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %300) #7
  %301 = bitcast [3 x %struct.IndexTriplet*]* %ind to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %301) #7
  %cleanup.dest344 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest344, label %unreachable [
    i32 0, label %cleanup.cont345
    i32 14, label %while.cond
  ]

cleanup.cont345:                                  ; preds = %cleanup338
  br label %while.cond

while.end346:                                     ; preds = %land.end
  %302 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %length347 = getelementptr inbounds %struct.Array, %struct.Array* %302, i32 0, i32 1
  %303 = load i32, i32* %length347, align 8, !tbaa !26
  %cmp348 = icmp eq i32 %303, 3
  br i1 %cmp348, label %if.then350, label %if.end373

if.then350:                                       ; preds = %while.end346
  %304 = bitcast %struct.Face* %face351 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %304) #7
  %305 = bitcast i32* %i352 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %305) #7
  store i32 0, i32* %i352, align 4, !tbaa !15
  br label %for.cond353

for.cond353:                                      ; preds = %for.inc366, %if.then350
  %306 = load i32, i32* %i352, align 4, !tbaa !15
  %cmp354 = icmp slt i32 %306, 3
  br i1 %cmp354, label %for.body357, label %for.cond.cleanup356

for.cond.cleanup356:                              ; preds = %for.cond353
  store i32 27, i32* %cleanup.dest.slot, align 4
  %307 = bitcast i32* %i352 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %307) #7
  br label %for.end369

for.body357:                                      ; preds = %for.cond353
  %indices358 = getelementptr inbounds %struct.Face, %struct.Face* %face351, i32 0, i32 2
  %308 = load i32, i32* %i352, align 4, !tbaa !15
  %idxprom359 = sext i32 %308 to i64
  %arrayidx360 = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices358, i64 0, i64 %idxprom359
  %309 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %data361 = getelementptr inbounds %struct.Array, %struct.Array* %309, i32 0, i32 0
  %310 = load i8*, i8** %data361, align 8, !tbaa !31
  %311 = load %struct.Array*, %struct.Array** %remainingIndices, align 8, !tbaa !4
  %elementSize362 = getelementptr inbounds %struct.Array, %struct.Array* %311, i32 0, i32 3
  %312 = load i32, i32* %elementSize362, align 8, !tbaa !32
  %313 = load i32, i32* %i352, align 4, !tbaa !15
  %mul363 = mul i32 %312, %313
  %idxprom364 = zext i32 %mul363 to i64
  %arrayidx365 = getelementptr inbounds i8, i8* %310, i64 %idxprom364
  %314 = bitcast i8* %arrayidx365 to %struct.IndexTriplet*
  %315 = bitcast %struct.IndexTriplet* %arrayidx360 to i8*
  %316 = bitcast %struct.IndexTriplet* %314 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %315, i8* align 4 %316, i64 12, i1 false), !tbaa.struct !45
  br label %for.inc366

for.inc366:                                       ; preds = %for.body357
  %317 = load i32, i32* %i352, align 4, !tbaa !15
  %inc367 = add nsw i32 %317, 1
  store i32 %inc367, i32* %i352, align 4, !tbaa !15
  br label %for.cond353

for.end369:                                       ; preds = %for.cond.cleanup356
  %318 = load i32, i32* %_materialIndex.addr, align 4, !tbaa !15
  %conv370 = trunc i32 %318 to i16
  %materialIndex371 = getelementptr inbounds %struct.Face, %struct.Face* %face351, i32 0, i32 0
  store i16 %conv370, i16* %materialIndex371, align 4, !tbaa !42
  %319 = load i16, i16* %_smoothingGroup.addr, align 2, !tbaa !22
  %smoothingGroup372 = getelementptr inbounds %struct.Face, %struct.Face* %face351, i32 0, i32 1
  store i16 %319, i16* %smoothingGroup372, align 2, !tbaa !44
  %320 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8, !tbaa !4
  %321 = bitcast %struct.Face* %face351 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %320, i8* %321)
  %322 = bitcast %struct.Face* %face351 to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %322) #7
  br label %if.end373

if.end373:                                        ; preds = %for.end369, %while.end346
  %323 = bitcast i32* %guess_vert to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %323) #7
  %324 = bitcast i32* %previousRemainingIndices to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %324) #7
  %325 = bitcast i32* %remainingIterations to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %325) #7
  %326 = bitcast %struct.Array** %remainingIndices to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %326) #7
  %327 = bitcast float* %area to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %327) #7
  %328 = bitcast [2 x i32]* %axes to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %328) #7
  ret void

unreachable:                                      ; preds = %cleanup338
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal void @strCopy(i8* %_dest, i64 %_destSize, i8* %_src, i64 %_count) #0 {
entry:
  %_dest.addr = alloca i8*, align 8
  %_destSize.addr = alloca i64, align 8
  %_src.addr = alloca i8*, align 8
  %_count.addr = alloca i64, align 8
  %n = alloca i64, align 8
  store i8* %_dest, i8** %_dest.addr, align 8, !tbaa !4
  store i64 %_destSize, i64* %_destSize.addr, align 8, !tbaa !13
  store i8* %_src, i8** %_src.addr, align 8, !tbaa !4
  store i64 %_count, i64* %_count.addr, align 8, !tbaa !13
  %0 = bitcast i64* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i64, i64* %_destSize.addr, align 8, !tbaa !13
  %sub = sub i64 %1, 1
  %2 = load i8*, i8** %_src.addr, align 8, !tbaa !4
  %3 = load i64, i64* %_count.addr, align 8, !tbaa !13
  %call = call i64 @strLength(i8* %2, i64 %3)
  %cmp = icmp ult i64 %sub, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, i64* %_destSize.addr, align 8, !tbaa !13
  %sub1 = sub i64 %4, 1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i8*, i8** %_src.addr, align 8, !tbaa !4
  %6 = load i64, i64* %_count.addr, align 8, !tbaa !13
  %call2 = call i64 @strLength(i8* %5, i64 %6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub1, %cond.true ], [ %call2, %cond.false ]
  store i64 %cond, i64* %n, align 8, !tbaa !13
  %7 = load i8*, i8** %_dest.addr, align 8, !tbaa !4
  %8 = load i8*, i8** %_src.addr, align 8, !tbaa !4
  %9 = load i64, i64* %n, align 8, !tbaa !13
  %10 = load i8*, i8** %_dest.addr, align 8, !tbaa !4
  %11 = call i64 @llvm.objectsize.i64.p0i8(i8* %10, i1 false, i1 true)
  %call3 = call i8* @__memcpy_chk(i8* %7, i8* %8, i64 %9, i64 %11) #7
  %12 = load i8*, i8** %_dest.addr, align 8, !tbaa !4
  %13 = load i64, i64* %n, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds i8, i8* %12, i64 %13
  store i8 0, i8* %arrayidx, align 1, !tbaa !14
  %14 = bitcast i64* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @strLength(i8* %_str, i64 %_size) #0 {
entry:
  %_str.addr = alloca i8*, align 8
  %_size.addr = alloca i64, align 8
  %c = alloca i8*, align 8
  %len = alloca i64, align 8
  store i8* %_str, i8** %_str.addr, align 8, !tbaa !4
  store i64 %_size, i64* %_size.addr, align 8, !tbaa !13
  %0 = bitcast i8** %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i8*, i8** %_str.addr, align 8, !tbaa !4
  store i8* %1, i8** %c, align 8, !tbaa !4
  %2 = bitcast i64* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  store i64 0, i64* %len, align 8, !tbaa !13
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load i8*, i8** %c, align 8, !tbaa !4
  %4 = load i8, i8* %3, align 1, !tbaa !14
  %conv = sext i8 %4 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load i64, i64* %len, align 8, !tbaa !13
  %6 = load i64, i64* %_size.addr, align 8, !tbaa !13
  %cmp2 = icmp ult i64 %5, %6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8*, i8** %c, align 8, !tbaa !4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %c, align 8, !tbaa !4
  %9 = load i64, i64* %len, align 8, !tbaa !13
  %inc = add i64 %9, 1
  store i64 %inc, i64* %len, align 8, !tbaa !13
  br label %while.cond

while.end:                                        ; preds = %land.end
  %10 = load i64, i64* %len, align 8, !tbaa !13
  %11 = bitcast i64* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  %12 = bitcast i8** %c to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #7
  ret i64 %10
}

; Function Attrs: nounwind ssp uwtable
define internal void @strConcat(i8* %_dest, i64 %_destSize, i8* %_src, i64 %_count) #0 {
entry:
  %_dest.addr = alloca i8*, align 8
  %_destSize.addr = alloca i64, align 8
  %_src.addr = alloca i8*, align 8
  %_count.addr = alloca i64, align 8
  %start = alloca i64, align 8
  store i8* %_dest, i8** %_dest.addr, align 8, !tbaa !4
  store i64 %_destSize, i64* %_destSize.addr, align 8, !tbaa !13
  store i8* %_src, i8** %_src.addr, align 8, !tbaa !4
  store i64 %_count, i64* %_count.addr, align 8, !tbaa !13
  %0 = bitcast i64* %start to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i8*, i8** %_dest.addr, align 8, !tbaa !4
  %2 = load i64, i64* %_destSize.addr, align 8, !tbaa !13
  %call = call i64 @strLength(i8* %1, i64 %2)
  store i64 %call, i64* %start, align 8, !tbaa !13
  %3 = load i8*, i8** %_dest.addr, align 8, !tbaa !4
  %4 = load i64, i64* %start, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 %4
  %5 = load i64, i64* %_destSize.addr, align 8, !tbaa !13
  %6 = load i64, i64* %start, align 8, !tbaa !13
  %sub = sub i64 %5, %6
  %7 = load i8*, i8** %_src.addr, align 8, !tbaa !4
  %8 = load i64, i64* %_count.addr, align 8, !tbaa !13
  call void @strCopy(i8* %arrayidx, i64 %sub, i8* %7, i64 %8)
  %9 = bitcast i64* %start to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @loadMaterialFile(i8* %_objFilename, i8* %_materialName, %struct.Array* %_materials) #0 {
entry:
  %retval = alloca i1, align 1
  %_objFilename.addr = alloca i8*, align 8
  %_materialName.addr = alloca i8*, align 8
  %_materials.addr = alloca %struct.Array*, align 8
  %filename = alloca [256 x i8], align 16
  %lastSlash = alloca i8*, align 8
  %i = alloca i32, align 4
  %file = alloca %struct.File, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %bom32 = alloca i32*, align 8
  %bom16 = alloca i16*, align 8
  %lexer = alloca %struct.Lexer, align 8
  %token = alloca %struct.Token, align 4
  %mat = alloca %struct.objzMaterial, align 4
  %result = alloca i8, align 1
  %line = alloca i8*, align 8
  %i66 = alloca i64, align 8
  %prop = alloca %struct.MaterialProperty*, align 8
  %dest = alloca i8*, align 8
  %argToken = alloca %struct.Token, align 4
  %j = alloca i32, align 4
  %match = alloca i8, align 1
  %k = alloca i64, align 8
  %arg = alloca %struct.MaterialMapArg*, align 8
  store i8* %_objFilename, i8** %_objFilename.addr, align 8, !tbaa !4
  store i8* %_materialName, i8** %_materialName.addr, align 8, !tbaa !4
  store %struct.Array* %_materials, %struct.Array** %_materials.addr, align 8, !tbaa !4
  %0 = bitcast [256 x i8]* %filename to i8*
  call void @llvm.lifetime.start.p0i8(i64 256, i8* %0) #7
  %1 = bitcast [256 x i8]* %filename to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %1, i8 0, i64 256, i1 false)
  %2 = bitcast i8** %lastSlash to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = load i8*, i8** %_objFilename.addr, align 8, !tbaa !4
  %call = call i8* @strrchr(i8* %3, i32 47)
  store i8* %call, i8** %lastSlash, align 8, !tbaa !4
  %4 = load i8*, i8** %lastSlash, align 8, !tbaa !4
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i8*, i8** %_objFilename.addr, align 8, !tbaa !4
  %call1 = call i8* @strrchr(i8* %5, i32 92)
  store i8* %call1, i8** %lastSlash, align 8, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i8*, i8** %lastSlash, align 8, !tbaa !4
  %tobool2 = icmp ne i8* %6, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %7 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %8 = load i8*, i8** %_objFilename.addr, align 8, !tbaa !4
  %9 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds i8, i8* %8, i64 %idxprom
  %10 = load i8, i8* %arrayidx, align 1, !tbaa !14
  %11 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom4 = sext i32 %11 to i64
  %arrayidx5 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i64 0, i64 %idxprom4
  store i8 %10, i8* %arrayidx5, align 1, !tbaa !14
  %12 = load i8*, i8** %_objFilename.addr, align 8, !tbaa !4
  %13 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr inbounds i8, i8* %12, i64 %idxprom6
  %14 = load i8*, i8** %lastSlash, align 8, !tbaa !4
  %cmp = icmp eq i8* %arrayidx7, %14
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.cond
  %15 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #7
  br label %for.end

if.end9:                                          ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %16 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.end:                                          ; preds = %if.then8
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %17 = load i8*, i8** %_materialName.addr, align 8, !tbaa !4
  %18 = load i8*, i8** %_materialName.addr, align 8, !tbaa !4
  %call10 = call i64 @strLength(i8* %18, i64 256)
  call void @strConcat(i8* %arraydecay, i64 256, i8* %17, i64 %call10)
  br label %if.end13

if.else:                                          ; preds = %if.end
  %arraydecay11 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %19 = load i8*, i8** %_materialName.addr, align 8, !tbaa !4
  %20 = load i8*, i8** %_materialName.addr, align 8, !tbaa !4
  %call12 = call i64 @strLength(i8* %20, i64 256)
  call void @strCopy(i8* %arraydecay11, i64 256, i8* %19, i64 %call12)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %for.end
  %21 = bitcast %struct.File* %file to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %21) #7
  %arraydecay14 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  %call15 = call zeroext i1 @fileOpen(%struct.File* %file, i8* %arraydecay14)
  br i1 %call15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end13
  %arraydecay17 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.25, i32 0, i32 0), i8* %arraydecay17)
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup173

if.end18:                                         ; preds = %if.end13
  %22 = bitcast i32** %bom32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %22) #7
  %buffer = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %23 = load i8*, i8** %buffer, align 8, !tbaa !12
  %24 = bitcast i8* %23 to i32*
  store i32* %24, i32** %bom32, align 8, !tbaa !4
  %25 = load i32*, i32** %bom32, align 8, !tbaa !4
  %26 = load i32, i32* %25, align 4, !tbaa !15
  %cmp19 = icmp eq i32 %26, 65279
  br i1 %cmp19, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %27 = load i32*, i32** %bom32, align 8, !tbaa !4
  %28 = load i32, i32* %27, align 4, !tbaa !15
  %cmp20 = icmp eq i32 %28, -131072
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %lor.lhs.false, %if.end18
  %arraydecay22 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i8* %arraydecay22)
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup172

if.end23:                                         ; preds = %lor.lhs.false
  %29 = bitcast i16** %bom16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %29) #7
  %buffer24 = getelementptr inbounds %struct.File, %struct.File* %file, i32 0, i32 0
  %30 = load i8*, i8** %buffer24, align 8, !tbaa !12
  %31 = bitcast i8* %30 to i16*
  store i16* %31, i16** %bom16, align 8, !tbaa !4
  %32 = load i16*, i16** %bom16, align 8, !tbaa !4
  %33 = load i16, i16* %32, align 2, !tbaa !22
  %conv = zext i16 %33 to i32
  %cmp25 = icmp eq i32 %conv, 65534
  br i1 %cmp25, label %if.then31, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %if.end23
  %34 = load i16*, i16** %bom16, align 8, !tbaa !4
  %35 = load i16, i16* %34, align 2, !tbaa !22
  %conv28 = zext i16 %35 to i32
  %cmp29 = icmp eq i32 %conv28, 65279
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %lor.lhs.false27, %if.end23
  %arraydecay32 = getelementptr inbounds [256 x i8], [256 x i8]* %filename, i32 0, i32 0
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i8* %arraydecay32)
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup171

if.end33:                                         ; preds = %lor.lhs.false27
  %36 = bitcast %struct.Lexer* %lexer to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %36) #7
  call void @initLexer(%struct.Lexer* %lexer)
  %37 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %37) #7
  %38 = bitcast %struct.objzMaterial* %mat to i8*
  call void @llvm.lifetime.start.p0i8(i64 568, i8* %38) #7
  call void @materialInit(%struct.objzMaterial* %mat)
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %result) #7
  store i8 0, i8* %result, align 1, !tbaa !24
  br label %for.cond34

for.cond34:                                       ; preds = %cleanup.cont156, %if.end33
  %39 = bitcast i8** %line to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %39) #7
  %call35 = call i8* @fileReadLine(%struct.File* %file)
  store i8* %call35, i8** %line, align 8, !tbaa !4
  %40 = load i8*, i8** %line, align 8, !tbaa !4
  %tobool36 = icmp ne i8* %40, null
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %for.cond34
  store i32 5, i32* %cleanup.dest.slot, align 4
  br label %cleanup154

if.end38:                                         ; preds = %for.cond34
  %41 = load i8*, i8** %line, align 8, !tbaa !4
  call void @lexerSetLine(%struct.Lexer* %lexer, i8* %41)
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay39 = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call40 = call i32 @strcasecmp(i8* %arraydecay39, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0))
  %cmp41 = icmp eq i32 %call40, 0
  br i1 %cmp41, label %if.then43, label %if.else65

if.then43:                                        ; preds = %if.end38
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %token, i1 zeroext false)
  %text44 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [256 x i8], [256 x i8]* %text44, i64 0, i64 0
  %42 = load i8, i8* %arrayidx45, align 4, !tbaa !14
  %conv46 = sext i8 %42 to i32
  %cmp47 = icmp eq i32 %conv46, 0
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.then43
  %line50 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %43 = load i32, i32* %line50, align 4, !tbaa !33
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %44 = load i32, i32* %column, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.27, i32 0, i32 0), i32 %43, i32 %44)
  store i32 7, i32* %cleanup.dest.slot, align 4
  br label %cleanup154

if.end51:                                         ; preds = %if.then43
  %name = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arrayidx52 = getelementptr inbounds [64 x i8], [64 x i8]* %name, i64 0, i64 0
  %45 = load i8, i8* %arrayidx52, align 4, !tbaa !14
  %conv53 = sext i8 %45 to i32
  %cmp54 = icmp ne i32 %conv53, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end51
  %46 = load %struct.Array*, %struct.Array** %_materials.addr, align 8, !tbaa !4
  %47 = bitcast %struct.objzMaterial* %mat to i8*
  call void @arrayAppend(%struct.Array* %46, i8* %47)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end51
  call void @materialInit(%struct.objzMaterial* %mat)
  %name58 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arraydecay59 = getelementptr inbounds [64 x i8], [64 x i8]* %name58, i32 0, i32 0
  %text60 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay61 = getelementptr inbounds [256 x i8], [256 x i8]* %text60, i32 0, i32 0
  %text62 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [256 x i8], [256 x i8]* %text62, i32 0, i32 0
  %call64 = call i64 @strLength(i8* %arraydecay63, i64 256)
  call void @strCopy(i8* %arraydecay59, i64 64, i8* %arraydecay61, i64 %call64)
  br label %if.end153

if.else65:                                        ; preds = %if.end38
  %48 = bitcast i64* %i66 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %48) #7
  store i64 0, i64* %i66, align 8, !tbaa !13
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc148, %if.else65
  %49 = load i64, i64* %i66, align 8, !tbaa !13
  %cmp68 = icmp ult i64 %49, 14
  br i1 %cmp68, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond67
  store i32 8, i32* %cleanup.dest.slot, align 4
  br label %cleanup150

for.body:                                         ; preds = %for.cond67
  %50 = bitcast %struct.MaterialProperty** %prop to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %50) #7
  %51 = load i64, i64* %i66, align 8, !tbaa !13
  %arrayidx70 = getelementptr inbounds [14 x %struct.MaterialProperty], [14 x %struct.MaterialProperty]* @s_materialProperties, i64 0, i64 %51
  store %struct.MaterialProperty* %arrayidx70, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %52 = bitcast i8** %dest to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %52) #7
  %53 = bitcast %struct.objzMaterial* %mat to i8*
  %54 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %offset = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %54, i32 0, i32 2
  %55 = load i64, i64* %offset, align 8, !tbaa !92
  %arrayidx71 = getelementptr inbounds i8, i8* %53, i64 %55
  store i8* %arrayidx71, i8** %dest, align 8, !tbaa !4
  %text72 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay73 = getelementptr inbounds [256 x i8], [256 x i8]* %text72, i32 0, i32 0
  %56 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %name74 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %56, i32 0, i32 0
  %57 = load i8*, i8** %name74, align 8, !tbaa !94
  %call75 = call i32 @strcasecmp(i8* %arraydecay73, i8* %57)
  %cmp76 = icmp eq i32 %call75, 0
  br i1 %cmp76, label %if.then78, label %if.end143

if.then78:                                        ; preds = %for.body
  %58 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %type = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %58, i32 0, i32 1
  %59 = load i32, i32* %type, align 8, !tbaa !95
  %cmp79 = icmp eq i32 %59, 0
  br i1 %cmp79, label %if.then81, label %if.else132

if.then81:                                        ; preds = %if.then78
  %60 = bitcast %struct.Token* %argToken to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %60) #7
  %61 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %61) #7
  store i32 0, i32* %j, align 4, !tbaa !15
  br label %for.cond82

for.cond82:                                       ; preds = %for.inc124, %if.then81
  call void @tokenize(%struct.Lexer* %lexer, %struct.Token* %argToken, i1 zeroext false)
  %text83 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arrayidx84 = getelementptr inbounds [256 x i8], [256 x i8]* %text83, i64 0, i64 0
  %62 = load i8, i8* %arrayidx84, align 4, !tbaa !14
  %conv85 = sext i8 %62 to i32
  %cmp86 = icmp eq i32 %conv85, 0
  br i1 %cmp86, label %if.then88, label %if.end96

if.then88:                                        ; preds = %for.cond82
  %63 = load i32, i32* %j, align 4, !tbaa !15
  %cmp89 = icmp eq i32 %63, 0
  br i1 %cmp89, label %if.then91, label %if.end95

if.then91:                                        ; preds = %if.then88
  %line92 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %64 = load i32, i32* %line92, align 4, !tbaa !33
  %column93 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %65 = load i32, i32* %column93, align 4, !tbaa !35
  %66 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %name94 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %66, i32 0, i32 0
  %67 = load i8*, i8** %name94, align 8, !tbaa !94
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28, i32 0, i32 0), i32 %64, i32 %65, i8* %67)
  store i32 7, i32* %cleanup.dest.slot, align 4
  br label %cleanup126

if.end95:                                         ; preds = %if.then88
  store i32 11, i32* %cleanup.dest.slot, align 4
  br label %cleanup126

if.end96:                                         ; preds = %for.cond82
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %match) #7
  store i8 0, i8* %match, align 1, !tbaa !24
  %68 = bitcast i64* %k to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %68) #7
  store i64 0, i64* %k, align 8, !tbaa !13
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc112, %if.end96
  %69 = load i64, i64* %k, align 8, !tbaa !13
  %cmp98 = icmp ult i64 %69, 12
  br i1 %cmp98, label %for.body101, label %for.cond.cleanup100

for.cond.cleanup100:                              ; preds = %for.cond97
  store i32 14, i32* %cleanup.dest.slot, align 4
  br label %cleanup114

for.body101:                                      ; preds = %for.cond97
  %70 = bitcast %struct.MaterialMapArg** %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %70) #7
  %71 = load i64, i64* %k, align 8, !tbaa !13
  %arrayidx102 = getelementptr inbounds [12 x %struct.MaterialMapArg], [12 x %struct.MaterialMapArg]* @s_materialMapArgs, i64 0, i64 %71
  store %struct.MaterialMapArg* %arrayidx102, %struct.MaterialMapArg** %arg, align 8, !tbaa !4
  %text103 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay104 = getelementptr inbounds [256 x i8], [256 x i8]* %text103, i32 0, i32 0
  %72 = load %struct.MaterialMapArg*, %struct.MaterialMapArg** %arg, align 8, !tbaa !4
  %name105 = getelementptr inbounds %struct.MaterialMapArg, %struct.MaterialMapArg* %72, i32 0, i32 0
  %73 = load i8*, i8** %name105, align 8, !tbaa !96
  %call106 = call i32 @strcasecmp(i8* %arraydecay104, i8* %73)
  %cmp107 = icmp eq i32 %call106, 0
  br i1 %cmp107, label %if.then109, label %if.end111

if.then109:                                       ; preds = %for.body101
  store i8 1, i8* %match, align 1, !tbaa !24
  %74 = load %struct.MaterialMapArg*, %struct.MaterialMapArg** %arg, align 8, !tbaa !4
  %n = getelementptr inbounds %struct.MaterialMapArg, %struct.MaterialMapArg* %74, i32 0, i32 1
  %75 = load i32, i32* %n, align 8, !tbaa !98
  %call110 = call zeroext i1 @skipTokens(%struct.Lexer* %lexer, i32 %75)
  store i32 14, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end111:                                        ; preds = %for.body101
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end111, %if.then109
  %76 = bitcast %struct.MaterialMapArg** %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %76) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup114 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc112

for.inc112:                                       ; preds = %cleanup.cont
  %77 = load i64, i64* %k, align 8, !tbaa !13
  %inc113 = add i64 %77, 1
  store i64 %inc113, i64* %k, align 8, !tbaa !13
  br label %for.cond97

cleanup114:                                       ; preds = %cleanup, %for.cond.cleanup100
  %78 = bitcast i64* %k to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %78) #7
  br label %for.end115

for.end115:                                       ; preds = %cleanup114
  %79 = load i8, i8* %match, align 1, !tbaa !24, !range !46
  %tobool116 = trunc i8 %79 to i1
  br i1 %tobool116, label %if.end123, label %if.then117

if.then117:                                       ; preds = %for.end115
  %80 = load i8*, i8** %dest, align 8, !tbaa !4
  %text118 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay119 = getelementptr inbounds [256 x i8], [256 x i8]* %text118, i32 0, i32 0
  %text120 = getelementptr inbounds %struct.Token, %struct.Token* %argToken, i32 0, i32 0
  %arraydecay121 = getelementptr inbounds [256 x i8], [256 x i8]* %text120, i32 0, i32 0
  %call122 = call i64 @strLength(i8* %arraydecay121, i64 256)
  call void @strCopy(i8* %80, i64 64, i8* %arraydecay119, i64 %call122)
  br label %if.end123

if.end123:                                        ; preds = %if.then117, %for.end115
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %match) #7
  br label %for.inc124

for.inc124:                                       ; preds = %if.end123
  %81 = load i32, i32* %j, align 4, !tbaa !15
  %inc125 = add nsw i32 %81, 1
  store i32 %inc125, i32* %j, align 4, !tbaa !15
  br label %for.cond82

cleanup126:                                       ; preds = %if.then91, %if.end95
  %82 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %82) #7
  %cleanup.dest127 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest127, label %cleanup129 [
    i32 11, label %for.end128
  ]

for.end128:                                       ; preds = %cleanup126
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup129

cleanup129:                                       ; preds = %for.end128, %cleanup126
  %83 = bitcast %struct.Token* %argToken to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %83) #7
  %cleanup.dest130 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest130, label %cleanup144 [
    i32 0, label %cleanup.cont131
  ]

cleanup.cont131:                                  ; preds = %cleanup129
  br label %if.end142

if.else132:                                       ; preds = %if.then78
  %84 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %type133 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %84, i32 0, i32 1
  %85 = load i32, i32* %type133, align 8, !tbaa !95
  %cmp134 = icmp eq i32 %85, 1
  br i1 %cmp134, label %if.then136, label %if.end141

if.then136:                                       ; preds = %if.else132
  %86 = load i8*, i8** %dest, align 8, !tbaa !4
  %87 = bitcast i8* %86 to float*
  %88 = load %struct.MaterialProperty*, %struct.MaterialProperty** %prop, align 8, !tbaa !4
  %n137 = getelementptr inbounds %struct.MaterialProperty, %struct.MaterialProperty* %88, i32 0, i32 3
  %89 = load i32, i32* %n137, align 8, !tbaa !99
  %call138 = call zeroext i1 @parseFloats(%struct.Lexer* %lexer, float* %87, i32 %89)
  br i1 %call138, label %if.end140, label %if.then139

if.then139:                                       ; preds = %if.then136
  store i32 7, i32* %cleanup.dest.slot, align 4
  br label %cleanup144

if.end140:                                        ; preds = %if.then136
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.else132
  br label %if.end142

if.end142:                                        ; preds = %if.end141, %cleanup.cont131
  store i32 8, i32* %cleanup.dest.slot, align 4
  br label %cleanup144

if.end143:                                        ; preds = %for.body
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup144

cleanup144:                                       ; preds = %if.then139, %if.end143, %if.end142, %cleanup129
  %90 = bitcast i8** %dest to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %90) #7
  %91 = bitcast %struct.MaterialProperty** %prop to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %91) #7
  %cleanup.dest146 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest146, label %cleanup150 [
    i32 0, label %cleanup.cont147
  ]

cleanup.cont147:                                  ; preds = %cleanup144
  br label %for.inc148

for.inc148:                                       ; preds = %cleanup.cont147
  %92 = load i64, i64* %i66, align 8, !tbaa !13
  %inc149 = add i64 %92, 1
  store i64 %inc149, i64* %i66, align 8, !tbaa !13
  br label %for.cond67

cleanup150:                                       ; preds = %cleanup144, %for.cond.cleanup
  %93 = bitcast i64* %i66 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %93) #7
  %cleanup.dest151 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest151, label %cleanup154 [
    i32 8, label %for.end152
  ]

for.end152:                                       ; preds = %cleanup150
  br label %if.end153

if.end153:                                        ; preds = %for.end152, %if.end57
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup154

cleanup154:                                       ; preds = %if.then49, %if.end153, %cleanup150, %if.then37
  %94 = bitcast i8** %line to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %94) #7
  %cleanup.dest155 = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest155, label %cleanup167 [
    i32 0, label %cleanup.cont156
    i32 5, label %for.end157
    i32 7, label %cleanup165
  ]

cleanup.cont156:                                  ; preds = %cleanup154
  br label %for.cond34

for.end157:                                       ; preds = %cleanup154
  %name158 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %mat, i32 0, i32 0
  %arrayidx159 = getelementptr inbounds [64 x i8], [64 x i8]* %name158, i64 0, i64 0
  %95 = load i8, i8* %arrayidx159, align 4, !tbaa !14
  %conv160 = sext i8 %95 to i32
  %cmp161 = icmp ne i32 %conv160, 0
  br i1 %cmp161, label %if.then163, label %if.end164

if.then163:                                       ; preds = %for.end157
  %96 = load %struct.Array*, %struct.Array** %_materials.addr, align 8, !tbaa !4
  %97 = bitcast %struct.objzMaterial* %mat to i8*
  call void @arrayAppend(%struct.Array* %96, i8* %97)
  br label %if.end164

if.end164:                                        ; preds = %if.then163, %for.end157
  store i8 1, i8* %result, align 1, !tbaa !24
  br label %cleanup165

cleanup165:                                       ; preds = %if.end164, %cleanup154
  call void @fileClose(%struct.File* %file)
  %98 = load i8, i8* %result, align 1, !tbaa !24, !range !46
  %tobool166 = trunc i8 %98 to i1
  store i1 %tobool166, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup167

cleanup167:                                       ; preds = %cleanup165, %cleanup154
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %result) #7
  %99 = bitcast %struct.objzMaterial* %mat to i8*
  call void @llvm.lifetime.end.p0i8(i64 568, i8* %99) #7
  %100 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %100) #7
  %101 = bitcast %struct.Lexer* %lexer to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %101) #7
  br label %cleanup171

cleanup171:                                       ; preds = %cleanup167, %if.then31
  %102 = bitcast i16** %bom16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %102) #7
  br label %cleanup172

cleanup172:                                       ; preds = %cleanup171, %if.then21
  %103 = bitcast i32** %bom32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %103) #7
  br label %cleanup173

cleanup173:                                       ; preds = %cleanup172, %if.then16
  %104 = bitcast %struct.File* %file to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %104) #7
  %105 = bitcast i8** %lastSlash to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %105) #7
  %106 = bitcast [256 x i8]* %filename to i8*
  call void @llvm.lifetime.end.p0i8(i64 256, i8* %106) #7
  %107 = load i1, i1* %retval, align 1
  ret i1 %107
}

declare i32 @atoi(i8*) #2

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @parseFloats(%struct.Lexer* %_lexer, float* %_result, i32 %n) #0 {
entry:
  %retval = alloca i1, align 1
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_result.addr = alloca float*, align 8
  %n.addr = alloca i32, align 4
  %token = alloca %struct.Token, align 4
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  store float* %_result, float** %_result.addr, align 8, !tbaa !4
  store i32 %n, i32* %n.addr, align 4, !tbaa !15
  %0 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %0) #7
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4, !tbaa !15
  %3 = load i32, i32* %n.addr, align 4, !tbaa !15
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  call void @tokenize(%struct.Lexer* %4, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %line = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %5 = load i32, i32* %line, align 4, !tbaa !33
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %6 = load i32, i32* %column, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56, i32 0, i32 0), i32 %5, i32 %6)
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %text2 = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %text2, i32 0, i32 0
  %call4 = call double @atof(i8* %arraydecay3)
  %conv = fptrunc double %call4 to float
  %7 = load float*, float** %_result.addr, align 8, !tbaa !4
  %8 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom = zext i32 %8 to i64
  %arrayidx = getelementptr inbounds float, float* %7, i64 %idxprom
  store float %conv, float* %arrayidx, align 4, !tbaa !91
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  %10 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup5 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup5

cleanup5:                                         ; preds = %for.end, %cleanup
  %11 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %11) #7
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: nounwind ssp uwtable
define internal void @arrayDestroy(%struct.Array* %_array) #0 {
entry:
  %_array.addr = alloca %struct.Array*, align 8
  store %struct.Array* %_array, %struct.Array** %_array.addr, align 8, !tbaa !4
  %0 = load %struct.Array*, %struct.Array** %_array.addr, align 8, !tbaa !4
  %data = getelementptr inbounds %struct.Array, %struct.Array* %0, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !31
  %call = call i8* @objz_realloc(i8* %1, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 182)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @chunkedArrayElement(%struct.ChunkedArray* %_array, i32 %_index) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %_index.addr = alloca i32, align 4
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  store i32 %_index, i32* %_index.addr, align 4, !tbaa !15
  %0 = bitcast i8*** %chunk to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %1, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 0
  %2 = load i8*, i8** %data, align 8, !tbaa !88
  %3 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks1 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %3, i32 0, i32 0
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %chunks1, i32 0, i32 3
  %4 = load i32, i32* %elementSize, align 8, !tbaa !89
  %5 = load i32, i32* %_index.addr, align 4, !tbaa !15
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %6, i32 0, i32 1
  %7 = load i32, i32* %elementsPerChunk, align 8, !tbaa !81
  %div = udiv i32 %5, %7
  %mul = mul i32 %4, %div
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 %idxprom
  %8 = bitcast i8* %arrayidx to i8**
  store i8** %8, i8*** %chunk, align 8, !tbaa !4
  %9 = load i8**, i8*** %chunk, align 8, !tbaa !4
  %10 = load i8*, i8** %9, align 8, !tbaa !4
  %11 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementSize2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %11, i32 0, i32 2
  %12 = load i64, i64* %elementSize2, align 8, !tbaa !82
  %13 = load i32, i32* %_index.addr, align 4, !tbaa !15
  %14 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %elementsPerChunk3 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %14, i32 0, i32 1
  %15 = load i32, i32* %elementsPerChunk3, align 8, !tbaa !81
  %rem = urem i32 %13, %15
  %conv = zext i32 %rem to i64
  %mul4 = mul i64 %12, %conv
  %arrayidx5 = getelementptr inbounds i8, i8* %10, i64 %mul4
  %16 = bitcast i8*** %chunk to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #7
  ret i8* %arrayidx5
}

; Function Attrs: nounwind ssp uwtable
define internal void @vec3Normalize(%struct.vec3* %_out, %struct.vec3* %_in) #0 {
entry:
  %_out.addr = alloca %struct.vec3*, align 8
  %_in.addr = alloca %struct.vec3*, align 8
  %len = alloca float, align 4
  store %struct.vec3* %_out, %struct.vec3** %_out.addr, align 8, !tbaa !4
  store %struct.vec3* %_in, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %0 = bitcast float* %len to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %1, i32 0, i32 0
  %2 = load float, float* %x, align 4, !tbaa !47
  %3 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %x1 = getelementptr inbounds %struct.vec3, %struct.vec3* %3, i32 0, i32 0
  %4 = load float, float* %x1, align 4, !tbaa !47
  %mul = fmul float %2, %4
  %5 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %5, i32 0, i32 1
  %6 = load float, float* %y, align 4, !tbaa !50
  %7 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %y2 = getelementptr inbounds %struct.vec3, %struct.vec3* %7, i32 0, i32 1
  %8 = load float, float* %y2, align 4, !tbaa !50
  %mul3 = fmul float %6, %8
  %add = fadd float %mul, %mul3
  %9 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %9, i32 0, i32 2
  %10 = load float, float* %z, align 4, !tbaa !51
  %11 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %z4 = getelementptr inbounds %struct.vec3, %struct.vec3* %11, i32 0, i32 2
  %12 = load float, float* %z4, align 4, !tbaa !51
  %mul5 = fmul float %10, %12
  %add6 = fadd float %add, %mul5
  store float %add6, float* %len, align 4, !tbaa !91
  %13 = load float, float* %len, align 4, !tbaa !91
  %cmp = fcmp ogt float %13, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %14 = load float, float* %len, align 4, !tbaa !91
  %15 = call float @llvm.sqrt.f32(float %14)
  %div = fdiv float 1.000000e+00, %15
  store float %div, float* %len, align 4, !tbaa !91
  %16 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %x7 = getelementptr inbounds %struct.vec3, %struct.vec3* %16, i32 0, i32 0
  %17 = load float, float* %x7, align 4, !tbaa !47
  %18 = load float, float* %len, align 4, !tbaa !91
  %mul8 = fmul float %17, %18
  %19 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8, !tbaa !4
  %x9 = getelementptr inbounds %struct.vec3, %struct.vec3* %19, i32 0, i32 0
  store float %mul8, float* %x9, align 4, !tbaa !47
  %20 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %y10 = getelementptr inbounds %struct.vec3, %struct.vec3* %20, i32 0, i32 1
  %21 = load float, float* %y10, align 4, !tbaa !50
  %22 = load float, float* %len, align 4, !tbaa !91
  %mul11 = fmul float %21, %22
  %23 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8, !tbaa !4
  %y12 = getelementptr inbounds %struct.vec3, %struct.vec3* %23, i32 0, i32 1
  store float %mul11, float* %y12, align 4, !tbaa !50
  %24 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %z13 = getelementptr inbounds %struct.vec3, %struct.vec3* %24, i32 0, i32 2
  %25 = load float, float* %z13, align 4, !tbaa !51
  %26 = load float, float* %len, align 4, !tbaa !91
  %mul14 = fmul float %25, %26
  %27 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8, !tbaa !4
  %z15 = getelementptr inbounds %struct.vec3, %struct.vec3* %27, i32 0, i32 2
  store float %mul14, float* %z15, align 4, !tbaa !51
  br label %if.end

if.else:                                          ; preds = %entry
  %28 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %x16 = getelementptr inbounds %struct.vec3, %struct.vec3* %28, i32 0, i32 0
  %29 = load float, float* %x16, align 4, !tbaa !47
  %30 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8, !tbaa !4
  %x17 = getelementptr inbounds %struct.vec3, %struct.vec3* %30, i32 0, i32 0
  store float %29, float* %x17, align 4, !tbaa !47
  %31 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %y18 = getelementptr inbounds %struct.vec3, %struct.vec3* %31, i32 0, i32 1
  %32 = load float, float* %y18, align 4, !tbaa !50
  %33 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8, !tbaa !4
  %y19 = getelementptr inbounds %struct.vec3, %struct.vec3* %33, i32 0, i32 1
  store float %32, float* %y19, align 4, !tbaa !50
  %34 = load %struct.vec3*, %struct.vec3** %_in.addr, align 8, !tbaa !4
  %z20 = getelementptr inbounds %struct.vec3, %struct.vec3* %34, i32 0, i32 2
  %35 = load float, float* %z20, align 4, !tbaa !51
  %36 = load %struct.vec3*, %struct.vec3** %_out.addr, align 8, !tbaa !4
  %z21 = getelementptr inbounds %struct.vec3, %struct.vec3* %36, i32 0, i32 2
  store float %35, float* %z21, align 4, !tbaa !51
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %37 = bitcast float* %len to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %37) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @vertexHashMapInit(%struct.VertexHashMap* %_map, i32 %_initialCapacity) #0 {
entry:
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  %_initialCapacity.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4, !tbaa !15
  %0 = load i32, i32* %_initialCapacity.addr, align 4, !tbaa !15
  %conv = uitofp i32 %0 to float
  %mul = fmul float %conv, 0x3FF4CCCCC0000000
  %conv1 = fptoui float %mul to i32
  %1 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %1, i32 0, i32 1
  store i32 %conv1, i32* %numSlots, align 8, !tbaa !100
  %2 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots2 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots2, align 8, !tbaa !100
  %conv3 = zext i32 %3 to i64
  %mul4 = mul i64 4, %conv3
  %call = call i8* @objz_realloc(i8* null, i64 %mul4, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 549)
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %5, i32 0, i32 0
  store i32* %4, i32** %slots, align 8, !tbaa !101
  %6 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %i, align 4, !tbaa !15
  %8 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots5 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %8, i32 0, i32 1
  %9 = load i32, i32* %numSlots5, align 8, !tbaa !100
  %cmp = icmp ult i32 %7, %9
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %10 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #7
  br label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots7 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %11, i32 0, i32 0
  %12 = load i32*, i32** %slots7, align 8, !tbaa !101
  %13 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom = zext i32 %13 to i64
  %arrayidx = getelementptr inbounds i32, i32* %12, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4, !tbaa !15
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %15 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %15, i32 0, i32 2
  %16 = load i32, i32* %_initialCapacity.addr, align 4, !tbaa !15
  call void @arrayInit(%struct.Array* %vertices, i64 20, i32 %16)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @normalHashMapInit(%struct.NormalHashMap* %_map, i32 %_initialCapacity, %struct.ChunkedArray* %_normals) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %_initialCapacity.addr = alloca i32, align 4
  %_normals.addr = alloca %struct.ChunkedArray*, align 8
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  store i32 %_initialCapacity, i32* %_initialCapacity.addr, align 4, !tbaa !15
  store %struct.ChunkedArray* %_normals, %struct.ChunkedArray** %_normals.addr, align 8, !tbaa !4
  %0 = load i32, i32* %_initialCapacity.addr, align 4, !tbaa !15
  %conv = uitofp i32 %0 to float
  %mul = fmul float %conv, 0x3FF4CCCCC0000000
  %conv1 = fptoui float %mul to i32
  %1 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %1, i32 0, i32 1
  store i32 %conv1, i32* %numSlots, align 8, !tbaa !102
  %2 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots2 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots2, align 8, !tbaa !102
  %conv3 = zext i32 %3 to i64
  %mul4 = mul i64 4, %conv3
  %call = call i8* @objz_realloc(i8* null, i64 %mul4, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 607)
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %5, i32 0, i32 0
  store i32* %4, i32** %slots, align 8, !tbaa !104
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_normals.addr, align 8, !tbaa !4
  %7 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %normals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %7, i32 0, i32 3
  store %struct.ChunkedArray* %6, %struct.ChunkedArray** %normals, align 8, !tbaa !105
  %8 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %8, i32 0, i32 2
  %9 = load i32, i32* %_initialCapacity.addr, align 4, !tbaa !15
  call void @arrayInit(%struct.Array* %hashedNormals, i64 8, i32 %9)
  %10 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  call void @normalHashMapClear(%struct.NormalHashMap* %10)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @normalHashMapClear(%struct.NormalHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %i = alloca i32, align 4
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4, !tbaa !15
  %2 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %2, i32 0, i32 1
  %3 = load i32, i32* %numSlots, align 8, !tbaa !102
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #7
  br label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %5, i32 0, i32 0
  %6 = load i32*, i32** %slots, align 8, !tbaa !104
  %7 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr inbounds i32, i32* %6, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4, !tbaa !15
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %9 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %9, i32 0, i32 2
  %length = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals, i32 0, i32 1
  store i32 0, i32* %length, align 8, !tbaa !106
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @normalHashMapInsert(%struct.NormalHashMap* %_map, %struct.vec3* %_normal) #0 {
entry:
  %retval = alloca i32, align 4
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  %_normal.addr = alloca %struct.vec3*, align 8
  %hashData = alloca [3 x i32], align 4
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca %struct.HashedNormal*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %n18 = alloca %struct.HashedNormal, align 4
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  store %struct.vec3* %_normal, %struct.vec3** %_normal.addr, align 8, !tbaa !4
  %0 = bitcast [3 x i32]* %hashData to i8*
  call void @llvm.lifetime.start.p0i8(i64 12, i8* %0) #7
  %1 = bitcast [3 x i32]* %hashData to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %1, i8 0, i64 12, i1 false)
  %2 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8, !tbaa !4
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %2, i32 0, i32 0
  %3 = load float, float* %x, align 4, !tbaa !47
  %mul = fmul float %3, 5.000000e-01
  %add = fadd float %mul, 1.275000e+02
  %conv = fptoui float %add to i32
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 0
  store i32 %conv, i32* %arrayidx, align 4, !tbaa !15
  %4 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8, !tbaa !4
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %4, i32 0, i32 1
  %5 = load float, float* %y, align 4, !tbaa !50
  %mul1 = fmul float %5, 5.000000e-01
  %add2 = fadd float %mul1, 1.275000e+02
  %conv3 = fptoui float %add2 to i32
  %arrayidx4 = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 1
  store i32 %conv3, i32* %arrayidx4, align 4, !tbaa !15
  %6 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8, !tbaa !4
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %6, i32 0, i32 2
  %7 = load float, float* %z, align 4, !tbaa !51
  %mul5 = fmul float %7, 5.000000e-01
  %add6 = fadd float %mul5, 1.275000e+02
  %conv7 = fptoui float %add6 to i32
  %arrayidx8 = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i64 0, i64 2
  store i32 %conv7, i32* %arrayidx8, align 4, !tbaa !15
  %8 = bitcast i32* %hash to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #7
  %arraydecay = getelementptr inbounds [3 x i32], [3 x i32]* %hashData, i32 0, i32 0
  %9 = bitcast i32* %arraydecay to i8*
  %call = call i32 @sdbmHash(i8* %9, i32 12)
  %10 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %10, i32 0, i32 1
  %11 = load i32, i32* %numSlots, align 8, !tbaa !102
  %rem = urem i32 %call, %11
  store i32 %rem, i32* %hash, align 4, !tbaa !15
  %12 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %12) #7
  %13 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %13, i32 0, i32 0
  %14 = load i32*, i32** %slots, align 8, !tbaa !104
  %15 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom = zext i32 %15 to i64
  %arrayidx9 = getelementptr inbounds i32, i32* %14, i64 %idxprom
  %16 = load i32, i32* %arrayidx9, align 4, !tbaa !15
  store i32 %16, i32* %i, align 4, !tbaa !15
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %entry
  %17 = load i32, i32* %i, align 4, !tbaa !15
  %cmp = icmp ne i32 %17, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %18 = bitcast %struct.HashedNormal** %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #7
  %19 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %19, i32 0, i32 2
  %data = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals, i32 0, i32 0
  %20 = load i8*, i8** %data, align 8, !tbaa !107
  %21 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals11 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %21, i32 0, i32 2
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals11, i32 0, i32 3
  %22 = load i32, i32* %elementSize, align 8, !tbaa !108
  %23 = load i32, i32* %i, align 4, !tbaa !15
  %mul12 = mul i32 %22, %23
  %idxprom13 = zext i32 %mul12 to i64
  %arrayidx14 = getelementptr inbounds i8, i8* %20, i64 %idxprom13
  %24 = bitcast i8* %arrayidx14 to %struct.HashedNormal*
  store %struct.HashedNormal* %24, %struct.HashedNormal** %n, align 8, !tbaa !4
  %25 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %normals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %25, i32 0, i32 3
  %26 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals, align 8, !tbaa !105
  %27 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8, !tbaa !4
  %normalIndex = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %27, i32 0, i32 0
  %28 = load i32, i32* %normalIndex, align 4, !tbaa !109
  %call15 = call i8* @chunkedArrayElement(%struct.ChunkedArray* %26, i32 %28)
  %29 = bitcast i8* %call15 to %struct.vec3*
  %30 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8, !tbaa !4
  %call16 = call zeroext i1 @vec3Equal(%struct.vec3* %29, %struct.vec3* %30, float 0x3E80000000000000)
  br i1 %call16, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %31 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8, !tbaa !4
  %normalIndex17 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %31, i32 0, i32 0
  %32 = load i32, i32* %normalIndex17, align 4, !tbaa !109
  store i32 %32, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %while.body
  %33 = load %struct.HashedNormal*, %struct.HashedNormal** %n, align 8, !tbaa !4
  %hashNext = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %33, i32 0, i32 1
  %34 = load i32, i32* %hashNext, align 4, !tbaa !111
  store i32 %34, i32* %i, align 4, !tbaa !15
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %35 = bitcast %struct.HashedNormal** %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %35) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup34 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = bitcast %struct.HashedNormal* %n18 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %36) #7
  %37 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %normals19 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %37, i32 0, i32 3
  %38 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals19, align 8, !tbaa !105
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %38, i32 0, i32 3
  %39 = load i32, i32* %length, align 8, !tbaa !36
  %normalIndex20 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 0
  store i32 %39, i32* %normalIndex20, align 4, !tbaa !109
  %40 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %slots21 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %40, i32 0, i32 0
  %41 = load i32*, i32** %slots21, align 8, !tbaa !104
  %42 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom22 = zext i32 %42 to i64
  %arrayidx23 = getelementptr inbounds i32, i32* %41, i64 %idxprom22
  %43 = load i32, i32* %arrayidx23, align 4, !tbaa !15
  %hashNext24 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 1
  store i32 %43, i32* %hashNext24, align 4, !tbaa !111
  %44 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals25 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %44, i32 0, i32 2
  %length26 = getelementptr inbounds %struct.Array, %struct.Array* %hashedNormals25, i32 0, i32 1
  %45 = load i32, i32* %length26, align 8, !tbaa !106
  %46 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %slots27 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %46, i32 0, i32 0
  %47 = load i32*, i32** %slots27, align 8, !tbaa !104
  %48 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom28 = zext i32 %48 to i64
  %arrayidx29 = getelementptr inbounds i32, i32* %47, i64 %idxprom28
  store i32 %45, i32* %arrayidx29, align 4, !tbaa !15
  %49 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals30 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %49, i32 0, i32 2
  %50 = bitcast %struct.HashedNormal* %n18 to i8*
  call void @arrayAppend(%struct.Array* %hashedNormals30, i8* %50)
  %51 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %normals31 = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %51, i32 0, i32 3
  %52 = load %struct.ChunkedArray*, %struct.ChunkedArray** %normals31, align 8, !tbaa !105
  %53 = load %struct.vec3*, %struct.vec3** %_normal.addr, align 8, !tbaa !4
  %54 = bitcast %struct.vec3* %53 to i8*
  call void @chunkedArrayAppend(%struct.ChunkedArray* %52, i8* %54)
  %normalIndex32 = getelementptr inbounds %struct.HashedNormal, %struct.HashedNormal* %n18, i32 0, i32 0
  %55 = load i32, i32* %normalIndex32, align 4, !tbaa !109
  store i32 %55, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  %56 = bitcast %struct.HashedNormal* %n18 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %56) #7
  br label %cleanup34

cleanup34:                                        ; preds = %while.end, %cleanup
  %57 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %57) #7
  %58 = bitcast i32* %hash to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %58) #7
  %59 = bitcast [3 x i32]* %hashData to i8*
  call void @llvm.lifetime.end.p0i8(i64 12, i8* %59) #7
  %60 = load i32, i32* %retval, align 4
  ret i32 %60
}

; Function Attrs: nounwind ssp uwtable
define internal { <2 x float>, float } @calculateSmoothNormal(i32 %_pos, %struct.ChunkedArray* %_faces, %struct.Array* %_faceNormals, i16 zeroext %_smoothingGroup) #0 {
entry:
  %retval = alloca %struct.vec3, align 4
  %_pos.addr = alloca i32, align 4
  %_faces.addr = alloca %struct.ChunkedArray*, align 8
  %_faceNormals.addr = alloca %struct.Array*, align 8
  %_smoothingGroup.addr = alloca i16, align 2
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %face = alloca %struct.Face*, align 8
  %j = alloca i32, align 4
  %s = alloca float, align 4
  %tmp = alloca { <2 x float>, float }, align 8
  store i32 %_pos, i32* %_pos.addr, align 4, !tbaa !15
  store %struct.ChunkedArray* %_faces, %struct.ChunkedArray** %_faces.addr, align 8, !tbaa !4
  store %struct.Array* %_faceNormals, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  store i16 %_smoothingGroup, i16* %_smoothingGroup.addr, align 2, !tbaa !22
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 0
  store float 0.000000e+00, float* %x, align 4, !tbaa !47
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 1
  store float 0.000000e+00, float* %y, align 4, !tbaa !50
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 2
  store float 0.000000e+00, float* %z, align 4, !tbaa !51
  %0 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %n, align 4, !tbaa !15
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc38, %entry
  %2 = load i32, i32* %i, align 4, !tbaa !15
  %3 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8, !tbaa !4
  %length = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %3, i32 0, i32 3
  %4 = load i32, i32* %length, align 8, !tbaa !36
  %cmp = icmp ult i32 %2, %4
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, i32* %cleanup.dest.slot, align 4
  %5 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #7
  br label %for.end41

for.body:                                         ; preds = %for.cond
  %6 = bitcast %struct.Face** %face to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %7 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_faces.addr, align 8, !tbaa !4
  %8 = load i32, i32* %i, align 4, !tbaa !15
  %call = call i8* @chunkedArrayElement(%struct.ChunkedArray* %7, i32 %8)
  %9 = bitcast i8* %call to %struct.Face*
  store %struct.Face* %9, %struct.Face** %face, align 8, !tbaa !4
  %10 = load %struct.Face*, %struct.Face** %face, align 8, !tbaa !4
  %smoothingGroup = getelementptr inbounds %struct.Face, %struct.Face* %10, i32 0, i32 1
  %11 = load i16, i16* %smoothingGroup, align 2, !tbaa !44
  %conv = zext i16 %11 to i32
  %12 = load i16, i16* %_smoothingGroup.addr, align 2, !tbaa !22
  %conv1 = zext i16 %12 to i32
  %cmp2 = icmp ne i32 %conv, %conv1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 4, i32* %cleanup.dest.slot, align 4
  br label %cleanup37

if.end:                                           ; preds = %for.body
  %13 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %13) #7
  store i32 0, i32* %j, align 4, !tbaa !15
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %if.end
  %14 = load i32, i32* %j, align 4, !tbaa !15
  %cmp5 = icmp slt i32 %14, 3
  br i1 %cmp5, label %for.body8, label %for.cond.cleanup7

for.cond.cleanup7:                                ; preds = %for.cond4
  store i32 5, i32* %cleanup.dest.slot, align 4
  br label %cleanup

for.body8:                                        ; preds = %for.cond4
  %15 = load %struct.Face*, %struct.Face** %face, align 8, !tbaa !4
  %indices = getelementptr inbounds %struct.Face, %struct.Face* %15, i32 0, i32 2
  %16 = load i32, i32* %j, align 4, !tbaa !15
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.IndexTriplet], [3 x %struct.IndexTriplet]* %indices, i64 0, i64 %idxprom
  %v = getelementptr inbounds %struct.IndexTriplet, %struct.IndexTriplet* %arrayidx, i32 0, i32 0
  %17 = load i32, i32* %v, align 4, !tbaa !38
  %18 = load i32, i32* %_pos.addr, align 4, !tbaa !15
  %cmp9 = icmp eq i32 %17, %18
  br i1 %cmp9, label %if.then11, label %if.end35

if.then11:                                        ; preds = %for.body8
  %x12 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 0
  %19 = load float, float* %x12, align 4, !tbaa !47
  %20 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  %data = getelementptr inbounds %struct.Array, %struct.Array* %20, i32 0, i32 0
  %21 = load i8*, i8** %data, align 8, !tbaa !31
  %22 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %22, i32 0, i32 3
  %23 = load i32, i32* %elementSize, align 8, !tbaa !32
  %24 = load i32, i32* %i, align 4, !tbaa !15
  %mul = mul i32 %23, %24
  %idxprom13 = zext i32 %mul to i64
  %arrayidx14 = getelementptr inbounds i8, i8* %21, i64 %idxprom13
  %25 = bitcast i8* %arrayidx14 to %struct.vec3*
  %x15 = getelementptr inbounds %struct.vec3, %struct.vec3* %25, i32 0, i32 0
  %26 = load float, float* %x15, align 4, !tbaa !47
  %add = fadd float %19, %26
  %x16 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 0
  store float %add, float* %x16, align 4, !tbaa !47
  %y17 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 1
  %27 = load float, float* %y17, align 4, !tbaa !50
  %28 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  %data18 = getelementptr inbounds %struct.Array, %struct.Array* %28, i32 0, i32 0
  %29 = load i8*, i8** %data18, align 8, !tbaa !31
  %30 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  %elementSize19 = getelementptr inbounds %struct.Array, %struct.Array* %30, i32 0, i32 3
  %31 = load i32, i32* %elementSize19, align 8, !tbaa !32
  %32 = load i32, i32* %i, align 4, !tbaa !15
  %mul20 = mul i32 %31, %32
  %idxprom21 = zext i32 %mul20 to i64
  %arrayidx22 = getelementptr inbounds i8, i8* %29, i64 %idxprom21
  %33 = bitcast i8* %arrayidx22 to %struct.vec3*
  %y23 = getelementptr inbounds %struct.vec3, %struct.vec3* %33, i32 0, i32 1
  %34 = load float, float* %y23, align 4, !tbaa !50
  %add24 = fadd float %27, %34
  %y25 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 1
  store float %add24, float* %y25, align 4, !tbaa !50
  %z26 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 2
  %35 = load float, float* %z26, align 4, !tbaa !51
  %36 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  %data27 = getelementptr inbounds %struct.Array, %struct.Array* %36, i32 0, i32 0
  %37 = load i8*, i8** %data27, align 8, !tbaa !31
  %38 = load %struct.Array*, %struct.Array** %_faceNormals.addr, align 8, !tbaa !4
  %elementSize28 = getelementptr inbounds %struct.Array, %struct.Array* %38, i32 0, i32 3
  %39 = load i32, i32* %elementSize28, align 8, !tbaa !32
  %40 = load i32, i32* %i, align 4, !tbaa !15
  %mul29 = mul i32 %39, %40
  %idxprom30 = zext i32 %mul29 to i64
  %arrayidx31 = getelementptr inbounds i8, i8* %37, i64 %idxprom30
  %41 = bitcast i8* %arrayidx31 to %struct.vec3*
  %z32 = getelementptr inbounds %struct.vec3, %struct.vec3* %41, i32 0, i32 2
  %42 = load float, float* %z32, align 4, !tbaa !51
  %add33 = fadd float %35, %42
  %z34 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 2
  store float %add33, float* %z34, align 4, !tbaa !51
  %43 = load i32, i32* %n, align 4, !tbaa !15
  %inc = add nsw i32 %43, 1
  store i32 %inc, i32* %n, align 4, !tbaa !15
  store i32 5, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end35:                                         ; preds = %for.body8
  br label %for.inc

for.inc:                                          ; preds = %if.end35
  %44 = load i32, i32* %j, align 4, !tbaa !15
  %inc36 = add nsw i32 %44, 1
  store i32 %inc36, i32* %j, align 4, !tbaa !15
  br label %for.cond4

cleanup:                                          ; preds = %if.then11, %for.cond.cleanup7
  %45 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %45) #7
  br label %for.end

for.end:                                          ; preds = %cleanup
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup37

cleanup37:                                        ; preds = %for.end, %if.then
  %46 = bitcast %struct.Face** %face to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 4, label %for.inc38
  ]

cleanup.cont:                                     ; preds = %cleanup37
  br label %for.inc38

for.inc38:                                        ; preds = %cleanup.cont, %cleanup37
  %47 = load i32, i32* %i, align 4, !tbaa !15
  %inc39 = add i32 %47, 1
  store i32 %inc39, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.end41:                                        ; preds = %for.cond.cleanup
  %48 = bitcast float* %s to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %48) #7
  %49 = load i32, i32* %n, align 4, !tbaa !15
  %conv42 = sitofp i32 %49 to float
  %div = fdiv float 1.000000e+00, %conv42
  store float %div, float* %s, align 4, !tbaa !91
  %x43 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 0
  %50 = load float, float* %x43, align 4, !tbaa !47
  %51 = load float, float* %s, align 4, !tbaa !91
  %mul44 = fmul float %50, %51
  %x45 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 0
  store float %mul44, float* %x45, align 4, !tbaa !47
  %y46 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 1
  %52 = load float, float* %y46, align 4, !tbaa !50
  %53 = load float, float* %s, align 4, !tbaa !91
  %mul47 = fmul float %52, %53
  %y48 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 1
  store float %mul47, float* %y48, align 4, !tbaa !50
  %z49 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 2
  %54 = load float, float* %z49, align 4, !tbaa !51
  %55 = load float, float* %s, align 4, !tbaa !91
  %mul50 = fmul float %54, %55
  %z51 = getelementptr inbounds %struct.vec3, %struct.vec3* %retval, i32 0, i32 2
  store float %mul50, float* %z51, align 4, !tbaa !51
  call void @vec3Normalize(%struct.vec3* %retval, %struct.vec3* %retval)
  store i32 1, i32* %cleanup.dest.slot, align 4
  %56 = bitcast float* %s to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %56) #7
  %57 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %57) #7
  %58 = bitcast { <2 x float>, float }* %tmp to i8*
  %59 = bitcast %struct.vec3* %retval to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %58, i8* align 4 %59, i64 12, i1 false)
  %60 = load { <2 x float>, float }, { <2 x float>, float }* %tmp, align 8
  ret { <2 x float>, float } %60

unreachable:                                      ; preds = %cleanup37
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @vertexHashMapInsert(%struct.VertexHashMap* %_map, i32 %_object, i32 %_pos, i32 %_texcoord, i32 %_normal) #0 {
entry:
  %retval = alloca i32, align 4
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  %_object.addr = alloca i32, align 4
  %_pos.addr = alloca i32, align 4
  %_texcoord.addr = alloca i32, align 4
  %_normal.addr = alloca i32, align 4
  %hashData = alloca [4 x i32], align 16
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  %v = alloca %struct.HashedVertex*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %v20 = alloca %struct.HashedVertex, align 4
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  store i32 %_object, i32* %_object.addr, align 4, !tbaa !15
  store i32 %_pos, i32* %_pos.addr, align 4, !tbaa !15
  store i32 %_texcoord, i32* %_texcoord.addr, align 4, !tbaa !15
  store i32 %_normal, i32* %_normal.addr, align 4, !tbaa !15
  %0 = bitcast [4 x i32]* %hashData to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast [4 x i32]* %hashData to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %1, i8 0, i64 16, i1 false)
  %2 = load i32, i32* %_object.addr, align 4, !tbaa !15
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 0
  store i32 %2, i32* %arrayidx, align 16, !tbaa !15
  %3 = load i32, i32* %_pos.addr, align 4, !tbaa !15
  %arrayidx1 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 1
  store i32 %3, i32* %arrayidx1, align 4, !tbaa !15
  %4 = load i32, i32* %_texcoord.addr, align 4, !tbaa !15
  %cmp = icmp ne i32 %4, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %_texcoord.addr, align 4, !tbaa !15
  %arrayidx2 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 2
  store i32 %5, i32* %arrayidx2, align 8, !tbaa !15
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %_normal.addr, align 4, !tbaa !15
  %cmp3 = icmp ne i32 %6, -1
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %7 = load i32, i32* %_normal.addr, align 4, !tbaa !15
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i64 0, i64 3
  store i32 %7, i32* %arrayidx5, align 4, !tbaa !15
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %8 = bitcast i32* %hash to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #7
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %hashData, i32 0, i32 0
  %9 = bitcast i32* %arraydecay to i8*
  %call = call i32 @sdbmHash(i8* %9, i32 16)
  %10 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %numSlots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %10, i32 0, i32 1
  %11 = load i32, i32* %numSlots, align 8, !tbaa !100
  %rem = urem i32 %call, %11
  store i32 %rem, i32* %hash, align 4, !tbaa !15
  %12 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %12) #7
  %13 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %13, i32 0, i32 0
  %14 = load i32*, i32** %slots, align 8, !tbaa !101
  %15 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom = zext i32 %15 to i64
  %arrayidx7 = getelementptr inbounds i32, i32* %14, i64 %idxprom
  %16 = load i32, i32* %arrayidx7, align 4, !tbaa !15
  store i32 %16, i32* %i, align 4, !tbaa !15
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.end6
  %17 = load i32, i32* %i, align 4, !tbaa !15
  %cmp8 = icmp ne i32 %17, -1
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %18 = bitcast %struct.HashedVertex** %v to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #7
  %19 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %19, i32 0, i32 2
  %data = getelementptr inbounds %struct.Array, %struct.Array* %vertices, i32 0, i32 0
  %20 = load i8*, i8** %data, align 8, !tbaa !72
  %21 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %vertices9 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %21, i32 0, i32 2
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %vertices9, i32 0, i32 3
  %22 = load i32, i32* %elementSize, align 8, !tbaa !73
  %23 = load i32, i32* %i, align 4, !tbaa !15
  %mul = mul i32 %22, %23
  %idxprom10 = zext i32 %mul to i64
  %arrayidx11 = getelementptr inbounds i8, i8* %20, i64 %idxprom10
  %24 = bitcast i8* %arrayidx11 to %struct.HashedVertex*
  store %struct.HashedVertex* %24, %struct.HashedVertex** %v, align 8, !tbaa !4
  %25 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8, !tbaa !4
  %object = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %25, i32 0, i32 0
  %26 = load i32, i32* %object, align 4, !tbaa !112
  %27 = load i32, i32* %_object.addr, align 4, !tbaa !15
  %cmp12 = icmp eq i32 %26, %27
  br i1 %cmp12, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %while.body
  %28 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8, !tbaa !4
  %pos = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %28, i32 0, i32 1
  %29 = load i32, i32* %pos, align 4, !tbaa !74
  %30 = load i32, i32* %_pos.addr, align 4, !tbaa !15
  %cmp13 = icmp eq i32 %29, %30
  br i1 %cmp13, label %land.lhs.true14, label %if.end19

land.lhs.true14:                                  ; preds = %land.lhs.true
  %31 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8, !tbaa !4
  %texcoord = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %31, i32 0, i32 2
  %32 = load i32, i32* %texcoord, align 4, !tbaa !76
  %33 = load i32, i32* %_texcoord.addr, align 4, !tbaa !15
  %cmp15 = icmp eq i32 %32, %33
  br i1 %cmp15, label %land.lhs.true16, label %if.end19

land.lhs.true16:                                  ; preds = %land.lhs.true14
  %34 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8, !tbaa !4
  %normal = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %34, i32 0, i32 3
  %35 = load i32, i32* %normal, align 4, !tbaa !77
  %36 = load i32, i32* %_normal.addr, align 4, !tbaa !15
  %cmp17 = icmp eq i32 %35, %36
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true16
  %37 = load i32, i32* %i, align 4, !tbaa !15
  store i32 %37, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end19:                                         ; preds = %land.lhs.true16, %land.lhs.true14, %land.lhs.true, %while.body
  %38 = load %struct.HashedVertex*, %struct.HashedVertex** %v, align 8, !tbaa !4
  %hashNext = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %38, i32 0, i32 4
  %39 = load i32, i32* %hashNext, align 4, !tbaa !113
  store i32 %39, i32* %i, align 4, !tbaa !15
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then18
  %40 = bitcast %struct.HashedVertex** %v to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %40) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup38 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %41 = bitcast %struct.HashedVertex* %v20 to i8*
  call void @llvm.lifetime.start.p0i8(i64 20, i8* %41) #7
  %42 = load i32, i32* %_object.addr, align 4, !tbaa !15
  %object21 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 0
  store i32 %42, i32* %object21, align 4, !tbaa !112
  %43 = load i32, i32* %_pos.addr, align 4, !tbaa !15
  %pos22 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 1
  store i32 %43, i32* %pos22, align 4, !tbaa !74
  %44 = load i32, i32* %_texcoord.addr, align 4, !tbaa !15
  %texcoord23 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 2
  store i32 %44, i32* %texcoord23, align 4, !tbaa !76
  %45 = load i32, i32* %_normal.addr, align 4, !tbaa !15
  %normal24 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 3
  store i32 %45, i32* %normal24, align 4, !tbaa !77
  %46 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots25 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %46, i32 0, i32 0
  %47 = load i32*, i32** %slots25, align 8, !tbaa !101
  %48 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom26 = zext i32 %48 to i64
  %arrayidx27 = getelementptr inbounds i32, i32* %47, i64 %idxprom26
  %49 = load i32, i32* %arrayidx27, align 4, !tbaa !15
  %hashNext28 = getelementptr inbounds %struct.HashedVertex, %struct.HashedVertex* %v20, i32 0, i32 4
  store i32 %49, i32* %hashNext28, align 4, !tbaa !113
  %50 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %vertices29 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %50, i32 0, i32 2
  %length = getelementptr inbounds %struct.Array, %struct.Array* %vertices29, i32 0, i32 1
  %51 = load i32, i32* %length, align 8, !tbaa !59
  %52 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots30 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %52, i32 0, i32 0
  %53 = load i32*, i32** %slots30, align 8, !tbaa !101
  %54 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom31 = zext i32 %54 to i64
  %arrayidx32 = getelementptr inbounds i32, i32* %53, i64 %idxprom31
  store i32 %51, i32* %arrayidx32, align 4, !tbaa !15
  %55 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %vertices33 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %55, i32 0, i32 2
  %56 = bitcast %struct.HashedVertex* %v20 to i8*
  call void @arrayAppend(%struct.Array* %vertices33, i8* %56)
  %57 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots34 = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %57, i32 0, i32 0
  %58 = load i32*, i32** %slots34, align 8, !tbaa !101
  %59 = load i32, i32* %hash, align 4, !tbaa !15
  %idxprom35 = zext i32 %59 to i64
  %arrayidx36 = getelementptr inbounds i32, i32* %58, i64 %idxprom35
  %60 = load i32, i32* %arrayidx36, align 4, !tbaa !15
  store i32 %60, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  %61 = bitcast %struct.HashedVertex* %v20 to i8*
  call void @llvm.lifetime.end.p0i8(i64 20, i8* %61) #7
  br label %cleanup38

cleanup38:                                        ; preds = %while.end, %cleanup
  %62 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %62) #7
  %63 = bitcast i32* %hash to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %63) #7
  %64 = bitcast [4 x i32]* %hashData to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %64) #7
  %65 = load i32, i32* %retval, align 4
  ret i32 %65
}

; Function Attrs: nounwind ssp uwtable
define internal void @normalHashMapDestroy(%struct.NormalHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.NormalHashMap*, align 8
  store %struct.NormalHashMap* %_map, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %0 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %0, i32 0, i32 0
  %1 = load i32*, i32** %slots, align 8, !tbaa !104
  %2 = bitcast i32* %1 to i8*
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 614)
  %3 = load %struct.NormalHashMap*, %struct.NormalHashMap** %_map.addr, align 8, !tbaa !4
  %hashedNormals = getelementptr inbounds %struct.NormalHashMap, %struct.NormalHashMap* %3, i32 0, i32 2
  call void @arrayDestroy(%struct.Array* %hashedNormals)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @chunkedArrayDestroy(%struct.ChunkedArray* %_array) #0 {
entry:
  %_array.addr = alloca %struct.ChunkedArray*, align 8
  %i = alloca i32, align 4
  %chunk = alloca i8**, align 8
  store %struct.ChunkedArray* %_array, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4, !tbaa !15
  %2 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %2, i32 0, i32 0
  %length = getelementptr inbounds %struct.Array, %struct.Array* %chunks, i32 0, i32 1
  %3 = load i32, i32* %length, align 8, !tbaa !87
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #7
  br label %for.end

for.body:                                         ; preds = %for.cond
  %5 = bitcast i8*** %chunk to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %6 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks1 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %6, i32 0, i32 0
  %data = getelementptr inbounds %struct.Array, %struct.Array* %chunks1, i32 0, i32 0
  %7 = load i8*, i8** %data, align 8, !tbaa !88
  %8 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks2 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %8, i32 0, i32 0
  %elementSize = getelementptr inbounds %struct.Array, %struct.Array* %chunks2, i32 0, i32 3
  %9 = load i32, i32* %elementSize, align 8, !tbaa !89
  %10 = load i32, i32* %i, align 4, !tbaa !15
  %mul = mul i32 %9, %10
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, i8* %7, i64 %idxprom
  %11 = bitcast i8* %arrayidx to i8**
  store i8** %11, i8*** %chunk, align 8, !tbaa !4
  %12 = load i8**, i8*** %chunk, align 8, !tbaa !4
  %13 = load i8*, i8** %12, align 8, !tbaa !4
  %call = call i8* @objz_realloc(i8* %13, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 218)
  %14 = bitcast i8*** %chunk to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %16 = load %struct.ChunkedArray*, %struct.ChunkedArray** %_array.addr, align 8, !tbaa !4
  %chunks3 = getelementptr inbounds %struct.ChunkedArray, %struct.ChunkedArray* %16, i32 0, i32 0
  call void @arrayDestroy(%struct.Array* %chunks3)
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #3

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #4

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #3

; Function Attrs: nounwind ssp uwtable
define internal void @vertexHashMapDestroy(%struct.VertexHashMap* %_map) #0 {
entry:
  %_map.addr = alloca %struct.VertexHashMap*, align 8
  store %struct.VertexHashMap* %_map, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %0 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %slots = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %0, i32 0, i32 0
  %1 = load i32*, i32** %slots, align 8, !tbaa !101
  %2 = bitcast i32* %1 to i8*
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 556)
  %3 = load %struct.VertexHashMap*, %struct.VertexHashMap** %_map.addr, align 8, !tbaa !4
  %vertices = getelementptr inbounds %struct.VertexHashMap, %struct.VertexHashMap* %3, i32 0, i32 2
  call void @arrayDestroy(%struct.Array* %vertices)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @objz_destroy(%struct.objzModel* %_model) #0 {
entry:
  %_model.addr = alloca %struct.objzModel*, align 8
  store %struct.objzModel* %_model, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %0 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %tobool = icmp ne %struct.objzModel* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %indices = getelementptr inbounds %struct.objzModel, %struct.objzModel* %1, i32 0, i32 1
  %2 = load i8*, i8** %indices, align 8, !tbaa !63
  %call = call i8* @objz_realloc(i8* %2, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1243)
  %3 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %materials = getelementptr inbounds %struct.objzModel, %struct.objzModel* %3, i32 0, i32 3
  %4 = load %struct.objzMaterial*, %struct.objzMaterial** %materials, align 8, !tbaa !65
  %5 = bitcast %struct.objzMaterial* %4 to i8*
  %call1 = call i8* @objz_realloc(i8* %5, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1244)
  %6 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %meshes = getelementptr inbounds %struct.objzModel, %struct.objzModel* %6, i32 0, i32 5
  %7 = load %struct.objzMesh*, %struct.objzMesh** %meshes, align 8, !tbaa !67
  %8 = bitcast %struct.objzMesh* %7 to i8*
  %call2 = call i8* @objz_realloc(i8* %8, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1245)
  %9 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %objects = getelementptr inbounds %struct.objzModel, %struct.objzModel* %9, i32 0, i32 7
  %10 = load %struct.objzObject*, %struct.objzObject** %objects, align 8, !tbaa !69
  %11 = bitcast %struct.objzObject* %10 to i8*
  %call3 = call i8* @objz_realloc(i8* %11, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1246)
  %12 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %vertices = getelementptr inbounds %struct.objzModel, %struct.objzModel* %12, i32 0, i32 9
  %13 = load i8*, i8** %vertices, align 8, !tbaa !71
  %call4 = call i8* @objz_realloc(i8* %13, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1247)
  %14 = load %struct.objzModel*, %struct.objzModel** %_model.addr, align 8, !tbaa !4
  %15 = bitcast %struct.objzModel* %14 to i8*
  %call5 = call i8* @objz_realloc(i8* %15, i64 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i32 1248)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i8* @objz_getError() #0 {
entry:
  %retval = alloca i8*, align 8
  %0 = load i8, i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i64 0, i64 0), align 16, !tbaa !14
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([1024 x i8], [1024 x i8]* @s_error, i32 0, i32 0), i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i8*, i8** %retval, align 8
  ret i8* %1
}

; Function Attrs: allocsize(1)
declare i8* @realloc(i8*, i64) #5

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #2

; Function Attrs: cold noreturn
declare void @abort() #6

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

declare i32 @__vsnprintf_chk(i8*, i64, i32, i64, i8*, %struct.__va_list_tag*) #2

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: nounwind ssp uwtable
define internal void @skipWhitespace(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  br label %for.cond

for.cond:                                         ; preds = %if.end3, %entry
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %call = call zeroext i1 @isEol(%struct.Lexer* %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %1 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %call1 = call zeroext i1 @isWhitespace(%struct.Lexer* %1)
  br i1 %call1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %for.end

if.end3:                                          ; preds = %if.end
  %2 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %2, i32 0, i32 0
  %3 = load i8*, i8** %buf, align 8, !tbaa !83
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %buf, align 8, !tbaa !83
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %column = getelementptr inbounds %struct.Lexer, %struct.Lexer* %4, i32 0, i32 2
  %5 = load i32, i32* %column, align 4, !tbaa !85
  %inc = add i32 %5, 1
  store i32 %inc, i32* %column, align 4, !tbaa !85
  br label %for.cond

for.end:                                          ; preds = %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @isWhitespace(%struct.Lexer* %_lexer) #0 {
entry:
  %_lexer.addr = alloca %struct.Lexer*, align 8
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %0 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf = getelementptr inbounds %struct.Lexer, %struct.Lexer* %0, i32 0, i32 0
  %1 = load i8*, i8** %buf, align 8, !tbaa !83
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !14
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf2 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %3, i32 0, i32 0
  %4 = load i8*, i8** %buf2, align 8, !tbaa !83
  %arrayidx3 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i8, i8* %arrayidx3, align 1, !tbaa !14
  %conv4 = sext i8 %5 to i32
  %cmp5 = icmp eq i32 %conv4, 9
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %6 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  %buf7 = getelementptr inbounds %struct.Lexer, %struct.Lexer* %6, i32 0, i32 0
  %7 = load i8*, i8** %buf7, align 8, !tbaa !83
  %arrayidx8 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = load i8, i8* %arrayidx8, align 1, !tbaa !14
  %conv9 = sext i8 %8 to i32
  %cmp10 = icmp eq i32 %conv9, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %9 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp10, %lor.rhs ]
  ret i1 %9
}

declare i8* @strstr(i8*, i8*) #2

; Function Attrs: nounwind readnone speculatable
declare float @llvm.fabs.f32(float) #4

; Function Attrs: nounwind ssp uwtable
define internal i32 @pnpoly(i32 %nvert, float* %vertx, float* %verty, float %testx, float %testy) #0 {
entry:
  %nvert.addr = alloca i32, align 4
  %vertx.addr = alloca float*, align 8
  %verty.addr = alloca float*, align 8
  %testx.addr = alloca float, align 4
  %testy.addr = alloca float, align 4
  %c = alloca i8, align 1
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store i32 %nvert, i32* %nvert.addr, align 4, !tbaa !15
  store float* %vertx, float** %vertx.addr, align 8, !tbaa !4
  store float* %verty, float** %verty.addr, align 8, !tbaa !4
  store float %testx, float* %testx.addr, align 4, !tbaa !91
  store float %testy, float* %testy.addr, align 4, !tbaa !91
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #7
  store i8 0, i8* %c, align 1, !tbaa !24
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  %1 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %2 = load i32, i32* %nvert.addr, align 4, !tbaa !15
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %j, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, i32* %i, align 4, !tbaa !15
  %4 = load i32, i32* %nvert.addr, align 4, !tbaa !15
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %5 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #7
  %6 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #7
  br label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load float*, float** %verty.addr, align 8, !tbaa !4
  %8 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds float, float* %7, i64 %idxprom
  %9 = load float, float* %arrayidx, align 4, !tbaa !91
  %10 = load float, float* %testy.addr, align 4, !tbaa !91
  %cmp1 = fcmp ogt float %9, %10
  %conv = zext i1 %cmp1 to i32
  %11 = load float*, float** %verty.addr, align 8, !tbaa !4
  %12 = load i32, i32* %j, align 4, !tbaa !15
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr inbounds float, float* %11, i64 %idxprom2
  %13 = load float, float* %arrayidx3, align 4, !tbaa !91
  %14 = load float, float* %testy.addr, align 4, !tbaa !91
  %cmp4 = fcmp ogt float %13, %14
  %conv5 = zext i1 %cmp4 to i32
  %cmp6 = icmp ne i32 %conv, %conv5
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %15 = load float, float* %testx.addr, align 4, !tbaa !91
  %16 = load float*, float** %vertx.addr, align 8, !tbaa !4
  %17 = load i32, i32* %j, align 4, !tbaa !15
  %idxprom8 = sext i32 %17 to i64
  %arrayidx9 = getelementptr inbounds float, float* %16, i64 %idxprom8
  %18 = load float, float* %arrayidx9, align 4, !tbaa !91
  %19 = load float*, float** %vertx.addr, align 8, !tbaa !4
  %20 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom10 = sext i32 %20 to i64
  %arrayidx11 = getelementptr inbounds float, float* %19, i64 %idxprom10
  %21 = load float, float* %arrayidx11, align 4, !tbaa !91
  %sub12 = fsub float %18, %21
  %22 = load float, float* %testy.addr, align 4, !tbaa !91
  %23 = load float*, float** %verty.addr, align 8, !tbaa !4
  %24 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom13 = sext i32 %24 to i64
  %arrayidx14 = getelementptr inbounds float, float* %23, i64 %idxprom13
  %25 = load float, float* %arrayidx14, align 4, !tbaa !91
  %sub15 = fsub float %22, %25
  %mul = fmul float %sub12, %sub15
  %26 = load float*, float** %verty.addr, align 8, !tbaa !4
  %27 = load i32, i32* %j, align 4, !tbaa !15
  %idxprom16 = sext i32 %27 to i64
  %arrayidx17 = getelementptr inbounds float, float* %26, i64 %idxprom16
  %28 = load float, float* %arrayidx17, align 4, !tbaa !91
  %29 = load float*, float** %verty.addr, align 8, !tbaa !4
  %30 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom18 = sext i32 %30 to i64
  %arrayidx19 = getelementptr inbounds float, float* %29, i64 %idxprom18
  %31 = load float, float* %arrayidx19, align 4, !tbaa !91
  %sub20 = fsub float %28, %31
  %div = fdiv float %mul, %sub20
  %32 = load float*, float** %vertx.addr, align 8, !tbaa !4
  %33 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom21 = sext i32 %33 to i64
  %arrayidx22 = getelementptr inbounds float, float* %32, i64 %idxprom21
  %34 = load float, float* %arrayidx22, align 4, !tbaa !91
  %add = fadd float %div, %34
  %cmp23 = fcmp olt float %15, %add
  br i1 %cmp23, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %35 = load i8, i8* %c, align 1, !tbaa !24, !range !46
  %tobool = trunc i8 %35 to i1
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %c, align 1, !tbaa !24
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %36 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add nsw i32 %36, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  store i32 %36, i32* %j, align 4, !tbaa !15
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %37 = load i8, i8* %c, align 1, !tbaa !24, !range !46
  %tobool25 = trunc i8 %37 to i1
  %conv26 = zext i1 %tobool25 to i32
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #7
  ret i32 %conv26
}

declare i8* @strrchr(i8*, i32) #2

; Function Attrs: nounwind ssp uwtable
define internal void @materialInit(%struct.objzMaterial* %_mat) #0 {
entry:
  %_mat.addr = alloca %struct.objzMaterial*, align 8
  store %struct.objzMaterial* %_mat, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %0 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %1 = bitcast %struct.objzMaterial* %0 to i8*
  %2 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %3 = bitcast %struct.objzMaterial* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 568, i64 %4) #7
  %5 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %diffuse = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %5, i32 0, i32 2
  %arrayidx = getelementptr inbounds [3 x float], [3 x float]* %diffuse, i64 0, i64 2
  store float 1.000000e+00, float* %arrayidx, align 4, !tbaa !91
  %6 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %diffuse1 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %6, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [3 x float], [3 x float]* %diffuse1, i64 0, i64 1
  store float 1.000000e+00, float* %arrayidx2, align 4, !tbaa !91
  %7 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %diffuse3 = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %7, i32 0, i32 2
  %arrayidx4 = getelementptr inbounds [3 x float], [3 x float]* %diffuse3, i64 0, i64 0
  store float 1.000000e+00, float* %arrayidx4, align 4, !tbaa !91
  %8 = load %struct.objzMaterial*, %struct.objzMaterial** %_mat.addr, align 8, !tbaa !4
  %opacity = getelementptr inbounds %struct.objzMaterial, %struct.objzMaterial* %8, i32 0, i32 6
  store float 1.000000e+00, float* %opacity, align 4, !tbaa !114
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @skipTokens(%struct.Lexer* %_lexer, i32 %_n) #0 {
entry:
  %retval = alloca i1, align 1
  %_lexer.addr = alloca %struct.Lexer*, align 8
  %_n.addr = alloca i32, align 4
  %token = alloca %struct.Token, align 4
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.Lexer* %_lexer, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  store i32 %_n, i32* %_n.addr, align 4, !tbaa !15
  %0 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %0) #7
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4, !tbaa !15
  %3 = load i32, i32* %_n.addr, align 4, !tbaa !15
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, i32* %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load %struct.Lexer*, %struct.Lexer** %_lexer.addr, align 8, !tbaa !4
  call void @tokenize(%struct.Lexer* %4, %struct.Token* %token, i1 zeroext false)
  %text = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %text, i32 0, i32 0
  %call = call i64 @strLength(i8* %arraydecay, i64 256)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %line = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 1
  %5 = load i32, i32* %line, align 4, !tbaa !33
  %column = getelementptr inbounds %struct.Token, %struct.Token* %token, i32 0, i32 2
  %6 = load i32, i32* %column, align 4, !tbaa !35
  call void (i8*, ...) @appendError(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.55, i32 0, i32 0), i32 %5, i32 %6)
  store i1 false, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  %8 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #7
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup2 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup
  store i1 true, i1* %retval, align 1
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup2

cleanup2:                                         ; preds = %for.end, %cleanup
  %9 = bitcast %struct.Token* %token to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %9) #7
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

declare double @atof(i8*) #2

; Function Attrs: nounwind readnone speculatable
declare float @llvm.sqrt.f32(float) #4

; Function Attrs: nounwind ssp uwtable
define internal i32 @sdbmHash(i8* %_data, i32 %_size) #0 {
entry:
  %_data.addr = alloca i8*, align 8
  %_size.addr = alloca i32, align 4
  %hash = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %_data, i8** %_data.addr, align 8, !tbaa !4
  store i32 %_size, i32* %_size.addr, align 4, !tbaa !15
  %0 = bitcast i32* %hash to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %hash, align 4, !tbaa !15
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  store i32 0, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4, !tbaa !15
  %3 = load i32, i32* %_size.addr, align 4, !tbaa !15
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #7
  br label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i8*, i8** %_data.addr, align 8, !tbaa !4
  %6 = load i32, i32* %i, align 4, !tbaa !15
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !14
  %conv = zext i8 %7 to i32
  %8 = load i32, i32* %hash, align 4, !tbaa !15
  %shl = shl i32 %8, 6
  %add = add i32 %conv, %shl
  %9 = load i32, i32* %hash, align 4, !tbaa !15
  %shl1 = shl i32 %9, 16
  %add2 = add i32 %add, %shl1
  %10 = load i32, i32* %hash, align 4, !tbaa !15
  %sub = sub i32 %add2, %10
  store i32 %sub, i32* %hash, align 4, !tbaa !15
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4, !tbaa !15
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4, !tbaa !15
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %12 = load i32, i32* %hash, align 4, !tbaa !15
  %13 = bitcast i32* %hash to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #7
  ret i32 %12
}

; Function Attrs: nounwind ssp uwtable
define internal zeroext i1 @vec3Equal(%struct.vec3* %_a, %struct.vec3* %_b, float %epsilon) #0 {
entry:
  %_a.addr = alloca %struct.vec3*, align 8
  %_b.addr = alloca %struct.vec3*, align 8
  %epsilon.addr = alloca float, align 4
  store %struct.vec3* %_a, %struct.vec3** %_a.addr, align 8, !tbaa !4
  store %struct.vec3* %_b, %struct.vec3** %_b.addr, align 8, !tbaa !4
  store float %epsilon, float* %epsilon.addr, align 4, !tbaa !91
  %0 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8, !tbaa !4
  %x = getelementptr inbounds %struct.vec3, %struct.vec3* %0, i32 0, i32 0
  %1 = load float, float* %x, align 4, !tbaa !47
  %2 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8, !tbaa !4
  %x1 = getelementptr inbounds %struct.vec3, %struct.vec3* %2, i32 0, i32 0
  %3 = load float, float* %x1, align 4, !tbaa !47
  %sub = fsub float %1, %3
  %4 = call float @llvm.fabs.f32(float %sub)
  %5 = load float, float* %epsilon.addr, align 4, !tbaa !91
  %cmp = fcmp ole float %4, %5
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8, !tbaa !4
  %y = getelementptr inbounds %struct.vec3, %struct.vec3* %6, i32 0, i32 1
  %7 = load float, float* %y, align 4, !tbaa !50
  %8 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8, !tbaa !4
  %y2 = getelementptr inbounds %struct.vec3, %struct.vec3* %8, i32 0, i32 1
  %9 = load float, float* %y2, align 4, !tbaa !50
  %sub3 = fsub float %7, %9
  %10 = call float @llvm.fabs.f32(float %sub3)
  %11 = load float, float* %epsilon.addr, align 4, !tbaa !91
  %cmp4 = fcmp ole float %10, %11
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %12 = load %struct.vec3*, %struct.vec3** %_a.addr, align 8, !tbaa !4
  %z = getelementptr inbounds %struct.vec3, %struct.vec3* %12, i32 0, i32 2
  %13 = load float, float* %z, align 4, !tbaa !51
  %14 = load %struct.vec3*, %struct.vec3** %_b.addr, align 8, !tbaa !4
  %z5 = getelementptr inbounds %struct.vec3, %struct.vec3* %14, i32 0, i32 2
  %15 = load float, float* %z5, align 4, !tbaa !51
  %sub6 = fsub float %13, %15
  %16 = call float @llvm.fabs.f32(float %sub6)
  %17 = load float, float* %epsilon.addr, align 4, !tbaa !91
  %cmp7 = fcmp ole float %16, %17
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %18 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %18
}

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone speculatable }
attributes #5 = { allocsize(1) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { cold noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { allocsize(1) }
attributes #9 = { cold noreturn }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 2, !"SDK Version", [3 x i32] [i32 10, i32 15, i32 4]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"PIC Level", i32 2}
!3 = !{!"clang version 8.0.1 (https://github.com/llvm-mirror/clang.git 2e4c9c5fc864c2c432e4c262a67c42d824b265c6) (https://github.com/llvm-mirror/llvm.git ea28a67e47fd87c6b78597d90eba543bad4d7468)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"any pointer", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!9, !10, i64 8}
!9 = !{!"", !5, i64 0, !10, i64 8, !10, i64 16}
!10 = !{!"long", !6, i64 0}
!11 = !{!9, !10, i64 16}
!12 = !{!9, !5, i64 0}
!13 = !{!10, !10, i64 0}
!14 = !{!6, !6, i64 0}
!15 = !{!16, !16, i64 0}
!16 = !{!"int", !6, i64 0}
!17 = !{!18, !10, i64 0}
!18 = !{!"", !10, i64 0, !10, i64 8, !10, i64 16, !10, i64 24}
!19 = !{!18, !10, i64 8}
!20 = !{!18, !10, i64 16}
!21 = !{!18, !10, i64 24}
!22 = !{!23, !23, i64 0}
!23 = !{!"short", !6, i64 0}
!24 = !{!25, !25, i64 0}
!25 = !{!"_Bool", !6, i64 0}
!26 = !{!27, !16, i64 8}
!27 = !{!"", !5, i64 0, !16, i64 8, !16, i64 12, !16, i64 16, !16, i64 20}
!28 = !{!29, !16, i64 68}
!29 = !{!"", !6, i64 0, !16, i64 64, !16, i64 68}
!30 = !{!29, !16, i64 64}
!31 = !{!27, !5, i64 0}
!32 = !{!27, !16, i64 16}
!33 = !{!34, !16, i64 256}
!34 = !{!"", !6, i64 0, !16, i64 256, !16, i64 260}
!35 = !{!34, !16, i64 260}
!36 = !{!37, !16, i64 40}
!37 = !{!"", !27, i64 0, !16, i64 24, !10, i64 32, !16, i64 40}
!38 = !{!39, !16, i64 0}
!39 = !{!"", !16, i64 0, !16, i64 4, !16, i64 8}
!40 = !{!39, !16, i64 4}
!41 = !{!39, !16, i64 8}
!42 = !{!43, !23, i64 0}
!43 = !{!"", !23, i64 0, !23, i64 2, !6, i64 4}
!44 = !{!43, !23, i64 2}
!45 = !{i64 0, i64 4, !15, i64 4, i64 4, !15, i64 8, i64 4, !15}
!46 = !{i8 0, i8 2}
!47 = !{!48, !49, i64 0}
!48 = !{!"", !49, i64 0, !49, i64 4, !49, i64 8}
!49 = !{!"float", !6, i64 0}
!50 = !{!48, !49, i64 4}
!51 = !{!48, !49, i64 8}
!52 = !{!53, !16, i64 64}
!53 = !{!"", !6, i64 0, !16, i64 64, !16, i64 68, !16, i64 72, !16, i64 76, !16, i64 80, !16, i64 84}
!54 = !{!53, !16, i64 68}
!55 = !{!53, !16, i64 72}
!56 = !{!53, !16, i64 76}
!57 = !{!53, !16, i64 80}
!58 = !{!53, !16, i64 84}
!59 = !{!60, !16, i64 24}
!60 = !{!"", !5, i64 0, !16, i64 8, !27, i64 16}
!61 = !{!62, !16, i64 0}
!62 = !{!"", !16, i64 0, !5, i64 8, !16, i64 16, !5, i64 24, !16, i64 32, !5, i64 40, !16, i64 48, !5, i64 56, !16, i64 64, !5, i64 72, !16, i64 80}
!63 = !{!62, !5, i64 8}
!64 = !{!62, !16, i64 16}
!65 = !{!62, !5, i64 24}
!66 = !{!62, !16, i64 32}
!67 = !{!62, !5, i64 40}
!68 = !{!62, !16, i64 48}
!69 = !{!62, !5, i64 56}
!70 = !{!62, !16, i64 64}
!71 = !{!62, !5, i64 72}
!72 = !{!60, !5, i64 16}
!73 = !{!60, !16, i64 32}
!74 = !{!75, !16, i64 4}
!75 = !{!"", !16, i64 0, !16, i64 4, !16, i64 8, !16, i64 12, !16, i64 16}
!76 = !{!75, !16, i64 8}
!77 = !{!75, !16, i64 12}
!78 = !{!62, !16, i64 80}
!79 = !{!27, !16, i64 12}
!80 = !{!27, !16, i64 20}
!81 = !{!37, !16, i64 24}
!82 = !{!37, !10, i64 32}
!83 = !{!84, !5, i64 0}
!84 = !{!"", !5, i64 0, !16, i64 8, !16, i64 12}
!85 = !{!84, !16, i64 12}
!86 = !{!84, !16, i64 8}
!87 = !{!37, !16, i64 8}
!88 = !{!37, !5, i64 0}
!89 = !{!37, !16, i64 16}
!90 = !{i64 0, i64 4, !91, i64 4, i64 4, !91, i64 8, i64 4, !91}
!91 = !{!49, !49, i64 0}
!92 = !{!93, !10, i64 16}
!93 = !{!"", !5, i64 0, !16, i64 8, !10, i64 16, !16, i64 24}
!94 = !{!93, !5, i64 0}
!95 = !{!93, !16, i64 8}
!96 = !{!97, !5, i64 0}
!97 = !{!"", !5, i64 0, !16, i64 8}
!98 = !{!97, !16, i64 8}
!99 = !{!93, !16, i64 24}
!100 = !{!60, !16, i64 8}
!101 = !{!60, !5, i64 0}
!102 = !{!103, !16, i64 8}
!103 = !{!"", !5, i64 0, !16, i64 8, !27, i64 16, !5, i64 40}
!104 = !{!103, !5, i64 0}
!105 = !{!103, !5, i64 40}
!106 = !{!103, !16, i64 24}
!107 = !{!103, !5, i64 16}
!108 = !{!103, !16, i64 32}
!109 = !{!110, !16, i64 0}
!110 = !{!"", !16, i64 0, !16, i64 4}
!111 = !{!110, !16, i64 4}
!112 = !{!75, !16, i64 0}
!113 = !{!75, !16, i64 16}
!114 = !{!115, !49, i64 116}
!115 = !{!"", !6, i64 0, !6, i64 64, !6, i64 76, !6, i64 88, !6, i64 100, !49, i64 112, !49, i64 116, !6, i64 120, !6, i64 184, !6, i64 248, !6, i64 312, !6, i64 376, !6, i64 440, !6, i64 504}
