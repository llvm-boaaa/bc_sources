; ModuleID = 'xxhash.c'
source_filename = "xxhash.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.XXH32_state_s = type { i32, i32, i32, i32, i32, i32, [4 x i32], i32, i32 }
%struct.XXH32_canonical_t = type { [4 x i8] }
%struct.XXH64_state_s = type { i64, i64, i64, i64, i64, [4 x i64], i32, i32, i64 }
%struct.XXH64_canonical_t = type { [8 x i8] }
%struct.XXH3_state_s = type { [8 x i64], [192 x i8], [256 x i8], i32, i32, i64, i64, i64, i64, i64, i64, i8* }
%struct.XXH128_canonical_t = type { [16 x i8] }
%struct.XXH128_hash_t = type { i64, i64 }
%struct.__loadu_si128 = type { <2 x i64> }

@XXH3_kSecret = internal constant [192 x i8] c"\B8\FEl9#\A4K\BE|\01\81,\F7!\AD\1C\DE\D4m\E9\83\90\97\DBr@\A4\A4\B7\B3g\1F\CBy\E6N\CC\C0\E5x\82Z\D0}\CC\FFr!\B8\08Ft\F7C$\8E\E05\90\E6\81:&L<(R\BB\91\C3\00\CB\88\D0e\8B\1BS.\A3qdH\97\A2\0D\F9N8\19\EFF\A9\DE\AC\D8\A8\FAv?\E3\9C4?\F9\DC\BB\C7\C7\0BO\1D\8AQ\E0K\CD\B4Y1\C8\9F~\C9\D9xsd\EA\C5\AC\834\D3\EB\C3\C5\81\A0\FF\FA\13c\EB\17\0D\DDQ\B7\F0\DAI\D3\16U&)\D4h\9E+\16\BEX}G\A1\FC\8F\F8\B8\D1z\D01\CEE\CB:\8F\95\16\04(\AF\D7\FB\CA\BBK@~", align 64
@__const.XXH3_hashLong_64b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16
@__const.XXH3_hashLong_128b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16

; Function Attrs: nounwind ssp uwtable
define i32 @XXH_versionNumber() #0 {
entry:
  ret i32 704
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32(i8* %input, i64 %len, i32 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i32 %seed, i32* %seed.addr, align 4, !tbaa !10
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %call = call i32 @XXH32_endian_align(i8* %0, i64 %1, i32 %2, i32 1)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH32_endian_align(i8* %input, i64 %len, i32 %seed, i32 %align) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h32 = alloca i32, align 4
  %limit = alloca i8*, align 8
  %v1 = alloca i32, align 4
  %v2 = alloca i32, align 4
  %v3 = alloca i32, align 4
  %v4 = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i32 %seed, i32* %seed.addr, align 4, !tbaa !10
  store i32 %align, i32* %align.addr, align 4, !tbaa !12
  %0 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !4
  %3 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp uge i64 %4, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #11
  %6 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %add.ptr1 = getelementptr inbounds i8, i8* %6, i64 -15
  store i8* %add.ptr1, i8** %limit, align 8, !tbaa !4
  %7 = bitcast i32* %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #11
  %8 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add = add i32 %8, -1640531535
  %add2 = add i32 %add, -2048144777
  store i32 %add2, i32* %v1, align 4, !tbaa !10
  %9 = bitcast i32* %v2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #11
  %10 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add3 = add i32 %10, -2048144777
  store i32 %add3, i32* %v2, align 4, !tbaa !10
  %11 = bitcast i32* %v3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %11) #11
  %12 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add4 = add i32 %12, 0
  store i32 %add4, i32* %v3, align 4, !tbaa !10
  %13 = bitcast i32* %v4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %13) #11
  %14 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %sub = sub i32 %14, -1640531535
  store i32 %sub, i32* %v4, align 4, !tbaa !10
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %15 = load i32, i32* %v1, align 4, !tbaa !10
  %16 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %17 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call = call i32 @XXH_readLE32_align(i8* %16, i32 %17)
  %call5 = call i32 @XXH32_round(i32 %15, i32 %call)
  store i32 %call5, i32* %v1, align 4, !tbaa !10
  %18 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr6 = getelementptr inbounds i8, i8* %18, i64 4
  store i8* %add.ptr6, i8** %input.addr, align 8, !tbaa !4
  %19 = load i32, i32* %v2, align 4, !tbaa !10
  %20 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %21 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call7 = call i32 @XXH_readLE32_align(i8* %20, i32 %21)
  %call8 = call i32 @XXH32_round(i32 %19, i32 %call7)
  store i32 %call8, i32* %v2, align 4, !tbaa !10
  %22 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr9 = getelementptr inbounds i8, i8* %22, i64 4
  store i8* %add.ptr9, i8** %input.addr, align 8, !tbaa !4
  %23 = load i32, i32* %v3, align 4, !tbaa !10
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %25 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call10 = call i32 @XXH_readLE32_align(i8* %24, i32 %25)
  %call11 = call i32 @XXH32_round(i32 %23, i32 %call10)
  store i32 %call11, i32* %v3, align 4, !tbaa !10
  %26 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr12 = getelementptr inbounds i8, i8* %26, i64 4
  store i8* %add.ptr12, i8** %input.addr, align 8, !tbaa !4
  %27 = load i32, i32* %v4, align 4, !tbaa !10
  %28 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %29 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call13 = call i32 @XXH_readLE32_align(i8* %28, i32 %29)
  %call14 = call i32 @XXH32_round(i32 %27, i32 %call13)
  store i32 %call14, i32* %v4, align 4, !tbaa !10
  %30 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr15 = getelementptr inbounds i8, i8* %30, i64 4
  store i8* %add.ptr15, i8** %input.addr, align 8, !tbaa !4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %31 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %32 = load i8*, i8** %limit, align 8, !tbaa !4
  %cmp16 = icmp ult i8* %31, %32
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %33 = load i32, i32* %v1, align 4, !tbaa !10
  %34 = call i32 @llvm.fshl.i32(i32 %33, i32 %33, i32 1)
  %35 = load i32, i32* %v2, align 4, !tbaa !10
  %36 = call i32 @llvm.fshl.i32(i32 %35, i32 %35, i32 7)
  %add17 = add i32 %34, %36
  %37 = load i32, i32* %v3, align 4, !tbaa !10
  %38 = call i32 @llvm.fshl.i32(i32 %37, i32 %37, i32 12)
  %add18 = add i32 %add17, %38
  %39 = load i32, i32* %v4, align 4, !tbaa !10
  %40 = call i32 @llvm.fshl.i32(i32 %39, i32 %39, i32 18)
  %add19 = add i32 %add18, %40
  store i32 %add19, i32* %h32, align 4, !tbaa !10
  %41 = bitcast i32* %v4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %41) #11
  %42 = bitcast i32* %v3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %42) #11
  %43 = bitcast i32* %v2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %43) #11
  %44 = bitcast i32* %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %44) #11
  %45 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #11
  br label %if.end

if.else:                                          ; preds = %entry
  %46 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add20 = add i32 %46, 374761393
  store i32 %add20, i32* %h32, align 4, !tbaa !10
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %47 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv = trunc i64 %47 to i32
  %48 = load i32, i32* %h32, align 4, !tbaa !10
  %add21 = add i32 %48, %conv
  store i32 %add21, i32* %h32, align 4, !tbaa !10
  %49 = load i32, i32* %h32, align 4, !tbaa !10
  %50 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %51 = load i64, i64* %len.addr, align 8, !tbaa !8
  %and = and i64 %51, 15
  %52 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call22 = call i32 @XXH32_finalize(i32 %49, i8* %50, i64 %and, i32 %52)
  %53 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %53) #11
  %54 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %54) #11
  ret i32 %call22
}

; Function Attrs: nounwind ssp uwtable
define %struct.XXH32_state_s* @XXH32_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 48)
  %0 = bitcast i8* %call to %struct.XXH32_state_s*
  ret %struct.XXH32_state_s* %0
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @XXH_malloc(i64 %s) #0 {
entry:
  %s.addr = alloca i64, align 8
  store i64 %s, i64* %s.addr, align 8, !tbaa !8
  %0 = load i64, i64* %s.addr, align 8, !tbaa !8
  %call = call i8* @malloc(i64 %0) #12
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_freeState(%struct.XXH32_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !4
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH_free(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %p.addr, align 8, !tbaa !4
  call void @free(i8* %0)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @XXH32_copyState(%struct.XXH32_state_s* %dstState, %struct.XXH32_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH32_state_s*, align 8
  %srcState.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %dstState, %struct.XXH32_state_s** %dstState.addr, align 8, !tbaa !4
  store %struct.XXH32_state_s* %srcState, %struct.XXH32_state_s** %srcState.addr, align 8, !tbaa !4
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  %2 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %srcState.addr, align 8, !tbaa !4
  %3 = bitcast %struct.XXH32_state_s* %2 to i8*
  %4 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8, !tbaa !4
  %5 = bitcast %struct.XXH32_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 48, i64 %6) #11
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #2

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #3

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_reset(%struct.XXH32_state_s* %statePtr, i32 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  %seed.addr = alloca i32, align 4
  %state = alloca %struct.XXH32_state_s, align 4
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !4
  store i32 %seed, i32* %seed.addr, align 4, !tbaa !10
  %0 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %0) #11
  %1 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %1, i8 0, i64 48, i1 false)
  %2 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add = add i32 %2, -1640531535
  %add1 = add i32 %add, -2048144777
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 2
  store i32 %add1, i32* %v1, align 4, !tbaa !13
  %3 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add2 = add i32 %3, -2048144777
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 3
  store i32 %add2, i32* %v2, align 4, !tbaa !15
  %4 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %add3 = add i32 %4, 0
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 4
  store i32 %add3, i32* %v3, align 4, !tbaa !16
  %5 = load i32, i32* %seed.addr, align 4, !tbaa !10
  %sub = sub i32 %5, -1640531535
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 5
  store i32 %sub, i32* %v4, align 4, !tbaa !17
  %6 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !4
  %7 = bitcast %struct.XXH32_state_s* %6 to i8*
  %8 = bitcast %struct.XXH32_state_s* %state to i8*
  %9 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !4
  %10 = bitcast %struct.XXH32_state_s* %9 to i8*
  %11 = call i64 @llvm.objectsize.i64.p0i8(i8* %10, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %7, i8* %8, i64 44, i64 %11) #11
  %12 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %12) #11
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_update(%struct.XXH32_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %p32 = alloca i32*, align 8
  %limit = alloca i8*, align 8
  %v155 = alloca i32, align 4
  %v257 = alloca i32, align 4
  %v359 = alloca i32, align 4
  %v461 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  store i8* %2, i8** %p, align 8, !tbaa !4
  %3 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i8*, i8** %p, align 8, !tbaa !4
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %5
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !4
  %6 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv = trunc i64 %6 to i32
  %7 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %7, i32 0, i32 0
  %8 = load i32, i32* %total_len_32, align 4, !tbaa !18
  %add = add i32 %8, %conv
  store i32 %add, i32* %total_len_32, align 4, !tbaa !18
  %9 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp1 = icmp uge i64 %9, 16
  %conv2 = zext i1 %cmp1 to i32
  %10 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %total_len_323 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %10, i32 0, i32 0
  %11 = load i32, i32* %total_len_323, align 4, !tbaa !18
  %cmp4 = icmp uge i32 %11, 16
  %conv5 = zext i1 %cmp4 to i32
  %or = or i32 %conv2, %conv5
  %12 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %12, i32 0, i32 1
  %13 = load i32, i32* %large_len, align 4, !tbaa !19
  %or6 = or i32 %13, %or
  store i32 %or6, i32* %large_len, align 4, !tbaa !19
  %14 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %14, i32 0, i32 7
  %15 = load i32, i32* %memsize, align 4, !tbaa !20
  %conv7 = zext i32 %15 to i64
  %16 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add8 = add i64 %conv7, %16
  %cmp9 = icmp ult i64 %add8, 16
  br i1 %cmp9, label %if.then11, label %if.end17

if.then11:                                        ; preds = %if.end
  %17 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %17, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %18 = bitcast i32* %arraydecay to i8*
  %19 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize12 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %19, i32 0, i32 7
  %20 = load i32, i32* %memsize12, align 4, !tbaa !20
  %idx.ext = zext i32 %20 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %18, i64 %idx.ext
  %21 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %22 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call i8* @XXH_memcpy(i8* %add.ptr13, i8* %21, i64 %22)
  %23 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv14 = trunc i64 %23 to i32
  %24 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize15 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %24, i32 0, i32 7
  %25 = load i32, i32* %memsize15, align 4, !tbaa !20
  %add16 = add i32 %25, %conv14
  store i32 %add16, i32* %memsize15, align 4, !tbaa !20
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end17:                                         ; preds = %if.end
  %26 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize18 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %26, i32 0, i32 7
  %27 = load i32, i32* %memsize18, align 4, !tbaa !20
  %tobool = icmp ne i32 %27, 0
  br i1 %tobool, label %if.then19, label %if.end49

if.then19:                                        ; preds = %if.end17
  %28 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %mem3220 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %28, i32 0, i32 6
  %arraydecay21 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3220, i32 0, i32 0
  %29 = bitcast i32* %arraydecay21 to i8*
  %30 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize22 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %30, i32 0, i32 7
  %31 = load i32, i32* %memsize22, align 4, !tbaa !20
  %idx.ext23 = zext i32 %31 to i64
  %add.ptr24 = getelementptr inbounds i8, i8* %29, i64 %idx.ext23
  %32 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %33 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize25 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %33, i32 0, i32 7
  %34 = load i32, i32* %memsize25, align 4, !tbaa !20
  %sub = sub i32 16, %34
  %conv26 = zext i32 %sub to i64
  %call27 = call i8* @XXH_memcpy(i8* %add.ptr24, i8* %32, i64 %conv26)
  %35 = bitcast i32** %p32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %35) #11
  %36 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %mem3228 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %36, i32 0, i32 6
  %arraydecay29 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3228, i32 0, i32 0
  store i32* %arraydecay29, i32** %p32, align 8, !tbaa !4
  %37 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %37, i32 0, i32 2
  %38 = load i32, i32* %v1, align 4, !tbaa !13
  %39 = load i32*, i32** %p32, align 8, !tbaa !4
  %40 = bitcast i32* %39 to i8*
  %call30 = call i32 @XXH_readLE32(i8* %40)
  %call31 = call i32 @XXH32_round(i32 %38, i32 %call30)
  %41 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v132 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %41, i32 0, i32 2
  store i32 %call31, i32* %v132, align 4, !tbaa !13
  %42 = load i32*, i32** %p32, align 8, !tbaa !4
  %incdec.ptr = getelementptr inbounds i32, i32* %42, i32 1
  store i32* %incdec.ptr, i32** %p32, align 8, !tbaa !4
  %43 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %43, i32 0, i32 3
  %44 = load i32, i32* %v2, align 4, !tbaa !15
  %45 = load i32*, i32** %p32, align 8, !tbaa !4
  %46 = bitcast i32* %45 to i8*
  %call33 = call i32 @XXH_readLE32(i8* %46)
  %call34 = call i32 @XXH32_round(i32 %44, i32 %call33)
  %47 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v235 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %47, i32 0, i32 3
  store i32 %call34, i32* %v235, align 4, !tbaa !15
  %48 = load i32*, i32** %p32, align 8, !tbaa !4
  %incdec.ptr36 = getelementptr inbounds i32, i32* %48, i32 1
  store i32* %incdec.ptr36, i32** %p32, align 8, !tbaa !4
  %49 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %49, i32 0, i32 4
  %50 = load i32, i32* %v3, align 4, !tbaa !16
  %51 = load i32*, i32** %p32, align 8, !tbaa !4
  %52 = bitcast i32* %51 to i8*
  %call37 = call i32 @XXH_readLE32(i8* %52)
  %call38 = call i32 @XXH32_round(i32 %50, i32 %call37)
  %53 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v339 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %53, i32 0, i32 4
  store i32 %call38, i32* %v339, align 4, !tbaa !16
  %54 = load i32*, i32** %p32, align 8, !tbaa !4
  %incdec.ptr40 = getelementptr inbounds i32, i32* %54, i32 1
  store i32* %incdec.ptr40, i32** %p32, align 8, !tbaa !4
  %55 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %55, i32 0, i32 5
  %56 = load i32, i32* %v4, align 4, !tbaa !17
  %57 = load i32*, i32** %p32, align 8, !tbaa !4
  %58 = bitcast i32* %57 to i8*
  %call41 = call i32 @XXH_readLE32(i8* %58)
  %call42 = call i32 @XXH32_round(i32 %56, i32 %call41)
  %59 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v443 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %59, i32 0, i32 5
  store i32 %call42, i32* %v443, align 4, !tbaa !17
  %60 = bitcast i32** %p32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %60) #11
  %61 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize44 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %61, i32 0, i32 7
  %62 = load i32, i32* %memsize44, align 4, !tbaa !20
  %sub45 = sub i32 16, %62
  %63 = load i8*, i8** %p, align 8, !tbaa !4
  %idx.ext46 = zext i32 %sub45 to i64
  %add.ptr47 = getelementptr inbounds i8, i8* %63, i64 %idx.ext46
  store i8* %add.ptr47, i8** %p, align 8, !tbaa !4
  %64 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize48 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %64, i32 0, i32 7
  store i32 0, i32* %memsize48, align 4, !tbaa !20
  br label %if.end49

if.end49:                                         ; preds = %if.then19, %if.end17
  %65 = load i8*, i8** %p, align 8, !tbaa !4
  %66 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %add.ptr50 = getelementptr inbounds i8, i8* %66, i64 -16
  %cmp51 = icmp ule i8* %65, %add.ptr50
  br i1 %cmp51, label %if.then53, label %if.end81

if.then53:                                        ; preds = %if.end49
  %67 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %67) #11
  %68 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %add.ptr54 = getelementptr inbounds i8, i8* %68, i64 -16
  store i8* %add.ptr54, i8** %limit, align 8, !tbaa !4
  %69 = bitcast i32* %v155 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %69) #11
  %70 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v156 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %70, i32 0, i32 2
  %71 = load i32, i32* %v156, align 4, !tbaa !13
  store i32 %71, i32* %v155, align 4, !tbaa !10
  %72 = bitcast i32* %v257 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %72) #11
  %73 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v258 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %73, i32 0, i32 3
  %74 = load i32, i32* %v258, align 4, !tbaa !15
  store i32 %74, i32* %v257, align 4, !tbaa !10
  %75 = bitcast i32* %v359 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %75) #11
  %76 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v360 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %76, i32 0, i32 4
  %77 = load i32, i32* %v360, align 4, !tbaa !16
  store i32 %77, i32* %v359, align 4, !tbaa !10
  %78 = bitcast i32* %v461 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %78) #11
  %79 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v462 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %79, i32 0, i32 5
  %80 = load i32, i32* %v462, align 4, !tbaa !17
  store i32 %80, i32* %v461, align 4, !tbaa !10
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then53
  %81 = load i32, i32* %v155, align 4, !tbaa !10
  %82 = load i8*, i8** %p, align 8, !tbaa !4
  %call63 = call i32 @XXH_readLE32(i8* %82)
  %call64 = call i32 @XXH32_round(i32 %81, i32 %call63)
  store i32 %call64, i32* %v155, align 4, !tbaa !10
  %83 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr65 = getelementptr inbounds i8, i8* %83, i64 4
  store i8* %add.ptr65, i8** %p, align 8, !tbaa !4
  %84 = load i32, i32* %v257, align 4, !tbaa !10
  %85 = load i8*, i8** %p, align 8, !tbaa !4
  %call66 = call i32 @XXH_readLE32(i8* %85)
  %call67 = call i32 @XXH32_round(i32 %84, i32 %call66)
  store i32 %call67, i32* %v257, align 4, !tbaa !10
  %86 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr68 = getelementptr inbounds i8, i8* %86, i64 4
  store i8* %add.ptr68, i8** %p, align 8, !tbaa !4
  %87 = load i32, i32* %v359, align 4, !tbaa !10
  %88 = load i8*, i8** %p, align 8, !tbaa !4
  %call69 = call i32 @XXH_readLE32(i8* %88)
  %call70 = call i32 @XXH32_round(i32 %87, i32 %call69)
  store i32 %call70, i32* %v359, align 4, !tbaa !10
  %89 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr71 = getelementptr inbounds i8, i8* %89, i64 4
  store i8* %add.ptr71, i8** %p, align 8, !tbaa !4
  %90 = load i32, i32* %v461, align 4, !tbaa !10
  %91 = load i8*, i8** %p, align 8, !tbaa !4
  %call72 = call i32 @XXH_readLE32(i8* %91)
  %call73 = call i32 @XXH32_round(i32 %90, i32 %call72)
  store i32 %call73, i32* %v461, align 4, !tbaa !10
  %92 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr74 = getelementptr inbounds i8, i8* %92, i64 4
  store i8* %add.ptr74, i8** %p, align 8, !tbaa !4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %93 = load i8*, i8** %p, align 8, !tbaa !4
  %94 = load i8*, i8** %limit, align 8, !tbaa !4
  %cmp75 = icmp ule i8* %93, %94
  br i1 %cmp75, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %95 = load i32, i32* %v155, align 4, !tbaa !10
  %96 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v177 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %96, i32 0, i32 2
  store i32 %95, i32* %v177, align 4, !tbaa !13
  %97 = load i32, i32* %v257, align 4, !tbaa !10
  %98 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v278 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %98, i32 0, i32 3
  store i32 %97, i32* %v278, align 4, !tbaa !15
  %99 = load i32, i32* %v359, align 4, !tbaa !10
  %100 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v379 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %100, i32 0, i32 4
  store i32 %99, i32* %v379, align 4, !tbaa !16
  %101 = load i32, i32* %v461, align 4, !tbaa !10
  %102 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v480 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %102, i32 0, i32 5
  store i32 %101, i32* %v480, align 4, !tbaa !17
  %103 = bitcast i32* %v461 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %103) #11
  %104 = bitcast i32* %v359 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %104) #11
  %105 = bitcast i32* %v257 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %105) #11
  %106 = bitcast i32* %v155 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %106) #11
  %107 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %107) #11
  br label %if.end81

if.end81:                                         ; preds = %do.end, %if.end49
  %108 = load i8*, i8** %p, align 8, !tbaa !4
  %109 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %cmp82 = icmp ult i8* %108, %109
  br i1 %cmp82, label %if.then84, label %if.end93

if.then84:                                        ; preds = %if.end81
  %110 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %mem3285 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %110, i32 0, i32 6
  %arraydecay86 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3285, i32 0, i32 0
  %111 = bitcast i32* %arraydecay86 to i8*
  %112 = load i8*, i8** %p, align 8, !tbaa !4
  %113 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %114 = load i8*, i8** %p, align 8, !tbaa !4
  %sub.ptr.lhs.cast = ptrtoint i8* %113 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %114 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call87 = call i8* @XXH_memcpy(i8* %111, i8* %112, i64 %sub.ptr.sub)
  %115 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %116 = load i8*, i8** %p, align 8, !tbaa !4
  %sub.ptr.lhs.cast88 = ptrtoint i8* %115 to i64
  %sub.ptr.rhs.cast89 = ptrtoint i8* %116 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %conv91 = trunc i64 %sub.ptr.sub90 to i32
  %117 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize92 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %117, i32 0, i32 7
  store i32 %conv91, i32* %memsize92, align 4, !tbaa !20
  br label %if.end93

if.end93:                                         ; preds = %if.then84, %if.end81
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end93, %if.then11
  %118 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %118) #11
  %119 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %119) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cleanup.cont, %cleanup, %if.then
  %120 = load i32, i32* %retval, align 4
  ret i32 %120

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @XXH_memcpy(i8* %dest, i8* %src, i64 %size) #0 {
entry:
  %dest.addr = alloca i8*, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  store i8* %dest, i8** %dest.addr, align 8, !tbaa !4
  store i8* %src, i8** %src.addr, align 8, !tbaa !4
  store i64 %size, i64* %size.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %dest.addr, align 8, !tbaa !4
  %1 = load i8*, i8** %src.addr, align 8, !tbaa !4
  %2 = load i64, i64* %size.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %dest.addr, align 8, !tbaa !4
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 %2, i64 %4) #11
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH32_round(i32 %acc, i32 %input) #0 {
entry:
  %acc.addr = alloca i32, align 4
  %input.addr = alloca i32, align 4
  store i32 %acc, i32* %acc.addr, align 4, !tbaa !10
  store i32 %input, i32* %input.addr, align 4, !tbaa !10
  %0 = load i32, i32* %input.addr, align 4, !tbaa !10
  %mul = mul i32 %0, -2048144777
  %1 = load i32, i32* %acc.addr, align 4, !tbaa !10
  %add = add i32 %1, %mul
  store i32 %add, i32* %acc.addr, align 4, !tbaa !10
  %2 = load i32, i32* %acc.addr, align 4, !tbaa !10
  %3 = call i32 @llvm.fshl.i32(i32 %2, i32 %2, i32 13)
  store i32 %3, i32* %acc.addr, align 4, !tbaa !10
  %4 = load i32, i32* %acc.addr, align 4, !tbaa !10
  %mul1 = mul i32 %4, -1640531535
  store i32 %mul1, i32* %acc.addr, align 4, !tbaa !10
  %5 = load i32, i32* %acc.addr, align 4, !tbaa !10
  %6 = call i32 asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %5) #9, !srcloc !21
  store i32 %6, i32* %acc.addr, align 4, !tbaa !10
  %7 = load i32, i32* %acc.addr, align 4, !tbaa !10
  ret i32 %7
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH_readLE32(i8* %ptr) #1 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %call = call i32 @XXH_read32(i8* %0)
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_digest(%struct.XXH32_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %h32 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %0 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %1, i32 0, i32 1
  %2 = load i32, i32* %large_len, align 4, !tbaa !19
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %3, i32 0, i32 2
  %4 = load i32, i32* %v1, align 4, !tbaa !13
  %5 = call i32 @llvm.fshl.i32(i32 %4, i32 %4, i32 1)
  %6 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %6, i32 0, i32 3
  %7 = load i32, i32* %v2, align 4, !tbaa !15
  %8 = call i32 @llvm.fshl.i32(i32 %7, i32 %7, i32 7)
  %add = add i32 %5, %8
  %9 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %9, i32 0, i32 4
  %10 = load i32, i32* %v3, align 4, !tbaa !16
  %11 = call i32 @llvm.fshl.i32(i32 %10, i32 %10, i32 12)
  %add1 = add i32 %add, %11
  %12 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %12, i32 0, i32 5
  %13 = load i32, i32* %v4, align 4, !tbaa !17
  %14 = call i32 @llvm.fshl.i32(i32 %13, i32 %13, i32 18)
  %add2 = add i32 %add1, %14
  store i32 %add2, i32* %h32, align 4, !tbaa !10
  br label %if.end

if.else:                                          ; preds = %entry
  %15 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %v33 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %15, i32 0, i32 4
  %16 = load i32, i32* %v33, align 4, !tbaa !16
  %add4 = add i32 %16, 374761393
  store i32 %add4, i32* %h32, align 4, !tbaa !10
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %17, i32 0, i32 0
  %18 = load i32, i32* %total_len_32, align 4, !tbaa !18
  %19 = load i32, i32* %h32, align 4, !tbaa !10
  %add5 = add i32 %19, %18
  store i32 %add5, i32* %h32, align 4, !tbaa !10
  %20 = load i32, i32* %h32, align 4, !tbaa !10
  %21 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %21, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %22 = bitcast i32* %arraydecay to i8*
  %23 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !4
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %23, i32 0, i32 7
  %24 = load i32, i32* %memsize, align 4, !tbaa !20
  %conv = zext i32 %24 to i64
  %call = call i32 @XXH32_finalize(i32 %20, i8* %22, i64 %conv, i32 0)
  %25 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %25) #11
  ret i32 %call
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.fshl.i32(i32, i32, i32) #3

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH32_finalize(i32 %h32, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i32, align 4
  %h32.addr = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4, !tbaa !10
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i32 %align, i32* %align.addr, align 4, !tbaa !12
  %0 = load i64, i64* %len.addr, align 8, !tbaa !8
  %and = and i64 %0, 15
  switch i64 %and, label %sw.epilog [
    i64 12, label %sw.bb
    i64 8, label %sw.bb2
    i64 4, label %sw.bb10
    i64 13, label %sw.bb19
    i64 9, label %sw.bb27
    i64 5, label %sw.bb35
    i64 14, label %sw.bb49
    i64 10, label %sw.bb57
    i64 6, label %sw.bb65
    i64 15, label %sw.bb88
    i64 11, label %sw.bb96
    i64 7, label %sw.bb104
    i64 3, label %sw.bb112
    i64 2, label %sw.bb120
    i64 1, label %sw.bb128
    i64 0, label %sw.bb136
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %2 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call = call i32 @XXH_readLE32_align(i8* %1, i32 %2)
  %mul = mul i32 %call, -1028477379
  %3 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add = add i32 %3, %mul
  store i32 %add, i32* %h32.addr, align 4, !tbaa !10
  %4 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 4
  store i8* %add.ptr, i8** %ptr.addr, align 8, !tbaa !4
  %5 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %6 = call i32 @llvm.fshl.i32(i32 %5, i32 %5, i32 17)
  %mul1 = mul i32 %6, 668265263
  store i32 %mul1, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %7 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %8 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call4 = call i32 @XXH_readLE32_align(i8* %7, i32 %8)
  %mul5 = mul i32 %call4, -1028477379
  %9 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add6 = add i32 %9, %mul5
  store i32 %add6, i32* %h32.addr, align 4, !tbaa !10
  %10 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 4
  store i8* %add.ptr7, i8** %ptr.addr, align 8, !tbaa !4
  %11 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %12 = call i32 @llvm.fshl.i32(i32 %11, i32 %11, i32 17)
  %mul8 = mul i32 %12, 668265263
  store i32 %mul8, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end9

do.end9:                                          ; preds = %do.body3
  br label %sw.bb10

sw.bb10:                                          ; preds = %entry, %do.end9
  br label %do.body11

do.body11:                                        ; preds = %sw.bb10
  %13 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %14 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call12 = call i32 @XXH_readLE32_align(i8* %13, i32 %14)
  %mul13 = mul i32 %call12, -1028477379
  %15 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add14 = add i32 %15, %mul13
  store i32 %add14, i32* %h32.addr, align 4, !tbaa !10
  %16 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr15 = getelementptr inbounds i8, i8* %16, i64 4
  store i8* %add.ptr15, i8** %ptr.addr, align 8, !tbaa !4
  %17 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %18 = call i32 @llvm.fshl.i32(i32 %17, i32 %17, i32 17)
  %mul16 = mul i32 %18, 668265263
  store i32 %mul16, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end17

do.end17:                                         ; preds = %do.body11
  %19 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %call18 = call i32 @XXH32_avalanche(i32 %19)
  store i32 %call18, i32* %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  br label %do.body20

do.body20:                                        ; preds = %sw.bb19
  %20 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %21 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call21 = call i32 @XXH_readLE32_align(i8* %20, i32 %21)
  %mul22 = mul i32 %call21, -1028477379
  %22 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add23 = add i32 %22, %mul22
  store i32 %add23, i32* %h32.addr, align 4, !tbaa !10
  %23 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr24 = getelementptr inbounds i8, i8* %23, i64 4
  store i8* %add.ptr24, i8** %ptr.addr, align 8, !tbaa !4
  %24 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %25 = call i32 @llvm.fshl.i32(i32 %24, i32 %24, i32 17)
  %mul25 = mul i32 %25, 668265263
  store i32 %mul25, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end26

do.end26:                                         ; preds = %do.body20
  br label %sw.bb27

sw.bb27:                                          ; preds = %entry, %do.end26
  br label %do.body28

do.body28:                                        ; preds = %sw.bb27
  %26 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %27 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call29 = call i32 @XXH_readLE32_align(i8* %26, i32 %27)
  %mul30 = mul i32 %call29, -1028477379
  %28 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add31 = add i32 %28, %mul30
  store i32 %add31, i32* %h32.addr, align 4, !tbaa !10
  %29 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr32 = getelementptr inbounds i8, i8* %29, i64 4
  store i8* %add.ptr32, i8** %ptr.addr, align 8, !tbaa !4
  %30 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %31 = call i32 @llvm.fshl.i32(i32 %30, i32 %30, i32 17)
  %mul33 = mul i32 %31, 668265263
  store i32 %mul33, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end34

do.end34:                                         ; preds = %do.body28
  br label %sw.bb35

sw.bb35:                                          ; preds = %entry, %do.end34
  br label %do.body36

do.body36:                                        ; preds = %sw.bb35
  %32 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %33 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call37 = call i32 @XXH_readLE32_align(i8* %32, i32 %33)
  %mul38 = mul i32 %call37, -1028477379
  %34 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add39 = add i32 %34, %mul38
  store i32 %add39, i32* %h32.addr, align 4, !tbaa !10
  %35 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr40 = getelementptr inbounds i8, i8* %35, i64 4
  store i8* %add.ptr40, i8** %ptr.addr, align 8, !tbaa !4
  %36 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %37 = call i32 @llvm.fshl.i32(i32 %36, i32 %36, i32 17)
  %mul41 = mul i32 %37, 668265263
  store i32 %mul41, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end42

do.end42:                                         ; preds = %do.body36
  br label %do.body43

do.body43:                                        ; preds = %do.end42
  %38 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr = getelementptr inbounds i8, i8* %38, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8, !tbaa !4
  %39 = load i8, i8* %38, align 1, !tbaa !12
  %conv = zext i8 %39 to i32
  %mul44 = mul i32 %conv, 374761393
  %40 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add45 = add i32 %40, %mul44
  store i32 %add45, i32* %h32.addr, align 4, !tbaa !10
  %41 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %42 = call i32 @llvm.fshl.i32(i32 %41, i32 %41, i32 11)
  %mul46 = mul i32 %42, -1640531535
  store i32 %mul46, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end47

do.end47:                                         ; preds = %do.body43
  %43 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %call48 = call i32 @XXH32_avalanche(i32 %43)
  store i32 %call48, i32* %retval, align 4
  br label %return

sw.bb49:                                          ; preds = %entry
  br label %do.body50

do.body50:                                        ; preds = %sw.bb49
  %44 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %45 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call51 = call i32 @XXH_readLE32_align(i8* %44, i32 %45)
  %mul52 = mul i32 %call51, -1028477379
  %46 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add53 = add i32 %46, %mul52
  store i32 %add53, i32* %h32.addr, align 4, !tbaa !10
  %47 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr54 = getelementptr inbounds i8, i8* %47, i64 4
  store i8* %add.ptr54, i8** %ptr.addr, align 8, !tbaa !4
  %48 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %49 = call i32 @llvm.fshl.i32(i32 %48, i32 %48, i32 17)
  %mul55 = mul i32 %49, 668265263
  store i32 %mul55, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end56

do.end56:                                         ; preds = %do.body50
  br label %sw.bb57

sw.bb57:                                          ; preds = %entry, %do.end56
  br label %do.body58

do.body58:                                        ; preds = %sw.bb57
  %50 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %51 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call59 = call i32 @XXH_readLE32_align(i8* %50, i32 %51)
  %mul60 = mul i32 %call59, -1028477379
  %52 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add61 = add i32 %52, %mul60
  store i32 %add61, i32* %h32.addr, align 4, !tbaa !10
  %53 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr62 = getelementptr inbounds i8, i8* %53, i64 4
  store i8* %add.ptr62, i8** %ptr.addr, align 8, !tbaa !4
  %54 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %55 = call i32 @llvm.fshl.i32(i32 %54, i32 %54, i32 17)
  %mul63 = mul i32 %55, 668265263
  store i32 %mul63, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end64

do.end64:                                         ; preds = %do.body58
  br label %sw.bb65

sw.bb65:                                          ; preds = %entry, %do.end64
  br label %do.body66

do.body66:                                        ; preds = %sw.bb65
  %56 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %57 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call67 = call i32 @XXH_readLE32_align(i8* %56, i32 %57)
  %mul68 = mul i32 %call67, -1028477379
  %58 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add69 = add i32 %58, %mul68
  store i32 %add69, i32* %h32.addr, align 4, !tbaa !10
  %59 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr70 = getelementptr inbounds i8, i8* %59, i64 4
  store i8* %add.ptr70, i8** %ptr.addr, align 8, !tbaa !4
  %60 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %61 = call i32 @llvm.fshl.i32(i32 %60, i32 %60, i32 17)
  %mul71 = mul i32 %61, 668265263
  store i32 %mul71, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end72

do.end72:                                         ; preds = %do.body66
  br label %do.body73

do.body73:                                        ; preds = %do.end72
  %62 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr74 = getelementptr inbounds i8, i8* %62, i32 1
  store i8* %incdec.ptr74, i8** %ptr.addr, align 8, !tbaa !4
  %63 = load i8, i8* %62, align 1, !tbaa !12
  %conv75 = zext i8 %63 to i32
  %mul76 = mul i32 %conv75, 374761393
  %64 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add77 = add i32 %64, %mul76
  store i32 %add77, i32* %h32.addr, align 4, !tbaa !10
  %65 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %66 = call i32 @llvm.fshl.i32(i32 %65, i32 %65, i32 11)
  %mul78 = mul i32 %66, -1640531535
  store i32 %mul78, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end79

do.end79:                                         ; preds = %do.body73
  br label %do.body80

do.body80:                                        ; preds = %do.end79
  %67 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr81 = getelementptr inbounds i8, i8* %67, i32 1
  store i8* %incdec.ptr81, i8** %ptr.addr, align 8, !tbaa !4
  %68 = load i8, i8* %67, align 1, !tbaa !12
  %conv82 = zext i8 %68 to i32
  %mul83 = mul i32 %conv82, 374761393
  %69 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add84 = add i32 %69, %mul83
  store i32 %add84, i32* %h32.addr, align 4, !tbaa !10
  %70 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %71 = call i32 @llvm.fshl.i32(i32 %70, i32 %70, i32 11)
  %mul85 = mul i32 %71, -1640531535
  store i32 %mul85, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end86

do.end86:                                         ; preds = %do.body80
  %72 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %call87 = call i32 @XXH32_avalanche(i32 %72)
  store i32 %call87, i32* %retval, align 4
  br label %return

sw.bb88:                                          ; preds = %entry
  br label %do.body89

do.body89:                                        ; preds = %sw.bb88
  %73 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %74 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call90 = call i32 @XXH_readLE32_align(i8* %73, i32 %74)
  %mul91 = mul i32 %call90, -1028477379
  %75 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add92 = add i32 %75, %mul91
  store i32 %add92, i32* %h32.addr, align 4, !tbaa !10
  %76 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr93 = getelementptr inbounds i8, i8* %76, i64 4
  store i8* %add.ptr93, i8** %ptr.addr, align 8, !tbaa !4
  %77 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %78 = call i32 @llvm.fshl.i32(i32 %77, i32 %77, i32 17)
  %mul94 = mul i32 %78, 668265263
  store i32 %mul94, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end95

do.end95:                                         ; preds = %do.body89
  br label %sw.bb96

sw.bb96:                                          ; preds = %entry, %do.end95
  br label %do.body97

do.body97:                                        ; preds = %sw.bb96
  %79 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %80 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call98 = call i32 @XXH_readLE32_align(i8* %79, i32 %80)
  %mul99 = mul i32 %call98, -1028477379
  %81 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add100 = add i32 %81, %mul99
  store i32 %add100, i32* %h32.addr, align 4, !tbaa !10
  %82 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr101 = getelementptr inbounds i8, i8* %82, i64 4
  store i8* %add.ptr101, i8** %ptr.addr, align 8, !tbaa !4
  %83 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %84 = call i32 @llvm.fshl.i32(i32 %83, i32 %83, i32 17)
  %mul102 = mul i32 %84, 668265263
  store i32 %mul102, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end103

do.end103:                                        ; preds = %do.body97
  br label %sw.bb104

sw.bb104:                                         ; preds = %entry, %do.end103
  br label %do.body105

do.body105:                                       ; preds = %sw.bb104
  %85 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %86 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call106 = call i32 @XXH_readLE32_align(i8* %85, i32 %86)
  %mul107 = mul i32 %call106, -1028477379
  %87 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add108 = add i32 %87, %mul107
  store i32 %add108, i32* %h32.addr, align 4, !tbaa !10
  %88 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr109 = getelementptr inbounds i8, i8* %88, i64 4
  store i8* %add.ptr109, i8** %ptr.addr, align 8, !tbaa !4
  %89 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %90 = call i32 @llvm.fshl.i32(i32 %89, i32 %89, i32 17)
  %mul110 = mul i32 %90, 668265263
  store i32 %mul110, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end111

do.end111:                                        ; preds = %do.body105
  br label %sw.bb112

sw.bb112:                                         ; preds = %entry, %do.end111
  br label %do.body113

do.body113:                                       ; preds = %sw.bb112
  %91 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr114 = getelementptr inbounds i8, i8* %91, i32 1
  store i8* %incdec.ptr114, i8** %ptr.addr, align 8, !tbaa !4
  %92 = load i8, i8* %91, align 1, !tbaa !12
  %conv115 = zext i8 %92 to i32
  %mul116 = mul i32 %conv115, 374761393
  %93 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add117 = add i32 %93, %mul116
  store i32 %add117, i32* %h32.addr, align 4, !tbaa !10
  %94 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %95 = call i32 @llvm.fshl.i32(i32 %94, i32 %94, i32 11)
  %mul118 = mul i32 %95, -1640531535
  store i32 %mul118, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end119

do.end119:                                        ; preds = %do.body113
  br label %sw.bb120

sw.bb120:                                         ; preds = %entry, %do.end119
  br label %do.body121

do.body121:                                       ; preds = %sw.bb120
  %96 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr122 = getelementptr inbounds i8, i8* %96, i32 1
  store i8* %incdec.ptr122, i8** %ptr.addr, align 8, !tbaa !4
  %97 = load i8, i8* %96, align 1, !tbaa !12
  %conv123 = zext i8 %97 to i32
  %mul124 = mul i32 %conv123, 374761393
  %98 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add125 = add i32 %98, %mul124
  store i32 %add125, i32* %h32.addr, align 4, !tbaa !10
  %99 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %100 = call i32 @llvm.fshl.i32(i32 %99, i32 %99, i32 11)
  %mul126 = mul i32 %100, -1640531535
  store i32 %mul126, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end127

do.end127:                                        ; preds = %do.body121
  br label %sw.bb128

sw.bb128:                                         ; preds = %entry, %do.end127
  br label %do.body129

do.body129:                                       ; preds = %sw.bb128
  %101 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr130 = getelementptr inbounds i8, i8* %101, i32 1
  store i8* %incdec.ptr130, i8** %ptr.addr, align 8, !tbaa !4
  %102 = load i8, i8* %101, align 1, !tbaa !12
  %conv131 = zext i8 %102 to i32
  %mul132 = mul i32 %conv131, 374761393
  %103 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %add133 = add i32 %103, %mul132
  store i32 %add133, i32* %h32.addr, align 4, !tbaa !10
  %104 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %105 = call i32 @llvm.fshl.i32(i32 %104, i32 %104, i32 11)
  %mul134 = mul i32 %105, -1640531535
  store i32 %mul134, i32* %h32.addr, align 4, !tbaa !10
  br label %do.end135

do.end135:                                        ; preds = %do.body129
  br label %sw.bb136

sw.bb136:                                         ; preds = %entry, %do.end135
  %106 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %call137 = call i32 @XXH32_avalanche(i32 %106)
  store i32 %call137, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %entry
  %107 = load i32, i32* %h32.addr, align 4, !tbaa !10
  store i32 %107, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb136, %do.end86, %do.end47, %do.end17
  %108 = load i32, i32* %retval, align 4
  ret i32 %108
}

; Function Attrs: nounwind ssp uwtable
define void @XXH32_canonicalFromHash(%struct.XXH32_canonical_t* %dst, i32 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH32_canonical_t*, align 8
  %hash.addr = alloca i32, align 4
  store %struct.XXH32_canonical_t* %dst, %struct.XXH32_canonical_t** %dst.addr, align 8, !tbaa !4
  store i32 %hash, i32* %hash.addr, align 4, !tbaa !10
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, i32* %hash.addr, align 4, !tbaa !10
  %call = call i32 @XXH_swap32(i32 %0)
  store i32 %call, i32* %hash.addr, align 4, !tbaa !10
  %1 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8, !tbaa !4
  %2 = bitcast %struct.XXH32_canonical_t* %1 to i8*
  %3 = bitcast i32* %hash.addr to i8*
  %4 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8, !tbaa !4
  %5 = bitcast %struct.XXH32_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 4, i64 %6) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH_swap32(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4, !tbaa !10
  %0 = load i32, i32* %x.addr, align 4, !tbaa !10
  %shl = shl i32 %0, 24
  %and = and i32 %shl, -16777216
  %1 = load i32, i32* %x.addr, align 4, !tbaa !10
  %shl1 = shl i32 %1, 8
  %and2 = and i32 %shl1, 16711680
  %or = or i32 %and, %and2
  %2 = load i32, i32* %x.addr, align 4, !tbaa !10
  %shr = lshr i32 %2, 8
  %and3 = and i32 %shr, 65280
  %or4 = or i32 %or, %and3
  %3 = load i32, i32* %x.addr, align 4, !tbaa !10
  %shr5 = lshr i32 %3, 24
  %and6 = and i32 %shr5, 255
  %or7 = or i32 %or4, %and6
  ret i32 %or7
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_hashFromCanonical(%struct.XXH32_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH32_canonical_t*, align 8
  store %struct.XXH32_canonical_t* %src, %struct.XXH32_canonical_t** %src.addr, align 8, !tbaa !4
  %0 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %src.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH32_canonical_t* %0 to i8*
  %call = call i32 @XXH_readBE32(i8* %1)
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH_readBE32(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %call = call i32 @XXH_read32(i8* %0)
  %call1 = call i32 @XXH_swap32(i32 %call)
  ret i32 %call1
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH64(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH64_endian_align(i8* %0, i64 %1, i64 %2, i32 1)
  ret i64 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH64_endian_align(i8* %input, i64 %len, i64 %seed, i32 %align) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h64 = alloca i64, align 8
  %limit = alloca i8*, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  store i32 %align, i32* %align.addr, align 4, !tbaa !12
  %0 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !4
  %3 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp uge i64 %4, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #11
  %6 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %add.ptr1 = getelementptr inbounds i8, i8* %6, i64 -32
  store i8* %add.ptr1, i8** %limit, align 8, !tbaa !4
  %7 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #11
  %8 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 %8, -7046029288634856825
  %add2 = add i64 %add, -4417276706812531889
  store i64 %add2, i64* %v1, align 8, !tbaa !22
  %9 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #11
  %10 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add3 = add i64 %10, -4417276706812531889
  store i64 %add3, i64* %v2, align 8, !tbaa !22
  %11 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #11
  %12 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add4 = add i64 %12, 0
  store i64 %add4, i64* %v3, align 8, !tbaa !22
  %13 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #11
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 %14, -7046029288634856825
  store i64 %sub, i64* %v4, align 8, !tbaa !22
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %15 = load i64, i64* %v1, align 8, !tbaa !22
  %16 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %17 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call = call i64 @XXH_readLE64_align(i8* %16, i32 %17)
  %call5 = call i64 @XXH64_round(i64 %15, i64 %call)
  store i64 %call5, i64* %v1, align 8, !tbaa !22
  %18 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr6 = getelementptr inbounds i8, i8* %18, i64 8
  store i8* %add.ptr6, i8** %input.addr, align 8, !tbaa !4
  %19 = load i64, i64* %v2, align 8, !tbaa !22
  %20 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %21 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call7 = call i64 @XXH_readLE64_align(i8* %20, i32 %21)
  %call8 = call i64 @XXH64_round(i64 %19, i64 %call7)
  store i64 %call8, i64* %v2, align 8, !tbaa !22
  %22 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr9 = getelementptr inbounds i8, i8* %22, i64 8
  store i8* %add.ptr9, i8** %input.addr, align 8, !tbaa !4
  %23 = load i64, i64* %v3, align 8, !tbaa !22
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %25 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call10 = call i64 @XXH_readLE64_align(i8* %24, i32 %25)
  %call11 = call i64 @XXH64_round(i64 %23, i64 %call10)
  store i64 %call11, i64* %v3, align 8, !tbaa !22
  %26 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr12 = getelementptr inbounds i8, i8* %26, i64 8
  store i8* %add.ptr12, i8** %input.addr, align 8, !tbaa !4
  %27 = load i64, i64* %v4, align 8, !tbaa !22
  %28 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %29 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call13 = call i64 @XXH_readLE64_align(i8* %28, i32 %29)
  %call14 = call i64 @XXH64_round(i64 %27, i64 %call13)
  store i64 %call14, i64* %v4, align 8, !tbaa !22
  %30 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr15 = getelementptr inbounds i8, i8* %30, i64 8
  store i8* %add.ptr15, i8** %input.addr, align 8, !tbaa !4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %31 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %32 = load i8*, i8** %limit, align 8, !tbaa !4
  %cmp16 = icmp ule i8* %31, %32
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %33 = load i64, i64* %v1, align 8, !tbaa !22
  %34 = call i64 @llvm.fshl.i64(i64 %33, i64 %33, i64 1)
  %35 = load i64, i64* %v2, align 8, !tbaa !22
  %36 = call i64 @llvm.fshl.i64(i64 %35, i64 %35, i64 7)
  %add17 = add i64 %34, %36
  %37 = load i64, i64* %v3, align 8, !tbaa !22
  %38 = call i64 @llvm.fshl.i64(i64 %37, i64 %37, i64 12)
  %add18 = add i64 %add17, %38
  %39 = load i64, i64* %v4, align 8, !tbaa !22
  %40 = call i64 @llvm.fshl.i64(i64 %39, i64 %39, i64 18)
  %add19 = add i64 %add18, %40
  store i64 %add19, i64* %h64, align 8, !tbaa !22
  %41 = load i64, i64* %h64, align 8, !tbaa !22
  %42 = load i64, i64* %v1, align 8, !tbaa !22
  %call20 = call i64 @XXH64_mergeRound(i64 %41, i64 %42)
  store i64 %call20, i64* %h64, align 8, !tbaa !22
  %43 = load i64, i64* %h64, align 8, !tbaa !22
  %44 = load i64, i64* %v2, align 8, !tbaa !22
  %call21 = call i64 @XXH64_mergeRound(i64 %43, i64 %44)
  store i64 %call21, i64* %h64, align 8, !tbaa !22
  %45 = load i64, i64* %h64, align 8, !tbaa !22
  %46 = load i64, i64* %v3, align 8, !tbaa !22
  %call22 = call i64 @XXH64_mergeRound(i64 %45, i64 %46)
  store i64 %call22, i64* %h64, align 8, !tbaa !22
  %47 = load i64, i64* %h64, align 8, !tbaa !22
  %48 = load i64, i64* %v4, align 8, !tbaa !22
  %call23 = call i64 @XXH64_mergeRound(i64 %47, i64 %48)
  store i64 %call23, i64* %h64, align 8, !tbaa !22
  %49 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #11
  %50 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %50) #11
  %51 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %51) #11
  %52 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %52) #11
  %53 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %53) #11
  br label %if.end

if.else:                                          ; preds = %entry
  %54 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add24 = add i64 %54, 2870177450012600261
  store i64 %add24, i64* %h64, align 8, !tbaa !22
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %55 = load i64, i64* %len.addr, align 8, !tbaa !8
  %56 = load i64, i64* %h64, align 8, !tbaa !22
  %add25 = add i64 %56, %55
  store i64 %add25, i64* %h64, align 8, !tbaa !22
  %57 = load i64, i64* %h64, align 8, !tbaa !22
  %58 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %59 = load i64, i64* %len.addr, align 8, !tbaa !8
  %60 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call26 = call i64 @XXH64_finalize(i64 %57, i8* %58, i64 %59, i32 %60)
  %61 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %61) #11
  %62 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %62) #11
  ret i64 %call26
}

; Function Attrs: nounwind ssp uwtable
define %struct.XXH64_state_s* @XXH64_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 88)
  %0 = bitcast i8* %call to %struct.XXH64_state_s*
  ret %struct.XXH64_state_s* %0
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH64_freeState(%struct.XXH64_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !4
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define void @XXH64_copyState(%struct.XXH64_state_s* %dstState, %struct.XXH64_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH64_state_s*, align 8
  %srcState.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %dstState, %struct.XXH64_state_s** %dstState.addr, align 8, !tbaa !4
  store %struct.XXH64_state_s* %srcState, %struct.XXH64_state_s** %srcState.addr, align 8, !tbaa !4
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  %2 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %srcState.addr, align 8, !tbaa !4
  %3 = bitcast %struct.XXH64_state_s* %2 to i8*
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8, !tbaa !4
  %5 = bitcast %struct.XXH64_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 88, i64 %6) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH64_reset(%struct.XXH64_state_s* %statePtr, i64 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %state = alloca %struct.XXH64_state_s, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 88, i8* %0) #11
  %1 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %1, i8 0, i64 88, i1 false)
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 %2, -7046029288634856825
  %add1 = add i64 %add, -4417276706812531889
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 1
  store i64 %add1, i64* %v1, align 8, !tbaa !24
  %3 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add2 = add i64 %3, -4417276706812531889
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 2
  store i64 %add2, i64* %v2, align 8, !tbaa !26
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add3 = add i64 %4, 0
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 3
  store i64 %add3, i64* %v3, align 8, !tbaa !27
  %5 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 %5, -7046029288634856825
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 4
  store i64 %sub, i64* %v4, align 8, !tbaa !28
  %6 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !4
  %7 = bitcast %struct.XXH64_state_s* %6 to i8*
  %8 = bitcast %struct.XXH64_state_s* %state to i8*
  %9 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !4
  %10 = bitcast %struct.XXH64_state_s* %9 to i8*
  %11 = call i64 @llvm.objectsize.i64.p0i8(i8* %10, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %7, i8* %8, i64 80, i64 %11) #11
  %12 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 88, i8* %12) #11
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH64_update(%struct.XXH64_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %limit = alloca i8*, align 8
  %v156 = alloca i64, align 8
  %v258 = alloca i64, align 8
  %v360 = alloca i64, align 8
  %v462 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  store i8* %2, i8** %p, align 8, !tbaa !4
  %3 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i8*, i8** %p, align 8, !tbaa !4
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %5
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !4
  %6 = load i64, i64* %len.addr, align 8, !tbaa !8
  %7 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %7, i32 0, i32 0
  %8 = load i64, i64* %total_len, align 8, !tbaa !29
  %add = add i64 %8, %6
  store i64 %add, i64* %total_len, align 8, !tbaa !29
  %9 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %9, i32 0, i32 6
  %10 = load i32, i32* %memsize, align 8, !tbaa !30
  %conv = zext i32 %10 to i64
  %11 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add1 = add i64 %conv, %11
  %cmp2 = icmp ult i64 %add1, 32
  br i1 %cmp2, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %12 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %12, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %13 = bitcast i64* %arraydecay to i8*
  %14 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize5 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %14, i32 0, i32 6
  %15 = load i32, i32* %memsize5, align 8, !tbaa !30
  %idx.ext = zext i32 %15 to i64
  %add.ptr6 = getelementptr inbounds i8, i8* %13, i64 %idx.ext
  %16 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %17 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call i8* @XXH_memcpy(i8* %add.ptr6, i8* %16, i64 %17)
  %18 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv7 = trunc i64 %18 to i32
  %19 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize8 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %19, i32 0, i32 6
  %20 = load i32, i32* %memsize8, align 8, !tbaa !30
  %add9 = add i32 %20, %conv7
  store i32 %add9, i32* %memsize8, align 8, !tbaa !30
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end10:                                         ; preds = %if.end
  %21 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %21, i32 0, i32 6
  %22 = load i32, i32* %memsize11, align 8, !tbaa !30
  %tobool = icmp ne i32 %22, 0
  br i1 %tobool, label %if.then12, label %if.end50

if.then12:                                        ; preds = %if.end10
  %23 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem6413 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %23, i32 0, i32 5
  %arraydecay14 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6413, i32 0, i32 0
  %24 = bitcast i64* %arraydecay14 to i8*
  %25 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize15 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %25, i32 0, i32 6
  %26 = load i32, i32* %memsize15, align 8, !tbaa !30
  %idx.ext16 = zext i32 %26 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %24, i64 %idx.ext16
  %27 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %28 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize18 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %28, i32 0, i32 6
  %29 = load i32, i32* %memsize18, align 8, !tbaa !30
  %sub = sub i32 32, %29
  %conv19 = zext i32 %sub to i64
  %call20 = call i8* @XXH_memcpy(i8* %add.ptr17, i8* %27, i64 %conv19)
  %30 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %30, i32 0, i32 1
  %31 = load i64, i64* %v1, align 8, !tbaa !24
  %32 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem6421 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %32, i32 0, i32 5
  %arraydecay22 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6421, i32 0, i32 0
  %add.ptr23 = getelementptr inbounds i64, i64* %arraydecay22, i64 0
  %33 = bitcast i64* %add.ptr23 to i8*
  %call24 = call i64 @XXH_readLE64(i8* %33)
  %call25 = call i64 @XXH64_round(i64 %31, i64 %call24)
  %34 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v126 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %34, i32 0, i32 1
  store i64 %call25, i64* %v126, align 8, !tbaa !24
  %35 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %35, i32 0, i32 2
  %36 = load i64, i64* %v2, align 8, !tbaa !26
  %37 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem6427 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %37, i32 0, i32 5
  %arraydecay28 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6427, i32 0, i32 0
  %add.ptr29 = getelementptr inbounds i64, i64* %arraydecay28, i64 1
  %38 = bitcast i64* %add.ptr29 to i8*
  %call30 = call i64 @XXH_readLE64(i8* %38)
  %call31 = call i64 @XXH64_round(i64 %36, i64 %call30)
  %39 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v232 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %39, i32 0, i32 2
  store i64 %call31, i64* %v232, align 8, !tbaa !26
  %40 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %40, i32 0, i32 3
  %41 = load i64, i64* %v3, align 8, !tbaa !27
  %42 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem6433 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %42, i32 0, i32 5
  %arraydecay34 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6433, i32 0, i32 0
  %add.ptr35 = getelementptr inbounds i64, i64* %arraydecay34, i64 2
  %43 = bitcast i64* %add.ptr35 to i8*
  %call36 = call i64 @XXH_readLE64(i8* %43)
  %call37 = call i64 @XXH64_round(i64 %41, i64 %call36)
  %44 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v338 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %44, i32 0, i32 3
  store i64 %call37, i64* %v338, align 8, !tbaa !27
  %45 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %45, i32 0, i32 4
  %46 = load i64, i64* %v4, align 8, !tbaa !28
  %47 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem6439 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %47, i32 0, i32 5
  %arraydecay40 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6439, i32 0, i32 0
  %add.ptr41 = getelementptr inbounds i64, i64* %arraydecay40, i64 3
  %48 = bitcast i64* %add.ptr41 to i8*
  %call42 = call i64 @XXH_readLE64(i8* %48)
  %call43 = call i64 @XXH64_round(i64 %46, i64 %call42)
  %49 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v444 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %49, i32 0, i32 4
  store i64 %call43, i64* %v444, align 8, !tbaa !28
  %50 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize45 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %50, i32 0, i32 6
  %51 = load i32, i32* %memsize45, align 8, !tbaa !30
  %sub46 = sub i32 32, %51
  %52 = load i8*, i8** %p, align 8, !tbaa !4
  %idx.ext47 = zext i32 %sub46 to i64
  %add.ptr48 = getelementptr inbounds i8, i8* %52, i64 %idx.ext47
  store i8* %add.ptr48, i8** %p, align 8, !tbaa !4
  %53 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize49 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %53, i32 0, i32 6
  store i32 0, i32* %memsize49, align 8, !tbaa !30
  br label %if.end50

if.end50:                                         ; preds = %if.then12, %if.end10
  %54 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr51 = getelementptr inbounds i8, i8* %54, i64 32
  %55 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %cmp52 = icmp ule i8* %add.ptr51, %55
  br i1 %cmp52, label %if.then54, label %if.end82

if.then54:                                        ; preds = %if.end50
  %56 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %56) #11
  %57 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %add.ptr55 = getelementptr inbounds i8, i8* %57, i64 -32
  store i8* %add.ptr55, i8** %limit, align 8, !tbaa !4
  %58 = bitcast i64* %v156 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %58) #11
  %59 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v157 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %59, i32 0, i32 1
  %60 = load i64, i64* %v157, align 8, !tbaa !24
  store i64 %60, i64* %v156, align 8, !tbaa !22
  %61 = bitcast i64* %v258 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %61) #11
  %62 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v259 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %62, i32 0, i32 2
  %63 = load i64, i64* %v259, align 8, !tbaa !26
  store i64 %63, i64* %v258, align 8, !tbaa !22
  %64 = bitcast i64* %v360 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %64) #11
  %65 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v361 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %65, i32 0, i32 3
  %66 = load i64, i64* %v361, align 8, !tbaa !27
  store i64 %66, i64* %v360, align 8, !tbaa !22
  %67 = bitcast i64* %v462 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %67) #11
  %68 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v463 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %68, i32 0, i32 4
  %69 = load i64, i64* %v463, align 8, !tbaa !28
  store i64 %69, i64* %v462, align 8, !tbaa !22
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then54
  %70 = load i64, i64* %v156, align 8, !tbaa !22
  %71 = load i8*, i8** %p, align 8, !tbaa !4
  %call64 = call i64 @XXH_readLE64(i8* %71)
  %call65 = call i64 @XXH64_round(i64 %70, i64 %call64)
  store i64 %call65, i64* %v156, align 8, !tbaa !22
  %72 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr66 = getelementptr inbounds i8, i8* %72, i64 8
  store i8* %add.ptr66, i8** %p, align 8, !tbaa !4
  %73 = load i64, i64* %v258, align 8, !tbaa !22
  %74 = load i8*, i8** %p, align 8, !tbaa !4
  %call67 = call i64 @XXH_readLE64(i8* %74)
  %call68 = call i64 @XXH64_round(i64 %73, i64 %call67)
  store i64 %call68, i64* %v258, align 8, !tbaa !22
  %75 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr69 = getelementptr inbounds i8, i8* %75, i64 8
  store i8* %add.ptr69, i8** %p, align 8, !tbaa !4
  %76 = load i64, i64* %v360, align 8, !tbaa !22
  %77 = load i8*, i8** %p, align 8, !tbaa !4
  %call70 = call i64 @XXH_readLE64(i8* %77)
  %call71 = call i64 @XXH64_round(i64 %76, i64 %call70)
  store i64 %call71, i64* %v360, align 8, !tbaa !22
  %78 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr72 = getelementptr inbounds i8, i8* %78, i64 8
  store i8* %add.ptr72, i8** %p, align 8, !tbaa !4
  %79 = load i64, i64* %v462, align 8, !tbaa !22
  %80 = load i8*, i8** %p, align 8, !tbaa !4
  %call73 = call i64 @XXH_readLE64(i8* %80)
  %call74 = call i64 @XXH64_round(i64 %79, i64 %call73)
  store i64 %call74, i64* %v462, align 8, !tbaa !22
  %81 = load i8*, i8** %p, align 8, !tbaa !4
  %add.ptr75 = getelementptr inbounds i8, i8* %81, i64 8
  store i8* %add.ptr75, i8** %p, align 8, !tbaa !4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %82 = load i8*, i8** %p, align 8, !tbaa !4
  %83 = load i8*, i8** %limit, align 8, !tbaa !4
  %cmp76 = icmp ule i8* %82, %83
  br i1 %cmp76, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %84 = load i64, i64* %v156, align 8, !tbaa !22
  %85 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v178 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %85, i32 0, i32 1
  store i64 %84, i64* %v178, align 8, !tbaa !24
  %86 = load i64, i64* %v258, align 8, !tbaa !22
  %87 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v279 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %87, i32 0, i32 2
  store i64 %86, i64* %v279, align 8, !tbaa !26
  %88 = load i64, i64* %v360, align 8, !tbaa !22
  %89 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v380 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %89, i32 0, i32 3
  store i64 %88, i64* %v380, align 8, !tbaa !27
  %90 = load i64, i64* %v462, align 8, !tbaa !22
  %91 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v481 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %91, i32 0, i32 4
  store i64 %90, i64* %v481, align 8, !tbaa !28
  %92 = bitcast i64* %v462 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %92) #11
  %93 = bitcast i64* %v360 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %93) #11
  %94 = bitcast i64* %v258 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %94) #11
  %95 = bitcast i64* %v156 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %95) #11
  %96 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %96) #11
  br label %if.end82

if.end82:                                         ; preds = %do.end, %if.end50
  %97 = load i8*, i8** %p, align 8, !tbaa !4
  %98 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %cmp83 = icmp ult i8* %97, %98
  br i1 %cmp83, label %if.then85, label %if.end94

if.then85:                                        ; preds = %if.end82
  %99 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem6486 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %99, i32 0, i32 5
  %arraydecay87 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6486, i32 0, i32 0
  %100 = bitcast i64* %arraydecay87 to i8*
  %101 = load i8*, i8** %p, align 8, !tbaa !4
  %102 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %103 = load i8*, i8** %p, align 8, !tbaa !4
  %sub.ptr.lhs.cast = ptrtoint i8* %102 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %103 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call88 = call i8* @XXH_memcpy(i8* %100, i8* %101, i64 %sub.ptr.sub)
  %104 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %105 = load i8*, i8** %p, align 8, !tbaa !4
  %sub.ptr.lhs.cast89 = ptrtoint i8* %104 to i64
  %sub.ptr.rhs.cast90 = ptrtoint i8* %105 to i64
  %sub.ptr.sub91 = sub i64 %sub.ptr.lhs.cast89, %sub.ptr.rhs.cast90
  %conv92 = trunc i64 %sub.ptr.sub91 to i32
  %106 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %memsize93 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %106, i32 0, i32 6
  store i32 %conv92, i32* %memsize93, align 8, !tbaa !30
  br label %if.end94

if.end94:                                         ; preds = %if.then85, %if.end82
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end94, %if.then4
  %107 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %107) #11
  %108 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %108) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cleanup.cont, %cleanup, %if.then
  %109 = load i32, i32* %retval, align 4
  ret i32 %109

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_round(i64 %acc, i64 %input) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %input.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8, !tbaa !22
  store i64 %input, i64* %input.addr, align 8, !tbaa !22
  %0 = load i64, i64* %input.addr, align 8, !tbaa !22
  %mul = mul i64 %0, -4417276706812531889
  %1 = load i64, i64* %acc.addr, align 8, !tbaa !22
  %add = add i64 %1, %mul
  store i64 %add, i64* %acc.addr, align 8, !tbaa !22
  %2 = load i64, i64* %acc.addr, align 8, !tbaa !22
  %3 = call i64 @llvm.fshl.i64(i64 %2, i64 %2, i64 31)
  store i64 %3, i64* %acc.addr, align 8, !tbaa !22
  %4 = load i64, i64* %acc.addr, align 8, !tbaa !22
  %mul1 = mul i64 %4, -7046029288634856825
  store i64 %mul1, i64* %acc.addr, align 8, !tbaa !22
  %5 = load i64, i64* %acc.addr, align 8, !tbaa !22
  ret i64 %5
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH_readLE64(i8* %ptr) #1 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %call = call i64 @XXH_read64(i8* %0)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH64_digest(%struct.XXH64_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %h64 = alloca i64, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %0 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %1, i32 0, i32 0
  %2 = load i64, i64* %total_len, align 8, !tbaa !29
  %cmp = icmp uge i64 %2, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %4, i32 0, i32 1
  %5 = load i64, i64* %v11, align 8, !tbaa !24
  store i64 %5, i64* %v1, align 8, !tbaa !22
  %6 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %7 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v22 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %7, i32 0, i32 2
  %8 = load i64, i64* %v22, align 8, !tbaa !26
  store i64 %8, i64* %v2, align 8, !tbaa !22
  %9 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #11
  %10 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v33 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %10, i32 0, i32 3
  %11 = load i64, i64* %v33, align 8, !tbaa !27
  store i64 %11, i64* %v3, align 8, !tbaa !22
  %12 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #11
  %13 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v44 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %13, i32 0, i32 4
  %14 = load i64, i64* %v44, align 8, !tbaa !28
  store i64 %14, i64* %v4, align 8, !tbaa !22
  %15 = load i64, i64* %v1, align 8, !tbaa !22
  %16 = call i64 @llvm.fshl.i64(i64 %15, i64 %15, i64 1)
  %17 = load i64, i64* %v2, align 8, !tbaa !22
  %18 = call i64 @llvm.fshl.i64(i64 %17, i64 %17, i64 7)
  %add = add i64 %16, %18
  %19 = load i64, i64* %v3, align 8, !tbaa !22
  %20 = call i64 @llvm.fshl.i64(i64 %19, i64 %19, i64 12)
  %add5 = add i64 %add, %20
  %21 = load i64, i64* %v4, align 8, !tbaa !22
  %22 = call i64 @llvm.fshl.i64(i64 %21, i64 %21, i64 18)
  %add6 = add i64 %add5, %22
  store i64 %add6, i64* %h64, align 8, !tbaa !22
  %23 = load i64, i64* %h64, align 8, !tbaa !22
  %24 = load i64, i64* %v1, align 8, !tbaa !22
  %call = call i64 @XXH64_mergeRound(i64 %23, i64 %24)
  store i64 %call, i64* %h64, align 8, !tbaa !22
  %25 = load i64, i64* %h64, align 8, !tbaa !22
  %26 = load i64, i64* %v2, align 8, !tbaa !22
  %call7 = call i64 @XXH64_mergeRound(i64 %25, i64 %26)
  store i64 %call7, i64* %h64, align 8, !tbaa !22
  %27 = load i64, i64* %h64, align 8, !tbaa !22
  %28 = load i64, i64* %v3, align 8, !tbaa !22
  %call8 = call i64 @XXH64_mergeRound(i64 %27, i64 %28)
  store i64 %call8, i64* %h64, align 8, !tbaa !22
  %29 = load i64, i64* %h64, align 8, !tbaa !22
  %30 = load i64, i64* %v4, align 8, !tbaa !22
  %call9 = call i64 @XXH64_mergeRound(i64 %29, i64 %30)
  store i64 %call9, i64* %h64, align 8, !tbaa !22
  %31 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #11
  %32 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #11
  %33 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %33) #11
  %34 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %34) #11
  br label %if.end

if.else:                                          ; preds = %entry
  %35 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %v310 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %35, i32 0, i32 3
  %36 = load i64, i64* %v310, align 8, !tbaa !27
  %add11 = add i64 %36, 2870177450012600261
  store i64 %add11, i64* %h64, align 8, !tbaa !22
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %37 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %total_len12 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %37, i32 0, i32 0
  %38 = load i64, i64* %total_len12, align 8, !tbaa !29
  %39 = load i64, i64* %h64, align 8, !tbaa !22
  %add13 = add i64 %39, %38
  store i64 %add13, i64* %h64, align 8, !tbaa !22
  %40 = load i64, i64* %h64, align 8, !tbaa !22
  %41 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %41, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %42 = bitcast i64* %arraydecay to i8*
  %43 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !4
  %total_len14 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %43, i32 0, i32 0
  %44 = load i64, i64* %total_len14, align 8, !tbaa !29
  %call15 = call i64 @XXH64_finalize(i64 %40, i8* %42, i64 %44, i32 0)
  %45 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #11
  ret i64 %call15
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.fshl.i64(i64, i64, i64) #3

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_mergeRound(i64 %acc, i64 %val) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8, !tbaa !22
  store i64 %val, i64* %val.addr, align 8, !tbaa !22
  %0 = load i64, i64* %val.addr, align 8, !tbaa !22
  %call = call i64 @XXH64_round(i64 0, i64 %0)
  store i64 %call, i64* %val.addr, align 8, !tbaa !22
  %1 = load i64, i64* %val.addr, align 8, !tbaa !22
  %2 = load i64, i64* %acc.addr, align 8, !tbaa !22
  %xor = xor i64 %2, %1
  store i64 %xor, i64* %acc.addr, align 8, !tbaa !22
  %3 = load i64, i64* %acc.addr, align 8, !tbaa !22
  %mul = mul i64 %3, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %acc.addr, align 8, !tbaa !22
  %4 = load i64, i64* %acc.addr, align 8, !tbaa !22
  ret i64 %4
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_finalize(i64 %h64, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i64, align 8
  %h64.addr = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %k1 = alloca i64, align 8
  %k14 = alloca i64, align 8
  %k114 = alloca i64, align 8
  %k125 = alloca i64, align 8
  %k135 = alloca i64, align 8
  %k145 = alloca i64, align 8
  %k165 = alloca i64, align 8
  %k175 = alloca i64, align 8
  %k185 = alloca i64, align 8
  %k1102 = alloca i64, align 8
  %k1112 = alloca i64, align 8
  %k1122 = alloca i64, align 8
  %k1150 = alloca i64, align 8
  %k1160 = alloca i64, align 8
  %k1170 = alloca i64, align 8
  %k1195 = alloca i64, align 8
  %k1205 = alloca i64, align 8
  %k1215 = alloca i64, align 8
  %k1250 = alloca i64, align 8
  %k1260 = alloca i64, align 8
  %k1270 = alloca i64, align 8
  %k1302 = alloca i64, align 8
  %k1312 = alloca i64, align 8
  %k1322 = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8, !tbaa !22
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i32 %align, i32* %align.addr, align 4, !tbaa !12
  %0 = load i64, i64* %len.addr, align 8, !tbaa !8
  %and = and i64 %0, 31
  switch i64 %and, label %sw.epilog [
    i64 24, label %sw.bb
    i64 16, label %sw.bb2
    i64 8, label %sw.bb12
    i64 28, label %sw.bb23
    i64 20, label %sw.bb33
    i64 12, label %sw.bb43
    i64 4, label %sw.bb53
    i64 25, label %sw.bb63
    i64 17, label %sw.bb73
    i64 9, label %sw.bb83
    i64 29, label %sw.bb100
    i64 21, label %sw.bb110
    i64 13, label %sw.bb120
    i64 5, label %sw.bb130
    i64 26, label %sw.bb148
    i64 18, label %sw.bb158
    i64 10, label %sw.bb168
    i64 30, label %sw.bb193
    i64 22, label %sw.bb203
    i64 14, label %sw.bb213
    i64 6, label %sw.bb223
    i64 27, label %sw.bb248
    i64 19, label %sw.bb258
    i64 11, label %sw.bb268
    i64 31, label %sw.bb300
    i64 23, label %sw.bb310
    i64 15, label %sw.bb320
    i64 7, label %sw.bb330
    i64 3, label %sw.bb340
    i64 2, label %sw.bb348
    i64 1, label %sw.bb356
    i64 0, label %sw.bb364
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = bitcast i64* %k1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %3 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call = call i64 @XXH_readLE64_align(i8* %2, i32 %3)
  %call1 = call i64 @XXH64_round(i64 0, i64 %call)
  store i64 %call1, i64* %k1, align 8, !tbaa !22
  %4 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 8
  store i8* %add.ptr, i8** %ptr.addr, align 8, !tbaa !4
  %5 = load i64, i64* %k1, align 8, !tbaa !22
  %6 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor = xor i64 %6, %5
  store i64 %xor, i64* %h64.addr, align 8, !tbaa !22
  %7 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %8 = call i64 @llvm.fshl.i64(i64 %7, i64 %7, i64 27)
  %mul = mul i64 %8, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %h64.addr, align 8, !tbaa !22
  %9 = bitcast i64* %k1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %10 = bitcast i64* %k14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #11
  %11 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %12 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call5 = call i64 @XXH_readLE64_align(i8* %11, i32 %12)
  %call6 = call i64 @XXH64_round(i64 0, i64 %call5)
  store i64 %call6, i64* %k14, align 8, !tbaa !22
  %13 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr7 = getelementptr inbounds i8, i8* %13, i64 8
  store i8* %add.ptr7, i8** %ptr.addr, align 8, !tbaa !4
  %14 = load i64, i64* %k14, align 8, !tbaa !22
  %15 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor8 = xor i64 %15, %14
  store i64 %xor8, i64* %h64.addr, align 8, !tbaa !22
  %16 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %17 = call i64 @llvm.fshl.i64(i64 %16, i64 %16, i64 27)
  %mul9 = mul i64 %17, -7046029288634856825
  %add10 = add i64 %mul9, -8796714831421723037
  store i64 %add10, i64* %h64.addr, align 8, !tbaa !22
  %18 = bitcast i64* %k14 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #11
  br label %do.end11

do.end11:                                         ; preds = %do.body3
  br label %sw.bb12

sw.bb12:                                          ; preds = %entry, %do.end11
  br label %do.body13

do.body13:                                        ; preds = %sw.bb12
  %19 = bitcast i64* %k114 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %19) #11
  %20 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %21 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call15 = call i64 @XXH_readLE64_align(i8* %20, i32 %21)
  %call16 = call i64 @XXH64_round(i64 0, i64 %call15)
  store i64 %call16, i64* %k114, align 8, !tbaa !22
  %22 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr17 = getelementptr inbounds i8, i8* %22, i64 8
  store i8* %add.ptr17, i8** %ptr.addr, align 8, !tbaa !4
  %23 = load i64, i64* %k114, align 8, !tbaa !22
  %24 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor18 = xor i64 %24, %23
  store i64 %xor18, i64* %h64.addr, align 8, !tbaa !22
  %25 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %26 = call i64 @llvm.fshl.i64(i64 %25, i64 %25, i64 27)
  %mul19 = mul i64 %26, -7046029288634856825
  %add20 = add i64 %mul19, -8796714831421723037
  store i64 %add20, i64* %h64.addr, align 8, !tbaa !22
  %27 = bitcast i64* %k114 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %27) #11
  br label %do.end21

do.end21:                                         ; preds = %do.body13
  %28 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call22 = call i64 @XXH64_avalanche(i64 %28)
  store i64 %call22, i64* %retval, align 8
  br label %return

sw.bb23:                                          ; preds = %entry
  br label %do.body24

do.body24:                                        ; preds = %sw.bb23
  %29 = bitcast i64* %k125 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %29) #11
  %30 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %31 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call26 = call i64 @XXH_readLE64_align(i8* %30, i32 %31)
  %call27 = call i64 @XXH64_round(i64 0, i64 %call26)
  store i64 %call27, i64* %k125, align 8, !tbaa !22
  %32 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr28 = getelementptr inbounds i8, i8* %32, i64 8
  store i8* %add.ptr28, i8** %ptr.addr, align 8, !tbaa !4
  %33 = load i64, i64* %k125, align 8, !tbaa !22
  %34 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor29 = xor i64 %34, %33
  store i64 %xor29, i64* %h64.addr, align 8, !tbaa !22
  %35 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %36 = call i64 @llvm.fshl.i64(i64 %35, i64 %35, i64 27)
  %mul30 = mul i64 %36, -7046029288634856825
  %add31 = add i64 %mul30, -8796714831421723037
  store i64 %add31, i64* %h64.addr, align 8, !tbaa !22
  %37 = bitcast i64* %k125 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %37) #11
  br label %do.end32

do.end32:                                         ; preds = %do.body24
  br label %sw.bb33

sw.bb33:                                          ; preds = %entry, %do.end32
  br label %do.body34

do.body34:                                        ; preds = %sw.bb33
  %38 = bitcast i64* %k135 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %38) #11
  %39 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %40 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call36 = call i64 @XXH_readLE64_align(i8* %39, i32 %40)
  %call37 = call i64 @XXH64_round(i64 0, i64 %call36)
  store i64 %call37, i64* %k135, align 8, !tbaa !22
  %41 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr38 = getelementptr inbounds i8, i8* %41, i64 8
  store i8* %add.ptr38, i8** %ptr.addr, align 8, !tbaa !4
  %42 = load i64, i64* %k135, align 8, !tbaa !22
  %43 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor39 = xor i64 %43, %42
  store i64 %xor39, i64* %h64.addr, align 8, !tbaa !22
  %44 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %45 = call i64 @llvm.fshl.i64(i64 %44, i64 %44, i64 27)
  %mul40 = mul i64 %45, -7046029288634856825
  %add41 = add i64 %mul40, -8796714831421723037
  store i64 %add41, i64* %h64.addr, align 8, !tbaa !22
  %46 = bitcast i64* %k135 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #11
  br label %do.end42

do.end42:                                         ; preds = %do.body34
  br label %sw.bb43

sw.bb43:                                          ; preds = %entry, %do.end42
  br label %do.body44

do.body44:                                        ; preds = %sw.bb43
  %47 = bitcast i64* %k145 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %47) #11
  %48 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %49 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call46 = call i64 @XXH_readLE64_align(i8* %48, i32 %49)
  %call47 = call i64 @XXH64_round(i64 0, i64 %call46)
  store i64 %call47, i64* %k145, align 8, !tbaa !22
  %50 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr48 = getelementptr inbounds i8, i8* %50, i64 8
  store i8* %add.ptr48, i8** %ptr.addr, align 8, !tbaa !4
  %51 = load i64, i64* %k145, align 8, !tbaa !22
  %52 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor49 = xor i64 %52, %51
  store i64 %xor49, i64* %h64.addr, align 8, !tbaa !22
  %53 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %54 = call i64 @llvm.fshl.i64(i64 %53, i64 %53, i64 27)
  %mul50 = mul i64 %54, -7046029288634856825
  %add51 = add i64 %mul50, -8796714831421723037
  store i64 %add51, i64* %h64.addr, align 8, !tbaa !22
  %55 = bitcast i64* %k145 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %55) #11
  br label %do.end52

do.end52:                                         ; preds = %do.body44
  br label %sw.bb53

sw.bb53:                                          ; preds = %entry, %do.end52
  br label %do.body54

do.body54:                                        ; preds = %sw.bb53
  %56 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %57 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call55 = call i32 @XXH_readLE32_align(i8* %56, i32 %57)
  %conv = zext i32 %call55 to i64
  %mul56 = mul i64 %conv, -7046029288634856825
  %58 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor57 = xor i64 %58, %mul56
  store i64 %xor57, i64* %h64.addr, align 8, !tbaa !22
  %59 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr58 = getelementptr inbounds i8, i8* %59, i64 4
  store i8* %add.ptr58, i8** %ptr.addr, align 8, !tbaa !4
  %60 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %61 = call i64 @llvm.fshl.i64(i64 %60, i64 %60, i64 23)
  %mul59 = mul i64 %61, -4417276706812531889
  %add60 = add i64 %mul59, 1609587929392839161
  store i64 %add60, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end61

do.end61:                                         ; preds = %do.body54
  %62 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call62 = call i64 @XXH64_avalanche(i64 %62)
  store i64 %call62, i64* %retval, align 8
  br label %return

sw.bb63:                                          ; preds = %entry
  br label %do.body64

do.body64:                                        ; preds = %sw.bb63
  %63 = bitcast i64* %k165 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %63) #11
  %64 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %65 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call66 = call i64 @XXH_readLE64_align(i8* %64, i32 %65)
  %call67 = call i64 @XXH64_round(i64 0, i64 %call66)
  store i64 %call67, i64* %k165, align 8, !tbaa !22
  %66 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr68 = getelementptr inbounds i8, i8* %66, i64 8
  store i8* %add.ptr68, i8** %ptr.addr, align 8, !tbaa !4
  %67 = load i64, i64* %k165, align 8, !tbaa !22
  %68 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor69 = xor i64 %68, %67
  store i64 %xor69, i64* %h64.addr, align 8, !tbaa !22
  %69 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %70 = call i64 @llvm.fshl.i64(i64 %69, i64 %69, i64 27)
  %mul70 = mul i64 %70, -7046029288634856825
  %add71 = add i64 %mul70, -8796714831421723037
  store i64 %add71, i64* %h64.addr, align 8, !tbaa !22
  %71 = bitcast i64* %k165 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #11
  br label %do.end72

do.end72:                                         ; preds = %do.body64
  br label %sw.bb73

sw.bb73:                                          ; preds = %entry, %do.end72
  br label %do.body74

do.body74:                                        ; preds = %sw.bb73
  %72 = bitcast i64* %k175 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %72) #11
  %73 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %74 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call76 = call i64 @XXH_readLE64_align(i8* %73, i32 %74)
  %call77 = call i64 @XXH64_round(i64 0, i64 %call76)
  store i64 %call77, i64* %k175, align 8, !tbaa !22
  %75 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr78 = getelementptr inbounds i8, i8* %75, i64 8
  store i8* %add.ptr78, i8** %ptr.addr, align 8, !tbaa !4
  %76 = load i64, i64* %k175, align 8, !tbaa !22
  %77 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor79 = xor i64 %77, %76
  store i64 %xor79, i64* %h64.addr, align 8, !tbaa !22
  %78 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %79 = call i64 @llvm.fshl.i64(i64 %78, i64 %78, i64 27)
  %mul80 = mul i64 %79, -7046029288634856825
  %add81 = add i64 %mul80, -8796714831421723037
  store i64 %add81, i64* %h64.addr, align 8, !tbaa !22
  %80 = bitcast i64* %k175 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %80) #11
  br label %do.end82

do.end82:                                         ; preds = %do.body74
  br label %sw.bb83

sw.bb83:                                          ; preds = %entry, %do.end82
  br label %do.body84

do.body84:                                        ; preds = %sw.bb83
  %81 = bitcast i64* %k185 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %81) #11
  %82 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %83 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call86 = call i64 @XXH_readLE64_align(i8* %82, i32 %83)
  %call87 = call i64 @XXH64_round(i64 0, i64 %call86)
  store i64 %call87, i64* %k185, align 8, !tbaa !22
  %84 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr88 = getelementptr inbounds i8, i8* %84, i64 8
  store i8* %add.ptr88, i8** %ptr.addr, align 8, !tbaa !4
  %85 = load i64, i64* %k185, align 8, !tbaa !22
  %86 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor89 = xor i64 %86, %85
  store i64 %xor89, i64* %h64.addr, align 8, !tbaa !22
  %87 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %88 = call i64 @llvm.fshl.i64(i64 %87, i64 %87, i64 27)
  %mul90 = mul i64 %88, -7046029288634856825
  %add91 = add i64 %mul90, -8796714831421723037
  store i64 %add91, i64* %h64.addr, align 8, !tbaa !22
  %89 = bitcast i64* %k185 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %89) #11
  br label %do.end92

do.end92:                                         ; preds = %do.body84
  br label %do.body93

do.body93:                                        ; preds = %do.end92
  %90 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr = getelementptr inbounds i8, i8* %90, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8, !tbaa !4
  %91 = load i8, i8* %90, align 1, !tbaa !12
  %conv94 = zext i8 %91 to i64
  %mul95 = mul i64 %conv94, 2870177450012600261
  %92 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor96 = xor i64 %92, %mul95
  store i64 %xor96, i64* %h64.addr, align 8, !tbaa !22
  %93 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %94 = call i64 @llvm.fshl.i64(i64 %93, i64 %93, i64 11)
  %mul97 = mul i64 %94, -7046029288634856825
  store i64 %mul97, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end98

do.end98:                                         ; preds = %do.body93
  %95 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call99 = call i64 @XXH64_avalanche(i64 %95)
  store i64 %call99, i64* %retval, align 8
  br label %return

sw.bb100:                                         ; preds = %entry
  br label %do.body101

do.body101:                                       ; preds = %sw.bb100
  %96 = bitcast i64* %k1102 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %96) #11
  %97 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %98 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call103 = call i64 @XXH_readLE64_align(i8* %97, i32 %98)
  %call104 = call i64 @XXH64_round(i64 0, i64 %call103)
  store i64 %call104, i64* %k1102, align 8, !tbaa !22
  %99 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr105 = getelementptr inbounds i8, i8* %99, i64 8
  store i8* %add.ptr105, i8** %ptr.addr, align 8, !tbaa !4
  %100 = load i64, i64* %k1102, align 8, !tbaa !22
  %101 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor106 = xor i64 %101, %100
  store i64 %xor106, i64* %h64.addr, align 8, !tbaa !22
  %102 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %103 = call i64 @llvm.fshl.i64(i64 %102, i64 %102, i64 27)
  %mul107 = mul i64 %103, -7046029288634856825
  %add108 = add i64 %mul107, -8796714831421723037
  store i64 %add108, i64* %h64.addr, align 8, !tbaa !22
  %104 = bitcast i64* %k1102 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %104) #11
  br label %do.end109

do.end109:                                        ; preds = %do.body101
  br label %sw.bb110

sw.bb110:                                         ; preds = %entry, %do.end109
  br label %do.body111

do.body111:                                       ; preds = %sw.bb110
  %105 = bitcast i64* %k1112 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %105) #11
  %106 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %107 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call113 = call i64 @XXH_readLE64_align(i8* %106, i32 %107)
  %call114 = call i64 @XXH64_round(i64 0, i64 %call113)
  store i64 %call114, i64* %k1112, align 8, !tbaa !22
  %108 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr115 = getelementptr inbounds i8, i8* %108, i64 8
  store i8* %add.ptr115, i8** %ptr.addr, align 8, !tbaa !4
  %109 = load i64, i64* %k1112, align 8, !tbaa !22
  %110 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor116 = xor i64 %110, %109
  store i64 %xor116, i64* %h64.addr, align 8, !tbaa !22
  %111 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %112 = call i64 @llvm.fshl.i64(i64 %111, i64 %111, i64 27)
  %mul117 = mul i64 %112, -7046029288634856825
  %add118 = add i64 %mul117, -8796714831421723037
  store i64 %add118, i64* %h64.addr, align 8, !tbaa !22
  %113 = bitcast i64* %k1112 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %113) #11
  br label %do.end119

do.end119:                                        ; preds = %do.body111
  br label %sw.bb120

sw.bb120:                                         ; preds = %entry, %do.end119
  br label %do.body121

do.body121:                                       ; preds = %sw.bb120
  %114 = bitcast i64* %k1122 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %114) #11
  %115 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %116 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call123 = call i64 @XXH_readLE64_align(i8* %115, i32 %116)
  %call124 = call i64 @XXH64_round(i64 0, i64 %call123)
  store i64 %call124, i64* %k1122, align 8, !tbaa !22
  %117 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr125 = getelementptr inbounds i8, i8* %117, i64 8
  store i8* %add.ptr125, i8** %ptr.addr, align 8, !tbaa !4
  %118 = load i64, i64* %k1122, align 8, !tbaa !22
  %119 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor126 = xor i64 %119, %118
  store i64 %xor126, i64* %h64.addr, align 8, !tbaa !22
  %120 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %121 = call i64 @llvm.fshl.i64(i64 %120, i64 %120, i64 27)
  %mul127 = mul i64 %121, -7046029288634856825
  %add128 = add i64 %mul127, -8796714831421723037
  store i64 %add128, i64* %h64.addr, align 8, !tbaa !22
  %122 = bitcast i64* %k1122 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %122) #11
  br label %do.end129

do.end129:                                        ; preds = %do.body121
  br label %sw.bb130

sw.bb130:                                         ; preds = %entry, %do.end129
  br label %do.body131

do.body131:                                       ; preds = %sw.bb130
  %123 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %124 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call132 = call i32 @XXH_readLE32_align(i8* %123, i32 %124)
  %conv133 = zext i32 %call132 to i64
  %mul134 = mul i64 %conv133, -7046029288634856825
  %125 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor135 = xor i64 %125, %mul134
  store i64 %xor135, i64* %h64.addr, align 8, !tbaa !22
  %126 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr136 = getelementptr inbounds i8, i8* %126, i64 4
  store i8* %add.ptr136, i8** %ptr.addr, align 8, !tbaa !4
  %127 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %128 = call i64 @llvm.fshl.i64(i64 %127, i64 %127, i64 23)
  %mul137 = mul i64 %128, -4417276706812531889
  %add138 = add i64 %mul137, 1609587929392839161
  store i64 %add138, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end139

do.end139:                                        ; preds = %do.body131
  br label %do.body140

do.body140:                                       ; preds = %do.end139
  %129 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr141 = getelementptr inbounds i8, i8* %129, i32 1
  store i8* %incdec.ptr141, i8** %ptr.addr, align 8, !tbaa !4
  %130 = load i8, i8* %129, align 1, !tbaa !12
  %conv142 = zext i8 %130 to i64
  %mul143 = mul i64 %conv142, 2870177450012600261
  %131 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor144 = xor i64 %131, %mul143
  store i64 %xor144, i64* %h64.addr, align 8, !tbaa !22
  %132 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %133 = call i64 @llvm.fshl.i64(i64 %132, i64 %132, i64 11)
  %mul145 = mul i64 %133, -7046029288634856825
  store i64 %mul145, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end146

do.end146:                                        ; preds = %do.body140
  %134 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call147 = call i64 @XXH64_avalanche(i64 %134)
  store i64 %call147, i64* %retval, align 8
  br label %return

sw.bb148:                                         ; preds = %entry
  br label %do.body149

do.body149:                                       ; preds = %sw.bb148
  %135 = bitcast i64* %k1150 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %135) #11
  %136 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %137 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call151 = call i64 @XXH_readLE64_align(i8* %136, i32 %137)
  %call152 = call i64 @XXH64_round(i64 0, i64 %call151)
  store i64 %call152, i64* %k1150, align 8, !tbaa !22
  %138 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr153 = getelementptr inbounds i8, i8* %138, i64 8
  store i8* %add.ptr153, i8** %ptr.addr, align 8, !tbaa !4
  %139 = load i64, i64* %k1150, align 8, !tbaa !22
  %140 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor154 = xor i64 %140, %139
  store i64 %xor154, i64* %h64.addr, align 8, !tbaa !22
  %141 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %142 = call i64 @llvm.fshl.i64(i64 %141, i64 %141, i64 27)
  %mul155 = mul i64 %142, -7046029288634856825
  %add156 = add i64 %mul155, -8796714831421723037
  store i64 %add156, i64* %h64.addr, align 8, !tbaa !22
  %143 = bitcast i64* %k1150 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %143) #11
  br label %do.end157

do.end157:                                        ; preds = %do.body149
  br label %sw.bb158

sw.bb158:                                         ; preds = %entry, %do.end157
  br label %do.body159

do.body159:                                       ; preds = %sw.bb158
  %144 = bitcast i64* %k1160 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %144) #11
  %145 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %146 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call161 = call i64 @XXH_readLE64_align(i8* %145, i32 %146)
  %call162 = call i64 @XXH64_round(i64 0, i64 %call161)
  store i64 %call162, i64* %k1160, align 8, !tbaa !22
  %147 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr163 = getelementptr inbounds i8, i8* %147, i64 8
  store i8* %add.ptr163, i8** %ptr.addr, align 8, !tbaa !4
  %148 = load i64, i64* %k1160, align 8, !tbaa !22
  %149 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor164 = xor i64 %149, %148
  store i64 %xor164, i64* %h64.addr, align 8, !tbaa !22
  %150 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %151 = call i64 @llvm.fshl.i64(i64 %150, i64 %150, i64 27)
  %mul165 = mul i64 %151, -7046029288634856825
  %add166 = add i64 %mul165, -8796714831421723037
  store i64 %add166, i64* %h64.addr, align 8, !tbaa !22
  %152 = bitcast i64* %k1160 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %152) #11
  br label %do.end167

do.end167:                                        ; preds = %do.body159
  br label %sw.bb168

sw.bb168:                                         ; preds = %entry, %do.end167
  br label %do.body169

do.body169:                                       ; preds = %sw.bb168
  %153 = bitcast i64* %k1170 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %153) #11
  %154 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %155 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call171 = call i64 @XXH_readLE64_align(i8* %154, i32 %155)
  %call172 = call i64 @XXH64_round(i64 0, i64 %call171)
  store i64 %call172, i64* %k1170, align 8, !tbaa !22
  %156 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr173 = getelementptr inbounds i8, i8* %156, i64 8
  store i8* %add.ptr173, i8** %ptr.addr, align 8, !tbaa !4
  %157 = load i64, i64* %k1170, align 8, !tbaa !22
  %158 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor174 = xor i64 %158, %157
  store i64 %xor174, i64* %h64.addr, align 8, !tbaa !22
  %159 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %160 = call i64 @llvm.fshl.i64(i64 %159, i64 %159, i64 27)
  %mul175 = mul i64 %160, -7046029288634856825
  %add176 = add i64 %mul175, -8796714831421723037
  store i64 %add176, i64* %h64.addr, align 8, !tbaa !22
  %161 = bitcast i64* %k1170 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %161) #11
  br label %do.end177

do.end177:                                        ; preds = %do.body169
  br label %do.body178

do.body178:                                       ; preds = %do.end177
  %162 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr179 = getelementptr inbounds i8, i8* %162, i32 1
  store i8* %incdec.ptr179, i8** %ptr.addr, align 8, !tbaa !4
  %163 = load i8, i8* %162, align 1, !tbaa !12
  %conv180 = zext i8 %163 to i64
  %mul181 = mul i64 %conv180, 2870177450012600261
  %164 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor182 = xor i64 %164, %mul181
  store i64 %xor182, i64* %h64.addr, align 8, !tbaa !22
  %165 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %166 = call i64 @llvm.fshl.i64(i64 %165, i64 %165, i64 11)
  %mul183 = mul i64 %166, -7046029288634856825
  store i64 %mul183, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end184

do.end184:                                        ; preds = %do.body178
  br label %do.body185

do.body185:                                       ; preds = %do.end184
  %167 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr186 = getelementptr inbounds i8, i8* %167, i32 1
  store i8* %incdec.ptr186, i8** %ptr.addr, align 8, !tbaa !4
  %168 = load i8, i8* %167, align 1, !tbaa !12
  %conv187 = zext i8 %168 to i64
  %mul188 = mul i64 %conv187, 2870177450012600261
  %169 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor189 = xor i64 %169, %mul188
  store i64 %xor189, i64* %h64.addr, align 8, !tbaa !22
  %170 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %171 = call i64 @llvm.fshl.i64(i64 %170, i64 %170, i64 11)
  %mul190 = mul i64 %171, -7046029288634856825
  store i64 %mul190, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end191

do.end191:                                        ; preds = %do.body185
  %172 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call192 = call i64 @XXH64_avalanche(i64 %172)
  store i64 %call192, i64* %retval, align 8
  br label %return

sw.bb193:                                         ; preds = %entry
  br label %do.body194

do.body194:                                       ; preds = %sw.bb193
  %173 = bitcast i64* %k1195 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %173) #11
  %174 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %175 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call196 = call i64 @XXH_readLE64_align(i8* %174, i32 %175)
  %call197 = call i64 @XXH64_round(i64 0, i64 %call196)
  store i64 %call197, i64* %k1195, align 8, !tbaa !22
  %176 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr198 = getelementptr inbounds i8, i8* %176, i64 8
  store i8* %add.ptr198, i8** %ptr.addr, align 8, !tbaa !4
  %177 = load i64, i64* %k1195, align 8, !tbaa !22
  %178 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor199 = xor i64 %178, %177
  store i64 %xor199, i64* %h64.addr, align 8, !tbaa !22
  %179 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %180 = call i64 @llvm.fshl.i64(i64 %179, i64 %179, i64 27)
  %mul200 = mul i64 %180, -7046029288634856825
  %add201 = add i64 %mul200, -8796714831421723037
  store i64 %add201, i64* %h64.addr, align 8, !tbaa !22
  %181 = bitcast i64* %k1195 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %181) #11
  br label %do.end202

do.end202:                                        ; preds = %do.body194
  br label %sw.bb203

sw.bb203:                                         ; preds = %entry, %do.end202
  br label %do.body204

do.body204:                                       ; preds = %sw.bb203
  %182 = bitcast i64* %k1205 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %182) #11
  %183 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %184 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call206 = call i64 @XXH_readLE64_align(i8* %183, i32 %184)
  %call207 = call i64 @XXH64_round(i64 0, i64 %call206)
  store i64 %call207, i64* %k1205, align 8, !tbaa !22
  %185 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr208 = getelementptr inbounds i8, i8* %185, i64 8
  store i8* %add.ptr208, i8** %ptr.addr, align 8, !tbaa !4
  %186 = load i64, i64* %k1205, align 8, !tbaa !22
  %187 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor209 = xor i64 %187, %186
  store i64 %xor209, i64* %h64.addr, align 8, !tbaa !22
  %188 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %189 = call i64 @llvm.fshl.i64(i64 %188, i64 %188, i64 27)
  %mul210 = mul i64 %189, -7046029288634856825
  %add211 = add i64 %mul210, -8796714831421723037
  store i64 %add211, i64* %h64.addr, align 8, !tbaa !22
  %190 = bitcast i64* %k1205 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %190) #11
  br label %do.end212

do.end212:                                        ; preds = %do.body204
  br label %sw.bb213

sw.bb213:                                         ; preds = %entry, %do.end212
  br label %do.body214

do.body214:                                       ; preds = %sw.bb213
  %191 = bitcast i64* %k1215 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %191) #11
  %192 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %193 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call216 = call i64 @XXH_readLE64_align(i8* %192, i32 %193)
  %call217 = call i64 @XXH64_round(i64 0, i64 %call216)
  store i64 %call217, i64* %k1215, align 8, !tbaa !22
  %194 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr218 = getelementptr inbounds i8, i8* %194, i64 8
  store i8* %add.ptr218, i8** %ptr.addr, align 8, !tbaa !4
  %195 = load i64, i64* %k1215, align 8, !tbaa !22
  %196 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor219 = xor i64 %196, %195
  store i64 %xor219, i64* %h64.addr, align 8, !tbaa !22
  %197 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %198 = call i64 @llvm.fshl.i64(i64 %197, i64 %197, i64 27)
  %mul220 = mul i64 %198, -7046029288634856825
  %add221 = add i64 %mul220, -8796714831421723037
  store i64 %add221, i64* %h64.addr, align 8, !tbaa !22
  %199 = bitcast i64* %k1215 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %199) #11
  br label %do.end222

do.end222:                                        ; preds = %do.body214
  br label %sw.bb223

sw.bb223:                                         ; preds = %entry, %do.end222
  br label %do.body224

do.body224:                                       ; preds = %sw.bb223
  %200 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %201 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call225 = call i32 @XXH_readLE32_align(i8* %200, i32 %201)
  %conv226 = zext i32 %call225 to i64
  %mul227 = mul i64 %conv226, -7046029288634856825
  %202 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor228 = xor i64 %202, %mul227
  store i64 %xor228, i64* %h64.addr, align 8, !tbaa !22
  %203 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr229 = getelementptr inbounds i8, i8* %203, i64 4
  store i8* %add.ptr229, i8** %ptr.addr, align 8, !tbaa !4
  %204 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %205 = call i64 @llvm.fshl.i64(i64 %204, i64 %204, i64 23)
  %mul230 = mul i64 %205, -4417276706812531889
  %add231 = add i64 %mul230, 1609587929392839161
  store i64 %add231, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end232

do.end232:                                        ; preds = %do.body224
  br label %do.body233

do.body233:                                       ; preds = %do.end232
  %206 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr234 = getelementptr inbounds i8, i8* %206, i32 1
  store i8* %incdec.ptr234, i8** %ptr.addr, align 8, !tbaa !4
  %207 = load i8, i8* %206, align 1, !tbaa !12
  %conv235 = zext i8 %207 to i64
  %mul236 = mul i64 %conv235, 2870177450012600261
  %208 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor237 = xor i64 %208, %mul236
  store i64 %xor237, i64* %h64.addr, align 8, !tbaa !22
  %209 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %210 = call i64 @llvm.fshl.i64(i64 %209, i64 %209, i64 11)
  %mul238 = mul i64 %210, -7046029288634856825
  store i64 %mul238, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end239

do.end239:                                        ; preds = %do.body233
  br label %do.body240

do.body240:                                       ; preds = %do.end239
  %211 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr241 = getelementptr inbounds i8, i8* %211, i32 1
  store i8* %incdec.ptr241, i8** %ptr.addr, align 8, !tbaa !4
  %212 = load i8, i8* %211, align 1, !tbaa !12
  %conv242 = zext i8 %212 to i64
  %mul243 = mul i64 %conv242, 2870177450012600261
  %213 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor244 = xor i64 %213, %mul243
  store i64 %xor244, i64* %h64.addr, align 8, !tbaa !22
  %214 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %215 = call i64 @llvm.fshl.i64(i64 %214, i64 %214, i64 11)
  %mul245 = mul i64 %215, -7046029288634856825
  store i64 %mul245, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end246

do.end246:                                        ; preds = %do.body240
  %216 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call247 = call i64 @XXH64_avalanche(i64 %216)
  store i64 %call247, i64* %retval, align 8
  br label %return

sw.bb248:                                         ; preds = %entry
  br label %do.body249

do.body249:                                       ; preds = %sw.bb248
  %217 = bitcast i64* %k1250 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %217) #11
  %218 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %219 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call251 = call i64 @XXH_readLE64_align(i8* %218, i32 %219)
  %call252 = call i64 @XXH64_round(i64 0, i64 %call251)
  store i64 %call252, i64* %k1250, align 8, !tbaa !22
  %220 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr253 = getelementptr inbounds i8, i8* %220, i64 8
  store i8* %add.ptr253, i8** %ptr.addr, align 8, !tbaa !4
  %221 = load i64, i64* %k1250, align 8, !tbaa !22
  %222 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor254 = xor i64 %222, %221
  store i64 %xor254, i64* %h64.addr, align 8, !tbaa !22
  %223 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %224 = call i64 @llvm.fshl.i64(i64 %223, i64 %223, i64 27)
  %mul255 = mul i64 %224, -7046029288634856825
  %add256 = add i64 %mul255, -8796714831421723037
  store i64 %add256, i64* %h64.addr, align 8, !tbaa !22
  %225 = bitcast i64* %k1250 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %225) #11
  br label %do.end257

do.end257:                                        ; preds = %do.body249
  br label %sw.bb258

sw.bb258:                                         ; preds = %entry, %do.end257
  br label %do.body259

do.body259:                                       ; preds = %sw.bb258
  %226 = bitcast i64* %k1260 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %226) #11
  %227 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %228 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call261 = call i64 @XXH_readLE64_align(i8* %227, i32 %228)
  %call262 = call i64 @XXH64_round(i64 0, i64 %call261)
  store i64 %call262, i64* %k1260, align 8, !tbaa !22
  %229 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr263 = getelementptr inbounds i8, i8* %229, i64 8
  store i8* %add.ptr263, i8** %ptr.addr, align 8, !tbaa !4
  %230 = load i64, i64* %k1260, align 8, !tbaa !22
  %231 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor264 = xor i64 %231, %230
  store i64 %xor264, i64* %h64.addr, align 8, !tbaa !22
  %232 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %233 = call i64 @llvm.fshl.i64(i64 %232, i64 %232, i64 27)
  %mul265 = mul i64 %233, -7046029288634856825
  %add266 = add i64 %mul265, -8796714831421723037
  store i64 %add266, i64* %h64.addr, align 8, !tbaa !22
  %234 = bitcast i64* %k1260 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %234) #11
  br label %do.end267

do.end267:                                        ; preds = %do.body259
  br label %sw.bb268

sw.bb268:                                         ; preds = %entry, %do.end267
  br label %do.body269

do.body269:                                       ; preds = %sw.bb268
  %235 = bitcast i64* %k1270 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %235) #11
  %236 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %237 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call271 = call i64 @XXH_readLE64_align(i8* %236, i32 %237)
  %call272 = call i64 @XXH64_round(i64 0, i64 %call271)
  store i64 %call272, i64* %k1270, align 8, !tbaa !22
  %238 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr273 = getelementptr inbounds i8, i8* %238, i64 8
  store i8* %add.ptr273, i8** %ptr.addr, align 8, !tbaa !4
  %239 = load i64, i64* %k1270, align 8, !tbaa !22
  %240 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor274 = xor i64 %240, %239
  store i64 %xor274, i64* %h64.addr, align 8, !tbaa !22
  %241 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %242 = call i64 @llvm.fshl.i64(i64 %241, i64 %241, i64 27)
  %mul275 = mul i64 %242, -7046029288634856825
  %add276 = add i64 %mul275, -8796714831421723037
  store i64 %add276, i64* %h64.addr, align 8, !tbaa !22
  %243 = bitcast i64* %k1270 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %243) #11
  br label %do.end277

do.end277:                                        ; preds = %do.body269
  br label %do.body278

do.body278:                                       ; preds = %do.end277
  %244 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr279 = getelementptr inbounds i8, i8* %244, i32 1
  store i8* %incdec.ptr279, i8** %ptr.addr, align 8, !tbaa !4
  %245 = load i8, i8* %244, align 1, !tbaa !12
  %conv280 = zext i8 %245 to i64
  %mul281 = mul i64 %conv280, 2870177450012600261
  %246 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor282 = xor i64 %246, %mul281
  store i64 %xor282, i64* %h64.addr, align 8, !tbaa !22
  %247 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %248 = call i64 @llvm.fshl.i64(i64 %247, i64 %247, i64 11)
  %mul283 = mul i64 %248, -7046029288634856825
  store i64 %mul283, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end284

do.end284:                                        ; preds = %do.body278
  br label %do.body285

do.body285:                                       ; preds = %do.end284
  %249 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr286 = getelementptr inbounds i8, i8* %249, i32 1
  store i8* %incdec.ptr286, i8** %ptr.addr, align 8, !tbaa !4
  %250 = load i8, i8* %249, align 1, !tbaa !12
  %conv287 = zext i8 %250 to i64
  %mul288 = mul i64 %conv287, 2870177450012600261
  %251 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor289 = xor i64 %251, %mul288
  store i64 %xor289, i64* %h64.addr, align 8, !tbaa !22
  %252 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %253 = call i64 @llvm.fshl.i64(i64 %252, i64 %252, i64 11)
  %mul290 = mul i64 %253, -7046029288634856825
  store i64 %mul290, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end291

do.end291:                                        ; preds = %do.body285
  br label %do.body292

do.body292:                                       ; preds = %do.end291
  %254 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr293 = getelementptr inbounds i8, i8* %254, i32 1
  store i8* %incdec.ptr293, i8** %ptr.addr, align 8, !tbaa !4
  %255 = load i8, i8* %254, align 1, !tbaa !12
  %conv294 = zext i8 %255 to i64
  %mul295 = mul i64 %conv294, 2870177450012600261
  %256 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor296 = xor i64 %256, %mul295
  store i64 %xor296, i64* %h64.addr, align 8, !tbaa !22
  %257 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %258 = call i64 @llvm.fshl.i64(i64 %257, i64 %257, i64 11)
  %mul297 = mul i64 %258, -7046029288634856825
  store i64 %mul297, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end298

do.end298:                                        ; preds = %do.body292
  %259 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call299 = call i64 @XXH64_avalanche(i64 %259)
  store i64 %call299, i64* %retval, align 8
  br label %return

sw.bb300:                                         ; preds = %entry
  br label %do.body301

do.body301:                                       ; preds = %sw.bb300
  %260 = bitcast i64* %k1302 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %260) #11
  %261 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %262 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call303 = call i64 @XXH_readLE64_align(i8* %261, i32 %262)
  %call304 = call i64 @XXH64_round(i64 0, i64 %call303)
  store i64 %call304, i64* %k1302, align 8, !tbaa !22
  %263 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr305 = getelementptr inbounds i8, i8* %263, i64 8
  store i8* %add.ptr305, i8** %ptr.addr, align 8, !tbaa !4
  %264 = load i64, i64* %k1302, align 8, !tbaa !22
  %265 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor306 = xor i64 %265, %264
  store i64 %xor306, i64* %h64.addr, align 8, !tbaa !22
  %266 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %267 = call i64 @llvm.fshl.i64(i64 %266, i64 %266, i64 27)
  %mul307 = mul i64 %267, -7046029288634856825
  %add308 = add i64 %mul307, -8796714831421723037
  store i64 %add308, i64* %h64.addr, align 8, !tbaa !22
  %268 = bitcast i64* %k1302 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %268) #11
  br label %do.end309

do.end309:                                        ; preds = %do.body301
  br label %sw.bb310

sw.bb310:                                         ; preds = %entry, %do.end309
  br label %do.body311

do.body311:                                       ; preds = %sw.bb310
  %269 = bitcast i64* %k1312 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %269) #11
  %270 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %271 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call313 = call i64 @XXH_readLE64_align(i8* %270, i32 %271)
  %call314 = call i64 @XXH64_round(i64 0, i64 %call313)
  store i64 %call314, i64* %k1312, align 8, !tbaa !22
  %272 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr315 = getelementptr inbounds i8, i8* %272, i64 8
  store i8* %add.ptr315, i8** %ptr.addr, align 8, !tbaa !4
  %273 = load i64, i64* %k1312, align 8, !tbaa !22
  %274 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor316 = xor i64 %274, %273
  store i64 %xor316, i64* %h64.addr, align 8, !tbaa !22
  %275 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %276 = call i64 @llvm.fshl.i64(i64 %275, i64 %275, i64 27)
  %mul317 = mul i64 %276, -7046029288634856825
  %add318 = add i64 %mul317, -8796714831421723037
  store i64 %add318, i64* %h64.addr, align 8, !tbaa !22
  %277 = bitcast i64* %k1312 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %277) #11
  br label %do.end319

do.end319:                                        ; preds = %do.body311
  br label %sw.bb320

sw.bb320:                                         ; preds = %entry, %do.end319
  br label %do.body321

do.body321:                                       ; preds = %sw.bb320
  %278 = bitcast i64* %k1322 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %278) #11
  %279 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %280 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call323 = call i64 @XXH_readLE64_align(i8* %279, i32 %280)
  %call324 = call i64 @XXH64_round(i64 0, i64 %call323)
  store i64 %call324, i64* %k1322, align 8, !tbaa !22
  %281 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr325 = getelementptr inbounds i8, i8* %281, i64 8
  store i8* %add.ptr325, i8** %ptr.addr, align 8, !tbaa !4
  %282 = load i64, i64* %k1322, align 8, !tbaa !22
  %283 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor326 = xor i64 %283, %282
  store i64 %xor326, i64* %h64.addr, align 8, !tbaa !22
  %284 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %285 = call i64 @llvm.fshl.i64(i64 %284, i64 %284, i64 27)
  %mul327 = mul i64 %285, -7046029288634856825
  %add328 = add i64 %mul327, -8796714831421723037
  store i64 %add328, i64* %h64.addr, align 8, !tbaa !22
  %286 = bitcast i64* %k1322 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %286) #11
  br label %do.end329

do.end329:                                        ; preds = %do.body321
  br label %sw.bb330

sw.bb330:                                         ; preds = %entry, %do.end329
  br label %do.body331

do.body331:                                       ; preds = %sw.bb330
  %287 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %288 = load i32, i32* %align.addr, align 4, !tbaa !12
  %call332 = call i32 @XXH_readLE32_align(i8* %287, i32 %288)
  %conv333 = zext i32 %call332 to i64
  %mul334 = mul i64 %conv333, -7046029288634856825
  %289 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor335 = xor i64 %289, %mul334
  store i64 %xor335, i64* %h64.addr, align 8, !tbaa !22
  %290 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %add.ptr336 = getelementptr inbounds i8, i8* %290, i64 4
  store i8* %add.ptr336, i8** %ptr.addr, align 8, !tbaa !4
  %291 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %292 = call i64 @llvm.fshl.i64(i64 %291, i64 %291, i64 23)
  %mul337 = mul i64 %292, -4417276706812531889
  %add338 = add i64 %mul337, 1609587929392839161
  store i64 %add338, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end339

do.end339:                                        ; preds = %do.body331
  br label %sw.bb340

sw.bb340:                                         ; preds = %entry, %do.end339
  br label %do.body341

do.body341:                                       ; preds = %sw.bb340
  %293 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr342 = getelementptr inbounds i8, i8* %293, i32 1
  store i8* %incdec.ptr342, i8** %ptr.addr, align 8, !tbaa !4
  %294 = load i8, i8* %293, align 1, !tbaa !12
  %conv343 = zext i8 %294 to i64
  %mul344 = mul i64 %conv343, 2870177450012600261
  %295 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor345 = xor i64 %295, %mul344
  store i64 %xor345, i64* %h64.addr, align 8, !tbaa !22
  %296 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %297 = call i64 @llvm.fshl.i64(i64 %296, i64 %296, i64 11)
  %mul346 = mul i64 %297, -7046029288634856825
  store i64 %mul346, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end347

do.end347:                                        ; preds = %do.body341
  br label %sw.bb348

sw.bb348:                                         ; preds = %entry, %do.end347
  br label %do.body349

do.body349:                                       ; preds = %sw.bb348
  %298 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr350 = getelementptr inbounds i8, i8* %298, i32 1
  store i8* %incdec.ptr350, i8** %ptr.addr, align 8, !tbaa !4
  %299 = load i8, i8* %298, align 1, !tbaa !12
  %conv351 = zext i8 %299 to i64
  %mul352 = mul i64 %conv351, 2870177450012600261
  %300 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor353 = xor i64 %300, %mul352
  store i64 %xor353, i64* %h64.addr, align 8, !tbaa !22
  %301 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %302 = call i64 @llvm.fshl.i64(i64 %301, i64 %301, i64 11)
  %mul354 = mul i64 %302, -7046029288634856825
  store i64 %mul354, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end355

do.end355:                                        ; preds = %do.body349
  br label %sw.bb356

sw.bb356:                                         ; preds = %entry, %do.end355
  br label %do.body357

do.body357:                                       ; preds = %sw.bb356
  %303 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %incdec.ptr358 = getelementptr inbounds i8, i8* %303, i32 1
  store i8* %incdec.ptr358, i8** %ptr.addr, align 8, !tbaa !4
  %304 = load i8, i8* %303, align 1, !tbaa !12
  %conv359 = zext i8 %304 to i64
  %mul360 = mul i64 %conv359, 2870177450012600261
  %305 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor361 = xor i64 %305, %mul360
  store i64 %xor361, i64* %h64.addr, align 8, !tbaa !22
  %306 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %307 = call i64 @llvm.fshl.i64(i64 %306, i64 %306, i64 11)
  %mul362 = mul i64 %307, -7046029288634856825
  store i64 %mul362, i64* %h64.addr, align 8, !tbaa !22
  br label %do.end363

do.end363:                                        ; preds = %do.body357
  br label %sw.bb364

sw.bb364:                                         ; preds = %entry, %do.end363
  %308 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call365 = call i64 @XXH64_avalanche(i64 %308)
  store i64 %call365, i64* %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, i64* %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb364, %do.end298, %do.end246, %do.end191, %do.end146, %do.end98, %do.end61, %do.end21
  %309 = load i64, i64* %retval, align 8
  ret i64 %309
}

; Function Attrs: nounwind ssp uwtable
define void @XXH64_canonicalFromHash(%struct.XXH64_canonical_t* %dst, i64 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH64_canonical_t*, align 8
  %hash.addr = alloca i64, align 8
  store %struct.XXH64_canonical_t* %dst, %struct.XXH64_canonical_t** %dst.addr, align 8, !tbaa !4
  store i64 %hash, i64* %hash.addr, align 8, !tbaa !22
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i64, i64* %hash.addr, align 8, !tbaa !22
  %call = call i64 @XXH_swap64(i64 %0)
  store i64 %call, i64* %hash.addr, align 8, !tbaa !22
  %1 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8, !tbaa !4
  %2 = bitcast %struct.XXH64_canonical_t* %1 to i8*
  %3 = bitcast i64* %hash.addr to i8*
  %4 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8, !tbaa !4
  %5 = bitcast %struct.XXH64_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 8, i64 %6) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH_swap64(i64 %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8, !tbaa !22
  %0 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shl = shl i64 %0, 56
  %and = and i64 %shl, -72057594037927936
  %1 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shl1 = shl i64 %1, 40
  %and2 = and i64 %shl1, 71776119061217280
  %or = or i64 %and, %and2
  %2 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shl3 = shl i64 %2, 24
  %and4 = and i64 %shl3, 280375465082880
  %or5 = or i64 %or, %and4
  %3 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shl6 = shl i64 %3, 8
  %and7 = and i64 %shl6, 1095216660480
  %or8 = or i64 %or5, %and7
  %4 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shr = lshr i64 %4, 8
  %and9 = and i64 %shr, 4278190080
  %or10 = or i64 %or8, %and9
  %5 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shr11 = lshr i64 %5, 24
  %and12 = and i64 %shr11, 16711680
  %or13 = or i64 %or10, %and12
  %6 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shr14 = lshr i64 %6, 40
  %and15 = and i64 %shr14, 65280
  %or16 = or i64 %or13, %and15
  %7 = load i64, i64* %x.addr, align 8, !tbaa !22
  %shr17 = lshr i64 %7, 56
  %and18 = and i64 %shr17, 255
  %or19 = or i64 %or16, %and18
  ret i64 %or19
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH64_hashFromCanonical(%struct.XXH64_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH64_canonical_t*, align 8
  store %struct.XXH64_canonical_t* %src, %struct.XXH64_canonical_t** %src.addr, align 8, !tbaa !4
  %0 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %src.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH64_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH_readBE64(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %call = call i64 @XXH_read64(i8* %0)
  %call1 = call i64 @XXH_swap64(i64 %call)
  ret i64 %call1
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits(i8* %input, i64 %len) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_64bits_internal(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, i64 (i8*, i64, i64, i8*, i64)* %f_hashLong) #1 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hashLong.addr = alloca i64 (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  store i64 (i8*, i64, i64, i8*, i64)* %f_hashLong, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8, !tbaa !4
  %0 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %4 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_len_0to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp1 = icmp ule i64 %5, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %7 = load i64, i64* %len.addr, align 8, !tbaa !8
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %9 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %10 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call3 = call i64 @XXH3_len_17to128_64b(i8* %6, i64 %7, i8* %8, i64 %9, i64 %10)
  store i64 %call3, i64* %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp5 = icmp ule i64 %11, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %12 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %13 = load i64, i64* %len.addr, align 8, !tbaa !8
  %14 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %15 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %16 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call7 = call i64 @XXH3_len_129to240_64b(i8* %12, i64 %13, i8* %14, i64 %15, i64 %16)
  store i64 %call7, i64* %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %17 = load i64 (i8*, i64, i64, i8*, i64)*, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8, !tbaa !4
  %18 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %19 = load i64, i64* %len.addr, align 8, !tbaa !8
  %20 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %22 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %call9 = call i64 %17(i8* %18, i64 %19, i64 %20, i8* %21, i64 %22)
  store i64 %call9, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %23 = load i64, i64* %retval, align 8
  ret i64 %23
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %4 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSeed)
  ret i64 %call
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed(i8* %input, i64 %len, i64 %seed, i8* %secret, i64 %secretLen) #5 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %1 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_hashLong_64b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define %struct.XXH3_state_s* @XXH3_createState() #0 {
entry:
  %call = call i8* @XXH_alignedMalloc(i64 576, i64 64)
  %0 = bitcast i8* %call to %struct.XXH3_state_s*
  ret %struct.XXH3_state_s* %0
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @XXH_alignedMalloc(i64 %s, i64 %align) #0 {
entry:
  %retval = alloca i8*, align 8
  %s.addr = alloca i64, align 8
  %align.addr = alloca i64, align 8
  %base = alloca i8*, align 8
  %offset = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %s, i64* %s.addr, align 8, !tbaa !8
  store i64 %align, i64* %align.addr, align 8, !tbaa !8
  %0 = bitcast i8** %base to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i64, i64* %s.addr, align 8, !tbaa !8
  %2 = load i64, i64* %align.addr, align 8, !tbaa !8
  %add = add i64 %1, %2
  %call = call i8* @XXH_malloc(i64 %add)
  store i8* %call, i8** %base, align 8, !tbaa !4
  %3 = load i8*, i8** %base, align 8, !tbaa !4
  %cmp = icmp ne i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load i64, i64* %align.addr, align 8, !tbaa !8
  %6 = load i8*, i8** %base, align 8, !tbaa !4
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %align.addr, align 8, !tbaa !8
  %sub = sub i64 %8, 1
  %and = and i64 %7, %sub
  %sub1 = sub i64 %5, %and
  store i64 %sub1, i64* %offset, align 8, !tbaa !8
  %9 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #11
  %10 = load i8*, i8** %base, align 8, !tbaa !4
  %11 = load i64, i64* %offset, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 %11
  store i8* %add.ptr, i8** %ptr, align 8, !tbaa !4
  %12 = load i64, i64* %offset, align 8, !tbaa !8
  %conv = trunc i64 %12 to i8
  %13 = load i8*, i8** %ptr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i8, i8* %13, i64 -1
  store i8 %conv, i8* %arrayidx, align 1, !tbaa !12
  %14 = load i8*, i8** %ptr, align 8, !tbaa !4
  store i8* %14, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  %15 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #11
  %16 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #11
  br label %cleanup

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %17 = bitcast i8** %base to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #11
  %18 = load i8*, i8** %retval, align 8
  ret i8* %18
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_freeState(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  call void @XXH_alignedFree(i8* %1)
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH_alignedFree(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %ptr = alloca i8*, align 8
  %offset = alloca i8, align 1
  %base = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %p.addr, align 8, !tbaa !4
  %cmp = icmp ne i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i8*, i8** %p.addr, align 8, !tbaa !4
  store i8* %2, i8** %ptr, align 8, !tbaa !4
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %offset) #11
  %3 = load i8*, i8** %ptr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 -1
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !12
  store i8 %4, i8* %offset, align 1, !tbaa !12
  %5 = bitcast i8** %base to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #11
  %6 = load i8*, i8** %ptr, align 8, !tbaa !4
  %7 = load i8, i8* %offset, align 1, !tbaa !12
  %conv = zext i8 %7 to i32
  %idx.ext = sext i32 %conv to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %idx.neg
  store i8* %add.ptr, i8** %base, align 8, !tbaa !4
  %8 = load i8*, i8** %base, align 8, !tbaa !4
  call void @XXH_free(i8* %8)
  %9 = bitcast i8** %base to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %offset) #11
  %10 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @XXH3_copyState(%struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s* %src_state) #0 {
entry:
  %dst_state.addr = alloca %struct.XXH3_state_s*, align 8
  %src_state.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s** %dst_state.addr, align 8, !tbaa !4
  store %struct.XXH3_state_s* %src_state, %struct.XXH3_state_s** %src_state.addr, align 8, !tbaa !4
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %src_state.addr, align 8, !tbaa !4
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8, !tbaa !4
  %5 = bitcast %struct.XXH3_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 576, i64 %6) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 576, i64 %4) #11
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 0
  %arrayidx = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i64 0, i64 0
  store i64 3266489917, i64* %arrayidx, align 16, !tbaa !22
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i64 0, i64 1
  store i64 -7046029288634856825, i64* %arrayidx2, align 8, !tbaa !22
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc3, i64 0, i64 2
  store i64 -4417276706812531889, i64* %arrayidx4, align 16, !tbaa !22
  %8 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %8, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc5, i64 0, i64 3
  store i64 1609587929392839161, i64* %arrayidx6, align 8, !tbaa !22
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [8 x i64], [8 x i64]* %acc7, i64 0, i64 4
  store i64 -8796714831421723037, i64* %arrayidx8, align 16, !tbaa !22
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [8 x i64], [8 x i64]* %acc9, i64 0, i64 5
  store i64 2246822519, i64* %arrayidx10, align 8, !tbaa !22
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [8 x i64], [8 x i64]* %acc11, i64 0, i64 6
  store i64 2870177450012600261, i64* %arrayidx12, align 16, !tbaa !22
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %acc13 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [8 x i64], [8 x i64]* %acc13, i64 0, i64 7
  store i64 2654435761, i64* %arrayidx14, align 8, !tbaa !22
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %seed15 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 9
  store i64 %13, i64* %seed15, align 8, !tbaa !31
  %15 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 11
  store i8* %15, i8** %extSecret, align 8, !tbaa !33
  %17 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %sub = sub i64 %17, 64
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 7
  store i64 %sub, i64* %secretLimit, align 8, !tbaa !34
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %secretLimit16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 7
  %20 = load i64, i64* %secretLimit16, align 8, !tbaa !34
  %div = udiv i64 %20, 8
  %21 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %21, i32 0, i32 5
  store i64 %div, i64* %nbStripesPerBlock, align 8, !tbaa !35
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !22
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8, !tbaa !33
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_initCustomSecret_sse2(i8* noalias %customSecret, i64 %seed64) #6 {
entry:
  %customSecret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %seed = alloca <2 x i64>, align 16
  %i = alloca i32, align 4
  %src = alloca float*, align 64
  %dest = alloca <2 x i64>*, align 16
  store i8* %customSecret, i8** %customSecret.addr, align 8, !tbaa !4
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  store i32 12, i32* %nbRounds, align 4, !tbaa !10
  %1 = bitcast <2 x i64>* %seed to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #11
  %2 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %sub = sub nsw i64 0, %2
  %3 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call = call <2 x i64> @_mm_set_epi64x(i64 %sub, i64 %3)
  store <2 x i64> %call, <2 x i64>* %seed, align 16, !tbaa !12
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = bitcast float** %src to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #11
  store float* bitcast ([192 x i8]* @XXH3_kSecret to float*), float** %src, align 64, !tbaa !4
  %6 = bitcast <2 x i64>** %dest to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %7 = load i8*, i8** %customSecret.addr, align 8, !tbaa !4
  %8 = bitcast i8* %7 to <2 x i64>*
  store <2 x i64>* %8, <2 x i64>** %dest, align 16, !tbaa !4
  %9 = load <2 x i64>*, <2 x i64>** %dest, align 16, !tbaa !4
  %10 = call <2 x i64>* asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(<2 x i64>* %9) #9, !srcloc !36
  store <2 x i64>* %10, <2 x i64>** %dest, align 16, !tbaa !4
  store i32 0, i32* %i, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %11 = load i32, i32* %i, align 4, !tbaa !10
  %cmp = icmp slt i32 %11, 12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, i32* %i, align 4, !tbaa !10
  %mul = mul nsw i32 %12, 4
  %idx.ext = sext i32 %mul to i64
  %add.ptr = getelementptr inbounds float, float* bitcast ([192 x i8]* @XXH3_kSecret to float*), i64 %idx.ext
  %call1 = call <4 x float> @_mm_load_ps(float* %add.ptr)
  %call2 = call <2 x i64> @_mm_castps_si128(<4 x float> %call1)
  %13 = load <2 x i64>, <2 x i64>* %seed, align 16, !tbaa !12
  %call3 = call <2 x i64> @_mm_add_epi64(<2 x i64> %call2, <2 x i64> %13)
  %14 = load <2 x i64>*, <2 x i64>** %dest, align 16, !tbaa !4
  %15 = load i32, i32* %i, align 4, !tbaa !10
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %14, i64 %idxprom
  store <2 x i64> %call3, <2 x i64>* %arrayidx, align 16, !tbaa !12
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4, !tbaa !10
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4, !tbaa !10
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = bitcast <2 x i64>** %dest to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #11
  %18 = bitcast float** %src to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #11
  %19 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %19) #11
  %20 = bitcast <2 x i64>* %seed to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %20) #11
  %21 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %21) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 0, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH3_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %bEnd = alloca i8*, align 8
  %secret = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %loadSize = alloca i64, align 8
  %limit = alloca i8*, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !12
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %3
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !4
  %4 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  %6 = load i8*, i8** %extSecret, align 8, !tbaa !33
  %cmp1 = icmp eq i8* %6, null
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %8 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %extSecret2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %8, i32 0, i32 11
  %9 = load i8*, i8** %extSecret2, align 8, !tbaa !33
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %9, %cond.false ]
  store i8* %cond, i8** %secret, align 8, !tbaa !4
  %10 = load i64, i64* %len.addr, align 8, !tbaa !8
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 8
  %12 = load i64, i64* %totalLen, align 16, !tbaa !37
  %add = add i64 %12, %10
  store i64 %add, i64* %totalLen, align 16, !tbaa !37
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 3
  %14 = load i32, i32* %bufferedSize, align 16, !tbaa !38
  %conv = zext i32 %14 to i64
  %15 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add3 = add i64 %conv, %15
  %cmp4 = icmp ule i64 %add3, 256
  br i1 %cmp4, label %if.then6, label %if.end13

if.then6:                                         ; preds = %cond.end
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 3
  %18 = load i32, i32* %bufferedSize8, align 16, !tbaa !38
  %idx.ext = zext i32 %18 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %arraydecay7, i64 %idx.ext
  %19 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %20 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call i8* @XXH_memcpy(i8* %add.ptr9, i8* %19, i64 %20)
  %21 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv10 = trunc i64 %21 to i32
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 3
  %23 = load i32, i32* %bufferedSize11, align 16, !tbaa !38
  %add12 = add i32 %23, %conv10
  store i32 %add12, i32* %bufferedSize11, align 16, !tbaa !38
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end13:                                         ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.end13
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 3
  %25 = load i32, i32* %bufferedSize14, align 16, !tbaa !38
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.then15, label %if.end29

if.then15:                                        ; preds = %do.end
  %26 = bitcast i64* %loadSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %26) #11
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 3
  %28 = load i32, i32* %bufferedSize16, align 16, !tbaa !38
  %sub = sub i32 256, %28
  %conv17 = zext i32 %sub to i64
  store i64 %conv17, i64* %loadSize, align 8, !tbaa !8
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer18 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer18, i32 0, i32 0
  %30 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %30, i32 0, i32 3
  %31 = load i32, i32* %bufferedSize20, align 16, !tbaa !38
  %idx.ext21 = zext i32 %31 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay19, i64 %idx.ext21
  %32 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %33 = load i64, i64* %loadSize, align 8, !tbaa !8
  %call23 = call i8* @XXH_memcpy(i8* %add.ptr22, i8* %32, i64 %33)
  %34 = load i64, i64* %loadSize, align 8, !tbaa !8
  %35 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr24 = getelementptr inbounds i8, i8* %35, i64 %34
  store i8* %add.ptr24, i8** %input.addr, align 8, !tbaa !4
  %36 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %36, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %nbStripesSoFar = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 6
  %38 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %38, i32 0, i32 5
  %39 = load i64, i64* %nbStripesPerBlock, align 8, !tbaa !35
  %40 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer26 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %40, i32 0, i32 2
  %arraydecay27 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer26, i32 0, i32 0
  %41 = load i8*, i8** %secret, align 8, !tbaa !4
  %42 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %42, i32 0, i32 7
  %43 = load i64, i64* %secretLimit, align 8, !tbaa !34
  %44 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %45 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %46 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  call void @XXH3_consumeStripes(i64* %arraydecay25, i64* %nbStripesSoFar, i64 %39, i8* %arraydecay27, i64 4, i8* %41, i64 %43, i32 %44, void (i8*, i8*, i8*, i32)* %45, void (i8*, i8*)* %46)
  %47 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize28 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %47, i32 0, i32 3
  store i32 0, i32* %bufferedSize28, align 16, !tbaa !38
  %48 = bitcast i64* %loadSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #11
  br label %if.end29

if.end29:                                         ; preds = %if.then15, %do.end
  %49 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr30 = getelementptr inbounds i8, i8* %49, i64 256
  %50 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %cmp31 = icmp ule i8* %add.ptr30, %50
  br i1 %cmp31, label %if.then33, label %if.end56

if.then33:                                        ; preds = %if.end29
  %51 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %51) #11
  %52 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %add.ptr34 = getelementptr inbounds i8, i8* %52, i64 -256
  store i8* %add.ptr34, i8** %limit, align 8, !tbaa !4
  br label %do.body35

do.body35:                                        ; preds = %do.cond42, %if.then33
  %53 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %acc36 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %53, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [8 x i64], [8 x i64]* %acc36, i32 0, i32 0
  %54 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %nbStripesSoFar38 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %54, i32 0, i32 6
  %55 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %nbStripesPerBlock39 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %55, i32 0, i32 5
  %56 = load i64, i64* %nbStripesPerBlock39, align 8, !tbaa !35
  %57 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %58 = load i8*, i8** %secret, align 8, !tbaa !4
  %59 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit40 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %59, i32 0, i32 7
  %60 = load i64, i64* %secretLimit40, align 8, !tbaa !34
  %61 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %62 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %63 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  call void @XXH3_consumeStripes(i64* %arraydecay37, i64* %nbStripesSoFar38, i64 %56, i8* %57, i64 4, i8* %58, i64 %60, i32 %61, void (i8*, i8*, i8*, i32)* %62, void (i8*, i8*)* %63)
  %64 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr41 = getelementptr inbounds i8, i8* %64, i64 256
  store i8* %add.ptr41, i8** %input.addr, align 8, !tbaa !4
  br label %do.cond42

do.cond42:                                        ; preds = %do.body35
  %65 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %66 = load i8*, i8** %limit, align 8, !tbaa !4
  %cmp43 = icmp ule i8* %65, %66
  br i1 %cmp43, label %do.body35, label %do.end45

do.end45:                                         ; preds = %do.cond42
  %67 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer46 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %67, i32 0, i32 2
  %arraydecay47 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer46, i32 0, i32 0
  %add.ptr48 = getelementptr inbounds i8, i8* %arraydecay47, i64 256
  %add.ptr49 = getelementptr inbounds i8, i8* %add.ptr48, i64 -64
  %68 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr50 = getelementptr inbounds i8, i8* %68, i64 -64
  %69 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer51 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %69, i32 0, i32 2
  %arraydecay52 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer51, i32 0, i32 0
  %add.ptr53 = getelementptr inbounds i8, i8* %arraydecay52, i64 256
  %add.ptr54 = getelementptr inbounds i8, i8* %add.ptr53, i64 -64
  %70 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr54, i1 false, i1 true)
  %call55 = call i8* @__memcpy_chk(i8* %add.ptr49, i8* %add.ptr50, i64 64, i64 %70) #11
  %71 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #11
  br label %if.end56

if.end56:                                         ; preds = %do.end45, %if.end29
  %72 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %73 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %cmp57 = icmp ult i8* %72, %73
  br i1 %cmp57, label %if.then59, label %if.end68

if.then59:                                        ; preds = %if.end56
  %74 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer60 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %74, i32 0, i32 2
  %arraydecay61 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer60, i32 0, i32 0
  %75 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %76 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %77 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %sub.ptr.lhs.cast = ptrtoint i8* %76 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %77 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call62 = call i8* @XXH_memcpy(i8* %arraydecay61, i8* %75, i64 %sub.ptr.sub)
  %78 = load i8*, i8** %bEnd, align 8, !tbaa !4
  %79 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %sub.ptr.lhs.cast63 = ptrtoint i8* %78 to i64
  %sub.ptr.rhs.cast64 = ptrtoint i8* %79 to i64
  %sub.ptr.sub65 = sub i64 %sub.ptr.lhs.cast63, %sub.ptr.rhs.cast64
  %conv66 = trunc i64 %sub.ptr.sub65 to i32
  %80 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize67 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %80, i32 0, i32 3
  store i32 %conv66, i32* %bufferedSize67, align 16, !tbaa !38
  br label %if.end68

if.end68:                                         ; preds = %if.then59, %if.end56
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end68, %if.then6
  %81 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %81) #11
  %82 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %82) #11
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cleanup.cont, %cleanup, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_accumulate_512_sse2(i8* noalias %acc, i8* noalias %input, i8* noalias %secret, i32 %accWidth) #6 {
entry:
  %acc.addr = alloca i8*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %xacc = alloca <2 x i64>*, align 16
  %xinput = alloca <2 x i64>*, align 8
  %xsecret = alloca <2 x i64>*, align 8
  %i = alloca i64, align 8
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_lo = alloca <2 x i64>, align 16
  %product = alloca <2 x i64>, align 16
  %data_swap = alloca <2 x i64>, align 16
  %sum = alloca <2 x i64>, align 16
  %sum10 = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !12
  %0 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %acc.addr, align 8, !tbaa !4
  %2 = bitcast i8* %1 to <2 x i64>*
  store <2 x i64>* %2, <2 x i64>** %xacc, align 16, !tbaa !4
  %3 = bitcast <2 x i64>** %xinput to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64>* %5, <2 x i64>** %xinput, align 8, !tbaa !4
  %6 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #11
  %7 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %8 = bitcast i8* %7 to <2 x i64>*
  store <2 x i64>* %8, <2 x i64>** %xsecret, align 8, !tbaa !4
  %9 = bitcast i64* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #11
  store i64 0, i64* %i, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i64, i64* %i, align 8, !tbaa !8
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %11) #11
  %12 = load <2 x i64>*, <2 x i64>** %xinput, align 8, !tbaa !4
  %13 = load i64, i64* %i, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %12, i64 %13
  %call = call <2 x i64> @_mm_loadu_si128(<2 x i64>* %add.ptr)
  store <2 x i64> %call, <2 x i64>* %data_vec, align 16, !tbaa !12
  %14 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %14) #11
  %15 = load <2 x i64>*, <2 x i64>** %xsecret, align 8, !tbaa !4
  %16 = load i64, i64* %i, align 8, !tbaa !8
  %add.ptr1 = getelementptr inbounds <2 x i64>, <2 x i64>* %15, i64 %16
  %call2 = call <2 x i64> @_mm_loadu_si128(<2 x i64>* %add.ptr1)
  store <2 x i64> %call2, <2 x i64>* %key_vec, align 16, !tbaa !12
  %17 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %17) #11
  %18 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !12
  %19 = load <2 x i64>, <2 x i64>* %key_vec, align 16, !tbaa !12
  %call3 = call <2 x i64> @_mm_xor_si128(<2 x i64> %18, <2 x i64> %19)
  store <2 x i64> %call3, <2 x i64>* %data_key, align 16, !tbaa !12
  %20 = bitcast <2 x i64>* %data_key_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %20) #11
  %21 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !12
  %22 = bitcast <2 x i64> %21 to <4 x i32>
  %permil = shufflevector <4 x i32> %22, <4 x i32> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %23 = bitcast <4 x i32> %permil to <2 x i64>
  store <2 x i64> %23, <2 x i64>* %data_key_lo, align 16, !tbaa !12
  %24 = bitcast <2 x i64>* %product to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %24) #11
  %25 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !12
  %26 = load <2 x i64>, <2 x i64>* %data_key_lo, align 16, !tbaa !12
  %call4 = call <2 x i64> @_mm_mul_epu32(<2 x i64> %25, <2 x i64> %26)
  store <2 x i64> %call4, <2 x i64>* %product, align 16, !tbaa !12
  %27 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %cmp5 = icmp eq i32 %27, 1
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %28 = bitcast <2 x i64>* %data_swap to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %28) #11
  %29 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !12
  %30 = bitcast <2 x i64> %29 to <4 x i32>
  %permil6 = shufflevector <4 x i32> %30, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %31 = bitcast <4 x i32> %permil6 to <2 x i64>
  store <2 x i64> %31, <2 x i64>* %data_swap, align 16, !tbaa !12
  %32 = bitcast <2 x i64>* %sum to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %32) #11
  %33 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !4
  %34 = load i64, i64* %i, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %33, i64 %34
  %35 = load <2 x i64>, <2 x i64>* %arrayidx, align 16, !tbaa !12
  %36 = load <2 x i64>, <2 x i64>* %data_swap, align 16, !tbaa !12
  %call7 = call <2 x i64> @_mm_add_epi64(<2 x i64> %35, <2 x i64> %36)
  store <2 x i64> %call7, <2 x i64>* %sum, align 16, !tbaa !12
  %37 = load <2 x i64>, <2 x i64>* %product, align 16, !tbaa !12
  %38 = load <2 x i64>, <2 x i64>* %sum, align 16, !tbaa !12
  %call8 = call <2 x i64> @_mm_add_epi64(<2 x i64> %37, <2 x i64> %38)
  %39 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !4
  %40 = load i64, i64* %i, align 8, !tbaa !8
  %arrayidx9 = getelementptr inbounds <2 x i64>, <2 x i64>* %39, i64 %40
  store <2 x i64> %call8, <2 x i64>* %arrayidx9, align 16, !tbaa !12
  %41 = bitcast <2 x i64>* %sum to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %41) #11
  %42 = bitcast <2 x i64>* %data_swap to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %42) #11
  br label %if.end

if.else:                                          ; preds = %for.body
  %43 = bitcast <2 x i64>* %sum10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %43) #11
  %44 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !4
  %45 = load i64, i64* %i, align 8, !tbaa !8
  %arrayidx11 = getelementptr inbounds <2 x i64>, <2 x i64>* %44, i64 %45
  %46 = load <2 x i64>, <2 x i64>* %arrayidx11, align 16, !tbaa !12
  %47 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !12
  %call12 = call <2 x i64> @_mm_add_epi64(<2 x i64> %46, <2 x i64> %47)
  store <2 x i64> %call12, <2 x i64>* %sum10, align 16, !tbaa !12
  %48 = load <2 x i64>, <2 x i64>* %product, align 16, !tbaa !12
  %49 = load <2 x i64>, <2 x i64>* %sum10, align 16, !tbaa !12
  %call13 = call <2 x i64> @_mm_add_epi64(<2 x i64> %48, <2 x i64> %49)
  %50 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !4
  %51 = load i64, i64* %i, align 8, !tbaa !8
  %arrayidx14 = getelementptr inbounds <2 x i64>, <2 x i64>* %50, i64 %51
  store <2 x i64> %call13, <2 x i64>* %arrayidx14, align 16, !tbaa !12
  %52 = bitcast <2 x i64>* %sum10 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %52) #11
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %53 = bitcast <2 x i64>* %product to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %53) #11
  %54 = bitcast <2 x i64>* %data_key_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %54) #11
  %55 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %55) #11
  %56 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %56) #11
  %57 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %57) #11
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %58 = load i64, i64* %i, align 8, !tbaa !8
  %inc = add i64 %58, 1
  store i64 %inc, i64* %i, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %59 = bitcast i64* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %59) #11
  %60 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %60) #11
  %61 = bitcast <2 x i64>** %xinput to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %61) #11
  %62 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %62) #11
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_scrambleAcc_sse2(i8* noalias %acc, i8* noalias %secret) #6 {
entry:
  %acc.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %xacc = alloca <2 x i64>*, align 16
  %xsecret = alloca <2 x i64>*, align 8
  %prime32 = alloca <2 x i64>, align 16
  %i = alloca i64, align 8
  %acc_vec = alloca <2 x i64>, align 16
  %shifted = alloca <2 x i64>, align 16
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_hi = alloca <2 x i64>, align 16
  %prod_lo = alloca <2 x i64>, align 16
  %prod_hi = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  %0 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %acc.addr, align 8, !tbaa !4
  %2 = bitcast i8* %1 to <2 x i64>*
  store <2 x i64>* %2, <2 x i64>** %xacc, align 16, !tbaa !4
  %3 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64>* %5, <2 x i64>** %xsecret, align 8, !tbaa !4
  %6 = bitcast <2 x i64>* %prime32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %6) #11
  %call = call <2 x i64> @_mm_set1_epi32(i32 -1640531535)
  store <2 x i64> %call, <2 x i64>* %prime32, align 16, !tbaa !12
  %7 = bitcast i64* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #11
  store i64 0, i64* %i, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i64, i64* %i, align 8, !tbaa !8
  %cmp = icmp ult i64 %8, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = bitcast <2 x i64>* %acc_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %9) #11
  %10 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !4
  %11 = load i64, i64* %i, align 8, !tbaa !8
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %10, i64 %11
  %12 = load <2 x i64>, <2 x i64>* %arrayidx, align 16, !tbaa !12
  store <2 x i64> %12, <2 x i64>* %acc_vec, align 16, !tbaa !12
  %13 = bitcast <2 x i64>* %shifted to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %13) #11
  %14 = load <2 x i64>, <2 x i64>* %acc_vec, align 16, !tbaa !12
  %call1 = call <2 x i64> @_mm_srli_epi64(<2 x i64> %14, i32 47)
  store <2 x i64> %call1, <2 x i64>* %shifted, align 16, !tbaa !12
  %15 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %15) #11
  %16 = load <2 x i64>, <2 x i64>* %acc_vec, align 16, !tbaa !12
  %17 = load <2 x i64>, <2 x i64>* %shifted, align 16, !tbaa !12
  %call2 = call <2 x i64> @_mm_xor_si128(<2 x i64> %16, <2 x i64> %17)
  store <2 x i64> %call2, <2 x i64>* %data_vec, align 16, !tbaa !12
  %18 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %18) #11
  %19 = load <2 x i64>*, <2 x i64>** %xsecret, align 8, !tbaa !4
  %20 = load i64, i64* %i, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %19, i64 %20
  %call3 = call <2 x i64> @_mm_loadu_si128(<2 x i64>* %add.ptr)
  store <2 x i64> %call3, <2 x i64>* %key_vec, align 16, !tbaa !12
  %21 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %21) #11
  %22 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !12
  %23 = load <2 x i64>, <2 x i64>* %key_vec, align 16, !tbaa !12
  %call4 = call <2 x i64> @_mm_xor_si128(<2 x i64> %22, <2 x i64> %23)
  store <2 x i64> %call4, <2 x i64>* %data_key, align 16, !tbaa !12
  %24 = bitcast <2 x i64>* %data_key_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %24) #11
  %25 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !12
  %26 = bitcast <2 x i64> %25 to <4 x i32>
  %permil = shufflevector <4 x i32> %26, <4 x i32> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %27 = bitcast <4 x i32> %permil to <2 x i64>
  store <2 x i64> %27, <2 x i64>* %data_key_hi, align 16, !tbaa !12
  %28 = bitcast <2 x i64>* %prod_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %28) #11
  %29 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !12
  %30 = load <2 x i64>, <2 x i64>* %prime32, align 16, !tbaa !12
  %call5 = call <2 x i64> @_mm_mul_epu32(<2 x i64> %29, <2 x i64> %30)
  store <2 x i64> %call5, <2 x i64>* %prod_lo, align 16, !tbaa !12
  %31 = bitcast <2 x i64>* %prod_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %31) #11
  %32 = load <2 x i64>, <2 x i64>* %data_key_hi, align 16, !tbaa !12
  %33 = load <2 x i64>, <2 x i64>* %prime32, align 16, !tbaa !12
  %call6 = call <2 x i64> @_mm_mul_epu32(<2 x i64> %32, <2 x i64> %33)
  store <2 x i64> %call6, <2 x i64>* %prod_hi, align 16, !tbaa !12
  %34 = load <2 x i64>, <2 x i64>* %prod_lo, align 16, !tbaa !12
  %35 = load <2 x i64>, <2 x i64>* %prod_hi, align 16, !tbaa !12
  %call7 = call <2 x i64> @_mm_slli_epi64(<2 x i64> %35, i32 32)
  %call8 = call <2 x i64> @_mm_add_epi64(<2 x i64> %34, <2 x i64> %call7)
  %36 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !4
  %37 = load i64, i64* %i, align 8, !tbaa !8
  %arrayidx9 = getelementptr inbounds <2 x i64>, <2 x i64>* %36, i64 %37
  store <2 x i64> %call8, <2 x i64>* %arrayidx9, align 16, !tbaa !12
  %38 = bitcast <2 x i64>* %prod_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %38) #11
  %39 = bitcast <2 x i64>* %prod_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %39) #11
  %40 = bitcast <2 x i64>* %data_key_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %40) #11
  %41 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %41) #11
  %42 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %42) #11
  %43 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %43) #11
  %44 = bitcast <2 x i64>* %shifted to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %44) #11
  %45 = bitcast <2 x i64>* %acc_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %45) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %46 = load i64, i64* %i, align 8, !tbaa !8
  %inc = add i64 %46, 1
  store i64 %inc, i64* %i, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %47 = bitcast i64* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #11
  %48 = bitcast <2 x i64>* %prime32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %48) #11
  %49 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #11
  %50 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %50) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca i64, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %0 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %1, i32 0, i32 11
  %2 = load i8*, i8** %extSecret, align 8, !tbaa !33
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %4, i32 0, i32 11
  %5 = load i8*, i8** %extSecret1, align 8, !tbaa !33
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %5, %cond.false ]
  store i8* %cond, i8** %secret, align 8, !tbaa !4
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 8
  %7 = load i64, i64* %totalLen, align 16, !tbaa !37
  %cmp2 = icmp ugt i64 %7, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %8 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %8) #11
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %10 = load i8*, i8** %secret, align 8, !tbaa !4
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %9, i8* %10, i32 0)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %11 = load i8*, i8** %secret, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 11
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 8
  %13 = load i64, i64* %totalLen5, align 16, !tbaa !37
  %mul = mul i64 %13, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  store i64 %call, i64* %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  %14 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %14) #11
  br label %cleanup

if.end:                                           ; preds = %cond.end
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 9
  %16 = load i64, i64* %seed, align 8, !tbaa !31
  %tobool = icmp ne i64 %16, 0
  br i1 %tobool, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 8
  %19 = load i64, i64* %totalLen8, align 16, !tbaa !37
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %seed9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 9
  %21 = load i64, i64* %seed9, align 8, !tbaa !31
  %call10 = call i64 @XXH3_64bits_withSeed(i8* %arraydecay7, i64 %19, i64 %21)
  store i64 %call10, i64* %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end11:                                         ; preds = %if.end
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer12 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 2
  %arraydecay13 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer12, i32 0, i32 0
  %23 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %23, i32 0, i32 8
  %24 = load i64, i64* %totalLen14, align 16, !tbaa !37
  %25 = load i8*, i8** %secret, align 8, !tbaa !4
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 7
  %27 = load i64, i64* %secretLimit, align 8, !tbaa !34
  %add = add i64 %27, 64
  %call15 = call i64 @XXH3_64bits_withSecret(i8* %arraydecay13, i64 %24, i8* %25, i64 %add)
  store i64 %call15, i64* %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.then6, %if.then
  %28 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #11
  %29 = load i64, i64* %retval, align 8
  ret i64 %29
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_digest_long(i64* %acc, %struct.XXH3_state_s* %state, i8* %secret, i32 %accWidth) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %nbStripes = alloca i64, align 8
  %nbStripesSoFar = alloca i64, align 8
  %lastStripe = alloca [64 x i8], align 16
  %catchupSize = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !4
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !12
  %0 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %1 = bitcast i64* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i32 0, i32 0
  %3 = bitcast i64* %arraydecay to i8*
  %4 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %5 = bitcast i64* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 64, i64 %6) #11
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 3
  %8 = load i32, i32* %bufferedSize, align 16, !tbaa !38
  %cmp = icmp uge i32 %8, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #11
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 3
  %11 = load i32, i32* %bufferedSize2, align 16, !tbaa !38
  %div = udiv i32 %11, 64
  %conv = zext i32 %div to i64
  store i64 %conv, i64* %nbStripes, align 8, !tbaa !8
  %12 = bitcast i64* %nbStripesSoFar to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #11
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %nbStripesSoFar3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 6
  %14 = load i64, i64* %nbStripesSoFar3, align 16, !tbaa !39
  store i64 %14, i64* %nbStripesSoFar, align 8, !tbaa !8
  %15 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 5
  %17 = load i64, i64* %nbStripesPerBlock, align 8, !tbaa !35
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %19 = load i64, i64* %nbStripes, align 8, !tbaa !8
  %20 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %21 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %21, i32 0, i32 7
  %22 = load i64, i64* %secretLimit, align 8, !tbaa !34
  %23 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  call void @XXH3_consumeStripes(i64* %15, i64* %nbStripesSoFar, i64 %17, i8* %arraydecay4, i64 %19, i8* %20, i64 %22, i32 %23, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 3
  %25 = load i32, i32* %bufferedSize5, align 16, !tbaa !38
  %rem = urem i32 %25, 64
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %26 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %27 = bitcast i64* %26 to i8*
  %28 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %28, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer7, i32 0, i32 0
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 3
  %30 = load i32, i32* %bufferedSize9, align 16, !tbaa !38
  %idx.ext = zext i32 %30 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay8, i64 %idx.ext
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr, i64 -64
  %31 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %32 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %32, i32 0, i32 7
  %33 = load i64, i64* %secretLimit11, align 8, !tbaa !34
  %add.ptr12 = getelementptr inbounds i8, i8* %31, i64 %33
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -7
  %34 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  call void @XXH3_accumulate_512_sse2(i8* %27, i8* %add.ptr10, i8* %add.ptr13, i32 %34)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %35 = bitcast i64* %nbStripesSoFar to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %35) #11
  %36 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %36) #11
  br label %if.end39

if.else:                                          ; preds = %entry
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 3
  %38 = load i32, i32* %bufferedSize14, align 16, !tbaa !38
  %tobool15 = icmp ne i32 %38, 0
  br i1 %tobool15, label %if.then16, label %if.end38

if.then16:                                        ; preds = %if.else
  %39 = bitcast [64 x i8]* %lastStripe to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %39) #11
  %40 = bitcast i64* %catchupSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %40) #11
  %41 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %41, i32 0, i32 3
  %42 = load i32, i32* %bufferedSize17, align 16, !tbaa !38
  %sub = sub i32 64, %42
  %conv18 = zext i32 %sub to i64
  store i64 %conv18, i64* %catchupSize, align 8, !tbaa !8
  %arraydecay19 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %43 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %43, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay21, i64 256
  %44 = load i64, i64* %catchupSize, align 8, !tbaa !8
  %idx.neg = sub i64 0, %44
  %add.ptr23 = getelementptr inbounds i8, i8* %add.ptr22, i64 %idx.neg
  %45 = load i64, i64* %catchupSize, align 8, !tbaa !8
  %call24 = call i8* @__memcpy_chk(i8* %arraydecay19, i8* %add.ptr23, i64 %45, i64 64) #11
  %arraydecay25 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %46 = load i64, i64* %catchupSize, align 8, !tbaa !8
  %add.ptr26 = getelementptr inbounds i8, i8* %arraydecay25, i64 %46
  %47 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer27 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %47, i32 0, i32 2
  %arraydecay28 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer27, i32 0, i32 0
  %48 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %bufferedSize29 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %48, i32 0, i32 3
  %49 = load i32, i32* %bufferedSize29, align 16, !tbaa !38
  %conv30 = zext i32 %49 to i64
  %arraydecay31 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %50 = load i64, i64* %catchupSize, align 8, !tbaa !8
  %add.ptr32 = getelementptr inbounds i8, i8* %arraydecay31, i64 %50
  %51 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr32, i1 false, i1 true)
  %call33 = call i8* @__memcpy_chk(i8* %add.ptr26, i8* %arraydecay28, i64 %conv30, i64 %51) #11
  %52 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %53 = bitcast i64* %52 to i8*
  %arraydecay34 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %54 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %55 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit35 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %55, i32 0, i32 7
  %56 = load i64, i64* %secretLimit35, align 8, !tbaa !34
  %add.ptr36 = getelementptr inbounds i8, i8* %54, i64 %56
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr36, i64 -7
  %57 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  call void @XXH3_accumulate_512_sse2(i8* %53, i8* %arraydecay34, i8* %add.ptr37, i32 %57)
  %58 = bitcast i64* %catchupSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %58) #11
  %59 = bitcast [64 x i8]* %lastStripe to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %59) #11
  br label %if.end38

if.end38:                                         ; preds = %if.then16, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH3_mergeAccs(i64* noalias %acc, i8* noalias %secret, i64 %start) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  %start.addr = alloca i64, align 8
  %result64 = alloca i64, align 8
  %i = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %start, i64* %start.addr, align 8, !tbaa !22
  %0 = bitcast i64* %result64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i64, i64* %start.addr, align 8, !tbaa !22
  store i64 %1, i64* %result64, align 8, !tbaa !22
  %2 = bitcast i64* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  store i64 0, i64* %i, align 8, !tbaa !8
  store i64 0, i64* %i, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64, i64* %i, align 8, !tbaa !8
  %cmp = icmp ult i64 %3, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %5 = load i64, i64* %i, align 8, !tbaa !8
  %mul = mul i64 2, %5
  %add.ptr = getelementptr inbounds i64, i64* %4, i64 %mul
  %6 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %7 = load i64, i64* %i, align 8, !tbaa !8
  %mul1 = mul i64 16, %7
  %add.ptr2 = getelementptr inbounds i8, i8* %6, i64 %mul1
  %call = call i64 @XXH3_mix2Accs(i64* %add.ptr, i8* %add.ptr2)
  %8 = load i64, i64* %result64, align 8, !tbaa !22
  %add = add i64 %8, %call
  store i64 %add, i64* %result64, align 8, !tbaa !22
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, i64* %i, align 8, !tbaa !8
  %inc = add i64 %9, 1
  store i64 %inc, i64* %i, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load i64, i64* %result64, align 8, !tbaa !22
  %call3 = call i64 @XXH3_avalanche(i64 %10)
  %11 = bitcast i64* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #11
  %12 = bitcast i64* %result64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #11
  ret i64 %call3
}

; Function Attrs: nounwind ssp uwtable
define void @XXH3_generateSecret(i8* %secretBuffer, i8* %customSeed, i64 %customSeedSize) #0 {
entry:
  %secretBuffer.addr = alloca i8*, align 8
  %customSeed.addr = alloca i8*, align 8
  %customSeedSize.addr = alloca i64, align 8
  %segmentSize = alloca i64, align 8
  %nbSegments = alloca i64, align 8
  %scrambler = alloca %struct.XXH128_canonical_t, align 1
  %seeds = alloca [12 x i64], align 16
  %segnb = alloca i64, align 8
  %agg.tmp = alloca %struct.XXH128_hash_t, align 8
  %toFill = alloca i64, align 8
  %filled = alloca i64, align 8
  %segmentStart = alloca i64, align 8
  %segment = alloca %struct.XXH128_canonical_t, align 1
  %agg.tmp18 = alloca %struct.XXH128_hash_t, align 8
  store i8* %secretBuffer, i8** %secretBuffer.addr, align 8, !tbaa !4
  store i8* %customSeed, i8** %customSeed.addr, align 8, !tbaa !4
  store i64 %customSeedSize, i64* %customSeedSize.addr, align 8, !tbaa !8
  %0 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !4
  %2 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !4
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 %3) #11
  br label %return

if.end:                                           ; preds = %entry
  %4 = bitcast i64* %segmentSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  store i64 16, i64* %segmentSize, align 8, !tbaa !8
  %5 = bitcast i64* %nbSegments to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #11
  store i64 12, i64* %nbSegments, align 8, !tbaa !8
  %6 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %6) #11
  %7 = bitcast [12 x i64]* %seeds to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* %7) #11
  %8 = bitcast i64* %segnb to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #11
  %9 = load i8*, i8** %customSeed.addr, align 8, !tbaa !4
  %10 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !8
  %call1 = call { i64, i64 } @XXH128(i8* %9, i64 %10, i64 0)
  %11 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = extractvalue { i64, i64 } %call1, 0
  store i64 %13, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = extractvalue { i64, i64 } %call1, 1
  store i64 %15, i64* %14, align 8
  %16 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %scrambler, i64 %18, i64 %20)
  %21 = bitcast i64* %toFill to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) #11
  %22 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !8
  %cmp2 = icmp ugt i64 %22, 96
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %23 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 96, %cond.true ], [ %23, %cond.false ]
  store i64 %cond, i64* %toFill, align 8, !tbaa !8
  %24 = bitcast i64* %filled to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #11
  %25 = load i64, i64* %toFill, align 8, !tbaa !8
  store i64 %25, i64* %filled, align 8, !tbaa !8
  %arraydecay = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %26 = bitcast i64* %arraydecay to i8*
  %27 = load i8*, i8** %customSeed.addr, align 8, !tbaa !4
  %28 = load i64, i64* %toFill, align 8, !tbaa !8
  %call3 = call i8* @__memcpy_chk(i8* %26, i8* %27, i64 %28, i64 96) #11
  br label %while.cond

while.cond:                                       ; preds = %cond.end9, %cond.end
  %29 = load i64, i64* %filled, align 8, !tbaa !8
  %cmp4 = icmp ult i64 %29, 96
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %30 = load i64, i64* %filled, align 8, !tbaa !8
  %31 = load i64, i64* %filled, align 8, !tbaa !8
  %sub = sub i64 96, %31
  %cmp5 = icmp ugt i64 %30, %sub
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %while.body
  %32 = load i64, i64* %filled, align 8, !tbaa !8
  %sub7 = sub i64 96, %32
  br label %cond.end9

cond.false8:                                      ; preds = %while.body
  %33 = load i64, i64* %filled, align 8, !tbaa !8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true6
  %cond10 = phi i64 [ %sub7, %cond.true6 ], [ %33, %cond.false8 ]
  store i64 %cond10, i64* %toFill, align 8, !tbaa !8
  %arraydecay11 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %34 = bitcast i64* %arraydecay11 to i8*
  %35 = load i64, i64* %filled, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %34, i64 %35
  %arraydecay12 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %36 = bitcast i64* %arraydecay12 to i8*
  %37 = load i64, i64* %toFill, align 8, !tbaa !8
  %arraydecay13 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %38 = bitcast i64* %arraydecay13 to i8*
  %39 = load i64, i64* %filled, align 8, !tbaa !8
  %add.ptr14 = getelementptr inbounds i8, i8* %38, i64 %39
  %40 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr14, i1 false, i1 true)
  %call15 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %36, i64 %37, i64 %40) #11
  %41 = load i64, i64* %toFill, align 8, !tbaa !8
  %42 = load i64, i64* %filled, align 8, !tbaa !8
  %add = add i64 %42, %41
  store i64 %add, i64* %filled, align 8, !tbaa !8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %43 = bitcast i64* %filled to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #11
  %44 = bitcast i64* %toFill to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %44) #11
  %45 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !4
  %46 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %47 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !4
  %48 = call i64 @llvm.objectsize.i64.p0i8(i8* %47, i1 false, i1 true)
  %call16 = call i8* @__memcpy_chk(i8* %45, i8* %46, i64 16, i64 %48) #11
  store i64 1, i64* %segnb, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %49 = load i64, i64* %segnb, align 8, !tbaa !8
  %cmp17 = icmp ult i64 %49, 12
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %50 = bitcast i64* %segmentStart to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %50) #11
  %51 = load i64, i64* %segnb, align 8, !tbaa !8
  %mul = mul i64 %51, 16
  store i64 %mul, i64* %segmentStart, align 8, !tbaa !8
  %52 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %52) #11
  %53 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %arraydecay19 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %54 = load i64, i64* %segnb, align 8, !tbaa !8
  %add.ptr20 = getelementptr inbounds i64, i64* %arraydecay19, i64 %54
  %55 = bitcast i64* %add.ptr20 to i8*
  %call21 = call i64 @XXH_readLE64(i8* %55)
  %56 = load i64, i64* %segnb, align 8, !tbaa !8
  %add22 = add i64 %call21, %56
  %call23 = call { i64, i64 } @XXH128(i8* %53, i64 16, i64 %add22)
  %57 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call23, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call23, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %segment, i64 %64, i64 %66)
  %67 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !4
  %68 = load i64, i64* %segmentStart, align 8, !tbaa !8
  %add.ptr24 = getelementptr inbounds i8, i8* %67, i64 %68
  %69 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  %70 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !4
  %71 = load i64, i64* %segmentStart, align 8, !tbaa !8
  %add.ptr25 = getelementptr inbounds i8, i8* %70, i64 %71
  %72 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr25, i1 false, i1 true)
  %call26 = call i8* @__memcpy_chk(i8* %add.ptr24, i8* %69, i64 16, i64 %72) #11
  %73 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %73) #11
  %74 = bitcast i64* %segmentStart to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %74) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %75 = load i64, i64* %segnb, align 8, !tbaa !8
  %inc = add i64 %75, 1
  store i64 %inc, i64* %segnb, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %76 = bitcast i64* %segnb to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %76) #11
  %77 = bitcast [12 x i64]* %seeds to i8*
  call void @llvm.lifetime.end.p0i8(i64 96, i8* %77) #11
  %78 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %78) #11
  %79 = bitcast i64* %nbSegments to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %79) #11
  %80 = bitcast i64* %segmentSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %80) #11
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %dst, i64 %hash.coerce0, i64 %hash.coerce1) #0 {
entry:
  %hash = alloca %struct.XXH128_hash_t, align 8
  %dst.addr = alloca %struct.XXH128_canonical_t*, align 8
  %0 = bitcast %struct.XXH128_hash_t* %hash to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %hash.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %hash.coerce1, i64* %2, align 8
  store %struct.XXH128_canonical_t* %dst, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %3 = load i64, i64* %high64, align 8, !tbaa !40
  %call = call i64 @XXH_swap64(i64 %3)
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  store i64 %call, i64* %high641, align 8, !tbaa !40
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %4 = load i64, i64* %low64, align 8, !tbaa !42
  %call2 = call i64 @XXH_swap64(i64 %4)
  %low643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  store i64 %call2, i64* %low643, align 8, !tbaa !42
  %5 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !4
  %6 = bitcast %struct.XXH128_canonical_t* %5 to i8*
  %high644 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %7 = bitcast i64* %high644 to i8*
  %8 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !4
  %9 = bitcast %struct.XXH128_canonical_t* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call5 = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 8, i64 %10) #11
  %11 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !4
  %12 = bitcast %struct.XXH128_canonical_t* %11 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 8
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %13 = bitcast i64* %low646 to i8*
  %14 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !4
  %15 = bitcast %struct.XXH128_canonical_t* %14 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %15, i64 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr7, i1 false, i1 true)
  %call8 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %13, i64 8, i64 %16) #11
  ret void
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH128(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call { i64, i64 } @XXH3_128bits_withSeed(i8* %0, i64 %1, i64 %2)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits(i8* %input, i64 %len) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSecret)
  %2 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_128bits_internal(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hl128.addr = alloca { i64, i64 } (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  store { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8, !tbaa !4
  %0 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %4 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call = call { i64, i64 } @XXH3_len_0to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp1 = icmp ule i64 %10, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %14 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %15 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call3 = call { i64, i64 } @XXH3_len_17to128_128b(i8* %11, i64 %12, i8* %13, i64 %14, i64 %15)
  %16 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call3, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call3, 1
  store i64 %20, i64* %19, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %21 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp5 = icmp ule i64 %21, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %22 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %23 = load i64, i64* %len.addr, align 8, !tbaa !8
  %24 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %25 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %26 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call7 = call { i64, i64 } @XXH3_len_129to240_128b(i8* %22, i64 %23, i8* %24, i64 %25, i64 %26)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call7, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call7, 1
  store i64 %31, i64* %30, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %32 = load { i64, i64 } (i8*, i64, i64, i8*, i64)*, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8, !tbaa !4
  %33 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %34 = load i64, i64* %len.addr, align 8, !tbaa !8
  %35 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %36 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %37 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %call9 = call { i64, i64 } %32(i8* %33, i64 %34, i64 %35, i8* %36, i64 %37)
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = extractvalue { i64, i64 } %call9, 0
  store i64 %40, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = extractvalue { i64, i64 } %call9, 1
  store i64 %42, i64* %41, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %43 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %44 = load { i64, i64 }, { i64, i64 }* %43, align 8
  ret { i64, i64 } %44
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %4 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_defaultSecret)
  %4 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = extractvalue { i64, i64 } %call, 0
  store i64 %6, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = extractvalue { i64, i64 } %call, 1
  store i64 %8, i64* %7, align 8
  %9 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_defaultSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %1 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %2 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %4 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %3, i64 %4, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %1 = load i64, i64* %len.addr, align 8, !tbaa !8
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSeed)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !8
  %0 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %1 = load i64, i64* %secretLen.addr, align 8, !tbaa !8
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %4 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %call = call { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %1 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %0, i64 %1, i8* %2, i64 %3)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !22
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !22
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !4
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8, !tbaa !33
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 1, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  %cleanup.dest.slot = alloca i32, align 4
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %0 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %1, i32 0, i32 11
  %2 = load i8*, i8** %extSecret, align 8, !tbaa !33
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %4, i32 0, i32 11
  %5 = load i8*, i8** %extSecret1, align 8, !tbaa !33
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %5, %cond.false ]
  store i8* %cond, i8** %secret, align 8, !tbaa !4
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 8
  %7 = load i64, i64* %totalLen, align 16, !tbaa !37
  %cmp2 = icmp ugt i64 %7, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %8 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %8) #11
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %10 = load i8*, i8** %secret, align 8, !tbaa !4
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %9, i8* %10, i32 1)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %11 = load i8*, i8** %secret, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 11
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 8
  %13 = load i64, i64* %totalLen5, align 16, !tbaa !37
  %mul = mul i64 %13, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call, i64* %low64, align 8, !tbaa !42
  %arraydecay6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %14 = load i8*, i8** %secret, align 8, !tbaa !4
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 7
  %16 = load i64, i64* %secretLimit, align 8, !tbaa !34
  %add.ptr7 = getelementptr inbounds i8, i8* %14, i64 %16
  %add.ptr8 = getelementptr inbounds i8, i8* %add.ptr7, i64 64
  %add.ptr9 = getelementptr inbounds i8, i8* %add.ptr8, i64 -64
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -11
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 8
  %18 = load i64, i64* %totalLen11, align 16, !tbaa !37
  %mul12 = mul i64 %18, -4417276706812531889
  %neg = xor i64 %mul12, -1
  %call13 = call i64 @XXH3_mergeAccs(i64* %arraydecay6, i8* %add.ptr10, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call13, i64* %high64, align 8, !tbaa !40
  store i32 1, i32* %cleanup.dest.slot, align 4
  %19 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %19) #11
  br label %cleanup

if.end:                                           ; preds = %cond.end
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 9
  %21 = load i64, i64* %seed, align 8, !tbaa !31
  %tobool = icmp ne i64 %21, 0
  br i1 %tobool, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.end
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 2
  %arraydecay15 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %23 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %23, i32 0, i32 8
  %24 = load i64, i64* %totalLen16, align 16, !tbaa !37
  %25 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %seed17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %25, i32 0, i32 9
  %26 = load i64, i64* %seed17, align 8, !tbaa !31
  %call18 = call { i64, i64 } @XXH3_128bits_withSeed(i8* %arraydecay15, i64 %24, i64 %26)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call18, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call18, 1
  store i64 %31, i64* %30, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end19:                                         ; preds = %if.end
  %32 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %32, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %33 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %totalLen22 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %33, i32 0, i32 8
  %34 = load i64, i64* %totalLen22, align 16, !tbaa !37
  %35 = load i8*, i8** %secret, align 8, !tbaa !4
  %36 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !4
  %secretLimit23 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %36, i32 0, i32 7
  %37 = load i64, i64* %secretLimit23, align 8, !tbaa !34
  %add = add i64 %37, 64
  %call24 = call { i64, i64 } @XXH3_128bits_withSecret(i8* %arraydecay21, i64 %34, i8* %35, i64 %add)
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = extractvalue { i64, i64 } %call24, 0
  store i64 %40, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = extractvalue { i64, i64 } %call24, 1
  store i64 %42, i64* %41, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then14, %if.then
  %43 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #11
  %44 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %45 = load { i64, i64 }, { i64, i64 }* %44, align 8
  ret { i64, i64 } %45
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH128_isEqual(i64 %h1.coerce0, i64 %h1.coerce1, i64 %h2.coerce0, i64 %h2.coerce1) #0 {
entry:
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %0 = bitcast %struct.XXH128_hash_t* %h1 to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %h1.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %h1.coerce1, i64* %2, align 8
  %3 = bitcast %struct.XXH128_hash_t* %h2 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %h2.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %h2.coerce1, i64* %5, align 8
  %6 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %7 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %call = call i32 @memcmp(i8* %6, i8* %7, i64 16)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i32 @memcmp(i8*, i8*, i64) #7

; Function Attrs: nounwind ssp uwtable
define i32 @XXH128_cmp(i8* %h128_1, i8* %h128_2) #0 {
entry:
  %retval = alloca i32, align 4
  %h128_1.addr = alloca i8*, align 8
  %h128_2.addr = alloca i8*, align 8
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %hcmp = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store i8* %h128_1, i8** %h128_1.addr, align 8, !tbaa !4
  store i8* %h128_2, i8** %h128_2.addr, align 8, !tbaa !4
  %0 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #11
  %1 = load i8*, i8** %h128_1.addr, align 8, !tbaa !4
  %2 = bitcast i8* %1 to %struct.XXH128_hash_t*
  %3 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %4 = bitcast %struct.XXH128_hash_t* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 16, i1 false), !tbaa.struct !43
  %5 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %5) #11
  %6 = load i8*, i8** %h128_2.addr, align 8, !tbaa !4
  %7 = bitcast i8* %6 to %struct.XXH128_hash_t*
  %8 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %9 = bitcast %struct.XXH128_hash_t* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %9, i64 16, i1 false), !tbaa.struct !43
  %10 = bitcast i32* %hcmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %10) #11
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %11 = load i64, i64* %high64, align 8, !tbaa !40
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %12 = load i64, i64* %high641, align 8, !tbaa !40
  %cmp = icmp ugt i64 %11, %12
  %conv = zext i1 %cmp to i32
  %high642 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %13 = load i64, i64* %high642, align 8, !tbaa !40
  %high643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %14 = load i64, i64* %high643, align 8, !tbaa !40
  %cmp4 = icmp ugt i64 %13, %14
  %conv5 = zext i1 %cmp4 to i32
  %sub = sub nsw i32 %conv, %conv5
  store i32 %sub, i32* %hcmp, align 4, !tbaa !10
  %15 = load i32, i32* %hcmp, align 4, !tbaa !10
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load i32, i32* %hcmp, align 4, !tbaa !10
  store i32 %16, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %17 = load i64, i64* %low64, align 8, !tbaa !42
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %18 = load i64, i64* %low646, align 8, !tbaa !42
  %cmp7 = icmp ugt i64 %17, %18
  %conv8 = zext i1 %cmp7 to i32
  %low649 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %19 = load i64, i64* %low649, align 8, !tbaa !42
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %20 = load i64, i64* %low6410, align 8, !tbaa !42
  %cmp11 = icmp ugt i64 %19, %20
  %conv12 = zext i1 %cmp11 to i32
  %sub13 = sub nsw i32 %conv8, %conv12
  store i32 %sub13, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %21 = bitcast i32* %hcmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %21) #11
  %22 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %22) #11
  %23 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %23) #11
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #4

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH128_hashFromCanonical(%struct.XXH128_canonical_t* %src) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %src.addr = alloca %struct.XXH128_canonical_t*, align 8
  store %struct.XXH128_canonical_t* %src, %struct.XXH128_canonical_t** %src.addr, align 8, !tbaa !4
  %0 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8, !tbaa !4
  %1 = bitcast %struct.XXH128_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call, i64* %high64, align 8, !tbaa !40
  %2 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8, !tbaa !4
  %digest = getelementptr inbounds %struct.XXH128_canonical_t, %struct.XXH128_canonical_t* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %digest, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 8
  %call1 = call i64 @XXH_readBE64(i8* %add.ptr)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call1, i64* %low64, align 8, !tbaa !42
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = load { i64, i64 }, { i64, i64 }* %3, align 8
  ret { i64, i64 } %4
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH_readLE32_align(i8* %ptr, i32 %align) #1 {
entry:
  %retval = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  store i32 %align, i32* %align.addr, align 4, !tbaa !12
  %0 = load i32, i32* %align.addr, align 4, !tbaa !12
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %call = call i32 @XXH_readLE32(i8* %1)
  store i32 %call, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3, align 4, !tbaa !10
  store i32 %4, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #8

declare void @free(i8*) #7

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH_read32(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i32, align 4
  store i8* %memPtr, i8** %memPtr.addr, align 8, !tbaa !4
  %0 = bitcast i32* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #11
  %1 = bitcast i32* %val to i8*
  %2 = load i8*, i8** %memPtr.addr, align 8, !tbaa !4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %1, i8* align 1 %2, i64 4, i1 false)
  %3 = load i32, i32* %val, align 4, !tbaa !10
  %4 = bitcast i32* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #11
  ret i32 %3
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH32_avalanche(i32 %h32) #0 {
entry:
  %h32.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4, !tbaa !10
  %0 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %shr = lshr i32 %0, 15
  %1 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %xor = xor i32 %1, %shr
  store i32 %xor, i32* %h32.addr, align 4, !tbaa !10
  %2 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %mul = mul i32 %2, -2048144777
  store i32 %mul, i32* %h32.addr, align 4, !tbaa !10
  %3 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %shr1 = lshr i32 %3, 13
  %4 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %xor2 = xor i32 %4, %shr1
  store i32 %xor2, i32* %h32.addr, align 4, !tbaa !10
  %5 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %mul3 = mul i32 %5, -1028477379
  store i32 %mul3, i32* %h32.addr, align 4, !tbaa !10
  %6 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %shr4 = lshr i32 %6, 16
  %7 = load i32, i32* %h32.addr, align 4, !tbaa !10
  %xor5 = xor i32 %7, %shr4
  store i32 %xor5, i32* %h32.addr, align 4, !tbaa !10
  %8 = load i32, i32* %h32.addr, align 4, !tbaa !10
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH_readLE64_align(i8* %ptr, i32 %align) #1 {
entry:
  %retval = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !4
  store i32 %align, i32* %align.addr, align 4, !tbaa !12
  %0 = load i32, i32* %align.addr, align 4, !tbaa !12
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %call = call i64 @XXH_readLE64(i8* %1)
  store i64 %call, i64* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8, !tbaa !4
  %3 = bitcast i8* %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !22
  store i64 %4, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i64, i64* %retval, align 8
  ret i64 %5
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH_read64(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i64, align 8
  store i8* %memPtr, i8** %memPtr.addr, align 8, !tbaa !4
  %0 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = bitcast i64* %val to i8*
  %2 = load i8*, i8** %memPtr.addr, align 8, !tbaa !4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1, i8* align 1 %2, i64 8, i1 false)
  %3 = load i64, i64* %val, align 8, !tbaa !22
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #11
  ret i64 %3
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8, !tbaa !22
  %0 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %shr = lshr i64 %0, 33
  %1 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor = xor i64 %1, %shr
  store i64 %xor, i64* %h64.addr, align 8, !tbaa !22
  %2 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %mul = mul i64 %2, -4417276706812531889
  store i64 %mul, i64* %h64.addr, align 8, !tbaa !22
  %3 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %shr1 = lshr i64 %3, 29
  %4 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor2 = xor i64 %4, %shr1
  store i64 %xor2, i64* %h64.addr, align 8, !tbaa !22
  %5 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %mul3 = mul i64 %5, 1609587929392839161
  store i64 %mul3, i64* %h64.addr, align 8, !tbaa !22
  %6 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %shr4 = lshr i64 %6, 32
  %7 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %xor5 = xor i64 %7, %shr4
  store i64 %xor5, i64* %h64.addr, align 8, !tbaa !22
  %8 = load i64, i64* %h64.addr, align 8, !tbaa !22
  ret i64 %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_0to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp ugt i64 %0, 8
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_len_9to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp2 = icmp uge i64 %5, 4
  %conv3 = zext i1 %cmp2 to i32
  %conv4 = sext i32 %conv3 to i64
  %expval5 = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool6 = icmp ne i64 %expval5, 0
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %7 = load i64, i64* %len.addr, align 8, !tbaa !8
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %9 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call8 = call i64 @XXH3_len_4to8_64b(i8* %6, i64 %7, i8* %8, i64 %9)
  store i64 %call8, i64* %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  %10 = load i64, i64* %len.addr, align 8, !tbaa !8
  %tobool10 = icmp ne i64 %10, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end9
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call12 = call i64 @XXH3_len_1to3_64b(i8* %11, i64 %12, i8* %13, i64 %14)
  store i64 %call12, i64* %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end9
  %15 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 -7046029288634856825, %15
  %16 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 56
  %call14 = call i64 @XXH_readLE64(i8* %add.ptr)
  %17 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr15 = getelementptr inbounds i8, i8* %17, i64 64
  %call16 = call i64 @XXH_readLE64(i8* %add.ptr15)
  %xor = xor i64 %call14, %call16
  %xor17 = xor i64 %add, %xor
  %call18 = call i64 @XXH3_avalanche(i64 %xor17)
  store i64 %call18, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.then11, %if.then7, %if.then
  %18 = load i64, i64* %retval, align 8
  ret i64 %18
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_17to128_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %1 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul = mul i64 %2, -7046029288634856825
  store i64 %mul, i64* %acc, align 8, !tbaa !22
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp ugt i64 %3, 32
  br i1 %cmp, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp1 = icmp ugt i64 %4, 64
  br i1 %cmp1, label %if.then2, label %if.end20

if.then2:                                         ; preds = %if.then
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp3 = icmp ugt i64 %5, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 48
  %7 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr5 = getelementptr inbounds i8, i8* %7, i64 96
  %8 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %8)
  %9 = load i64, i64* %acc, align 8, !tbaa !22
  %add = add i64 %9, %call
  store i64 %add, i64* %acc, align 8, !tbaa !22
  %10 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %11 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr6 = getelementptr inbounds i8, i8* %10, i64 %11
  %add.ptr7 = getelementptr inbounds i8, i8* %add.ptr6, i64 -64
  %12 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr8 = getelementptr inbounds i8, i8* %12, i64 112
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call9 = call i64 @XXH3_mix16B(i8* %add.ptr7, i8* %add.ptr8, i64 %13)
  %14 = load i64, i64* %acc, align 8, !tbaa !22
  %add10 = add i64 %14, %call9
  store i64 %add10, i64* %acc, align 8, !tbaa !22
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %15 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr11 = getelementptr inbounds i8, i8* %15, i64 32
  %16 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr12 = getelementptr inbounds i8, i8* %16, i64 64
  %17 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call13 = call i64 @XXH3_mix16B(i8* %add.ptr11, i8* %add.ptr12, i64 %17)
  %18 = load i64, i64* %acc, align 8, !tbaa !22
  %add14 = add i64 %18, %call13
  store i64 %add14, i64* %acc, align 8, !tbaa !22
  %19 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %20 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr15 = getelementptr inbounds i8, i8* %19, i64 %20
  %add.ptr16 = getelementptr inbounds i8, i8* %add.ptr15, i64 -48
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr17 = getelementptr inbounds i8, i8* %21, i64 80
  %22 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr16, i8* %add.ptr17, i64 %22)
  %23 = load i64, i64* %acc, align 8, !tbaa !22
  %add19 = add i64 %23, %call18
  store i64 %add19, i64* %acc, align 8, !tbaa !22
  br label %if.end20

if.end20:                                         ; preds = %if.end, %if.then
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr21 = getelementptr inbounds i8, i8* %24, i64 16
  %25 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr22 = getelementptr inbounds i8, i8* %25, i64 32
  %26 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call23 = call i64 @XXH3_mix16B(i8* %add.ptr21, i8* %add.ptr22, i64 %26)
  %27 = load i64, i64* %acc, align 8, !tbaa !22
  %add24 = add i64 %27, %call23
  store i64 %add24, i64* %acc, align 8, !tbaa !22
  %28 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %29 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr25 = getelementptr inbounds i8, i8* %28, i64 %29
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -32
  %30 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr27 = getelementptr inbounds i8, i8* %30, i64 48
  %31 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call28 = call i64 @XXH3_mix16B(i8* %add.ptr26, i8* %add.ptr27, i64 %31)
  %32 = load i64, i64* %acc, align 8, !tbaa !22
  %add29 = add i64 %32, %call28
  store i64 %add29, i64* %acc, align 8, !tbaa !22
  br label %if.end30

if.end30:                                         ; preds = %if.end20, %entry
  %33 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr31 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr32 = getelementptr inbounds i8, i8* %34, i64 0
  %35 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call33 = call i64 @XXH3_mix16B(i8* %add.ptr31, i8* %add.ptr32, i64 %35)
  %36 = load i64, i64* %acc, align 8, !tbaa !22
  %add34 = add i64 %36, %call33
  store i64 %add34, i64* %acc, align 8, !tbaa !22
  %37 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %38 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr35 = getelementptr inbounds i8, i8* %37, i64 %38
  %add.ptr36 = getelementptr inbounds i8, i8* %add.ptr35, i64 -16
  %39 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr37 = getelementptr inbounds i8, i8* %39, i64 16
  %40 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call38 = call i64 @XXH3_mix16B(i8* %add.ptr36, i8* %add.ptr37, i64 %40)
  %41 = load i64, i64* %acc, align 8, !tbaa !22
  %add39 = add i64 %41, %call38
  store i64 %add39, i64* %acc, align 8, !tbaa !22
  %42 = load i64, i64* %acc, align 8, !tbaa !22
  %call40 = call i64 @XXH3_avalanche(i64 %42)
  %43 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #11
  ret i64 %call40
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @XXH3_len_129to240_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #5 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %1 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #11
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul = mul i64 %2, -7046029288634856825
  store i64 %mul, i64* %acc, align 8, !tbaa !22
  %3 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #11
  %4 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv = trunc i64 %4 to i32
  %div = sdiv i32 %conv, 16
  store i32 %div, i32* %nbRounds, align 4, !tbaa !10
  %5 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #11
  store i32 0, i32* %i, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4, !tbaa !10
  %cmp = icmp slt i32 %6, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %8 = load i32, i32* %i, align 4, !tbaa !10
  %mul2 = mul nsw i32 16, %8
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %idx.ext
  %9 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %10 = load i32, i32* %i, align 4, !tbaa !10
  %mul3 = mul nsw i32 16, %10
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %9, i64 %idx.ext4
  %11 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %11)
  %12 = load i64, i64* %acc, align 8, !tbaa !22
  %add = add i64 %12, %call
  store i64 %add, i64* %acc, align 8, !tbaa !22
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, i32* %i, align 4, !tbaa !10
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4, !tbaa !10
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i64, i64* %acc, align 8, !tbaa !22
  %call6 = call i64 @XXH3_avalanche(i64 %14)
  store i64 %call6, i64* %acc, align 8, !tbaa !22
  store i32 8, i32* %i, align 4, !tbaa !10
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc20, %for.end
  %15 = load i32, i32* %i, align 4, !tbaa !10
  %16 = load i32, i32* %nbRounds, align 4, !tbaa !10
  %cmp8 = icmp slt i32 %15, %16
  br i1 %cmp8, label %for.body10, label %for.end22

for.body10:                                       ; preds = %for.cond7
  %17 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %18 = load i32, i32* %i, align 4, !tbaa !10
  %mul11 = mul nsw i32 16, %18
  %idx.ext12 = sext i32 %mul11 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %17, i64 %idx.ext12
  %19 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %20 = load i32, i32* %i, align 4, !tbaa !10
  %sub = sub nsw i32 %20, 8
  %mul14 = mul nsw i32 16, %sub
  %idx.ext15 = sext i32 %mul14 to i64
  %add.ptr16 = getelementptr inbounds i8, i8* %19, i64 %idx.ext15
  %add.ptr17 = getelementptr inbounds i8, i8* %add.ptr16, i64 3
  %21 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr13, i8* %add.ptr17, i64 %21)
  %22 = load i64, i64* %acc, align 8, !tbaa !22
  %add19 = add i64 %22, %call18
  store i64 %add19, i64* %acc, align 8, !tbaa !22
  br label %for.inc20

for.inc20:                                        ; preds = %for.body10
  %23 = load i32, i32* %i, align 4, !tbaa !10
  %inc21 = add nsw i32 %23, 1
  store i32 %inc21, i32* %i, align 4, !tbaa !10
  br label %for.cond7

for.end22:                                        ; preds = %for.cond7
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %25 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr23 = getelementptr inbounds i8, i8* %24, i64 %25
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %26 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr25 = getelementptr inbounds i8, i8* %26, i64 136
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -17
  %27 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call27 = call i64 @XXH3_mix16B(i8* %add.ptr24, i8* %add.ptr26, i64 %27)
  %28 = load i64, i64* %acc, align 8, !tbaa !22
  %add28 = add i64 %28, %call27
  store i64 %add28, i64* %acc, align 8, !tbaa !22
  %29 = load i64, i64* %acc, align 8, !tbaa !22
  %call29 = call i64 @XXH3_avalanche(i64 %29)
  %30 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #11
  %31 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #11
  %32 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #11
  ret i64 %call29
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #9

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_9to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflip1 = alloca i64, align 8
  %bitflip2 = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = bitcast i64* %bitflip1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 24
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 32
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %3 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 %xor, %3
  store i64 %add, i64* %bitflip1, align 8, !tbaa !22
  %4 = bitcast i64* %bitflip2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr3 = getelementptr inbounds i8, i8* %5, i64 40
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %6 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 48
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %7 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 %xor7, %7
  store i64 %sub, i64* %bitflip2, align 8, !tbaa !22
  %8 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #11
  %9 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %call8 = call i64 @XXH_readLE64(i8* %9)
  %10 = load i64, i64* %bitflip1, align 8, !tbaa !22
  %xor9 = xor i64 %call8, %10
  store i64 %xor9, i64* %input_lo, align 8, !tbaa !22
  %11 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #11
  %12 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %13 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr10 = getelementptr inbounds i8, i8* %12, i64 %13
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -8
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %14 = load i64, i64* %bitflip2, align 8, !tbaa !22
  %xor13 = xor i64 %call12, %14
  store i64 %xor13, i64* %input_hi, align 8, !tbaa !22
  %15 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %15) #11
  %16 = load i64, i64* %len.addr, align 8, !tbaa !8
  %17 = load i64, i64* %input_lo, align 8, !tbaa !22
  %call14 = call i64 @XXH_swap64(i64 %17)
  %add15 = add i64 %16, %call14
  %18 = load i64, i64* %input_hi, align 8, !tbaa !22
  %add16 = add i64 %add15, %18
  %19 = load i64, i64* %input_lo, align 8, !tbaa !22
  %20 = load i64, i64* %input_hi, align 8, !tbaa !22
  %call17 = call i64 @XXH3_mul128_fold64(i64 %19, i64 %20)
  %add18 = add i64 %add16, %call17
  store i64 %add18, i64* %acc, align 8, !tbaa !22
  %21 = load i64, i64* %acc, align 8, !tbaa !22
  %call19 = call i64 @XXH3_avalanche(i64 %21)
  %22 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #11
  %23 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #11
  %24 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #11
  %25 = bitcast i64* %bitflip2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %25) #11
  %26 = bitcast i64* %bitflip1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %26) #11
  ret i64 %call19
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_4to8_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input1 = alloca i32, align 4
  %input2 = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %input64 = alloca i64, align 8
  %x = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8, !tbaa !22
  %2 = bitcast i32* %input1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %call2 = call i32 @XXH_readLE32(i8* %3)
  store i32 %call2, i32* %input1, align 4, !tbaa !10
  %4 = bitcast i32* %input2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %6 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 %6
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input2, align 4, !tbaa !10
  %7 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #11
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr5 = getelementptr inbounds i8, i8* %8, i64 8
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %9 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr7 = getelementptr inbounds i8, i8* %9, i64 16
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr7)
  %xor9 = xor i64 %call6, %call8
  %10 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 %xor9, %10
  store i64 %sub, i64* %bitflip, align 8, !tbaa !22
  %11 = bitcast i64* %input64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #11
  %12 = load i32, i32* %input2, align 4, !tbaa !10
  %conv10 = zext i32 %12 to i64
  %13 = load i32, i32* %input1, align 4, !tbaa !10
  %conv11 = zext i32 %13 to i64
  %shl12 = shl i64 %conv11, 32
  %add = add i64 %conv10, %shl12
  store i64 %add, i64* %input64, align 8, !tbaa !22
  %14 = bitcast i64* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #11
  %15 = load i64, i64* %input64, align 8, !tbaa !22
  %16 = load i64, i64* %bitflip, align 8, !tbaa !22
  %xor13 = xor i64 %15, %16
  store i64 %xor13, i64* %x, align 8, !tbaa !22
  %17 = load i64, i64* %x, align 8, !tbaa !22
  %18 = call i64 @llvm.fshl.i64(i64 %17, i64 %17, i64 49)
  %19 = load i64, i64* %x, align 8, !tbaa !22
  %20 = call i64 @llvm.fshl.i64(i64 %19, i64 %19, i64 24)
  %xor14 = xor i64 %18, %20
  %21 = load i64, i64* %x, align 8, !tbaa !22
  %xor15 = xor i64 %21, %xor14
  store i64 %xor15, i64* %x, align 8, !tbaa !22
  %22 = load i64, i64* %x, align 8, !tbaa !22
  %mul = mul i64 %22, -6939452855193903323
  store i64 %mul, i64* %x, align 8, !tbaa !22
  %23 = load i64, i64* %x, align 8, !tbaa !22
  %shr = lshr i64 %23, 35
  %24 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add16 = add i64 %shr, %24
  %25 = load i64, i64* %x, align 8, !tbaa !22
  %xor17 = xor i64 %25, %add16
  store i64 %xor17, i64* %x, align 8, !tbaa !22
  %26 = load i64, i64* %x, align 8, !tbaa !22
  %mul18 = mul i64 %26, -6939452855193903323
  store i64 %mul18, i64* %x, align 8, !tbaa !22
  %27 = load i64, i64* %x, align 8, !tbaa !22
  %call19 = call i64 @XXH_xorshift64(i64 %27, i32 28)
  %28 = bitcast i64* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #11
  %29 = bitcast i64* %input64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %29) #11
  %30 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) #11
  %31 = bitcast i32* %input2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #11
  %32 = bitcast i32* %input1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #11
  ret i64 %call19
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_1to3_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combined = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  %mixed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c1) #11
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !12
  store i8 %1, i8* %c1, align 1, !tbaa !12
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c2) #11
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1, !tbaa !12
  store i8 %4, i8* %c2, align 1, !tbaa !12
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c3) #11
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %6 = load i64, i64* %len.addr, align 8, !tbaa !8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1, !tbaa !12
  store i8 %7, i8* %c3, align 1, !tbaa !12
  %8 = bitcast i32* %combined to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #11
  %9 = load i8, i8* %c1, align 1, !tbaa !12
  %conv = zext i8 %9 to i32
  %shl = shl i32 %conv, 16
  %10 = load i8, i8* %c2, align 1, !tbaa !12
  %conv3 = zext i8 %10 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %11 = load i8, i8* %c3, align 1, !tbaa !12
  %conv5 = zext i8 %11 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv8 = trunc i64 %12 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combined, align 4, !tbaa !10
  %13 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #11
  %14 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %call = call i32 @XXH_readLE32(i8* %14)
  %15 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 4
  %call11 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call, %call11
  %conv12 = zext i32 %xor to i64
  %16 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 %conv12, %16
  store i64 %add, i64* %bitflip, align 8, !tbaa !22
  %17 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #11
  %18 = load i32, i32* %combined, align 4, !tbaa !10
  %conv13 = zext i32 %18 to i64
  %19 = load i64, i64* %bitflip, align 8, !tbaa !22
  %xor14 = xor i64 %conv13, %19
  store i64 %xor14, i64* %keyed, align 8, !tbaa !22
  %20 = bitcast i64* %mixed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #11
  %21 = load i64, i64* %keyed, align 8, !tbaa !22
  %mul = mul i64 %21, -7046029288634856825
  store i64 %mul, i64* %mixed, align 8, !tbaa !22
  %22 = load i64, i64* %mixed, align 8, !tbaa !22
  %call15 = call i64 @XXH3_avalanche(i64 %22)
  %23 = bitcast i64* %mixed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #11
  %24 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #11
  %25 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %25) #11
  %26 = bitcast i32* %combined to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c3) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c2) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c1) #11
  ret i64 %call15
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH3_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8, !tbaa !22
  %0 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call = call i64 @XXH_xorshift64(i64 %0, i32 37)
  store i64 %call, i64* %h64.addr, align 8, !tbaa !22
  %1 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %mul = mul i64 %1, 1609587791953885689
  store i64 %mul, i64* %h64.addr, align 8, !tbaa !22
  %2 = load i64, i64* %h64.addr, align 8, !tbaa !22
  %call1 = call i64 @XXH_xorshift64(i64 %2, i32 32)
  store i64 %call1, i64* %h64.addr, align 8, !tbaa !22
  %3 = load i64, i64* %h64.addr, align 8, !tbaa !22
  ret i64 %3
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH3_mul128_fold64(i64 %lhs, i64 %rhs) #0 {
entry:
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca %struct.XXH128_hash_t, align 8
  store i64 %lhs, i64* %lhs.addr, align 8, !tbaa !22
  store i64 %rhs, i64* %rhs.addr, align 8, !tbaa !22
  %0 = bitcast %struct.XXH128_hash_t* %product to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #11
  %1 = load i64, i64* %lhs.addr, align 8, !tbaa !22
  %2 = load i64, i64* %rhs.addr, align 8, !tbaa !22
  %call = call { i64, i64 } @XXH_mult64to128(i64 %1, i64 %2)
  %3 = bitcast %struct.XXH128_hash_t* %product to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 0
  %8 = load i64, i64* %low64, align 8, !tbaa !42
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 1
  %9 = load i64, i64* %high64, align 8, !tbaa !40
  %xor = xor i64 %8, %9
  %10 = bitcast %struct.XXH128_hash_t* %product to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #11
  ret i64 %xor
}

; Function Attrs: nounwind ssp uwtable
define internal { i64, i64 } @XXH_mult64to128(i64 %lhs, i64 %rhs) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca i128, align 16
  store i64 %lhs, i64* %lhs.addr, align 8, !tbaa !22
  store i64 %rhs, i64* %rhs.addr, align 8, !tbaa !22
  %0 = bitcast i128* %product to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #11
  %1 = load i64, i64* %lhs.addr, align 8, !tbaa !22
  %conv = zext i64 %1 to i128
  %2 = load i64, i64* %rhs.addr, align 8, !tbaa !22
  %conv1 = zext i64 %2 to i128
  %mul = mul i128 %conv, %conv1
  store i128 %mul, i128* %product, align 16, !tbaa !44
  %3 = load i128, i128* %product, align 16, !tbaa !44
  %conv2 = trunc i128 %3 to i64
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %conv2, i64* %low64, align 8, !tbaa !42
  %4 = load i128, i128* %product, align 16, !tbaa !44
  %shr = lshr i128 %4, 64
  %conv3 = trunc i128 %shr to i64
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %conv3, i64* %high64, align 8, !tbaa !40
  %5 = bitcast i128* %product to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %5) #11
  %6 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %7 = load { i64, i64 }, { i64, i64 }* %6, align 8
  ret { i64, i64 } %7
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH_xorshift64(i64 %v64, i32 %shift) #1 {
entry:
  %v64.addr = alloca i64, align 8
  %shift.addr = alloca i32, align 4
  store i64 %v64, i64* %v64.addr, align 8, !tbaa !22
  store i32 %shift, i32* %shift.addr, align 4, !tbaa !10
  %0 = load i64, i64* %v64.addr, align 8, !tbaa !22
  %1 = load i64, i64* %v64.addr, align 8, !tbaa !22
  %2 = load i32, i32* %shift.addr, align 4, !tbaa !10
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %1, %sh_prom
  %xor = xor i64 %0, %shr
  ret i64 %xor
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_mix16B(i8* noalias %input, i8* noalias %secret, i64 %seed64) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  %0 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %call = call i64 @XXH_readLE64(i8* %1)
  store i64 %call, i64* %input_lo, align 8, !tbaa !22
  %2 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 8
  %call1 = call i64 @XXH_readLE64(i8* %add.ptr)
  store i64 %call1, i64* %input_hi, align 8, !tbaa !22
  %4 = load i64, i64* %input_lo, align 8, !tbaa !22
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %call2 = call i64 @XXH_readLE64(i8* %5)
  %6 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %add = add i64 %call2, %6
  %xor = xor i64 %4, %add
  %7 = load i64, i64* %input_hi, align 8, !tbaa !22
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr3 = getelementptr inbounds i8, i8* %8, i64 8
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %9 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %sub = sub i64 %call4, %9
  %xor5 = xor i64 %7, %sub
  %call6 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor5)
  %10 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #11
  %11 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #11
  ret i64 %call6
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #11
  %1 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %1, i8* align 16 bitcast ([8 x i64]* @__const.XXH3_hashLong_64b_internal.acc to i8*), i64 64, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %6 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %7 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %2, i64 %3, i8* %4, i64 %5, i32 0, void (i8*, i8*, i8*, i32)* %6, void (i8*, i8*)* %7)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 11
  %9 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul = mul i64 %9, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  %10 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %10) #11
  ret i64 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_hashLong_internal_loop(i64* noalias %acc, i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nb_rounds = alloca i64, align 8
  %block_len = alloca i64, align 8
  %nb_blocks = alloca i64, align 8
  %n = alloca i64, align 8
  %nbStripes = alloca i64, align 8
  %p = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !12
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %0 = bitcast i64* %nb_rounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %sub = sub i64 %1, 64
  %div = udiv i64 %sub, 8
  store i64 %div, i64* %nb_rounds, align 8, !tbaa !8
  %2 = bitcast i64* %block_len to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #11
  %3 = load i64, i64* %nb_rounds, align 8, !tbaa !8
  %mul = mul i64 64, %3
  store i64 %mul, i64* %block_len, align 8, !tbaa !8
  %4 = bitcast i64* %nb_blocks to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %6 = load i64, i64* %block_len, align 8, !tbaa !8
  %div1 = udiv i64 %5, %6
  store i64 %div1, i64* %nb_blocks, align 8, !tbaa !8
  %7 = bitcast i64* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #11
  store i64 0, i64* %n, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i64, i64* %n, align 8, !tbaa !8
  %9 = load i64, i64* %nb_blocks, align 8, !tbaa !8
  %cmp = icmp ult i64 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %12 = load i64, i64* %n, align 8, !tbaa !8
  %13 = load i64, i64* %block_len, align 8, !tbaa !8
  %mul2 = mul i64 %12, %13
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 %mul2
  %14 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %15 = load i64, i64* %nb_rounds, align 8, !tbaa !8
  %16 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %17 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  call void @XXH3_accumulate(i64* %10, i8* %add.ptr, i8* %14, i64 %15, i32 %16, void (i8*, i8*, i8*, i32)* %17)
  %18 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %19 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %20 = bitcast i64* %19 to i8*
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %22 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %add.ptr3 = getelementptr inbounds i8, i8* %21, i64 %22
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  call void %18(i8* %20, i8* %add.ptr4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i64, i64* %n, align 8, !tbaa !8
  %inc = add i64 %23, 1
  store i64 %inc, i64* %n, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %24 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #11
  %25 = load i64, i64* %len.addr, align 8, !tbaa !8
  %26 = load i64, i64* %block_len, align 8, !tbaa !8
  %27 = load i64, i64* %nb_blocks, align 8, !tbaa !8
  %mul5 = mul i64 %26, %27
  %sub6 = sub i64 %25, %mul5
  %div7 = udiv i64 %sub6, 64
  store i64 %div7, i64* %nbStripes, align 8, !tbaa !8
  %28 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %29 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %30 = load i64, i64* %nb_blocks, align 8, !tbaa !8
  %31 = load i64, i64* %block_len, align 8, !tbaa !8
  %mul8 = mul i64 %30, %31
  %add.ptr9 = getelementptr inbounds i8, i8* %29, i64 %mul8
  %32 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %33 = load i64, i64* %nbStripes, align 8, !tbaa !8
  %34 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %35 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  call void @XXH3_accumulate(i64* %28, i8* %add.ptr9, i8* %32, i64 %33, i32 %34, void (i8*, i8*, i8*, i32)* %35)
  %36 = load i64, i64* %len.addr, align 8, !tbaa !8
  %and = and i64 %36, 63
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %37 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %37) #11
  %38 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %39 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr10 = getelementptr inbounds i8, i8* %38, i64 %39
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -64
  store i8* %add.ptr11, i8** %p, align 8, !tbaa !4
  %40 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %41 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %42 = bitcast i64* %41 to i8*
  %43 = load i8*, i8** %p, align 8, !tbaa !4
  %44 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %45 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %add.ptr12 = getelementptr inbounds i8, i8* %44, i64 %45
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -64
  %add.ptr14 = getelementptr inbounds i8, i8* %add.ptr13, i64 -7
  %46 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  call void %40(i8* %42, i8* %43, i8* %add.ptr14, i32 %46)
  %47 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %48 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #11
  %49 = bitcast i64* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #11
  %50 = bitcast i64* %nb_blocks to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %50) #11
  %51 = bitcast i64* %block_len to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %51) #11
  %52 = bitcast i64* %nb_rounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %52) #11
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_accumulate(i64* noalias %acc, i8* noalias %input, i8* noalias %secret, i64 %nbStripes, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %n = alloca i64, align 8
  %in = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !4
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %nbStripes, i64* %nbStripes.addr, align 8, !tbaa !8
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !12
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %0 = bitcast i64* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  store i64 0, i64* %n, align 8, !tbaa !8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %n, align 8, !tbaa !8
  %2 = load i64, i64* %nbStripes.addr, align 8, !tbaa !8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = bitcast i8** %in to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #11
  %4 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %5 = load i64, i64* %n, align 8, !tbaa !8
  %mul = mul i64 %5, 64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %mul
  store i8* %add.ptr, i8** %in, align 8, !tbaa !4
  %6 = load i8*, i8** %in, align 8, !tbaa !4
  %add.ptr1 = getelementptr inbounds i8, i8* %6, i64 320
  call void @llvm.prefetch(i8* %add.ptr1, i32 0, i32 3, i32 1)
  %7 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %8 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %9 = bitcast i64* %8 to i8*
  %10 = load i8*, i8** %in, align 8, !tbaa !4
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %12 = load i64, i64* %n, align 8, !tbaa !8
  %mul2 = mul i64 %12, 8
  %add.ptr3 = getelementptr inbounds i8, i8* %11, i64 %mul2
  %13 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  call void %7(i8* %9, i8* %10, i8* %add.ptr3, i32 %13)
  %14 = bitcast i8** %in to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i64, i64* %n, align 8, !tbaa !8
  %inc = add i64 %15, 1
  store i64 %inc, i64* %n, align 8, !tbaa !8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = bitcast i64* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #11
  ret void
}

; Function Attrs: inaccessiblemem_or_argmemonly nounwind
declare void @llvm.prefetch(i8* nocapture readonly, i32, i32, i32) #10

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed_internal(i8* %input, i64 %len, i64 %seed, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #1 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !4
  %0 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 192, i8* %5) #11
  %6 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !4
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %7 = load i64, i64* %seed.addr, align 8, !tbaa !22
  call void %6(i8* %arraydecay, i64 %7)
  %8 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %9 = load i64, i64* %len.addr, align 8, !tbaa !8
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %10 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %11 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %call2 = call i64 @XXH3_hashLong_64b_internal(i8* %8, i64 %9, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %10, void (i8*, i8*)* %11)
  store i64 %call2, i64* %retval, align 8
  %12 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 192, i8* %12) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i64, i64* %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #2

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH_writeLE64(i8* %dst, i64 %v64) #1 {
entry:
  %dst.addr = alloca i8*, align 8
  %v64.addr = alloca i64, align 8
  store i8* %dst, i8** %dst.addr, align 8, !tbaa !4
  store i64 %v64, i64* %v64.addr, align 8, !tbaa !22
  %0 = load i8*, i8** %dst.addr, align 8, !tbaa !4
  %1 = bitcast i64* %v64.addr to i8*
  %2 = load i8*, i8** %dst.addr, align 8, !tbaa !4
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 8, i64 %3) #11
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_set_epi64x(i64 %__q1, i64 %__q0) #6 {
entry:
  %__q1.addr = alloca i64, align 8
  %__q0.addr = alloca i64, align 8
  %.compoundliteral = alloca <2 x i64>, align 16
  store i64 %__q1, i64* %__q1.addr, align 8, !tbaa !22
  store i64 %__q0, i64* %__q0.addr, align 8, !tbaa !22
  %0 = load i64, i64* %__q0.addr, align 8, !tbaa !22
  %vecinit = insertelement <2 x i64> undef, i64 %0, i32 0
  %1 = load i64, i64* %__q1.addr, align 8, !tbaa !22
  %vecinit1 = insertelement <2 x i64> %vecinit, i64 %1, i32 1
  store <2 x i64> %vecinit1, <2 x i64>* %.compoundliteral, align 16, !tbaa !12
  %2 = load <2 x i64>, <2 x i64>* %.compoundliteral, align 16, !tbaa !12
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_add_epi64(<2 x i64> %__a, <2 x i64> %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !12
  store <2 x i64> %__b, <2 x i64>* %__b.addr, align 16, !tbaa !12
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !12
  %1 = load <2 x i64>, <2 x i64>* %__b.addr, align 16, !tbaa !12
  %add = add <2 x i64> %0, %1
  ret <2 x i64> %add
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_castps_si128(<4 x float> %__a) #6 {
entry:
  %__a.addr = alloca <4 x float>, align 16
  store <4 x float> %__a, <4 x float>* %__a.addr, align 16, !tbaa !12
  %0 = load <4 x float>, <4 x float>* %__a.addr, align 16, !tbaa !12
  %1 = bitcast <4 x float> %0 to <2 x i64>
  ret <2 x i64> %1
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <4 x float> @_mm_load_ps(float* %__p) #6 {
entry:
  %__p.addr = alloca float*, align 8
  store float* %__p, float** %__p.addr, align 8, !tbaa !4
  %0 = load float*, float** %__p.addr, align 8, !tbaa !4
  %1 = bitcast float* %0 to <4 x float>*
  %2 = load <4 x float>, <4 x float>* %1, align 16, !tbaa !12
  ret <4 x float> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_consumeStripes(i64* noalias %acc, i64* noalias %nbStripesSoFarPtr, i64 %nbStripesPerBlock, i8* noalias %input, i64 %nbStripes, i8* noalias %secret, i64 %secretLimit, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %nbStripesSoFarPtr.addr = alloca i64*, align 8
  %nbStripesPerBlock.addr = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLimit.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nbStripesToEndofBlock = alloca i64, align 8
  %nbStripesAfterBlock = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !4
  store i64* %nbStripesSoFarPtr, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  store i64 %nbStripesPerBlock, i64* %nbStripesPerBlock.addr, align 8, !tbaa !8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %nbStripes, i64* %nbStripes.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretLimit, i64* %secretLimit.addr, align 8, !tbaa !8
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !12
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %0 = load i64, i64* %nbStripesPerBlock.addr, align 8, !tbaa !8
  %1 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  %2 = load i64, i64* %1, align 8, !tbaa !8
  %sub = sub i64 %0, %2
  %3 = load i64, i64* %nbStripes.addr, align 8, !tbaa !8
  %cmp = icmp ule i64 %sub, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = bitcast i64* %nbStripesToEndofBlock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load i64, i64* %nbStripesPerBlock.addr, align 8, !tbaa !8
  %6 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  %7 = load i64, i64* %6, align 8, !tbaa !8
  %sub1 = sub i64 %5, %7
  store i64 %sub1, i64* %nbStripesToEndofBlock, align 8, !tbaa !8
  %8 = bitcast i64* %nbStripesAfterBlock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #11
  %9 = load i64, i64* %nbStripes.addr, align 8, !tbaa !8
  %10 = load i64, i64* %nbStripesToEndofBlock, align 8, !tbaa !8
  %sub2 = sub i64 %9, %10
  store i64 %sub2, i64* %nbStripesAfterBlock, align 8, !tbaa !8
  %11 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %12 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %14 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i64, i64* %14, i64 0
  %15 = load i64, i64* %arrayidx, align 8, !tbaa !8
  %mul = mul i64 %15, 8
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 %mul
  %16 = load i64, i64* %nbStripesToEndofBlock, align 8, !tbaa !8
  %17 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %18 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  call void @XXH3_accumulate(i64* %11, i8* %12, i8* %add.ptr, i64 %16, i32 %17, void (i8*, i8*, i8*, i32)* %18)
  %19 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %20 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %21 = bitcast i64* %20 to i8*
  %22 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %23 = load i64, i64* %secretLimit.addr, align 8, !tbaa !8
  %add.ptr3 = getelementptr inbounds i8, i8* %22, i64 %23
  call void %19(i8* %21, i8* %add.ptr3)
  %24 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %25 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %26 = load i64, i64* %nbStripesToEndofBlock, align 8, !tbaa !8
  %mul4 = mul i64 %26, 64
  %add.ptr5 = getelementptr inbounds i8, i8* %25, i64 %mul4
  %27 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %28 = load i64, i64* %nbStripesAfterBlock, align 8, !tbaa !8
  %29 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %30 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  call void @XXH3_accumulate(i64* %24, i8* %add.ptr5, i8* %27, i64 %28, i32 %29, void (i8*, i8*, i8*, i32)* %30)
  %31 = load i64, i64* %nbStripesAfterBlock, align 8, !tbaa !8
  %32 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  store i64 %31, i64* %32, align 8, !tbaa !8
  %33 = bitcast i64* %nbStripesAfterBlock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %33) #11
  %34 = bitcast i64* %nbStripesToEndofBlock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %34) #11
  br label %if.end

if.else:                                          ; preds = %entry
  %35 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %36 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %37 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %38 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  %arrayidx6 = getelementptr inbounds i64, i64* %38, i64 0
  %39 = load i64, i64* %arrayidx6, align 8, !tbaa !8
  %mul7 = mul i64 %39, 8
  %add.ptr8 = getelementptr inbounds i8, i8* %37, i64 %mul7
  %40 = load i64, i64* %nbStripes.addr, align 8, !tbaa !8
  %41 = load i32, i32* %accWidth.addr, align 4, !tbaa !12
  %42 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  call void @XXH3_accumulate(i64* %35, i8* %36, i8* %add.ptr8, i64 %40, i32 %41, void (i8*, i8*, i8*, i32)* %42)
  %43 = load i64, i64* %nbStripes.addr, align 8, !tbaa !8
  %44 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !4
  %45 = load i64, i64* %44, align 8, !tbaa !8
  %add = add i64 %45, %43
  store i64 %add, i64* %44, align 8, !tbaa !8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_loadu_si128(<2 x i64>* %__p) #6 {
entry:
  %__p.addr = alloca <2 x i64>*, align 8
  store <2 x i64>* %__p, <2 x i64>** %__p.addr, align 8, !tbaa !4
  %0 = load <2 x i64>*, <2 x i64>** %__p.addr, align 8, !tbaa !4
  %1 = bitcast <2 x i64>* %0 to %struct.__loadu_si128*
  %__v = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %1, i32 0, i32 0
  %2 = load <2 x i64>, <2 x i64>* %__v, align 1, !tbaa !12
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_xor_si128(<2 x i64> %__a, <2 x i64> %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !12
  store <2 x i64> %__b, <2 x i64>* %__b.addr, align 16, !tbaa !12
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !12
  %1 = load <2 x i64>, <2 x i64>* %__b.addr, align 16, !tbaa !12
  %xor = xor <2 x i64> %0, %1
  ret <2 x i64> %xor
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_mul_epu32(<2 x i64> %__a, <2 x i64> %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !12
  store <2 x i64> %__b, <2 x i64>* %__b.addr, align 16, !tbaa !12
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !12
  %1 = bitcast <2 x i64> %0 to <4 x i32>
  %2 = load <2 x i64>, <2 x i64>* %__b.addr, align 16, !tbaa !12
  %3 = bitcast <2 x i64> %2 to <4 x i32>
  %4 = bitcast <4 x i32> %1 to <2 x i64>
  %5 = bitcast <4 x i32> %3 to <2 x i64>
  %6 = and <2 x i64> %4, <i64 4294967295, i64 4294967295>
  %7 = and <2 x i64> %5, <i64 4294967295, i64 4294967295>
  %8 = mul <2 x i64> %6, %7
  ret <2 x i64> %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_set1_epi32(i32 %__i) #6 {
entry:
  %__i.addr = alloca i32, align 4
  store i32 %__i, i32* %__i.addr, align 4, !tbaa !10
  %0 = load i32, i32* %__i.addr, align 4, !tbaa !10
  %1 = load i32, i32* %__i.addr, align 4, !tbaa !10
  %2 = load i32, i32* %__i.addr, align 4, !tbaa !10
  %3 = load i32, i32* %__i.addr, align 4, !tbaa !10
  %call = call <2 x i64> @_mm_set_epi32(i32 %0, i32 %1, i32 %2, i32 %3)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_srli_epi64(<2 x i64> %__a, i32 %__count) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__count.addr = alloca i32, align 4
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !12
  store i32 %__count, i32* %__count.addr, align 4, !tbaa !10
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !12
  %1 = load i32, i32* %__count.addr, align 4, !tbaa !10
  %2 = call <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64> %0, i32 %1)
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_slli_epi64(<2 x i64> %__a, i32 %__count) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__count.addr = alloca i32, align 4
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !12
  store i32 %__count, i32* %__count.addr, align 4, !tbaa !10
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !12
  %1 = load i32, i32* %__count.addr, align 4, !tbaa !10
  %2 = call <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64> %0, i32 %1)
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_set_epi32(i32 %__i3, i32 %__i2, i32 %__i1, i32 %__i0) #6 {
entry:
  %__i3.addr = alloca i32, align 4
  %__i2.addr = alloca i32, align 4
  %__i1.addr = alloca i32, align 4
  %__i0.addr = alloca i32, align 4
  %.compoundliteral = alloca <4 x i32>, align 16
  store i32 %__i3, i32* %__i3.addr, align 4, !tbaa !10
  store i32 %__i2, i32* %__i2.addr, align 4, !tbaa !10
  store i32 %__i1, i32* %__i1.addr, align 4, !tbaa !10
  store i32 %__i0, i32* %__i0.addr, align 4, !tbaa !10
  %0 = load i32, i32* %__i0.addr, align 4, !tbaa !10
  %vecinit = insertelement <4 x i32> undef, i32 %0, i32 0
  %1 = load i32, i32* %__i1.addr, align 4, !tbaa !10
  %vecinit1 = insertelement <4 x i32> %vecinit, i32 %1, i32 1
  %2 = load i32, i32* %__i2.addr, align 4, !tbaa !10
  %vecinit2 = insertelement <4 x i32> %vecinit1, i32 %2, i32 2
  %3 = load i32, i32* %__i3.addr, align 4, !tbaa !10
  %vecinit3 = insertelement <4 x i32> %vecinit2, i32 %3, i32 3
  store <4 x i32> %vecinit3, <4 x i32>* %.compoundliteral, align 16, !tbaa !12
  %4 = load <4 x i32>, <4 x i32>* %.compoundliteral, align 16, !tbaa !12
  %5 = bitcast <4 x i32> %4 to <2 x i64>
  ret <2 x i64> %5
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64>, i32) #9

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64>, i32) #9

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_mix2Accs(i64* noalias %acc, i8* noalias %secret) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  %0 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !22
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %call = call i64 @XXH_readLE64(i8* %2)
  %xor = xor i64 %1, %call
  %3 = load i64*, i64** %acc.addr, align 8, !tbaa !4
  %arrayidx1 = getelementptr inbounds i64, i64* %3, i64 1
  %4 = load i64, i64* %arrayidx1, align 8, !tbaa !22
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 8
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr)
  %xor3 = xor i64 %4, %call2
  %call4 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor3)
  ret i64 %call4
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_0to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp ugt i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call { i64, i64 } @XXH3_len_9to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp1 = icmp uge i64 %10, 4
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call3 = call { i64, i64 } @XXH3_len_4to8_128b(i8* %11, i64 %12, i8* %13, i64 %14)
  %15 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call3, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call3, 1
  store i64 %19, i64* %18, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %20 = load i64, i64* %len.addr, align 8, !tbaa !8
  %tobool = icmp ne i64 %20, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end4
  %21 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %22 = load i64, i64* %len.addr, align 8, !tbaa !8
  %23 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %24 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call6 = call { i64, i64 } @XXH3_len_1to3_128b(i8* %21, i64 %22, i8* %23, i64 %24)
  %25 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call6, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call6, 1
  store i64 %29, i64* %28, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %30 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %30) #11
  %31 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %31, i64 64
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr)
  %32 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr9 = getelementptr inbounds i8, i8* %32, i64 72
  %call10 = call i64 @XXH_readLE64(i8* %add.ptr9)
  %xor = xor i64 %call8, %call10
  store i64 %xor, i64* %bitflipl, align 8, !tbaa !22
  %33 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %33) #11
  %34 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr11 = getelementptr inbounds i8, i8* %34, i64 80
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %35 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr13 = getelementptr inbounds i8, i8* %35, i64 88
  %call14 = call i64 @XXH_readLE64(i8* %add.ptr13)
  %xor15 = xor i64 %call12, %call14
  store i64 %xor15, i64* %bitfliph, align 8, !tbaa !22
  %36 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 -7046029288634856825, %36
  %37 = load i64, i64* %bitflipl, align 8, !tbaa !22
  %xor16 = xor i64 %add, %37
  %call17 = call i64 @XXH3_avalanche(i64 %xor16)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call17, i64* %low64, align 8, !tbaa !42
  %38 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 -4417276706812531889, %38
  %39 = load i64, i64* %bitfliph, align 8, !tbaa !22
  %xor18 = xor i64 %sub, %39
  %call19 = call i64 @XXH3_avalanche(i64 %xor18)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call19, i64* %high64, align 8, !tbaa !40
  %40 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %40) #11
  %41 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %41) #11
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then2, %if.then
  %42 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %43 = load { i64, i64 }, { i64, i64 }* %42, align 8
  ret { i64, i64 } %43
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_17to128_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %tmp = alloca %struct.XXH128_hash_t, align 8
  %tmp8 = alloca %struct.XXH128_hash_t, align 8
  %tmp15 = alloca %struct.XXH128_hash_t, align 8
  %tmp22 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %1 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #11
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul = mul i64 %2, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8, !tbaa !42
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8, !tbaa !40
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp = icmp ugt i64 %3, 32
  br i1 %cmp, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp1 = icmp ugt i64 %4, 64
  br i1 %cmp1, label %if.then2, label %if.end14

if.then2:                                         ; preds = %if.then
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %cmp3 = icmp ugt i64 %5, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %6 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %6) #11
  %7 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 48
  %8 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %9 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr5 = getelementptr inbounds i8, i8* %8, i64 %9
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 -64
  %10 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 96
  %11 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %12 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %14, i64 %16, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr7, i64 %11)
  %17 = bitcast %struct.XXH128_hash_t* %tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %23 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %23, i64 16, i1 false), !tbaa.struct !43
  %24 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %24) #11
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %25 = bitcast %struct.XXH128_hash_t* %tmp8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %25) #11
  %26 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr9 = getelementptr inbounds i8, i8* %26, i64 32
  %27 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %28 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr10 = getelementptr inbounds i8, i8* %27, i64 %28
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -48
  %29 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr12 = getelementptr inbounds i8, i8* %29, i64 64
  %30 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %31 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %call13 = call { i64, i64 } @XXH128_mix32B(i64 %33, i64 %35, i8* %add.ptr9, i8* %add.ptr11, i8* %add.ptr12, i64 %30)
  %36 = bitcast %struct.XXH128_hash_t* %tmp8 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = extractvalue { i64, i64 } %call13, 0
  store i64 %38, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = extractvalue { i64, i64 } %call13, 1
  store i64 %40, i64* %39, align 8
  %41 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %42 = bitcast %struct.XXH128_hash_t* %tmp8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %41, i8* align 8 %42, i64 16, i1 false), !tbaa.struct !43
  %43 = bitcast %struct.XXH128_hash_t* %tmp8 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %43) #11
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %44 = bitcast %struct.XXH128_hash_t* %tmp15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %44) #11
  %45 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %add.ptr16 = getelementptr inbounds i8, i8* %45, i64 16
  %46 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %47 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr17 = getelementptr inbounds i8, i8* %46, i64 %47
  %add.ptr18 = getelementptr inbounds i8, i8* %add.ptr17, i64 -32
  %48 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr19 = getelementptr inbounds i8, i8* %48, i64 32
  %49 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %50 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %call20 = call { i64, i64 } @XXH128_mix32B(i64 %52, i64 %54, i8* %add.ptr16, i8* %add.ptr18, i8* %add.ptr19, i64 %49)
  %55 = bitcast %struct.XXH128_hash_t* %tmp15 to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = extractvalue { i64, i64 } %call20, 0
  store i64 %57, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = extractvalue { i64, i64 } %call20, 1
  store i64 %59, i64* %58, align 8
  %60 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %61 = bitcast %struct.XXH128_hash_t* %tmp15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %60, i8* align 8 %61, i64 16, i1 false), !tbaa.struct !43
  %62 = bitcast %struct.XXH128_hash_t* %tmp15 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %62) #11
  br label %if.end21

if.end21:                                         ; preds = %if.end14, %entry
  %63 = bitcast %struct.XXH128_hash_t* %tmp22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %63) #11
  %64 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %65 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %66 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr23 = getelementptr inbounds i8, i8* %65, i64 %66
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %67 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %68 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %69 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 0
  %71 = load i64, i64* %70, align 8
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 1
  %73 = load i64, i64* %72, align 8
  %call25 = call { i64, i64 } @XXH128_mix32B(i64 %71, i64 %73, i8* %64, i8* %add.ptr24, i8* %67, i64 %68)
  %74 = bitcast %struct.XXH128_hash_t* %tmp22 to { i64, i64 }*
  %75 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 0
  %76 = extractvalue { i64, i64 } %call25, 0
  store i64 %76, i64* %75, align 8
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 1
  %78 = extractvalue { i64, i64 } %call25, 1
  store i64 %78, i64* %77, align 8
  %79 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %80 = bitcast %struct.XXH128_hash_t* %tmp22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %79, i8* align 8 %80, i64 16, i1 false), !tbaa.struct !43
  %81 = bitcast %struct.XXH128_hash_t* %tmp22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %81) #11
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %82 = load i64, i64* %low6426, align 8, !tbaa !42
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %83 = load i64, i64* %high6427, align 8, !tbaa !40
  %add = add i64 %82, %83
  %low6428 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %add, i64* %low6428, align 8, !tbaa !42
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %84 = load i64, i64* %low6429, align 8, !tbaa !42
  %mul30 = mul i64 %84, -7046029288634856825
  %high6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %85 = load i64, i64* %high6431, align 8, !tbaa !40
  %mul32 = mul i64 %85, -8796714831421723037
  %add33 = add i64 %mul30, %mul32
  %86 = load i64, i64* %len.addr, align 8, !tbaa !8
  %87 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 %86, %87
  %mul34 = mul i64 %sub, -4417276706812531889
  %add35 = add i64 %add33, %mul34
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %add35, i64* %high6436, align 8, !tbaa !40
  %low6437 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %88 = load i64, i64* %low6437, align 8, !tbaa !42
  %call38 = call i64 @XXH3_avalanche(i64 %88)
  %low6439 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call38, i64* %low6439, align 8, !tbaa !42
  %high6440 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %89 = load i64, i64* %high6440, align 8, !tbaa !40
  %call41 = call i64 @XXH3_avalanche(i64 %89)
  %sub42 = sub i64 0, %call41
  %high6443 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %sub42, i64* %high6443, align 8, !tbaa !40
  %90 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %90) #11
  %91 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %92 = load { i64, i64 }, { i64, i64 }* %91, align 8
  ret { i64, i64 } %92
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_129to240_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  %tmp = alloca %struct.XXH128_hash_t, align 8
  %tmp20 = alloca %struct.XXH128_hash_t, align 8
  %tmp36 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %1 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #11
  %2 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv = trunc i64 %3 to i32
  %div = sdiv i32 %conv, 32
  store i32 %div, i32* %nbRounds, align 4, !tbaa !10
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul = mul i64 %5, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8, !tbaa !42
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8, !tbaa !40
  store i32 0, i32* %i, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4, !tbaa !10
  %cmp = icmp slt i32 %6, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %7) #11
  %8 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %9 = load i32, i32* %i, align 4, !tbaa !10
  %mul2 = mul nsw i32 32, %9
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 %idx.ext
  %10 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %11 = load i32, i32* %i, align 4, !tbaa !10
  %mul3 = mul nsw i32 32, %11
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %10, i64 %idx.ext4
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 16
  %12 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %13 = load i32, i32* %i, align 4, !tbaa !10
  %mul7 = mul nsw i32 32, %13
  %idx.ext8 = sext i32 %mul7 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %12, i64 %idx.ext8
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %15 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %17, i64 %19, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr9, i64 %14)
  %20 = bitcast %struct.XXH128_hash_t* %tmp to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call, 1
  store i64 %24, i64* %23, align 8
  %25 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %26 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %26, i64 16, i1 false), !tbaa.struct !43
  %27 = bitcast %struct.XXH128_hash_t* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %27) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %28 = load i32, i32* %i, align 4, !tbaa !10
  %inc = add nsw i32 %28, 1
  store i32 %inc, i32* %i, align 4, !tbaa !10
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %29 = load i64, i64* %low6410, align 8, !tbaa !42
  %call11 = call i64 @XXH3_avalanche(i64 %29)
  %low6412 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %call11, i64* %low6412, align 8, !tbaa !42
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %30 = load i64, i64* %high6413, align 8, !tbaa !40
  %call14 = call i64 @XXH3_avalanche(i64 %30)
  %high6415 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 %call14, i64* %high6415, align 8, !tbaa !40
  store i32 4, i32* %i, align 4, !tbaa !10
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc33, %for.end
  %31 = load i32, i32* %i, align 4, !tbaa !10
  %32 = load i32, i32* %nbRounds, align 4, !tbaa !10
  %cmp17 = icmp slt i32 %31, %32
  br i1 %cmp17, label %for.body19, label %for.end35

for.body19:                                       ; preds = %for.cond16
  %33 = bitcast %struct.XXH128_hash_t* %tmp20 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %33) #11
  %34 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %35 = load i32, i32* %i, align 4, !tbaa !10
  %mul21 = mul nsw i32 32, %35
  %idx.ext22 = sext i32 %mul21 to i64
  %add.ptr23 = getelementptr inbounds i8, i8* %34, i64 %idx.ext22
  %36 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %37 = load i32, i32* %i, align 4, !tbaa !10
  %mul24 = mul nsw i32 32, %37
  %idx.ext25 = sext i32 %mul24 to i64
  %add.ptr26 = getelementptr inbounds i8, i8* %36, i64 %idx.ext25
  %add.ptr27 = getelementptr inbounds i8, i8* %add.ptr26, i64 16
  %38 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr28 = getelementptr inbounds i8, i8* %38, i64 3
  %39 = load i32, i32* %i, align 4, !tbaa !10
  %sub = sub nsw i32 %39, 4
  %mul29 = mul nsw i32 32, %sub
  %idx.ext30 = sext i32 %mul29 to i64
  %add.ptr31 = getelementptr inbounds i8, i8* %add.ptr28, i64 %idx.ext30
  %40 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %41 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = load i64, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = load i64, i64* %44, align 8
  %call32 = call { i64, i64 } @XXH128_mix32B(i64 %43, i64 %45, i8* %add.ptr23, i8* %add.ptr27, i8* %add.ptr31, i64 %40)
  %46 = bitcast %struct.XXH128_hash_t* %tmp20 to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = extractvalue { i64, i64 } %call32, 0
  store i64 %48, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = extractvalue { i64, i64 } %call32, 1
  store i64 %50, i64* %49, align 8
  %51 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %52 = bitcast %struct.XXH128_hash_t* %tmp20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %51, i8* align 8 %52, i64 16, i1 false), !tbaa.struct !43
  %53 = bitcast %struct.XXH128_hash_t* %tmp20 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %53) #11
  br label %for.inc33

for.inc33:                                        ; preds = %for.body19
  %54 = load i32, i32* %i, align 4, !tbaa !10
  %inc34 = add nsw i32 %54, 1
  store i32 %inc34, i32* %i, align 4, !tbaa !10
  br label %for.cond16

for.end35:                                        ; preds = %for.cond16
  %55 = bitcast %struct.XXH128_hash_t* %tmp36 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %55) #11
  %56 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %57 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr37 = getelementptr inbounds i8, i8* %56, i64 %57
  %add.ptr38 = getelementptr inbounds i8, i8* %add.ptr37, i64 -16
  %58 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %59 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr39 = getelementptr inbounds i8, i8* %58, i64 %59
  %add.ptr40 = getelementptr inbounds i8, i8* %add.ptr39, i64 -32
  %60 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr41 = getelementptr inbounds i8, i8* %60, i64 136
  %add.ptr42 = getelementptr inbounds i8, i8* %add.ptr41, i64 -17
  %add.ptr43 = getelementptr inbounds i8, i8* %add.ptr42, i64 -16
  %61 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub44 = sub i64 0, %61
  %62 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call45 = call { i64, i64 } @XXH128_mix32B(i64 %64, i64 %66, i8* %add.ptr38, i8* %add.ptr40, i8* %add.ptr43, i64 %sub44)
  %67 = bitcast %struct.XXH128_hash_t* %tmp36 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = extractvalue { i64, i64 } %call45, 0
  store i64 %69, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = extractvalue { i64, i64 } %call45, 1
  store i64 %71, i64* %70, align 8
  %72 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %73 = bitcast %struct.XXH128_hash_t* %tmp36 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %72, i8* align 8 %73, i64 16, i1 false), !tbaa.struct !43
  %74 = bitcast %struct.XXH128_hash_t* %tmp36 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %74) #11
  %low6446 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %75 = load i64, i64* %low6446, align 8, !tbaa !42
  %high6447 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %76 = load i64, i64* %high6447, align 8, !tbaa !40
  %add = add i64 %75, %76
  %low6448 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %add, i64* %low6448, align 8, !tbaa !42
  %low6449 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %77 = load i64, i64* %low6449, align 8, !tbaa !42
  %mul50 = mul i64 %77, -7046029288634856825
  %high6451 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %78 = load i64, i64* %high6451, align 8, !tbaa !40
  %mul52 = mul i64 %78, -8796714831421723037
  %add53 = add i64 %mul50, %mul52
  %79 = load i64, i64* %len.addr, align 8, !tbaa !8
  %80 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub54 = sub i64 %79, %80
  %mul55 = mul i64 %sub54, -4417276706812531889
  %add56 = add i64 %add53, %mul55
  %high6457 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %add56, i64* %high6457, align 8, !tbaa !40
  %low6458 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %81 = load i64, i64* %low6458, align 8, !tbaa !42
  %call59 = call i64 @XXH3_avalanche(i64 %81)
  %low6460 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call59, i64* %low6460, align 8, !tbaa !42
  %high6461 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %82 = load i64, i64* %high6461, align 8, !tbaa !40
  %call62 = call i64 @XXH3_avalanche(i64 %82)
  %sub63 = sub i64 0, %call62
  %high6464 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %sub63, i64* %high6464, align 8, !tbaa !40
  %83 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %83) #11
  %84 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %84) #11
  %85 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %85) #11
  %86 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %87 = load { i64, i64 }, { i64, i64 }* %86, align 8
  ret { i64, i64 } %87
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_9to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %m128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #11
  %1 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 32
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 40
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %3 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub = sub i64 %xor, %3
  store i64 %sub, i64* %bitflipl, align 8, !tbaa !22
  %4 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #11
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr3 = getelementptr inbounds i8, i8* %5, i64 48
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %6 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 56
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %7 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 %xor7, %7
  store i64 %add, i64* %bitfliph, align 8, !tbaa !22
  %8 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #11
  %9 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %call8 = call i64 @XXH_readLE64(i8* %9)
  store i64 %call8, i64* %input_lo, align 8, !tbaa !22
  %10 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #11
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr9 = getelementptr inbounds i8, i8* %11, i64 %12
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  store i64 %call11, i64* %input_hi, align 8, !tbaa !22
  %13 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %13) #11
  %14 = load i64, i64* %input_lo, align 8, !tbaa !22
  %15 = load i64, i64* %input_hi, align 8, !tbaa !22
  %xor12 = xor i64 %14, %15
  %16 = load i64, i64* %bitflipl, align 8, !tbaa !22
  %xor13 = xor i64 %xor12, %16
  %call14 = call { i64, i64 } @XXH_mult64to128(i64 %xor13, i64 -7046029288634856825)
  %17 = bitcast %struct.XXH128_hash_t* %m128 to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call14, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call14, 1
  store i64 %21, i64* %20, align 8
  %22 = load i64, i64* %len.addr, align 8, !tbaa !8
  %sub15 = sub i64 %22, 1
  %shl = shl i64 %sub15, 54
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %23 = load i64, i64* %low64, align 8, !tbaa !42
  %add16 = add i64 %23, %shl
  store i64 %add16, i64* %low64, align 8, !tbaa !42
  %24 = load i64, i64* %bitfliph, align 8, !tbaa !22
  %25 = load i64, i64* %input_hi, align 8, !tbaa !22
  %xor17 = xor i64 %25, %24
  store i64 %xor17, i64* %input_hi, align 8, !tbaa !22
  %26 = load i64, i64* %input_hi, align 8, !tbaa !22
  %27 = load i64, i64* %input_hi, align 8, !tbaa !22
  %conv = trunc i64 %27 to i32
  %conv18 = zext i32 %conv to i64
  %mul = mul i64 %conv18, 2246822518
  %add19 = add i64 %26, %mul
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %28 = load i64, i64* %high64, align 8, !tbaa !40
  %add20 = add i64 %28, %add19
  store i64 %add20, i64* %high64, align 8, !tbaa !40
  %high6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %29 = load i64, i64* %high6421, align 8, !tbaa !40
  %call22 = call i64 @XXH_swap64(i64 %29)
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %30 = load i64, i64* %low6423, align 8, !tbaa !42
  %xor24 = xor i64 %30, %call22
  store i64 %xor24, i64* %low6423, align 8, !tbaa !42
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %31 = load i64, i64* %low6425, align 8, !tbaa !42
  %call26 = call { i64, i64 } @XXH_mult64to128(i64 %31, i64 -4417276706812531889)
  %32 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 0
  %34 = extractvalue { i64, i64 } %call26, 0
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 1
  %36 = extractvalue { i64, i64 } %call26, 1
  store i64 %36, i64* %35, align 8
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %37 = load i64, i64* %high6427, align 8, !tbaa !40
  %mul28 = mul i64 %37, -4417276706812531889
  %high6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %38 = load i64, i64* %high6429, align 8, !tbaa !40
  %add30 = add i64 %38, %mul28
  store i64 %add30, i64* %high6429, align 8, !tbaa !40
  %low6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %39 = load i64, i64* %low6431, align 8, !tbaa !42
  %call32 = call i64 @XXH3_avalanche(i64 %39)
  %low6433 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call32, i64* %low6433, align 8, !tbaa !42
  %high6434 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %40 = load i64, i64* %high6434, align 8, !tbaa !40
  %call35 = call i64 @XXH3_avalanche(i64 %40)
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call35, i64* %high6436, align 8, !tbaa !40
  %41 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %41) #11
  %42 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %42) #11
  %43 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #11
  %44 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %44) #11
  %45 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #11
  %46 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %47 = load { i64, i64 }, { i64, i64 }* %46, align 8
  ret { i64, i64 } %47
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_4to8_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input_lo = alloca i32, align 4
  %input_hi = alloca i32, align 4
  %input_64 = alloca i64, align 8
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %0 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8, !tbaa !22
  %2 = bitcast i32* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #11
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %call2 = call i32 @XXH_readLE32(i8* %3)
  store i32 %call2, i32* %input_lo, align 4, !tbaa !10
  %4 = bitcast i32* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #11
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %6 = load i64, i64* %len.addr, align 8, !tbaa !8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 %6
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input_hi, align 4, !tbaa !10
  %7 = bitcast i64* %input_64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #11
  %8 = load i32, i32* %input_lo, align 4, !tbaa !10
  %conv5 = zext i32 %8 to i64
  %9 = load i32, i32* %input_hi, align 4, !tbaa !10
  %conv6 = zext i32 %9 to i64
  %shl7 = shl i64 %conv6, 32
  %add = add i64 %conv5, %shl7
  store i64 %add, i64* %input_64, align 8, !tbaa !22
  %10 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #11
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr8 = getelementptr inbounds i8, i8* %11, i64 16
  %call9 = call i64 @XXH_readLE64(i8* %add.ptr8)
  %12 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr10 = getelementptr inbounds i8, i8* %12, i64 24
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %xor12 = xor i64 %call9, %call11
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add13 = add i64 %xor12, %13
  store i64 %add13, i64* %bitflip, align 8, !tbaa !22
  %14 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #11
  %15 = load i64, i64* %input_64, align 8, !tbaa !22
  %16 = load i64, i64* %bitflip, align 8, !tbaa !22
  %xor14 = xor i64 %15, %16
  store i64 %xor14, i64* %keyed, align 8, !tbaa !22
  %17 = load i64, i64* %keyed, align 8, !tbaa !22
  %18 = load i64, i64* %len.addr, align 8, !tbaa !8
  %shl15 = shl i64 %18, 2
  %add16 = add i64 -7046029288634856825, %shl15
  %call17 = call { i64, i64 } @XXH_mult64to128(i64 %17, i64 %add16)
  %19 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = extractvalue { i64, i64 } %call17, 0
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = extractvalue { i64, i64 } %call17, 1
  store i64 %23, i64* %22, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %24 = load i64, i64* %low64, align 8, !tbaa !42
  %shl18 = shl i64 %24, 1
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %25 = load i64, i64* %high64, align 8, !tbaa !40
  %add19 = add i64 %25, %shl18
  store i64 %add19, i64* %high64, align 8, !tbaa !40
  %high6420 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %26 = load i64, i64* %high6420, align 8, !tbaa !40
  %shr = lshr i64 %26, 3
  %low6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %27 = load i64, i64* %low6421, align 8, !tbaa !42
  %xor22 = xor i64 %27, %shr
  store i64 %xor22, i64* %low6421, align 8, !tbaa !42
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %28 = load i64, i64* %low6423, align 8, !tbaa !42
  %call24 = call i64 @XXH_xorshift64(i64 %28, i32 35)
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call24, i64* %low6425, align 8, !tbaa !42
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %29 = load i64, i64* %low6426, align 8, !tbaa !42
  %mul = mul i64 %29, -6939452855193903323
  store i64 %mul, i64* %low6426, align 8, !tbaa !42
  %low6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  %30 = load i64, i64* %low6427, align 8, !tbaa !42
  %call28 = call i64 @XXH_xorshift64(i64 %30, i32 28)
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call28, i64* %low6429, align 8, !tbaa !42
  %high6430 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  %31 = load i64, i64* %high6430, align 8, !tbaa !40
  %call31 = call i64 @XXH3_avalanche(i64 %31)
  %high6432 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call31, i64* %high6432, align 8, !tbaa !40
  %32 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #11
  %33 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %33) #11
  %34 = bitcast i64* %input_64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %34) #11
  %35 = bitcast i32* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %35) #11
  %36 = bitcast i32* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %36) #11
  %37 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %38 = load { i64, i64 }, { i64, i64 }* %37, align 8
  ret { i64, i64 } %38
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_1to3_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combinedl = alloca i32, align 4
  %combinedh = alloca i32, align 4
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %keyed_lo = alloca i64, align 8
  %keyed_hi = alloca i64, align 8
  %mixedl = alloca i64, align 8
  %mixedh = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c1) #11
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !12
  store i8 %1, i8* %c1, align 1, !tbaa !12
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c2) #11
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1, !tbaa !12
  store i8 %4, i8* %c2, align 1, !tbaa !12
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c3) #11
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %6 = load i64, i64* %len.addr, align 8, !tbaa !8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1, !tbaa !12
  store i8 %7, i8* %c3, align 1, !tbaa !12
  %8 = bitcast i32* %combinedl to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #11
  %9 = load i8, i8* %c1, align 1, !tbaa !12
  %conv = zext i8 %9 to i32
  %shl = shl i32 %conv, 16
  %10 = load i8, i8* %c2, align 1, !tbaa !12
  %conv3 = zext i8 %10 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %11 = load i8, i8* %c3, align 1, !tbaa !12
  %conv5 = zext i8 %11 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %conv8 = trunc i64 %12 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combinedl, align 4, !tbaa !10
  %13 = bitcast i32* %combinedh to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %13) #11
  %14 = load i32, i32* %combinedl, align 4, !tbaa !10
  %call = call i32 @XXH_swap32(i32 %14)
  %15 = call i32 @llvm.fshl.i32(i32 %call, i32 %call, i32 13)
  store i32 %15, i32* %combinedh, align 4, !tbaa !10
  %16 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #11
  %17 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %call11 = call i32 @XXH_readLE32(i8* %17)
  %18 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %18, i64 4
  %call12 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call11, %call12
  %conv13 = zext i32 %xor to i64
  %19 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %add = add i64 %conv13, %19
  store i64 %add, i64* %bitflipl, align 8, !tbaa !22
  %20 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #11
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr14 = getelementptr inbounds i8, i8* %21, i64 8
  %call15 = call i32 @XXH_readLE32(i8* %add.ptr14)
  %22 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr16 = getelementptr inbounds i8, i8* %22, i64 12
  %call17 = call i32 @XXH_readLE32(i8* %add.ptr16)
  %xor18 = xor i32 %call15, %call17
  %conv19 = zext i32 %xor18 to i64
  %23 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %sub20 = sub i64 %conv19, %23
  store i64 %sub20, i64* %bitfliph, align 8, !tbaa !22
  %24 = bitcast i64* %keyed_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #11
  %25 = load i32, i32* %combinedl, align 4, !tbaa !10
  %conv21 = zext i32 %25 to i64
  %26 = load i64, i64* %bitflipl, align 8, !tbaa !22
  %xor22 = xor i64 %conv21, %26
  store i64 %xor22, i64* %keyed_lo, align 8, !tbaa !22
  %27 = bitcast i64* %keyed_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %27) #11
  %28 = load i32, i32* %combinedh, align 4, !tbaa !10
  %conv23 = zext i32 %28 to i64
  %29 = load i64, i64* %bitfliph, align 8, !tbaa !22
  %xor24 = xor i64 %conv23, %29
  store i64 %xor24, i64* %keyed_hi, align 8, !tbaa !22
  %30 = bitcast i64* %mixedl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %30) #11
  %31 = load i64, i64* %keyed_lo, align 8, !tbaa !22
  %mul = mul i64 %31, -7046029288634856825
  store i64 %mul, i64* %mixedl, align 8, !tbaa !22
  %32 = bitcast i64* %mixedh to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %32) #11
  %33 = load i64, i64* %keyed_hi, align 8, !tbaa !22
  %mul25 = mul i64 %33, 2870177450012600261
  store i64 %mul25, i64* %mixedh, align 8, !tbaa !22
  %34 = load i64, i64* %mixedl, align 8, !tbaa !22
  %call26 = call i64 @XXH3_avalanche(i64 %34)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call26, i64* %low64, align 8, !tbaa !42
  %35 = load i64, i64* %mixedh, align 8, !tbaa !22
  %call27 = call i64 @XXH3_avalanche(i64 %35)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call27, i64* %high64, align 8, !tbaa !40
  %36 = bitcast i64* %mixedh to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %36) #11
  %37 = bitcast i64* %mixedl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %37) #11
  %38 = bitcast i64* %keyed_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %38) #11
  %39 = bitcast i64* %keyed_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %39) #11
  %40 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %40) #11
  %41 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %41) #11
  %42 = bitcast i32* %combinedh to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %42) #11
  %43 = bitcast i32* %combinedl to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %43) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c3) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c2) #11
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c1) #11
  %44 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %45 = load { i64, i64 }, { i64, i64 }* %44, align 8
  ret { i64, i64 } %45
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH128_mix32B(i64 %acc.coerce0, i64 %acc.coerce1, i8* %input_1, i8* %input_2, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %input_1.addr = alloca i8*, align 8
  %input_2.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %0 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %acc.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %acc.coerce1, i64* %2, align 8
  store i8* %input_1, i8** %input_1.addr, align 8, !tbaa !4
  store i8* %input_2, i8** %input_2.addr, align 8, !tbaa !4
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !22
  %3 = load i8*, i8** %input_1.addr, align 8, !tbaa !4
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call = call i64 @XXH3_mix16B(i8* %3, i8* %add.ptr, i64 %5)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %6 = load i64, i64* %low64, align 8, !tbaa !42
  %add = add i64 %6, %call
  store i64 %add, i64* %low64, align 8, !tbaa !42
  %7 = load i8*, i8** %input_2.addr, align 8, !tbaa !4
  %call1 = call i64 @XXH_readLE64(i8* %7)
  %8 = load i8*, i8** %input_2.addr, align 8, !tbaa !4
  %add.ptr2 = getelementptr inbounds i8, i8* %8, i64 8
  %call3 = call i64 @XXH_readLE64(i8* %add.ptr2)
  %add4 = add i64 %call1, %call3
  %low645 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %9 = load i64, i64* %low645, align 8, !tbaa !42
  %xor = xor i64 %9, %add4
  store i64 %xor, i64* %low645, align 8, !tbaa !42
  %10 = load i8*, i8** %input_2.addr, align 8, !tbaa !4
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 16
  %12 = load i64, i64* %seed.addr, align 8, !tbaa !22
  %call7 = call i64 @XXH3_mix16B(i8* %10, i8* %add.ptr6, i64 %12)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %13 = load i64, i64* %high64, align 8, !tbaa !40
  %add8 = add i64 %13, %call7
  store i64 %add8, i64* %high64, align 8, !tbaa !40
  %14 = load i8*, i8** %input_1.addr, align 8, !tbaa !4
  %call9 = call i64 @XXH_readLE64(i8* %14)
  %15 = load i8*, i8** %input_1.addr, align 8, !tbaa !4
  %add.ptr10 = getelementptr inbounds i8, i8* %15, i64 8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %add12 = add i64 %call9, %call11
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %16 = load i64, i64* %high6413, align 8, !tbaa !40
  %xor14 = xor i64 %16, %add12
  store i64 %xor14, i64* %high6413, align 8, !tbaa !40
  %17 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %18 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %18, i64 16, i1 false), !tbaa.struct !43
  %19 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %20 = load { i64, i64 }, { i64, i64 }* %19, align 8
  ret { i64, i64 } %20
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !4
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !8
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #11
  %1 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %1, i8* align 16 bitcast ([8 x i64]* @__const.XXH3_hashLong_128b_internal.acc to i8*), i64 64, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %3 = load i64, i64* %len.addr, align 8, !tbaa !8
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %6 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %7 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %2, i64 %3, i8* %4, i64 %5, i32 1, void (i8*, i8*, i8*, i32)* %6, void (i8*, i8*)* %7)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 11
  %9 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul = mul i64 %9, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 0
  store i64 %call, i64* %low64, align 8, !tbaa !42
  %arraydecay2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %10 = load i8*, i8** %secret.addr, align 8, !tbaa !4
  %11 = load i64, i64* %secretSize.addr, align 8, !tbaa !8
  %add.ptr3 = getelementptr inbounds i8, i8* %10, i64 %11
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  %add.ptr5 = getelementptr inbounds i8, i8* %add.ptr4, i64 -11
  %12 = load i64, i64* %len.addr, align 8, !tbaa !8
  %mul6 = mul i64 %12, -4417276706812531889
  %neg = xor i64 %mul6, -1
  %call7 = call i64 @XXH3_mergeAccs(i64* %arraydecay2, i8* %add.ptr5, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %retval, i32 0, i32 1
  store i64 %call7, i64* %high64, align 8, !tbaa !40
  %13 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %13) #11
  %14 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %15 = load { i64, i64 }, { i64, i64 }* %14, align 8
  ret { i64, i64 } %15
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* noalias %input, i64 %len, i64 %seed64, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !4
  store i64 %len, i64* %len.addr, align 8, !tbaa !8
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !22
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !4
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %2 = load i64, i64* %len.addr, align 8, !tbaa !8
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 192, i8* %10) #11
  %11 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !4
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %12 = load i64, i64* %seed64.addr, align 8, !tbaa !22
  call void %11(i8* %arraydecay, i64 %12)
  %13 = load i8*, i8** %input.addr, align 8, !tbaa !4
  %14 = load i64, i64* %len.addr, align 8, !tbaa !8
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %15 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !4
  %16 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !4
  %call2 = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %13, i64 %14, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %15, void (i8*, i8*)* %16)
  %17 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call2, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call2, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 192, i8* %22) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  %23 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %24 = load { i64, i64 }, { i64, i64 }* %23, align 8
  ret { i64, i64 } %24
}

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { alwaysinline nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone speculatable }
attributes #4 = { argmemonly nounwind }
attributes #5 = { noinline nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { alwaysinline nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="128" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind readnone }
attributes #10 = { inaccessiblemem_or_argmemonly nounwind }
attributes #11 = { nounwind }
attributes #12 = { allocsize(0) }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 2, !"SDK Version", [3 x i32] [i32 10, i32 15, i32 4]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"PIC Level", i32 2}
!3 = !{!"clang version 8.0.1 (https://github.com/llvm-mirror/clang.git 2e4c9c5fc864c2c432e4c262a67c42d824b265c6) (https://github.com/llvm-mirror/llvm.git ea28a67e47fd87c6b78597d90eba543bad4d7468)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"any pointer", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!9, !9, i64 0}
!9 = !{!"long", !6, i64 0}
!10 = !{!11, !11, i64 0}
!11 = !{!"int", !6, i64 0}
!12 = !{!6, !6, i64 0}
!13 = !{!14, !11, i64 8}
!14 = !{!"XXH32_state_s", !11, i64 0, !11, i64 4, !11, i64 8, !11, i64 12, !11, i64 16, !11, i64 20, !6, i64 24, !11, i64 40, !11, i64 44}
!15 = !{!14, !11, i64 12}
!16 = !{!14, !11, i64 16}
!17 = !{!14, !11, i64 20}
!18 = !{!14, !11, i64 0}
!19 = !{!14, !11, i64 4}
!20 = !{!14, !11, i64 40}
!21 = !{i32 61697}
!22 = !{!23, !23, i64 0}
!23 = !{!"long long", !6, i64 0}
!24 = !{!25, !23, i64 8}
!25 = !{!"XXH64_state_s", !23, i64 0, !23, i64 8, !23, i64 16, !23, i64 24, !23, i64 32, !6, i64 40, !11, i64 72, !11, i64 76, !23, i64 80}
!26 = !{!25, !23, i64 16}
!27 = !{!25, !23, i64 24}
!28 = !{!25, !23, i64 32}
!29 = !{!25, !23, i64 0}
!30 = !{!25, !11, i64 72}
!31 = !{!32, !23, i64 552}
!32 = !{!"XXH3_state_s", !6, i64 0, !6, i64 64, !6, i64 256, !11, i64 512, !11, i64 516, !9, i64 520, !9, i64 528, !9, i64 536, !23, i64 544, !23, i64 552, !23, i64 560, !5, i64 568}
!33 = !{!32, !5, i64 568}
!34 = !{!32, !9, i64 536}
!35 = !{!32, !9, i64 520}
!36 = !{i32 1010721}
!37 = !{!32, !23, i64 544}
!38 = !{!32, !11, i64 512}
!39 = !{!32, !9, i64 528}
!40 = !{!41, !23, i64 8}
!41 = !{!"", !23, i64 0, !23, i64 8}
!42 = !{!41, !23, i64 0}
!43 = !{i64 0, i64 8, !22, i64 8, i64 8, !22}
!44 = !{!45, !45, i64 0}
!45 = !{!"__int128", !6, i64 0}
