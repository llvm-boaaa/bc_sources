; ModuleID = 'xxhash.c'
source_filename = "xxhash.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

%struct.XXH32_state_s = type { i32, i32, i32, i32, i32, i32, [4 x i32], i32, i32 }
%struct.XXH32_canonical_t = type { [4 x i8] }
%struct.XXH64_state_s = type { i64, i64, i64, i64, i64, [4 x i64], i32, i32, i64 }
%struct.XXH64_canonical_t = type { [8 x i8] }
%struct.XXH3_state_s = type { [8 x i64], [192 x i8], [256 x i8], i32, i32, i64, i64, i64, i64, i64, i64, i8* }
%struct.XXH128_canonical_t = type { [16 x i8] }
%struct.XXH128_hash_t = type { i64, i64 }
%struct.__loadu_si128 = type { <2 x i64> }

@XXH3_kSecret = internal constant [192 x i8] c"\B8\FEl9#\A4K\BE|\01\81,\F7!\AD\1C\DE\D4m\E9\83\90\97\DBr@\A4\A4\B7\B3g\1F\CBy\E6N\CC\C0\E5x\82Z\D0}\CC\FFr!\B8\08Ft\F7C$\8E\E05\90\E6\81:&L<(R\BB\91\C3\00\CB\88\D0e\8B\1BS.\A3qdH\97\A2\0D\F9N8\19\EFF\A9\DE\AC\D8\A8\FAv?\E3\9C4?\F9\DC\BB\C7\C7\0BO\1D\8AQ\E0K\CD\B4Y1\C8\9F~\C9\D9xsd\EA\C5\AC\834\D3\EB\C3\C5\81\A0\FF\FA\13c\EB\17\0D\DDQ\B7\F0\DAI\D3\16U&)\D4h\9E+\16\BEX}G\A1\FC\8F\F8\B8\D1z\D01\CEE\CB:\8F\95\16\04(\AF\D7\FB\CA\BBK@~", align 64
@XXH3_hashLong_64b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16
@XXH3_hashLong_128b_internal.acc = private unnamed_addr constant [8 x i64] [i64 3266489917, i64 -7046029288634856825, i64 -4417276706812531889, i64 1609587929392839161, i64 -8796714831421723037, i64 2246822519, i64 2870177450012600261, i64 2654435761], align 16

; Function Attrs: nounwind ssp uwtable
define i32 @XXH_versionNumber() #0 {
entry:
  ret i32 704
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32(i8* %input, i64 %len, i32 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i32 %seed, i32* %seed.addr, align 4, !tbaa !9
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %call = call i32 @XXH32_endian_align(i8* %0, i64 %1, i32 %2, i32 1)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH32_endian_align(i8* %input, i64 %len, i32 %seed, i32 %align) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h32 = alloca i32, align 4
  %limit = alloca i8*, align 8
  %v1 = alloca i32, align 4
  %v2 = alloca i32, align 4
  %v3 = alloca i32, align 4
  %v4 = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i32 %seed, i32* %seed.addr, align 4, !tbaa !9
  store i32 %align, i32* %align.addr, align 4, !tbaa !11
  %0 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !3
  %3 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #10
  %4 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp uge i64 %4, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #10
  %6 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, i8* %6, i64 -15
  store i8* %add.ptr1, i8** %limit, align 8, !tbaa !3
  %7 = bitcast i32* %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #10
  %8 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add = add i32 %8, -1640531535
  %add2 = add i32 %add, -2048144777
  store i32 %add2, i32* %v1, align 4, !tbaa !9
  %9 = bitcast i32* %v2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #10
  %10 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add3 = add i32 %10, -2048144777
  store i32 %add3, i32* %v2, align 4, !tbaa !9
  %11 = bitcast i32* %v3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %11) #10
  %12 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add4 = add i32 %12, 0
  store i32 %add4, i32* %v3, align 4, !tbaa !9
  %13 = bitcast i32* %v4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %13) #10
  %14 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %sub = sub i32 %14, -1640531535
  store i32 %sub, i32* %v4, align 4, !tbaa !9
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %15 = load i32, i32* %v1, align 4, !tbaa !9
  %16 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %17 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call = call i32 @XXH_readLE32_align(i8* %16, i32 %17)
  %call5 = call i32 @XXH32_round(i32 %15, i32 %call)
  store i32 %call5, i32* %v1, align 4, !tbaa !9
  %18 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr6 = getelementptr inbounds i8, i8* %18, i64 4
  store i8* %add.ptr6, i8** %input.addr, align 8, !tbaa !3
  %19 = load i32, i32* %v2, align 4, !tbaa !9
  %20 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %21 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call7 = call i32 @XXH_readLE32_align(i8* %20, i32 %21)
  %call8 = call i32 @XXH32_round(i32 %19, i32 %call7)
  store i32 %call8, i32* %v2, align 4, !tbaa !9
  %22 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr9 = getelementptr inbounds i8, i8* %22, i64 4
  store i8* %add.ptr9, i8** %input.addr, align 8, !tbaa !3
  %23 = load i32, i32* %v3, align 4, !tbaa !9
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %25 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call10 = call i32 @XXH_readLE32_align(i8* %24, i32 %25)
  %call11 = call i32 @XXH32_round(i32 %23, i32 %call10)
  store i32 %call11, i32* %v3, align 4, !tbaa !9
  %26 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr12 = getelementptr inbounds i8, i8* %26, i64 4
  store i8* %add.ptr12, i8** %input.addr, align 8, !tbaa !3
  %27 = load i32, i32* %v4, align 4, !tbaa !9
  %28 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %29 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call13 = call i32 @XXH_readLE32_align(i8* %28, i32 %29)
  %call14 = call i32 @XXH32_round(i32 %27, i32 %call13)
  store i32 %call14, i32* %v4, align 4, !tbaa !9
  %30 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr15 = getelementptr inbounds i8, i8* %30, i64 4
  store i8* %add.ptr15, i8** %input.addr, align 8, !tbaa !3
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %31 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %32 = load i8*, i8** %limit, align 8, !tbaa !3
  %cmp16 = icmp ult i8* %31, %32
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %33 = load i32, i32* %v1, align 4, !tbaa !9
  %shl = shl i32 %33, 1
  %34 = load i32, i32* %v1, align 4, !tbaa !9
  %shr = lshr i32 %34, 31
  %or = or i32 %shl, %shr
  %35 = load i32, i32* %v2, align 4, !tbaa !9
  %shl17 = shl i32 %35, 7
  %36 = load i32, i32* %v2, align 4, !tbaa !9
  %shr18 = lshr i32 %36, 25
  %or19 = or i32 %shl17, %shr18
  %add20 = add i32 %or, %or19
  %37 = load i32, i32* %v3, align 4, !tbaa !9
  %shl21 = shl i32 %37, 12
  %38 = load i32, i32* %v3, align 4, !tbaa !9
  %shr22 = lshr i32 %38, 20
  %or23 = or i32 %shl21, %shr22
  %add24 = add i32 %add20, %or23
  %39 = load i32, i32* %v4, align 4, !tbaa !9
  %shl25 = shl i32 %39, 18
  %40 = load i32, i32* %v4, align 4, !tbaa !9
  %shr26 = lshr i32 %40, 14
  %or27 = or i32 %shl25, %shr26
  %add28 = add i32 %add24, %or27
  store i32 %add28, i32* %h32, align 4, !tbaa !9
  %41 = bitcast i32* %v4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %41) #10
  %42 = bitcast i32* %v3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %42) #10
  %43 = bitcast i32* %v2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %43) #10
  %44 = bitcast i32* %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %44) #10
  %45 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #10
  br label %if.end

if.else:                                          ; preds = %entry
  %46 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add29 = add i32 %46, 374761393
  store i32 %add29, i32* %h32, align 4, !tbaa !9
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %47 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv = trunc i64 %47 to i32
  %48 = load i32, i32* %h32, align 4, !tbaa !9
  %add30 = add i32 %48, %conv
  store i32 %add30, i32* %h32, align 4, !tbaa !9
  %49 = load i32, i32* %h32, align 4, !tbaa !9
  %50 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %51 = load i64, i64* %len.addr, align 8, !tbaa !7
  %and = and i64 %51, 15
  %52 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call31 = call i32 @XXH32_finalize(i32 %49, i8* %50, i64 %and, i32 %52)
  %53 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %53) #10
  %54 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %54) #10
  ret i32 %call31
}

; Function Attrs: nounwind ssp uwtable
define %struct.XXH32_state_s* @XXH32_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 48)
  %0 = bitcast i8* %call to %struct.XXH32_state_s*
  ret %struct.XXH32_state_s* %0
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @XXH_malloc(i64 %s) #0 {
entry:
  %s.addr = alloca i64, align 8
  store i64 %s, i64* %s.addr, align 8, !tbaa !7
  %0 = load i64, i64* %s.addr, align 8, !tbaa !7
  %call = call i8* @malloc(i64 %0) #11
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_freeState(%struct.XXH32_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !3
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH_free(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %p.addr, align 8, !tbaa !3
  call void @free(i8* %0)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @XXH32_copyState(%struct.XXH32_state_s* %dstState, %struct.XXH32_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH32_state_s*, align 8
  %srcState.addr = alloca %struct.XXH32_state_s*, align 8
  store %struct.XXH32_state_s* %dstState, %struct.XXH32_state_s** %dstState.addr, align 8, !tbaa !3
  store %struct.XXH32_state_s* %srcState, %struct.XXH32_state_s** %srcState.addr, align 8, !tbaa !3
  %0 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH32_state_s* %0 to i8*
  %2 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %srcState.addr, align 8, !tbaa !3
  %3 = bitcast %struct.XXH32_state_s* %2 to i8*
  %4 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %dstState.addr, align 8, !tbaa !3
  %5 = bitcast %struct.XXH32_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 48, i64 %6) #10
  ret void
}

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #2

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #3

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_reset(%struct.XXH32_state_s* %statePtr, i32 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH32_state_s*, align 8
  %seed.addr = alloca i32, align 4
  %state = alloca %struct.XXH32_state_s, align 4
  store %struct.XXH32_state_s* %statePtr, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !3
  store i32 %seed, i32* %seed.addr, align 4, !tbaa !9
  %0 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %0) #10
  %1 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 48, i32 4, i1 false)
  %2 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add = add i32 %2, -1640531535
  %add1 = add i32 %add, -2048144777
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 2
  store i32 %add1, i32* %v1, align 4, !tbaa !12
  %3 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add2 = add i32 %3, -2048144777
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 3
  store i32 %add2, i32* %v2, align 4, !tbaa !14
  %4 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %add3 = add i32 %4, 0
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 4
  store i32 %add3, i32* %v3, align 4, !tbaa !15
  %5 = load i32, i32* %seed.addr, align 4, !tbaa !9
  %sub = sub i32 %5, -1640531535
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %state, i32 0, i32 5
  store i32 %sub, i32* %v4, align 4, !tbaa !16
  %6 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !3
  %7 = bitcast %struct.XXH32_state_s* %6 to i8*
  %8 = bitcast %struct.XXH32_state_s* %state to i8*
  %9 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %statePtr.addr, align 8, !tbaa !3
  %10 = bitcast %struct.XXH32_state_s* %9 to i8*
  %11 = call i64 @llvm.objectsize.i64.p0i8(i8* %10, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %7, i8* %8, i64 44, i64 %11) #10
  %12 = bitcast %struct.XXH32_state_s* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %12) #10
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_update(%struct.XXH32_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  %p32 = alloca i32*, align 8
  %limit = alloca i8*, align 8
  %v155 = alloca i32, align 4
  %v257 = alloca i32, align 4
  %v359 = alloca i32, align 4
  %v461 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  store i8* %2, i8** %p, align 8, !tbaa !3
  %3 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load i8*, i8** %p, align 8, !tbaa !3
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %5
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !3
  %6 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv = trunc i64 %6 to i32
  %7 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %7, i32 0, i32 0
  %8 = load i32, i32* %total_len_32, align 4, !tbaa !17
  %add = add i32 %8, %conv
  store i32 %add, i32* %total_len_32, align 4, !tbaa !17
  %9 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp1 = icmp uge i64 %9, 16
  %conv2 = zext i1 %cmp1 to i32
  %10 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %total_len_323 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %10, i32 0, i32 0
  %11 = load i32, i32* %total_len_323, align 4, !tbaa !17
  %cmp4 = icmp uge i32 %11, 16
  %conv5 = zext i1 %cmp4 to i32
  %or = or i32 %conv2, %conv5
  %12 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %12, i32 0, i32 1
  %13 = load i32, i32* %large_len, align 4, !tbaa !18
  %or6 = or i32 %13, %or
  store i32 %or6, i32* %large_len, align 4, !tbaa !18
  %14 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %14, i32 0, i32 7
  %15 = load i32, i32* %memsize, align 4, !tbaa !19
  %conv7 = zext i32 %15 to i64
  %16 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add8 = add i64 %conv7, %16
  %cmp9 = icmp ult i64 %add8, 16
  br i1 %cmp9, label %if.then11, label %if.end17

if.then11:                                        ; preds = %if.end
  %17 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %17, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %18 = bitcast i32* %arraydecay to i8*
  %19 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize12 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %19, i32 0, i32 7
  %20 = load i32, i32* %memsize12, align 4, !tbaa !19
  %idx.ext = zext i32 %20 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %18, i64 %idx.ext
  %21 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %22 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call i8* @XXH_memcpy(i8* %add.ptr13, i8* %21, i64 %22)
  %23 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv14 = trunc i64 %23 to i32
  %24 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize15 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %24, i32 0, i32 7
  %25 = load i32, i32* %memsize15, align 4, !tbaa !19
  %add16 = add i32 %25, %conv14
  store i32 %add16, i32* %memsize15, align 4, !tbaa !19
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end17:                                         ; preds = %if.end
  %26 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize18 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %26, i32 0, i32 7
  %27 = load i32, i32* %memsize18, align 4, !tbaa !19
  %tobool = icmp ne i32 %27, 0
  br i1 %tobool, label %if.then19, label %if.end49

if.then19:                                        ; preds = %if.end17
  %28 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %mem3220 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %28, i32 0, i32 6
  %arraydecay21 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3220, i32 0, i32 0
  %29 = bitcast i32* %arraydecay21 to i8*
  %30 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize22 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %30, i32 0, i32 7
  %31 = load i32, i32* %memsize22, align 4, !tbaa !19
  %idx.ext23 = zext i32 %31 to i64
  %add.ptr24 = getelementptr inbounds i8, i8* %29, i64 %idx.ext23
  %32 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %33 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize25 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %33, i32 0, i32 7
  %34 = load i32, i32* %memsize25, align 4, !tbaa !19
  %sub = sub i32 16, %34
  %conv26 = zext i32 %sub to i64
  %call27 = call i8* @XXH_memcpy(i8* %add.ptr24, i8* %32, i64 %conv26)
  %35 = bitcast i32** %p32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %35) #10
  %36 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %mem3228 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %36, i32 0, i32 6
  %arraydecay29 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3228, i32 0, i32 0
  store i32* %arraydecay29, i32** %p32, align 8, !tbaa !3
  %37 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %37, i32 0, i32 2
  %38 = load i32, i32* %v1, align 4, !tbaa !12
  %39 = load i32*, i32** %p32, align 8, !tbaa !3
  %40 = bitcast i32* %39 to i8*
  %call30 = call i32 @XXH_readLE32(i8* %40)
  %call31 = call i32 @XXH32_round(i32 %38, i32 %call30)
  %41 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v132 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %41, i32 0, i32 2
  store i32 %call31, i32* %v132, align 4, !tbaa !12
  %42 = load i32*, i32** %p32, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds i32, i32* %42, i32 1
  store i32* %incdec.ptr, i32** %p32, align 8, !tbaa !3
  %43 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %43, i32 0, i32 3
  %44 = load i32, i32* %v2, align 4, !tbaa !14
  %45 = load i32*, i32** %p32, align 8, !tbaa !3
  %46 = bitcast i32* %45 to i8*
  %call33 = call i32 @XXH_readLE32(i8* %46)
  %call34 = call i32 @XXH32_round(i32 %44, i32 %call33)
  %47 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v235 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %47, i32 0, i32 3
  store i32 %call34, i32* %v235, align 4, !tbaa !14
  %48 = load i32*, i32** %p32, align 8, !tbaa !3
  %incdec.ptr36 = getelementptr inbounds i32, i32* %48, i32 1
  store i32* %incdec.ptr36, i32** %p32, align 8, !tbaa !3
  %49 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %49, i32 0, i32 4
  %50 = load i32, i32* %v3, align 4, !tbaa !15
  %51 = load i32*, i32** %p32, align 8, !tbaa !3
  %52 = bitcast i32* %51 to i8*
  %call37 = call i32 @XXH_readLE32(i8* %52)
  %call38 = call i32 @XXH32_round(i32 %50, i32 %call37)
  %53 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v339 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %53, i32 0, i32 4
  store i32 %call38, i32* %v339, align 4, !tbaa !15
  %54 = load i32*, i32** %p32, align 8, !tbaa !3
  %incdec.ptr40 = getelementptr inbounds i32, i32* %54, i32 1
  store i32* %incdec.ptr40, i32** %p32, align 8, !tbaa !3
  %55 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %55, i32 0, i32 5
  %56 = load i32, i32* %v4, align 4, !tbaa !16
  %57 = load i32*, i32** %p32, align 8, !tbaa !3
  %58 = bitcast i32* %57 to i8*
  %call41 = call i32 @XXH_readLE32(i8* %58)
  %call42 = call i32 @XXH32_round(i32 %56, i32 %call41)
  %59 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v443 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %59, i32 0, i32 5
  store i32 %call42, i32* %v443, align 4, !tbaa !16
  %60 = bitcast i32** %p32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %60) #10
  %61 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize44 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %61, i32 0, i32 7
  %62 = load i32, i32* %memsize44, align 4, !tbaa !19
  %sub45 = sub i32 16, %62
  %63 = load i8*, i8** %p, align 8, !tbaa !3
  %idx.ext46 = zext i32 %sub45 to i64
  %add.ptr47 = getelementptr inbounds i8, i8* %63, i64 %idx.ext46
  store i8* %add.ptr47, i8** %p, align 8, !tbaa !3
  %64 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize48 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %64, i32 0, i32 7
  store i32 0, i32* %memsize48, align 4, !tbaa !19
  br label %if.end49

if.end49:                                         ; preds = %if.then19, %if.end17
  %65 = load i8*, i8** %p, align 8, !tbaa !3
  %66 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %add.ptr50 = getelementptr inbounds i8, i8* %66, i64 -16
  %cmp51 = icmp ule i8* %65, %add.ptr50
  br i1 %cmp51, label %if.then53, label %if.end81

if.then53:                                        ; preds = %if.end49
  %67 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %67) #10
  %68 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %add.ptr54 = getelementptr inbounds i8, i8* %68, i64 -16
  store i8* %add.ptr54, i8** %limit, align 8, !tbaa !3
  %69 = bitcast i32* %v155 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %69) #10
  %70 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v156 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %70, i32 0, i32 2
  %71 = load i32, i32* %v156, align 4, !tbaa !12
  store i32 %71, i32* %v155, align 4, !tbaa !9
  %72 = bitcast i32* %v257 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %72) #10
  %73 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v258 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %73, i32 0, i32 3
  %74 = load i32, i32* %v258, align 4, !tbaa !14
  store i32 %74, i32* %v257, align 4, !tbaa !9
  %75 = bitcast i32* %v359 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %75) #10
  %76 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v360 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %76, i32 0, i32 4
  %77 = load i32, i32* %v360, align 4, !tbaa !15
  store i32 %77, i32* %v359, align 4, !tbaa !9
  %78 = bitcast i32* %v461 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %78) #10
  %79 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v462 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %79, i32 0, i32 5
  %80 = load i32, i32* %v462, align 4, !tbaa !16
  store i32 %80, i32* %v461, align 4, !tbaa !9
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then53
  %81 = load i32, i32* %v155, align 4, !tbaa !9
  %82 = load i8*, i8** %p, align 8, !tbaa !3
  %call63 = call i32 @XXH_readLE32(i8* %82)
  %call64 = call i32 @XXH32_round(i32 %81, i32 %call63)
  store i32 %call64, i32* %v155, align 4, !tbaa !9
  %83 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr65 = getelementptr inbounds i8, i8* %83, i64 4
  store i8* %add.ptr65, i8** %p, align 8, !tbaa !3
  %84 = load i32, i32* %v257, align 4, !tbaa !9
  %85 = load i8*, i8** %p, align 8, !tbaa !3
  %call66 = call i32 @XXH_readLE32(i8* %85)
  %call67 = call i32 @XXH32_round(i32 %84, i32 %call66)
  store i32 %call67, i32* %v257, align 4, !tbaa !9
  %86 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr68 = getelementptr inbounds i8, i8* %86, i64 4
  store i8* %add.ptr68, i8** %p, align 8, !tbaa !3
  %87 = load i32, i32* %v359, align 4, !tbaa !9
  %88 = load i8*, i8** %p, align 8, !tbaa !3
  %call69 = call i32 @XXH_readLE32(i8* %88)
  %call70 = call i32 @XXH32_round(i32 %87, i32 %call69)
  store i32 %call70, i32* %v359, align 4, !tbaa !9
  %89 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr71 = getelementptr inbounds i8, i8* %89, i64 4
  store i8* %add.ptr71, i8** %p, align 8, !tbaa !3
  %90 = load i32, i32* %v461, align 4, !tbaa !9
  %91 = load i8*, i8** %p, align 8, !tbaa !3
  %call72 = call i32 @XXH_readLE32(i8* %91)
  %call73 = call i32 @XXH32_round(i32 %90, i32 %call72)
  store i32 %call73, i32* %v461, align 4, !tbaa !9
  %92 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr74 = getelementptr inbounds i8, i8* %92, i64 4
  store i8* %add.ptr74, i8** %p, align 8, !tbaa !3
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %93 = load i8*, i8** %p, align 8, !tbaa !3
  %94 = load i8*, i8** %limit, align 8, !tbaa !3
  %cmp75 = icmp ule i8* %93, %94
  br i1 %cmp75, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %95 = load i32, i32* %v155, align 4, !tbaa !9
  %96 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v177 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %96, i32 0, i32 2
  store i32 %95, i32* %v177, align 4, !tbaa !12
  %97 = load i32, i32* %v257, align 4, !tbaa !9
  %98 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v278 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %98, i32 0, i32 3
  store i32 %97, i32* %v278, align 4, !tbaa !14
  %99 = load i32, i32* %v359, align 4, !tbaa !9
  %100 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v379 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %100, i32 0, i32 4
  store i32 %99, i32* %v379, align 4, !tbaa !15
  %101 = load i32, i32* %v461, align 4, !tbaa !9
  %102 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v480 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %102, i32 0, i32 5
  store i32 %101, i32* %v480, align 4, !tbaa !16
  %103 = bitcast i32* %v461 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %103) #10
  %104 = bitcast i32* %v359 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %104) #10
  %105 = bitcast i32* %v257 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %105) #10
  %106 = bitcast i32* %v155 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %106) #10
  %107 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %107) #10
  br label %if.end81

if.end81:                                         ; preds = %do.end, %if.end49
  %108 = load i8*, i8** %p, align 8, !tbaa !3
  %109 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %cmp82 = icmp ult i8* %108, %109
  br i1 %cmp82, label %if.then84, label %if.end93

if.then84:                                        ; preds = %if.end81
  %110 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %mem3285 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %110, i32 0, i32 6
  %arraydecay86 = getelementptr inbounds [4 x i32], [4 x i32]* %mem3285, i32 0, i32 0
  %111 = bitcast i32* %arraydecay86 to i8*
  %112 = load i8*, i8** %p, align 8, !tbaa !3
  %113 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %114 = load i8*, i8** %p, align 8, !tbaa !3
  %sub.ptr.lhs.cast = ptrtoint i8* %113 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %114 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call87 = call i8* @XXH_memcpy(i8* %111, i8* %112, i64 %sub.ptr.sub)
  %115 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %116 = load i8*, i8** %p, align 8, !tbaa !3
  %sub.ptr.lhs.cast88 = ptrtoint i8* %115 to i64
  %sub.ptr.rhs.cast89 = ptrtoint i8* %116 to i64
  %sub.ptr.sub90 = sub i64 %sub.ptr.lhs.cast88, %sub.ptr.rhs.cast89
  %conv91 = trunc i64 %sub.ptr.sub90 to i32
  %117 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize92 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %117, i32 0, i32 7
  store i32 %conv91, i32* %memsize92, align 4, !tbaa !19
  br label %if.end93

if.end93:                                         ; preds = %if.then84, %if.end81
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end93, %if.then11
  %118 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %118) #10
  %119 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %119) #10
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cleanup.cont, %cleanup, %if.then
  %120 = load i32, i32* %retval, align 4
  ret i32 %120

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @XXH_memcpy(i8* %dest, i8* %src, i64 %size) #0 {
entry:
  %dest.addr = alloca i8*, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  store i8* %dest, i8** %dest.addr, align 8, !tbaa !3
  store i8* %src, i8** %src.addr, align 8, !tbaa !3
  store i64 %size, i64* %size.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %dest.addr, align 8, !tbaa !3
  %1 = load i8*, i8** %src.addr, align 8, !tbaa !3
  %2 = load i64, i64* %size.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %dest.addr, align 8, !tbaa !3
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 %2, i64 %4) #10
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH32_round(i32 %acc, i32 %input) #0 {
entry:
  %acc.addr = alloca i32, align 4
  %input.addr = alloca i32, align 4
  store i32 %acc, i32* %acc.addr, align 4, !tbaa !9
  store i32 %input, i32* %input.addr, align 4, !tbaa !9
  %0 = load i32, i32* %input.addr, align 4, !tbaa !9
  %mul = mul i32 %0, -2048144777
  %1 = load i32, i32* %acc.addr, align 4, !tbaa !9
  %add = add i32 %1, %mul
  store i32 %add, i32* %acc.addr, align 4, !tbaa !9
  %2 = load i32, i32* %acc.addr, align 4, !tbaa !9
  %shl = shl i32 %2, 13
  %3 = load i32, i32* %acc.addr, align 4, !tbaa !9
  %shr = lshr i32 %3, 19
  %or = or i32 %shl, %shr
  store i32 %or, i32* %acc.addr, align 4, !tbaa !9
  %4 = load i32, i32* %acc.addr, align 4, !tbaa !9
  %mul1 = mul i32 %4, -1640531535
  store i32 %mul1, i32* %acc.addr, align 4, !tbaa !9
  %5 = load i32, i32* %acc.addr, align 4, !tbaa !9
  %6 = call i32 asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %5) #8, !srcloc !20
  store i32 %6, i32* %acc.addr, align 4, !tbaa !9
  %7 = load i32, i32* %acc.addr, align 4, !tbaa !9
  ret i32 %7
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH_readLE32(i8* %ptr) #1 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %call = call i32 @XXH_read32(i8* %0)
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_digest(%struct.XXH32_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH32_state_s*, align 8
  %h32 = alloca i32, align 4
  store %struct.XXH32_state_s* %state, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %0 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #10
  %1 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %large_len = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %1, i32 0, i32 1
  %2 = load i32, i32* %large_len, align 4, !tbaa !18
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v1 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %3, i32 0, i32 2
  %4 = load i32, i32* %v1, align 4, !tbaa !12
  %shl = shl i32 %4, 1
  %5 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v11 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %5, i32 0, i32 2
  %6 = load i32, i32* %v11, align 4, !tbaa !12
  %shr = lshr i32 %6, 31
  %or = or i32 %shl, %shr
  %7 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v2 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %7, i32 0, i32 3
  %8 = load i32, i32* %v2, align 4, !tbaa !14
  %shl2 = shl i32 %8, 7
  %9 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v23 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %9, i32 0, i32 3
  %10 = load i32, i32* %v23, align 4, !tbaa !14
  %shr4 = lshr i32 %10, 25
  %or5 = or i32 %shl2, %shr4
  %add = add i32 %or, %or5
  %11 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v3 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %11, i32 0, i32 4
  %12 = load i32, i32* %v3, align 4, !tbaa !15
  %shl6 = shl i32 %12, 12
  %13 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v37 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %13, i32 0, i32 4
  %14 = load i32, i32* %v37, align 4, !tbaa !15
  %shr8 = lshr i32 %14, 20
  %or9 = or i32 %shl6, %shr8
  %add10 = add i32 %add, %or9
  %15 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v4 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %15, i32 0, i32 5
  %16 = load i32, i32* %v4, align 4, !tbaa !16
  %shl11 = shl i32 %16, 18
  %17 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v412 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %17, i32 0, i32 5
  %18 = load i32, i32* %v412, align 4, !tbaa !16
  %shr13 = lshr i32 %18, 14
  %or14 = or i32 %shl11, %shr13
  %add15 = add i32 %add10, %or14
  store i32 %add15, i32* %h32, align 4, !tbaa !9
  br label %if.end

if.else:                                          ; preds = %entry
  %19 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %v316 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %19, i32 0, i32 4
  %20 = load i32, i32* %v316, align 4, !tbaa !15
  %add17 = add i32 %20, 374761393
  store i32 %add17, i32* %h32, align 4, !tbaa !9
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %21 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %total_len_32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %21, i32 0, i32 0
  %22 = load i32, i32* %total_len_32, align 4, !tbaa !17
  %23 = load i32, i32* %h32, align 4, !tbaa !9
  %add18 = add i32 %23, %22
  store i32 %add18, i32* %h32, align 4, !tbaa !9
  %24 = load i32, i32* %h32, align 4, !tbaa !9
  %25 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %mem32 = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %25, i32 0, i32 6
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %mem32, i32 0, i32 0
  %26 = bitcast i32* %arraydecay to i8*
  %27 = load %struct.XXH32_state_s*, %struct.XXH32_state_s** %state.addr, align 8, !tbaa !3
  %memsize = getelementptr inbounds %struct.XXH32_state_s, %struct.XXH32_state_s* %27, i32 0, i32 7
  %28 = load i32, i32* %memsize, align 4, !tbaa !19
  %conv = zext i32 %28 to i64
  %call = call i32 @XXH32_finalize(i32 %24, i8* %26, i64 %conv, i32 0)
  %29 = bitcast i32* %h32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %29) #10
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH32_finalize(i32 %h32, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i32, align 4
  %h32.addr = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4, !tbaa !9
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i32 %align, i32* %align.addr, align 4, !tbaa !11
  %0 = load i64, i64* %len.addr, align 8, !tbaa !7
  %and = and i64 %0, 15
  switch i64 %and, label %sw.epilog [
    i64 12, label %sw.bb
    i64 8, label %sw.bb2
    i64 4, label %sw.bb13
    i64 13, label %sw.bb25
    i64 9, label %sw.bb36
    i64 5, label %sw.bb47
    i64 14, label %sw.bb67
    i64 10, label %sw.bb78
    i64 6, label %sw.bb89
    i64 15, label %sw.bb121
    i64 11, label %sw.bb132
    i64 7, label %sw.bb143
    i64 3, label %sw.bb154
    i64 2, label %sw.bb165
    i64 1, label %sw.bb176
    i64 0, label %sw.bb187
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %2 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call = call i32 @XXH_readLE32_align(i8* %1, i32 %2)
  %mul = mul i32 %call, -1028477379
  %3 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add = add i32 %3, %mul
  store i32 %add, i32* %h32.addr, align 4, !tbaa !9
  %4 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 4
  store i8* %add.ptr, i8** %ptr.addr, align 8, !tbaa !3
  %5 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl = shl i32 %5, 17
  %6 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr = lshr i32 %6, 15
  %or = or i32 %shl, %shr
  %mul1 = mul i32 %or, 668265263
  store i32 %mul1, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %7 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %8 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call4 = call i32 @XXH_readLE32_align(i8* %7, i32 %8)
  %mul5 = mul i32 %call4, -1028477379
  %9 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add6 = add i32 %9, %mul5
  store i32 %add6, i32* %h32.addr, align 4, !tbaa !9
  %10 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 4
  store i8* %add.ptr7, i8** %ptr.addr, align 8, !tbaa !3
  %11 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl8 = shl i32 %11, 17
  %12 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr9 = lshr i32 %12, 15
  %or10 = or i32 %shl8, %shr9
  %mul11 = mul i32 %or10, 668265263
  store i32 %mul11, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end12

do.end12:                                         ; preds = %do.body3
  br label %sw.bb13

sw.bb13:                                          ; preds = %entry, %do.end12
  br label %do.body14

do.body14:                                        ; preds = %sw.bb13
  %13 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %14 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call15 = call i32 @XXH_readLE32_align(i8* %13, i32 %14)
  %mul16 = mul i32 %call15, -1028477379
  %15 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add17 = add i32 %15, %mul16
  store i32 %add17, i32* %h32.addr, align 4, !tbaa !9
  %16 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr18 = getelementptr inbounds i8, i8* %16, i64 4
  store i8* %add.ptr18, i8** %ptr.addr, align 8, !tbaa !3
  %17 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl19 = shl i32 %17, 17
  %18 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr20 = lshr i32 %18, 15
  %or21 = or i32 %shl19, %shr20
  %mul22 = mul i32 %or21, 668265263
  store i32 %mul22, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end23

do.end23:                                         ; preds = %do.body14
  %19 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %call24 = call i32 @XXH32_avalanche(i32 %19)
  store i32 %call24, i32* %retval, align 4
  br label %return

sw.bb25:                                          ; preds = %entry
  br label %do.body26

do.body26:                                        ; preds = %sw.bb25
  %20 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %21 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call27 = call i32 @XXH_readLE32_align(i8* %20, i32 %21)
  %mul28 = mul i32 %call27, -1028477379
  %22 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add29 = add i32 %22, %mul28
  store i32 %add29, i32* %h32.addr, align 4, !tbaa !9
  %23 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr30 = getelementptr inbounds i8, i8* %23, i64 4
  store i8* %add.ptr30, i8** %ptr.addr, align 8, !tbaa !3
  %24 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl31 = shl i32 %24, 17
  %25 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr32 = lshr i32 %25, 15
  %or33 = or i32 %shl31, %shr32
  %mul34 = mul i32 %or33, 668265263
  store i32 %mul34, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end35

do.end35:                                         ; preds = %do.body26
  br label %sw.bb36

sw.bb36:                                          ; preds = %entry, %do.end35
  br label %do.body37

do.body37:                                        ; preds = %sw.bb36
  %26 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %27 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call38 = call i32 @XXH_readLE32_align(i8* %26, i32 %27)
  %mul39 = mul i32 %call38, -1028477379
  %28 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add40 = add i32 %28, %mul39
  store i32 %add40, i32* %h32.addr, align 4, !tbaa !9
  %29 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr41 = getelementptr inbounds i8, i8* %29, i64 4
  store i8* %add.ptr41, i8** %ptr.addr, align 8, !tbaa !3
  %30 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl42 = shl i32 %30, 17
  %31 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr43 = lshr i32 %31, 15
  %or44 = or i32 %shl42, %shr43
  %mul45 = mul i32 %or44, 668265263
  store i32 %mul45, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end46

do.end46:                                         ; preds = %do.body37
  br label %sw.bb47

sw.bb47:                                          ; preds = %entry, %do.end46
  br label %do.body48

do.body48:                                        ; preds = %sw.bb47
  %32 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %33 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call49 = call i32 @XXH_readLE32_align(i8* %32, i32 %33)
  %mul50 = mul i32 %call49, -1028477379
  %34 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add51 = add i32 %34, %mul50
  store i32 %add51, i32* %h32.addr, align 4, !tbaa !9
  %35 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr52 = getelementptr inbounds i8, i8* %35, i64 4
  store i8* %add.ptr52, i8** %ptr.addr, align 8, !tbaa !3
  %36 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl53 = shl i32 %36, 17
  %37 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr54 = lshr i32 %37, 15
  %or55 = or i32 %shl53, %shr54
  %mul56 = mul i32 %or55, 668265263
  store i32 %mul56, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end57

do.end57:                                         ; preds = %do.body48
  br label %do.body58

do.body58:                                        ; preds = %do.end57
  %38 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds i8, i8* %38, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8, !tbaa !3
  %39 = load i8, i8* %38, align 1, !tbaa !11
  %conv = zext i8 %39 to i32
  %mul59 = mul i32 %conv, 374761393
  %40 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add60 = add i32 %40, %mul59
  store i32 %add60, i32* %h32.addr, align 4, !tbaa !9
  %41 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl61 = shl i32 %41, 11
  %42 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr62 = lshr i32 %42, 21
  %or63 = or i32 %shl61, %shr62
  %mul64 = mul i32 %or63, -1640531535
  store i32 %mul64, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end65

do.end65:                                         ; preds = %do.body58
  %43 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %call66 = call i32 @XXH32_avalanche(i32 %43)
  store i32 %call66, i32* %retval, align 4
  br label %return

sw.bb67:                                          ; preds = %entry
  br label %do.body68

do.body68:                                        ; preds = %sw.bb67
  %44 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %45 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call69 = call i32 @XXH_readLE32_align(i8* %44, i32 %45)
  %mul70 = mul i32 %call69, -1028477379
  %46 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add71 = add i32 %46, %mul70
  store i32 %add71, i32* %h32.addr, align 4, !tbaa !9
  %47 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr72 = getelementptr inbounds i8, i8* %47, i64 4
  store i8* %add.ptr72, i8** %ptr.addr, align 8, !tbaa !3
  %48 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl73 = shl i32 %48, 17
  %49 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr74 = lshr i32 %49, 15
  %or75 = or i32 %shl73, %shr74
  %mul76 = mul i32 %or75, 668265263
  store i32 %mul76, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end77

do.end77:                                         ; preds = %do.body68
  br label %sw.bb78

sw.bb78:                                          ; preds = %entry, %do.end77
  br label %do.body79

do.body79:                                        ; preds = %sw.bb78
  %50 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %51 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call80 = call i32 @XXH_readLE32_align(i8* %50, i32 %51)
  %mul81 = mul i32 %call80, -1028477379
  %52 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add82 = add i32 %52, %mul81
  store i32 %add82, i32* %h32.addr, align 4, !tbaa !9
  %53 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr83 = getelementptr inbounds i8, i8* %53, i64 4
  store i8* %add.ptr83, i8** %ptr.addr, align 8, !tbaa !3
  %54 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl84 = shl i32 %54, 17
  %55 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr85 = lshr i32 %55, 15
  %or86 = or i32 %shl84, %shr85
  %mul87 = mul i32 %or86, 668265263
  store i32 %mul87, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end88

do.end88:                                         ; preds = %do.body79
  br label %sw.bb89

sw.bb89:                                          ; preds = %entry, %do.end88
  br label %do.body90

do.body90:                                        ; preds = %sw.bb89
  %56 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %57 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call91 = call i32 @XXH_readLE32_align(i8* %56, i32 %57)
  %mul92 = mul i32 %call91, -1028477379
  %58 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add93 = add i32 %58, %mul92
  store i32 %add93, i32* %h32.addr, align 4, !tbaa !9
  %59 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr94 = getelementptr inbounds i8, i8* %59, i64 4
  store i8* %add.ptr94, i8** %ptr.addr, align 8, !tbaa !3
  %60 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl95 = shl i32 %60, 17
  %61 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr96 = lshr i32 %61, 15
  %or97 = or i32 %shl95, %shr96
  %mul98 = mul i32 %or97, 668265263
  store i32 %mul98, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end99

do.end99:                                         ; preds = %do.body90
  br label %do.body100

do.body100:                                       ; preds = %do.end99
  %62 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr101 = getelementptr inbounds i8, i8* %62, i32 1
  store i8* %incdec.ptr101, i8** %ptr.addr, align 8, !tbaa !3
  %63 = load i8, i8* %62, align 1, !tbaa !11
  %conv102 = zext i8 %63 to i32
  %mul103 = mul i32 %conv102, 374761393
  %64 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add104 = add i32 %64, %mul103
  store i32 %add104, i32* %h32.addr, align 4, !tbaa !9
  %65 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl105 = shl i32 %65, 11
  %66 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr106 = lshr i32 %66, 21
  %or107 = or i32 %shl105, %shr106
  %mul108 = mul i32 %or107, -1640531535
  store i32 %mul108, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end109

do.end109:                                        ; preds = %do.body100
  br label %do.body110

do.body110:                                       ; preds = %do.end109
  %67 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr111 = getelementptr inbounds i8, i8* %67, i32 1
  store i8* %incdec.ptr111, i8** %ptr.addr, align 8, !tbaa !3
  %68 = load i8, i8* %67, align 1, !tbaa !11
  %conv112 = zext i8 %68 to i32
  %mul113 = mul i32 %conv112, 374761393
  %69 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add114 = add i32 %69, %mul113
  store i32 %add114, i32* %h32.addr, align 4, !tbaa !9
  %70 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl115 = shl i32 %70, 11
  %71 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr116 = lshr i32 %71, 21
  %or117 = or i32 %shl115, %shr116
  %mul118 = mul i32 %or117, -1640531535
  store i32 %mul118, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end119

do.end119:                                        ; preds = %do.body110
  %72 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %call120 = call i32 @XXH32_avalanche(i32 %72)
  store i32 %call120, i32* %retval, align 4
  br label %return

sw.bb121:                                         ; preds = %entry
  br label %do.body122

do.body122:                                       ; preds = %sw.bb121
  %73 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %74 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call123 = call i32 @XXH_readLE32_align(i8* %73, i32 %74)
  %mul124 = mul i32 %call123, -1028477379
  %75 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add125 = add i32 %75, %mul124
  store i32 %add125, i32* %h32.addr, align 4, !tbaa !9
  %76 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr126 = getelementptr inbounds i8, i8* %76, i64 4
  store i8* %add.ptr126, i8** %ptr.addr, align 8, !tbaa !3
  %77 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl127 = shl i32 %77, 17
  %78 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr128 = lshr i32 %78, 15
  %or129 = or i32 %shl127, %shr128
  %mul130 = mul i32 %or129, 668265263
  store i32 %mul130, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end131

do.end131:                                        ; preds = %do.body122
  br label %sw.bb132

sw.bb132:                                         ; preds = %entry, %do.end131
  br label %do.body133

do.body133:                                       ; preds = %sw.bb132
  %79 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %80 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call134 = call i32 @XXH_readLE32_align(i8* %79, i32 %80)
  %mul135 = mul i32 %call134, -1028477379
  %81 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add136 = add i32 %81, %mul135
  store i32 %add136, i32* %h32.addr, align 4, !tbaa !9
  %82 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr137 = getelementptr inbounds i8, i8* %82, i64 4
  store i8* %add.ptr137, i8** %ptr.addr, align 8, !tbaa !3
  %83 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl138 = shl i32 %83, 17
  %84 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr139 = lshr i32 %84, 15
  %or140 = or i32 %shl138, %shr139
  %mul141 = mul i32 %or140, 668265263
  store i32 %mul141, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end142

do.end142:                                        ; preds = %do.body133
  br label %sw.bb143

sw.bb143:                                         ; preds = %entry, %do.end142
  br label %do.body144

do.body144:                                       ; preds = %sw.bb143
  %85 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %86 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call145 = call i32 @XXH_readLE32_align(i8* %85, i32 %86)
  %mul146 = mul i32 %call145, -1028477379
  %87 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add147 = add i32 %87, %mul146
  store i32 %add147, i32* %h32.addr, align 4, !tbaa !9
  %88 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr148 = getelementptr inbounds i8, i8* %88, i64 4
  store i8* %add.ptr148, i8** %ptr.addr, align 8, !tbaa !3
  %89 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl149 = shl i32 %89, 17
  %90 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr150 = lshr i32 %90, 15
  %or151 = or i32 %shl149, %shr150
  %mul152 = mul i32 %or151, 668265263
  store i32 %mul152, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end153

do.end153:                                        ; preds = %do.body144
  br label %sw.bb154

sw.bb154:                                         ; preds = %entry, %do.end153
  br label %do.body155

do.body155:                                       ; preds = %sw.bb154
  %91 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr156 = getelementptr inbounds i8, i8* %91, i32 1
  store i8* %incdec.ptr156, i8** %ptr.addr, align 8, !tbaa !3
  %92 = load i8, i8* %91, align 1, !tbaa !11
  %conv157 = zext i8 %92 to i32
  %mul158 = mul i32 %conv157, 374761393
  %93 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add159 = add i32 %93, %mul158
  store i32 %add159, i32* %h32.addr, align 4, !tbaa !9
  %94 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl160 = shl i32 %94, 11
  %95 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr161 = lshr i32 %95, 21
  %or162 = or i32 %shl160, %shr161
  %mul163 = mul i32 %or162, -1640531535
  store i32 %mul163, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end164

do.end164:                                        ; preds = %do.body155
  br label %sw.bb165

sw.bb165:                                         ; preds = %entry, %do.end164
  br label %do.body166

do.body166:                                       ; preds = %sw.bb165
  %96 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr167 = getelementptr inbounds i8, i8* %96, i32 1
  store i8* %incdec.ptr167, i8** %ptr.addr, align 8, !tbaa !3
  %97 = load i8, i8* %96, align 1, !tbaa !11
  %conv168 = zext i8 %97 to i32
  %mul169 = mul i32 %conv168, 374761393
  %98 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add170 = add i32 %98, %mul169
  store i32 %add170, i32* %h32.addr, align 4, !tbaa !9
  %99 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl171 = shl i32 %99, 11
  %100 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr172 = lshr i32 %100, 21
  %or173 = or i32 %shl171, %shr172
  %mul174 = mul i32 %or173, -1640531535
  store i32 %mul174, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end175

do.end175:                                        ; preds = %do.body166
  br label %sw.bb176

sw.bb176:                                         ; preds = %entry, %do.end175
  br label %do.body177

do.body177:                                       ; preds = %sw.bb176
  %101 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr178 = getelementptr inbounds i8, i8* %101, i32 1
  store i8* %incdec.ptr178, i8** %ptr.addr, align 8, !tbaa !3
  %102 = load i8, i8* %101, align 1, !tbaa !11
  %conv179 = zext i8 %102 to i32
  %mul180 = mul i32 %conv179, 374761393
  %103 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %add181 = add i32 %103, %mul180
  store i32 %add181, i32* %h32.addr, align 4, !tbaa !9
  %104 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shl182 = shl i32 %104, 11
  %105 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr183 = lshr i32 %105, 21
  %or184 = or i32 %shl182, %shr183
  %mul185 = mul i32 %or184, -1640531535
  store i32 %mul185, i32* %h32.addr, align 4, !tbaa !9
  br label %do.end186

do.end186:                                        ; preds = %do.body177
  br label %sw.bb187

sw.bb187:                                         ; preds = %entry, %do.end186
  %106 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %call188 = call i32 @XXH32_avalanche(i32 %106)
  store i32 %call188, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %entry
  %107 = load i32, i32* %h32.addr, align 4, !tbaa !9
  store i32 %107, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb187, %do.end119, %do.end65, %do.end23
  %108 = load i32, i32* %retval, align 4
  ret i32 %108
}

; Function Attrs: nounwind ssp uwtable
define void @XXH32_canonicalFromHash(%struct.XXH32_canonical_t* %dst, i32 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH32_canonical_t*, align 8
  %hash.addr = alloca i32, align 4
  store %struct.XXH32_canonical_t* %dst, %struct.XXH32_canonical_t** %dst.addr, align 8, !tbaa !3
  store i32 %hash, i32* %hash.addr, align 4, !tbaa !9
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, i32* %hash.addr, align 4, !tbaa !9
  %call = call i32 @XXH_swap32(i32 %0)
  store i32 %call, i32* %hash.addr, align 4, !tbaa !9
  %1 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8, !tbaa !3
  %2 = bitcast %struct.XXH32_canonical_t* %1 to i8*
  %3 = bitcast i32* %hash.addr to i8*
  %4 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %dst.addr, align 8, !tbaa !3
  %5 = bitcast %struct.XXH32_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 4, i64 %6) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH_swap32(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4, !tbaa !9
  %0 = load i32, i32* %x.addr, align 4, !tbaa !9
  %shl = shl i32 %0, 24
  %and = and i32 %shl, -16777216
  %1 = load i32, i32* %x.addr, align 4, !tbaa !9
  %shl1 = shl i32 %1, 8
  %and2 = and i32 %shl1, 16711680
  %or = or i32 %and, %and2
  %2 = load i32, i32* %x.addr, align 4, !tbaa !9
  %shr = lshr i32 %2, 8
  %and3 = and i32 %shr, 65280
  %or4 = or i32 %or, %and3
  %3 = load i32, i32* %x.addr, align 4, !tbaa !9
  %shr5 = lshr i32 %3, 24
  %and6 = and i32 %shr5, 255
  %or7 = or i32 %or4, %and6
  ret i32 %or7
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH32_hashFromCanonical(%struct.XXH32_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH32_canonical_t*, align 8
  store %struct.XXH32_canonical_t* %src, %struct.XXH32_canonical_t** %src.addr, align 8, !tbaa !3
  %0 = load %struct.XXH32_canonical_t*, %struct.XXH32_canonical_t** %src.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH32_canonical_t* %0 to i8*
  %call = call i32 @XXH_readBE32(i8* %1)
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH_readBE32(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %call = call i32 @XXH_read32(i8* %0)
  %call1 = call i32 @XXH_swap32(i32 %call)
  ret i32 %call1
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH64(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH64_endian_align(i8* %0, i64 %1, i64 %2, i32 1)
  ret i64 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH64_endian_align(i8* %input, i64 %len, i64 %seed, i32 %align) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %bEnd = alloca i8*, align 8
  %h64 = alloca i64, align 8
  %limit = alloca i8*, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  store i32 %align, i32* %align.addr, align 4, !tbaa !11
  %0 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !3
  %3 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp uge i64 %4, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #10
  %6 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, i8* %6, i64 -32
  store i8* %add.ptr1, i8** %limit, align 8, !tbaa !3
  %7 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #10
  %8 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 %8, -7046029288634856825
  %add2 = add i64 %add, -4417276706812531889
  store i64 %add2, i64* %v1, align 8, !tbaa !21
  %9 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #10
  %10 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add3 = add i64 %10, -4417276706812531889
  store i64 %add3, i64* %v2, align 8, !tbaa !21
  %11 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #10
  %12 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add4 = add i64 %12, 0
  store i64 %add4, i64* %v3, align 8, !tbaa !21
  %13 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #10
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 %14, -7046029288634856825
  store i64 %sub, i64* %v4, align 8, !tbaa !21
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then
  %15 = load i64, i64* %v1, align 8, !tbaa !21
  %16 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %17 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call = call i64 @XXH_readLE64_align(i8* %16, i32 %17)
  %call5 = call i64 @XXH64_round(i64 %15, i64 %call)
  store i64 %call5, i64* %v1, align 8, !tbaa !21
  %18 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr6 = getelementptr inbounds i8, i8* %18, i64 8
  store i8* %add.ptr6, i8** %input.addr, align 8, !tbaa !3
  %19 = load i64, i64* %v2, align 8, !tbaa !21
  %20 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %21 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call7 = call i64 @XXH_readLE64_align(i8* %20, i32 %21)
  %call8 = call i64 @XXH64_round(i64 %19, i64 %call7)
  store i64 %call8, i64* %v2, align 8, !tbaa !21
  %22 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr9 = getelementptr inbounds i8, i8* %22, i64 8
  store i8* %add.ptr9, i8** %input.addr, align 8, !tbaa !3
  %23 = load i64, i64* %v3, align 8, !tbaa !21
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %25 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call10 = call i64 @XXH_readLE64_align(i8* %24, i32 %25)
  %call11 = call i64 @XXH64_round(i64 %23, i64 %call10)
  store i64 %call11, i64* %v3, align 8, !tbaa !21
  %26 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr12 = getelementptr inbounds i8, i8* %26, i64 8
  store i8* %add.ptr12, i8** %input.addr, align 8, !tbaa !3
  %27 = load i64, i64* %v4, align 8, !tbaa !21
  %28 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %29 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call13 = call i64 @XXH_readLE64_align(i8* %28, i32 %29)
  %call14 = call i64 @XXH64_round(i64 %27, i64 %call13)
  store i64 %call14, i64* %v4, align 8, !tbaa !21
  %30 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr15 = getelementptr inbounds i8, i8* %30, i64 8
  store i8* %add.ptr15, i8** %input.addr, align 8, !tbaa !3
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %31 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %32 = load i8*, i8** %limit, align 8, !tbaa !3
  %cmp16 = icmp ule i8* %31, %32
  br i1 %cmp16, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %33 = load i64, i64* %v1, align 8, !tbaa !21
  %shl = shl i64 %33, 1
  %34 = load i64, i64* %v1, align 8, !tbaa !21
  %shr = lshr i64 %34, 63
  %or = or i64 %shl, %shr
  %35 = load i64, i64* %v2, align 8, !tbaa !21
  %shl17 = shl i64 %35, 7
  %36 = load i64, i64* %v2, align 8, !tbaa !21
  %shr18 = lshr i64 %36, 57
  %or19 = or i64 %shl17, %shr18
  %add20 = add i64 %or, %or19
  %37 = load i64, i64* %v3, align 8, !tbaa !21
  %shl21 = shl i64 %37, 12
  %38 = load i64, i64* %v3, align 8, !tbaa !21
  %shr22 = lshr i64 %38, 52
  %or23 = or i64 %shl21, %shr22
  %add24 = add i64 %add20, %or23
  %39 = load i64, i64* %v4, align 8, !tbaa !21
  %shl25 = shl i64 %39, 18
  %40 = load i64, i64* %v4, align 8, !tbaa !21
  %shr26 = lshr i64 %40, 46
  %or27 = or i64 %shl25, %shr26
  %add28 = add i64 %add24, %or27
  store i64 %add28, i64* %h64, align 8, !tbaa !21
  %41 = load i64, i64* %h64, align 8, !tbaa !21
  %42 = load i64, i64* %v1, align 8, !tbaa !21
  %call29 = call i64 @XXH64_mergeRound(i64 %41, i64 %42)
  store i64 %call29, i64* %h64, align 8, !tbaa !21
  %43 = load i64, i64* %h64, align 8, !tbaa !21
  %44 = load i64, i64* %v2, align 8, !tbaa !21
  %call30 = call i64 @XXH64_mergeRound(i64 %43, i64 %44)
  store i64 %call30, i64* %h64, align 8, !tbaa !21
  %45 = load i64, i64* %h64, align 8, !tbaa !21
  %46 = load i64, i64* %v3, align 8, !tbaa !21
  %call31 = call i64 @XXH64_mergeRound(i64 %45, i64 %46)
  store i64 %call31, i64* %h64, align 8, !tbaa !21
  %47 = load i64, i64* %h64, align 8, !tbaa !21
  %48 = load i64, i64* %v4, align 8, !tbaa !21
  %call32 = call i64 @XXH64_mergeRound(i64 %47, i64 %48)
  store i64 %call32, i64* %h64, align 8, !tbaa !21
  %49 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #10
  %50 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %50) #10
  %51 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %51) #10
  %52 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %52) #10
  %53 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %53) #10
  br label %if.end

if.else:                                          ; preds = %entry
  %54 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add33 = add i64 %54, 2870177450012600261
  store i64 %add33, i64* %h64, align 8, !tbaa !21
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %55 = load i64, i64* %len.addr, align 8, !tbaa !7
  %56 = load i64, i64* %h64, align 8, !tbaa !21
  %add34 = add i64 %56, %55
  store i64 %add34, i64* %h64, align 8, !tbaa !21
  %57 = load i64, i64* %h64, align 8, !tbaa !21
  %58 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %59 = load i64, i64* %len.addr, align 8, !tbaa !7
  %60 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call35 = call i64 @XXH64_finalize(i64 %57, i8* %58, i64 %59, i32 %60)
  %61 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %61) #10
  %62 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %62) #10
  ret i64 %call35
}

; Function Attrs: nounwind ssp uwtable
define %struct.XXH64_state_s* @XXH64_createState() #0 {
entry:
  %call = call i8* @XXH_malloc(i64 88)
  %0 = bitcast i8* %call to %struct.XXH64_state_s*
  ret %struct.XXH64_state_s* %0
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH64_freeState(%struct.XXH64_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !3
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  call void @XXH_free(i8* %1)
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define void @XXH64_copyState(%struct.XXH64_state_s* %dstState, %struct.XXH64_state_s* %srcState) #0 {
entry:
  %dstState.addr = alloca %struct.XXH64_state_s*, align 8
  %srcState.addr = alloca %struct.XXH64_state_s*, align 8
  store %struct.XXH64_state_s* %dstState, %struct.XXH64_state_s** %dstState.addr, align 8, !tbaa !3
  store %struct.XXH64_state_s* %srcState, %struct.XXH64_state_s** %srcState.addr, align 8, !tbaa !3
  %0 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH64_state_s* %0 to i8*
  %2 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %srcState.addr, align 8, !tbaa !3
  %3 = bitcast %struct.XXH64_state_s* %2 to i8*
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %dstState.addr, align 8, !tbaa !3
  %5 = bitcast %struct.XXH64_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 88, i64 %6) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH64_reset(%struct.XXH64_state_s* %statePtr, i64 %seed) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH64_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %state = alloca %struct.XXH64_state_s, align 8
  store %struct.XXH64_state_s* %statePtr, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 88, i8* %0) #10
  %1 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 88, i32 8, i1 false)
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 %2, -7046029288634856825
  %add1 = add i64 %add, -4417276706812531889
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 1
  store i64 %add1, i64* %v1, align 8, !tbaa !23
  %3 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add2 = add i64 %3, -4417276706812531889
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 2
  store i64 %add2, i64* %v2, align 8, !tbaa !25
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add3 = add i64 %4, 0
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 3
  store i64 %add3, i64* %v3, align 8, !tbaa !26
  %5 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 %5, -7046029288634856825
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %state, i32 0, i32 4
  store i64 %sub, i64* %v4, align 8, !tbaa !27
  %6 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !3
  %7 = bitcast %struct.XXH64_state_s* %6 to i8*
  %8 = bitcast %struct.XXH64_state_s* %state to i8*
  %9 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %statePtr.addr, align 8, !tbaa !3
  %10 = bitcast %struct.XXH64_state_s* %9 to i8*
  %11 = call i64 @llvm.objectsize.i64.p0i8(i8* %10, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %7, i8* %8, i64 80, i64 %11) #10
  %12 = bitcast %struct.XXH64_state_s* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 88, i8* %12) #10
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH64_update(%struct.XXH64_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %bEnd = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  %limit = alloca i8*, align 8
  %v156 = alloca i64, align 8
  %v258 = alloca i64, align 8
  %v360 = alloca i64, align 8
  %v462 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  store i8* %2, i8** %p, align 8, !tbaa !3
  %3 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load i8*, i8** %p, align 8, !tbaa !3
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %5
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !3
  %6 = load i64, i64* %len.addr, align 8, !tbaa !7
  %7 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %7, i32 0, i32 0
  %8 = load i64, i64* %total_len, align 8, !tbaa !28
  %add = add i64 %8, %6
  store i64 %add, i64* %total_len, align 8, !tbaa !28
  %9 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %9, i32 0, i32 6
  %10 = load i32, i32* %memsize, align 8, !tbaa !29
  %conv = zext i32 %10 to i64
  %11 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add1 = add i64 %conv, %11
  %cmp2 = icmp ult i64 %add1, 32
  br i1 %cmp2, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %12 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %12, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %13 = bitcast i64* %arraydecay to i8*
  %14 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize5 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %14, i32 0, i32 6
  %15 = load i32, i32* %memsize5, align 8, !tbaa !29
  %idx.ext = zext i32 %15 to i64
  %add.ptr6 = getelementptr inbounds i8, i8* %13, i64 %idx.ext
  %16 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %17 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call i8* @XXH_memcpy(i8* %add.ptr6, i8* %16, i64 %17)
  %18 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv7 = trunc i64 %18 to i32
  %19 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize8 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %19, i32 0, i32 6
  %20 = load i32, i32* %memsize8, align 8, !tbaa !29
  %add9 = add i32 %20, %conv7
  store i32 %add9, i32* %memsize8, align 8, !tbaa !29
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end10:                                         ; preds = %if.end
  %21 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %21, i32 0, i32 6
  %22 = load i32, i32* %memsize11, align 8, !tbaa !29
  %tobool = icmp ne i32 %22, 0
  br i1 %tobool, label %if.then12, label %if.end50

if.then12:                                        ; preds = %if.end10
  %23 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem6413 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %23, i32 0, i32 5
  %arraydecay14 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6413, i32 0, i32 0
  %24 = bitcast i64* %arraydecay14 to i8*
  %25 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize15 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %25, i32 0, i32 6
  %26 = load i32, i32* %memsize15, align 8, !tbaa !29
  %idx.ext16 = zext i32 %26 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %24, i64 %idx.ext16
  %27 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %28 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize18 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %28, i32 0, i32 6
  %29 = load i32, i32* %memsize18, align 8, !tbaa !29
  %sub = sub i32 32, %29
  %conv19 = zext i32 %sub to i64
  %call20 = call i8* @XXH_memcpy(i8* %add.ptr17, i8* %27, i64 %conv19)
  %30 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v1 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %30, i32 0, i32 1
  %31 = load i64, i64* %v1, align 8, !tbaa !23
  %32 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem6421 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %32, i32 0, i32 5
  %arraydecay22 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6421, i32 0, i32 0
  %add.ptr23 = getelementptr inbounds i64, i64* %arraydecay22, i64 0
  %33 = bitcast i64* %add.ptr23 to i8*
  %call24 = call i64 @XXH_readLE64(i8* %33)
  %call25 = call i64 @XXH64_round(i64 %31, i64 %call24)
  %34 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v126 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %34, i32 0, i32 1
  store i64 %call25, i64* %v126, align 8, !tbaa !23
  %35 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v2 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %35, i32 0, i32 2
  %36 = load i64, i64* %v2, align 8, !tbaa !25
  %37 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem6427 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %37, i32 0, i32 5
  %arraydecay28 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6427, i32 0, i32 0
  %add.ptr29 = getelementptr inbounds i64, i64* %arraydecay28, i64 1
  %38 = bitcast i64* %add.ptr29 to i8*
  %call30 = call i64 @XXH_readLE64(i8* %38)
  %call31 = call i64 @XXH64_round(i64 %36, i64 %call30)
  %39 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v232 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %39, i32 0, i32 2
  store i64 %call31, i64* %v232, align 8, !tbaa !25
  %40 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v3 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %40, i32 0, i32 3
  %41 = load i64, i64* %v3, align 8, !tbaa !26
  %42 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem6433 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %42, i32 0, i32 5
  %arraydecay34 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6433, i32 0, i32 0
  %add.ptr35 = getelementptr inbounds i64, i64* %arraydecay34, i64 2
  %43 = bitcast i64* %add.ptr35 to i8*
  %call36 = call i64 @XXH_readLE64(i8* %43)
  %call37 = call i64 @XXH64_round(i64 %41, i64 %call36)
  %44 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v338 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %44, i32 0, i32 3
  store i64 %call37, i64* %v338, align 8, !tbaa !26
  %45 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v4 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %45, i32 0, i32 4
  %46 = load i64, i64* %v4, align 8, !tbaa !27
  %47 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem6439 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %47, i32 0, i32 5
  %arraydecay40 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6439, i32 0, i32 0
  %add.ptr41 = getelementptr inbounds i64, i64* %arraydecay40, i64 3
  %48 = bitcast i64* %add.ptr41 to i8*
  %call42 = call i64 @XXH_readLE64(i8* %48)
  %call43 = call i64 @XXH64_round(i64 %46, i64 %call42)
  %49 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v444 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %49, i32 0, i32 4
  store i64 %call43, i64* %v444, align 8, !tbaa !27
  %50 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize45 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %50, i32 0, i32 6
  %51 = load i32, i32* %memsize45, align 8, !tbaa !29
  %sub46 = sub i32 32, %51
  %52 = load i8*, i8** %p, align 8, !tbaa !3
  %idx.ext47 = zext i32 %sub46 to i64
  %add.ptr48 = getelementptr inbounds i8, i8* %52, i64 %idx.ext47
  store i8* %add.ptr48, i8** %p, align 8, !tbaa !3
  %53 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize49 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %53, i32 0, i32 6
  store i32 0, i32* %memsize49, align 8, !tbaa !29
  br label %if.end50

if.end50:                                         ; preds = %if.then12, %if.end10
  %54 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr51 = getelementptr inbounds i8, i8* %54, i64 32
  %55 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %cmp52 = icmp ule i8* %add.ptr51, %55
  br i1 %cmp52, label %if.then54, label %if.end82

if.then54:                                        ; preds = %if.end50
  %56 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %56) #10
  %57 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %add.ptr55 = getelementptr inbounds i8, i8* %57, i64 -32
  store i8* %add.ptr55, i8** %limit, align 8, !tbaa !3
  %58 = bitcast i64* %v156 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %58) #10
  %59 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v157 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %59, i32 0, i32 1
  %60 = load i64, i64* %v157, align 8, !tbaa !23
  store i64 %60, i64* %v156, align 8, !tbaa !21
  %61 = bitcast i64* %v258 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %61) #10
  %62 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v259 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %62, i32 0, i32 2
  %63 = load i64, i64* %v259, align 8, !tbaa !25
  store i64 %63, i64* %v258, align 8, !tbaa !21
  %64 = bitcast i64* %v360 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %64) #10
  %65 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v361 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %65, i32 0, i32 3
  %66 = load i64, i64* %v361, align 8, !tbaa !26
  store i64 %66, i64* %v360, align 8, !tbaa !21
  %67 = bitcast i64* %v462 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %67) #10
  %68 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v463 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %68, i32 0, i32 4
  %69 = load i64, i64* %v463, align 8, !tbaa !27
  store i64 %69, i64* %v462, align 8, !tbaa !21
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then54
  %70 = load i64, i64* %v156, align 8, !tbaa !21
  %71 = load i8*, i8** %p, align 8, !tbaa !3
  %call64 = call i64 @XXH_readLE64(i8* %71)
  %call65 = call i64 @XXH64_round(i64 %70, i64 %call64)
  store i64 %call65, i64* %v156, align 8, !tbaa !21
  %72 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr66 = getelementptr inbounds i8, i8* %72, i64 8
  store i8* %add.ptr66, i8** %p, align 8, !tbaa !3
  %73 = load i64, i64* %v258, align 8, !tbaa !21
  %74 = load i8*, i8** %p, align 8, !tbaa !3
  %call67 = call i64 @XXH_readLE64(i8* %74)
  %call68 = call i64 @XXH64_round(i64 %73, i64 %call67)
  store i64 %call68, i64* %v258, align 8, !tbaa !21
  %75 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr69 = getelementptr inbounds i8, i8* %75, i64 8
  store i8* %add.ptr69, i8** %p, align 8, !tbaa !3
  %76 = load i64, i64* %v360, align 8, !tbaa !21
  %77 = load i8*, i8** %p, align 8, !tbaa !3
  %call70 = call i64 @XXH_readLE64(i8* %77)
  %call71 = call i64 @XXH64_round(i64 %76, i64 %call70)
  store i64 %call71, i64* %v360, align 8, !tbaa !21
  %78 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr72 = getelementptr inbounds i8, i8* %78, i64 8
  store i8* %add.ptr72, i8** %p, align 8, !tbaa !3
  %79 = load i64, i64* %v462, align 8, !tbaa !21
  %80 = load i8*, i8** %p, align 8, !tbaa !3
  %call73 = call i64 @XXH_readLE64(i8* %80)
  %call74 = call i64 @XXH64_round(i64 %79, i64 %call73)
  store i64 %call74, i64* %v462, align 8, !tbaa !21
  %81 = load i8*, i8** %p, align 8, !tbaa !3
  %add.ptr75 = getelementptr inbounds i8, i8* %81, i64 8
  store i8* %add.ptr75, i8** %p, align 8, !tbaa !3
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %82 = load i8*, i8** %p, align 8, !tbaa !3
  %83 = load i8*, i8** %limit, align 8, !tbaa !3
  %cmp76 = icmp ule i8* %82, %83
  br i1 %cmp76, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %84 = load i64, i64* %v156, align 8, !tbaa !21
  %85 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v178 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %85, i32 0, i32 1
  store i64 %84, i64* %v178, align 8, !tbaa !23
  %86 = load i64, i64* %v258, align 8, !tbaa !21
  %87 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v279 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %87, i32 0, i32 2
  store i64 %86, i64* %v279, align 8, !tbaa !25
  %88 = load i64, i64* %v360, align 8, !tbaa !21
  %89 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v380 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %89, i32 0, i32 3
  store i64 %88, i64* %v380, align 8, !tbaa !26
  %90 = load i64, i64* %v462, align 8, !tbaa !21
  %91 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v481 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %91, i32 0, i32 4
  store i64 %90, i64* %v481, align 8, !tbaa !27
  %92 = bitcast i64* %v462 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %92) #10
  %93 = bitcast i64* %v360 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %93) #10
  %94 = bitcast i64* %v258 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %94) #10
  %95 = bitcast i64* %v156 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %95) #10
  %96 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %96) #10
  br label %if.end82

if.end82:                                         ; preds = %do.end, %if.end50
  %97 = load i8*, i8** %p, align 8, !tbaa !3
  %98 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %cmp83 = icmp ult i8* %97, %98
  br i1 %cmp83, label %if.then85, label %if.end94

if.then85:                                        ; preds = %if.end82
  %99 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem6486 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %99, i32 0, i32 5
  %arraydecay87 = getelementptr inbounds [4 x i64], [4 x i64]* %mem6486, i32 0, i32 0
  %100 = bitcast i64* %arraydecay87 to i8*
  %101 = load i8*, i8** %p, align 8, !tbaa !3
  %102 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %103 = load i8*, i8** %p, align 8, !tbaa !3
  %sub.ptr.lhs.cast = ptrtoint i8* %102 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %103 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call88 = call i8* @XXH_memcpy(i8* %100, i8* %101, i64 %sub.ptr.sub)
  %104 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %105 = load i8*, i8** %p, align 8, !tbaa !3
  %sub.ptr.lhs.cast89 = ptrtoint i8* %104 to i64
  %sub.ptr.rhs.cast90 = ptrtoint i8* %105 to i64
  %sub.ptr.sub91 = sub i64 %sub.ptr.lhs.cast89, %sub.ptr.rhs.cast90
  %conv92 = trunc i64 %sub.ptr.sub91 to i32
  %106 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %memsize93 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %106, i32 0, i32 6
  store i32 %conv92, i32* %memsize93, align 8, !tbaa !29
  br label %if.end94

if.end94:                                         ; preds = %if.then85, %if.end82
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end94, %if.then4
  %107 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %107) #10
  %108 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %108) #10
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cleanup.cont, %cleanup, %if.then
  %109 = load i32, i32* %retval, align 4
  ret i32 %109

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_round(i64 %acc, i64 %input) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %input.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8, !tbaa !21
  store i64 %input, i64* %input.addr, align 8, !tbaa !21
  %0 = load i64, i64* %input.addr, align 8, !tbaa !21
  %mul = mul i64 %0, -4417276706812531889
  %1 = load i64, i64* %acc.addr, align 8, !tbaa !21
  %add = add i64 %1, %mul
  store i64 %add, i64* %acc.addr, align 8, !tbaa !21
  %2 = load i64, i64* %acc.addr, align 8, !tbaa !21
  %shl = shl i64 %2, 31
  %3 = load i64, i64* %acc.addr, align 8, !tbaa !21
  %shr = lshr i64 %3, 33
  %or = or i64 %shl, %shr
  store i64 %or, i64* %acc.addr, align 8, !tbaa !21
  %4 = load i64, i64* %acc.addr, align 8, !tbaa !21
  %mul1 = mul i64 %4, -7046029288634856825
  store i64 %mul1, i64* %acc.addr, align 8, !tbaa !21
  %5 = load i64, i64* %acc.addr, align 8, !tbaa !21
  ret i64 %5
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH_readLE64(i8* %ptr) #1 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %call = call i64 @XXH_read64(i8* %0)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH64_digest(%struct.XXH64_state_s* %state) #0 {
entry:
  %state.addr = alloca %struct.XXH64_state_s*, align 8
  %h64 = alloca i64, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  %v3 = alloca i64, align 8
  %v4 = alloca i64, align 8
  store %struct.XXH64_state_s* %state, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %0 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %total_len = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %1, i32 0, i32 0
  %2 = load i64, i64* %total_len, align 8, !tbaa !28
  %cmp = icmp uge i64 %2, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v11 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %4, i32 0, i32 1
  %5 = load i64, i64* %v11, align 8, !tbaa !23
  store i64 %5, i64* %v1, align 8, !tbaa !21
  %6 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #10
  %7 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v22 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %7, i32 0, i32 2
  %8 = load i64, i64* %v22, align 8, !tbaa !25
  store i64 %8, i64* %v2, align 8, !tbaa !21
  %9 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #10
  %10 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v33 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %10, i32 0, i32 3
  %11 = load i64, i64* %v33, align 8, !tbaa !26
  store i64 %11, i64* %v3, align 8, !tbaa !21
  %12 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #10
  %13 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v44 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %13, i32 0, i32 4
  %14 = load i64, i64* %v44, align 8, !tbaa !27
  store i64 %14, i64* %v4, align 8, !tbaa !21
  %15 = load i64, i64* %v1, align 8, !tbaa !21
  %shl = shl i64 %15, 1
  %16 = load i64, i64* %v1, align 8, !tbaa !21
  %shr = lshr i64 %16, 63
  %or = or i64 %shl, %shr
  %17 = load i64, i64* %v2, align 8, !tbaa !21
  %shl5 = shl i64 %17, 7
  %18 = load i64, i64* %v2, align 8, !tbaa !21
  %shr6 = lshr i64 %18, 57
  %or7 = or i64 %shl5, %shr6
  %add = add i64 %or, %or7
  %19 = load i64, i64* %v3, align 8, !tbaa !21
  %shl8 = shl i64 %19, 12
  %20 = load i64, i64* %v3, align 8, !tbaa !21
  %shr9 = lshr i64 %20, 52
  %or10 = or i64 %shl8, %shr9
  %add11 = add i64 %add, %or10
  %21 = load i64, i64* %v4, align 8, !tbaa !21
  %shl12 = shl i64 %21, 18
  %22 = load i64, i64* %v4, align 8, !tbaa !21
  %shr13 = lshr i64 %22, 46
  %or14 = or i64 %shl12, %shr13
  %add15 = add i64 %add11, %or14
  store i64 %add15, i64* %h64, align 8, !tbaa !21
  %23 = load i64, i64* %h64, align 8, !tbaa !21
  %24 = load i64, i64* %v1, align 8, !tbaa !21
  %call = call i64 @XXH64_mergeRound(i64 %23, i64 %24)
  store i64 %call, i64* %h64, align 8, !tbaa !21
  %25 = load i64, i64* %h64, align 8, !tbaa !21
  %26 = load i64, i64* %v2, align 8, !tbaa !21
  %call16 = call i64 @XXH64_mergeRound(i64 %25, i64 %26)
  store i64 %call16, i64* %h64, align 8, !tbaa !21
  %27 = load i64, i64* %h64, align 8, !tbaa !21
  %28 = load i64, i64* %v3, align 8, !tbaa !21
  %call17 = call i64 @XXH64_mergeRound(i64 %27, i64 %28)
  store i64 %call17, i64* %h64, align 8, !tbaa !21
  %29 = load i64, i64* %h64, align 8, !tbaa !21
  %30 = load i64, i64* %v4, align 8, !tbaa !21
  %call18 = call i64 @XXH64_mergeRound(i64 %29, i64 %30)
  store i64 %call18, i64* %h64, align 8, !tbaa !21
  %31 = bitcast i64* %v4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #10
  %32 = bitcast i64* %v3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #10
  %33 = bitcast i64* %v2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %33) #10
  %34 = bitcast i64* %v1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %34) #10
  br label %if.end

if.else:                                          ; preds = %entry
  %35 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %v319 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %35, i32 0, i32 3
  %36 = load i64, i64* %v319, align 8, !tbaa !26
  %add20 = add i64 %36, 2870177450012600261
  store i64 %add20, i64* %h64, align 8, !tbaa !21
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %37 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %total_len21 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %37, i32 0, i32 0
  %38 = load i64, i64* %total_len21, align 8, !tbaa !28
  %39 = load i64, i64* %h64, align 8, !tbaa !21
  %add22 = add i64 %39, %38
  store i64 %add22, i64* %h64, align 8, !tbaa !21
  %40 = load i64, i64* %h64, align 8, !tbaa !21
  %41 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %mem64 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %41, i32 0, i32 5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %mem64, i32 0, i32 0
  %42 = bitcast i64* %arraydecay to i8*
  %43 = load %struct.XXH64_state_s*, %struct.XXH64_state_s** %state.addr, align 8, !tbaa !3
  %total_len23 = getelementptr inbounds %struct.XXH64_state_s, %struct.XXH64_state_s* %43, i32 0, i32 0
  %44 = load i64, i64* %total_len23, align 8, !tbaa !28
  %call24 = call i64 @XXH64_finalize(i64 %40, i8* %42, i64 %44, i32 0)
  %45 = bitcast i64* %h64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #10
  ret i64 %call24
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_mergeRound(i64 %acc, i64 %val) #0 {
entry:
  %acc.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store i64 %acc, i64* %acc.addr, align 8, !tbaa !21
  store i64 %val, i64* %val.addr, align 8, !tbaa !21
  %0 = load i64, i64* %val.addr, align 8, !tbaa !21
  %call = call i64 @XXH64_round(i64 0, i64 %0)
  store i64 %call, i64* %val.addr, align 8, !tbaa !21
  %1 = load i64, i64* %val.addr, align 8, !tbaa !21
  %2 = load i64, i64* %acc.addr, align 8, !tbaa !21
  %xor = xor i64 %2, %1
  store i64 %xor, i64* %acc.addr, align 8, !tbaa !21
  %3 = load i64, i64* %acc.addr, align 8, !tbaa !21
  %mul = mul i64 %3, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %acc.addr, align 8, !tbaa !21
  %4 = load i64, i64* %acc.addr, align 8, !tbaa !21
  ret i64 %4
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_finalize(i64 %h64, i8* %ptr, i64 %len, i32 %align) #0 {
entry:
  %retval = alloca i64, align 8
  %h64.addr = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %k1 = alloca i64, align 8
  %k14 = alloca i64, align 8
  %k117 = alloca i64, align 8
  %k131 = alloca i64, align 8
  %k144 = alloca i64, align 8
  %k157 = alloca i64, align 8
  %k183 = alloca i64, align 8
  %k196 = alloca i64, align 8
  %k1109 = alloca i64, align 8
  %k1132 = alloca i64, align 8
  %k1145 = alloca i64, align 8
  %k1158 = alloca i64, align 8
  %k1195 = alloca i64, align 8
  %k1208 = alloca i64, align 8
  %k1221 = alloca i64, align 8
  %k1255 = alloca i64, align 8
  %k1268 = alloca i64, align 8
  %k1281 = alloca i64, align 8
  %k1328 = alloca i64, align 8
  %k1341 = alloca i64, align 8
  %k1354 = alloca i64, align 8
  %k1398 = alloca i64, align 8
  %k1411 = alloca i64, align 8
  %k1424 = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8, !tbaa !21
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i32 %align, i32* %align.addr, align 4, !tbaa !11
  %0 = load i64, i64* %len.addr, align 8, !tbaa !7
  %and = and i64 %0, 31
  switch i64 %and, label %sw.epilog [
    i64 24, label %sw.bb
    i64 16, label %sw.bb2
    i64 8, label %sw.bb15
    i64 28, label %sw.bb29
    i64 20, label %sw.bb42
    i64 12, label %sw.bb55
    i64 4, label %sw.bb68
    i64 25, label %sw.bb81
    i64 17, label %sw.bb94
    i64 9, label %sw.bb107
    i64 29, label %sw.bb130
    i64 21, label %sw.bb143
    i64 13, label %sw.bb156
    i64 5, label %sw.bb169
    i64 26, label %sw.bb193
    i64 18, label %sw.bb206
    i64 10, label %sw.bb219
    i64 30, label %sw.bb253
    i64 22, label %sw.bb266
    i64 14, label %sw.bb279
    i64 6, label %sw.bb292
    i64 27, label %sw.bb326
    i64 19, label %sw.bb339
    i64 11, label %sw.bb352
    i64 31, label %sw.bb396
    i64 23, label %sw.bb409
    i64 15, label %sw.bb422
    i64 7, label %sw.bb435
    i64 3, label %sw.bb448
    i64 2, label %sw.bb459
    i64 1, label %sw.bb470
    i64 0, label %sw.bb481
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = bitcast i64* %k1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %3 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call = call i64 @XXH_readLE64_align(i8* %2, i32 %3)
  %call1 = call i64 @XXH64_round(i64 0, i64 %call)
  store i64 %call1, i64* %k1, align 8, !tbaa !21
  %4 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 8
  store i8* %add.ptr, i8** %ptr.addr, align 8, !tbaa !3
  %5 = load i64, i64* %k1, align 8, !tbaa !21
  %6 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor = xor i64 %6, %5
  store i64 %xor, i64* %h64.addr, align 8, !tbaa !21
  %7 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl = shl i64 %7, 27
  %8 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr = lshr i64 %8, 37
  %or = or i64 %shl, %shr
  %mul = mul i64 %or, -7046029288634856825
  %add = add i64 %mul, -8796714831421723037
  store i64 %add, i64* %h64.addr, align 8, !tbaa !21
  %9 = bitcast i64* %k1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #10
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %do.end
  br label %do.body3

do.body3:                                         ; preds = %sw.bb2
  %10 = bitcast i64* %k14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #10
  %11 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %12 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call5 = call i64 @XXH_readLE64_align(i8* %11, i32 %12)
  %call6 = call i64 @XXH64_round(i64 0, i64 %call5)
  store i64 %call6, i64* %k14, align 8, !tbaa !21
  %13 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr7 = getelementptr inbounds i8, i8* %13, i64 8
  store i8* %add.ptr7, i8** %ptr.addr, align 8, !tbaa !3
  %14 = load i64, i64* %k14, align 8, !tbaa !21
  %15 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor8 = xor i64 %15, %14
  store i64 %xor8, i64* %h64.addr, align 8, !tbaa !21
  %16 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl9 = shl i64 %16, 27
  %17 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr10 = lshr i64 %17, 37
  %or11 = or i64 %shl9, %shr10
  %mul12 = mul i64 %or11, -7046029288634856825
  %add13 = add i64 %mul12, -8796714831421723037
  store i64 %add13, i64* %h64.addr, align 8, !tbaa !21
  %18 = bitcast i64* %k14 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #10
  br label %do.end14

do.end14:                                         ; preds = %do.body3
  br label %sw.bb15

sw.bb15:                                          ; preds = %entry, %do.end14
  br label %do.body16

do.body16:                                        ; preds = %sw.bb15
  %19 = bitcast i64* %k117 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %19) #10
  %20 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %21 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call18 = call i64 @XXH_readLE64_align(i8* %20, i32 %21)
  %call19 = call i64 @XXH64_round(i64 0, i64 %call18)
  store i64 %call19, i64* %k117, align 8, !tbaa !21
  %22 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr20 = getelementptr inbounds i8, i8* %22, i64 8
  store i8* %add.ptr20, i8** %ptr.addr, align 8, !tbaa !3
  %23 = load i64, i64* %k117, align 8, !tbaa !21
  %24 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor21 = xor i64 %24, %23
  store i64 %xor21, i64* %h64.addr, align 8, !tbaa !21
  %25 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl22 = shl i64 %25, 27
  %26 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr23 = lshr i64 %26, 37
  %or24 = or i64 %shl22, %shr23
  %mul25 = mul i64 %or24, -7046029288634856825
  %add26 = add i64 %mul25, -8796714831421723037
  store i64 %add26, i64* %h64.addr, align 8, !tbaa !21
  %27 = bitcast i64* %k117 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %27) #10
  br label %do.end27

do.end27:                                         ; preds = %do.body16
  %28 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call28 = call i64 @XXH64_avalanche(i64 %28)
  store i64 %call28, i64* %retval, align 8
  br label %return

sw.bb29:                                          ; preds = %entry
  br label %do.body30

do.body30:                                        ; preds = %sw.bb29
  %29 = bitcast i64* %k131 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %29) #10
  %30 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %31 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call32 = call i64 @XXH_readLE64_align(i8* %30, i32 %31)
  %call33 = call i64 @XXH64_round(i64 0, i64 %call32)
  store i64 %call33, i64* %k131, align 8, !tbaa !21
  %32 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr34 = getelementptr inbounds i8, i8* %32, i64 8
  store i8* %add.ptr34, i8** %ptr.addr, align 8, !tbaa !3
  %33 = load i64, i64* %k131, align 8, !tbaa !21
  %34 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor35 = xor i64 %34, %33
  store i64 %xor35, i64* %h64.addr, align 8, !tbaa !21
  %35 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl36 = shl i64 %35, 27
  %36 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr37 = lshr i64 %36, 37
  %or38 = or i64 %shl36, %shr37
  %mul39 = mul i64 %or38, -7046029288634856825
  %add40 = add i64 %mul39, -8796714831421723037
  store i64 %add40, i64* %h64.addr, align 8, !tbaa !21
  %37 = bitcast i64* %k131 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %37) #10
  br label %do.end41

do.end41:                                         ; preds = %do.body30
  br label %sw.bb42

sw.bb42:                                          ; preds = %entry, %do.end41
  br label %do.body43

do.body43:                                        ; preds = %sw.bb42
  %38 = bitcast i64* %k144 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %38) #10
  %39 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %40 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call45 = call i64 @XXH_readLE64_align(i8* %39, i32 %40)
  %call46 = call i64 @XXH64_round(i64 0, i64 %call45)
  store i64 %call46, i64* %k144, align 8, !tbaa !21
  %41 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr47 = getelementptr inbounds i8, i8* %41, i64 8
  store i8* %add.ptr47, i8** %ptr.addr, align 8, !tbaa !3
  %42 = load i64, i64* %k144, align 8, !tbaa !21
  %43 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor48 = xor i64 %43, %42
  store i64 %xor48, i64* %h64.addr, align 8, !tbaa !21
  %44 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl49 = shl i64 %44, 27
  %45 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr50 = lshr i64 %45, 37
  %or51 = or i64 %shl49, %shr50
  %mul52 = mul i64 %or51, -7046029288634856825
  %add53 = add i64 %mul52, -8796714831421723037
  store i64 %add53, i64* %h64.addr, align 8, !tbaa !21
  %46 = bitcast i64* %k144 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #10
  br label %do.end54

do.end54:                                         ; preds = %do.body43
  br label %sw.bb55

sw.bb55:                                          ; preds = %entry, %do.end54
  br label %do.body56

do.body56:                                        ; preds = %sw.bb55
  %47 = bitcast i64* %k157 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %47) #10
  %48 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %49 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call58 = call i64 @XXH_readLE64_align(i8* %48, i32 %49)
  %call59 = call i64 @XXH64_round(i64 0, i64 %call58)
  store i64 %call59, i64* %k157, align 8, !tbaa !21
  %50 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr60 = getelementptr inbounds i8, i8* %50, i64 8
  store i8* %add.ptr60, i8** %ptr.addr, align 8, !tbaa !3
  %51 = load i64, i64* %k157, align 8, !tbaa !21
  %52 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor61 = xor i64 %52, %51
  store i64 %xor61, i64* %h64.addr, align 8, !tbaa !21
  %53 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl62 = shl i64 %53, 27
  %54 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr63 = lshr i64 %54, 37
  %or64 = or i64 %shl62, %shr63
  %mul65 = mul i64 %or64, -7046029288634856825
  %add66 = add i64 %mul65, -8796714831421723037
  store i64 %add66, i64* %h64.addr, align 8, !tbaa !21
  %55 = bitcast i64* %k157 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %55) #10
  br label %do.end67

do.end67:                                         ; preds = %do.body56
  br label %sw.bb68

sw.bb68:                                          ; preds = %entry, %do.end67
  br label %do.body69

do.body69:                                        ; preds = %sw.bb68
  %56 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %57 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call70 = call i32 @XXH_readLE32_align(i8* %56, i32 %57)
  %conv = zext i32 %call70 to i64
  %mul71 = mul i64 %conv, -7046029288634856825
  %58 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor72 = xor i64 %58, %mul71
  store i64 %xor72, i64* %h64.addr, align 8, !tbaa !21
  %59 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr73 = getelementptr inbounds i8, i8* %59, i64 4
  store i8* %add.ptr73, i8** %ptr.addr, align 8, !tbaa !3
  %60 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl74 = shl i64 %60, 23
  %61 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr75 = lshr i64 %61, 41
  %or76 = or i64 %shl74, %shr75
  %mul77 = mul i64 %or76, -4417276706812531889
  %add78 = add i64 %mul77, 1609587929392839161
  store i64 %add78, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end79

do.end79:                                         ; preds = %do.body69
  %62 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call80 = call i64 @XXH64_avalanche(i64 %62)
  store i64 %call80, i64* %retval, align 8
  br label %return

sw.bb81:                                          ; preds = %entry
  br label %do.body82

do.body82:                                        ; preds = %sw.bb81
  %63 = bitcast i64* %k183 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %63) #10
  %64 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %65 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call84 = call i64 @XXH_readLE64_align(i8* %64, i32 %65)
  %call85 = call i64 @XXH64_round(i64 0, i64 %call84)
  store i64 %call85, i64* %k183, align 8, !tbaa !21
  %66 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr86 = getelementptr inbounds i8, i8* %66, i64 8
  store i8* %add.ptr86, i8** %ptr.addr, align 8, !tbaa !3
  %67 = load i64, i64* %k183, align 8, !tbaa !21
  %68 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor87 = xor i64 %68, %67
  store i64 %xor87, i64* %h64.addr, align 8, !tbaa !21
  %69 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl88 = shl i64 %69, 27
  %70 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr89 = lshr i64 %70, 37
  %or90 = or i64 %shl88, %shr89
  %mul91 = mul i64 %or90, -7046029288634856825
  %add92 = add i64 %mul91, -8796714831421723037
  store i64 %add92, i64* %h64.addr, align 8, !tbaa !21
  %71 = bitcast i64* %k183 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #10
  br label %do.end93

do.end93:                                         ; preds = %do.body82
  br label %sw.bb94

sw.bb94:                                          ; preds = %entry, %do.end93
  br label %do.body95

do.body95:                                        ; preds = %sw.bb94
  %72 = bitcast i64* %k196 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %72) #10
  %73 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %74 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call97 = call i64 @XXH_readLE64_align(i8* %73, i32 %74)
  %call98 = call i64 @XXH64_round(i64 0, i64 %call97)
  store i64 %call98, i64* %k196, align 8, !tbaa !21
  %75 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr99 = getelementptr inbounds i8, i8* %75, i64 8
  store i8* %add.ptr99, i8** %ptr.addr, align 8, !tbaa !3
  %76 = load i64, i64* %k196, align 8, !tbaa !21
  %77 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor100 = xor i64 %77, %76
  store i64 %xor100, i64* %h64.addr, align 8, !tbaa !21
  %78 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl101 = shl i64 %78, 27
  %79 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr102 = lshr i64 %79, 37
  %or103 = or i64 %shl101, %shr102
  %mul104 = mul i64 %or103, -7046029288634856825
  %add105 = add i64 %mul104, -8796714831421723037
  store i64 %add105, i64* %h64.addr, align 8, !tbaa !21
  %80 = bitcast i64* %k196 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %80) #10
  br label %do.end106

do.end106:                                        ; preds = %do.body95
  br label %sw.bb107

sw.bb107:                                         ; preds = %entry, %do.end106
  br label %do.body108

do.body108:                                       ; preds = %sw.bb107
  %81 = bitcast i64* %k1109 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %81) #10
  %82 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %83 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call110 = call i64 @XXH_readLE64_align(i8* %82, i32 %83)
  %call111 = call i64 @XXH64_round(i64 0, i64 %call110)
  store i64 %call111, i64* %k1109, align 8, !tbaa !21
  %84 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr112 = getelementptr inbounds i8, i8* %84, i64 8
  store i8* %add.ptr112, i8** %ptr.addr, align 8, !tbaa !3
  %85 = load i64, i64* %k1109, align 8, !tbaa !21
  %86 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor113 = xor i64 %86, %85
  store i64 %xor113, i64* %h64.addr, align 8, !tbaa !21
  %87 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl114 = shl i64 %87, 27
  %88 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr115 = lshr i64 %88, 37
  %or116 = or i64 %shl114, %shr115
  %mul117 = mul i64 %or116, -7046029288634856825
  %add118 = add i64 %mul117, -8796714831421723037
  store i64 %add118, i64* %h64.addr, align 8, !tbaa !21
  %89 = bitcast i64* %k1109 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %89) #10
  br label %do.end119

do.end119:                                        ; preds = %do.body108
  br label %do.body120

do.body120:                                       ; preds = %do.end119
  %90 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds i8, i8* %90, i32 1
  store i8* %incdec.ptr, i8** %ptr.addr, align 8, !tbaa !3
  %91 = load i8, i8* %90, align 1, !tbaa !11
  %conv121 = zext i8 %91 to i64
  %mul122 = mul i64 %conv121, 2870177450012600261
  %92 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor123 = xor i64 %92, %mul122
  store i64 %xor123, i64* %h64.addr, align 8, !tbaa !21
  %93 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl124 = shl i64 %93, 11
  %94 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr125 = lshr i64 %94, 53
  %or126 = or i64 %shl124, %shr125
  %mul127 = mul i64 %or126, -7046029288634856825
  store i64 %mul127, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end128

do.end128:                                        ; preds = %do.body120
  %95 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call129 = call i64 @XXH64_avalanche(i64 %95)
  store i64 %call129, i64* %retval, align 8
  br label %return

sw.bb130:                                         ; preds = %entry
  br label %do.body131

do.body131:                                       ; preds = %sw.bb130
  %96 = bitcast i64* %k1132 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %96) #10
  %97 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %98 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call133 = call i64 @XXH_readLE64_align(i8* %97, i32 %98)
  %call134 = call i64 @XXH64_round(i64 0, i64 %call133)
  store i64 %call134, i64* %k1132, align 8, !tbaa !21
  %99 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr135 = getelementptr inbounds i8, i8* %99, i64 8
  store i8* %add.ptr135, i8** %ptr.addr, align 8, !tbaa !3
  %100 = load i64, i64* %k1132, align 8, !tbaa !21
  %101 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor136 = xor i64 %101, %100
  store i64 %xor136, i64* %h64.addr, align 8, !tbaa !21
  %102 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl137 = shl i64 %102, 27
  %103 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr138 = lshr i64 %103, 37
  %or139 = or i64 %shl137, %shr138
  %mul140 = mul i64 %or139, -7046029288634856825
  %add141 = add i64 %mul140, -8796714831421723037
  store i64 %add141, i64* %h64.addr, align 8, !tbaa !21
  %104 = bitcast i64* %k1132 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %104) #10
  br label %do.end142

do.end142:                                        ; preds = %do.body131
  br label %sw.bb143

sw.bb143:                                         ; preds = %entry, %do.end142
  br label %do.body144

do.body144:                                       ; preds = %sw.bb143
  %105 = bitcast i64* %k1145 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %105) #10
  %106 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %107 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call146 = call i64 @XXH_readLE64_align(i8* %106, i32 %107)
  %call147 = call i64 @XXH64_round(i64 0, i64 %call146)
  store i64 %call147, i64* %k1145, align 8, !tbaa !21
  %108 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr148 = getelementptr inbounds i8, i8* %108, i64 8
  store i8* %add.ptr148, i8** %ptr.addr, align 8, !tbaa !3
  %109 = load i64, i64* %k1145, align 8, !tbaa !21
  %110 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor149 = xor i64 %110, %109
  store i64 %xor149, i64* %h64.addr, align 8, !tbaa !21
  %111 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl150 = shl i64 %111, 27
  %112 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr151 = lshr i64 %112, 37
  %or152 = or i64 %shl150, %shr151
  %mul153 = mul i64 %or152, -7046029288634856825
  %add154 = add i64 %mul153, -8796714831421723037
  store i64 %add154, i64* %h64.addr, align 8, !tbaa !21
  %113 = bitcast i64* %k1145 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %113) #10
  br label %do.end155

do.end155:                                        ; preds = %do.body144
  br label %sw.bb156

sw.bb156:                                         ; preds = %entry, %do.end155
  br label %do.body157

do.body157:                                       ; preds = %sw.bb156
  %114 = bitcast i64* %k1158 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %114) #10
  %115 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %116 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call159 = call i64 @XXH_readLE64_align(i8* %115, i32 %116)
  %call160 = call i64 @XXH64_round(i64 0, i64 %call159)
  store i64 %call160, i64* %k1158, align 8, !tbaa !21
  %117 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr161 = getelementptr inbounds i8, i8* %117, i64 8
  store i8* %add.ptr161, i8** %ptr.addr, align 8, !tbaa !3
  %118 = load i64, i64* %k1158, align 8, !tbaa !21
  %119 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor162 = xor i64 %119, %118
  store i64 %xor162, i64* %h64.addr, align 8, !tbaa !21
  %120 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl163 = shl i64 %120, 27
  %121 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr164 = lshr i64 %121, 37
  %or165 = or i64 %shl163, %shr164
  %mul166 = mul i64 %or165, -7046029288634856825
  %add167 = add i64 %mul166, -8796714831421723037
  store i64 %add167, i64* %h64.addr, align 8, !tbaa !21
  %122 = bitcast i64* %k1158 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %122) #10
  br label %do.end168

do.end168:                                        ; preds = %do.body157
  br label %sw.bb169

sw.bb169:                                         ; preds = %entry, %do.end168
  br label %do.body170

do.body170:                                       ; preds = %sw.bb169
  %123 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %124 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call171 = call i32 @XXH_readLE32_align(i8* %123, i32 %124)
  %conv172 = zext i32 %call171 to i64
  %mul173 = mul i64 %conv172, -7046029288634856825
  %125 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor174 = xor i64 %125, %mul173
  store i64 %xor174, i64* %h64.addr, align 8, !tbaa !21
  %126 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr175 = getelementptr inbounds i8, i8* %126, i64 4
  store i8* %add.ptr175, i8** %ptr.addr, align 8, !tbaa !3
  %127 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl176 = shl i64 %127, 23
  %128 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr177 = lshr i64 %128, 41
  %or178 = or i64 %shl176, %shr177
  %mul179 = mul i64 %or178, -4417276706812531889
  %add180 = add i64 %mul179, 1609587929392839161
  store i64 %add180, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end181

do.end181:                                        ; preds = %do.body170
  br label %do.body182

do.body182:                                       ; preds = %do.end181
  %129 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr183 = getelementptr inbounds i8, i8* %129, i32 1
  store i8* %incdec.ptr183, i8** %ptr.addr, align 8, !tbaa !3
  %130 = load i8, i8* %129, align 1, !tbaa !11
  %conv184 = zext i8 %130 to i64
  %mul185 = mul i64 %conv184, 2870177450012600261
  %131 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor186 = xor i64 %131, %mul185
  store i64 %xor186, i64* %h64.addr, align 8, !tbaa !21
  %132 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl187 = shl i64 %132, 11
  %133 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr188 = lshr i64 %133, 53
  %or189 = or i64 %shl187, %shr188
  %mul190 = mul i64 %or189, -7046029288634856825
  store i64 %mul190, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end191

do.end191:                                        ; preds = %do.body182
  %134 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call192 = call i64 @XXH64_avalanche(i64 %134)
  store i64 %call192, i64* %retval, align 8
  br label %return

sw.bb193:                                         ; preds = %entry
  br label %do.body194

do.body194:                                       ; preds = %sw.bb193
  %135 = bitcast i64* %k1195 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %135) #10
  %136 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %137 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call196 = call i64 @XXH_readLE64_align(i8* %136, i32 %137)
  %call197 = call i64 @XXH64_round(i64 0, i64 %call196)
  store i64 %call197, i64* %k1195, align 8, !tbaa !21
  %138 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr198 = getelementptr inbounds i8, i8* %138, i64 8
  store i8* %add.ptr198, i8** %ptr.addr, align 8, !tbaa !3
  %139 = load i64, i64* %k1195, align 8, !tbaa !21
  %140 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor199 = xor i64 %140, %139
  store i64 %xor199, i64* %h64.addr, align 8, !tbaa !21
  %141 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl200 = shl i64 %141, 27
  %142 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr201 = lshr i64 %142, 37
  %or202 = or i64 %shl200, %shr201
  %mul203 = mul i64 %or202, -7046029288634856825
  %add204 = add i64 %mul203, -8796714831421723037
  store i64 %add204, i64* %h64.addr, align 8, !tbaa !21
  %143 = bitcast i64* %k1195 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %143) #10
  br label %do.end205

do.end205:                                        ; preds = %do.body194
  br label %sw.bb206

sw.bb206:                                         ; preds = %entry, %do.end205
  br label %do.body207

do.body207:                                       ; preds = %sw.bb206
  %144 = bitcast i64* %k1208 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %144) #10
  %145 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %146 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call209 = call i64 @XXH_readLE64_align(i8* %145, i32 %146)
  %call210 = call i64 @XXH64_round(i64 0, i64 %call209)
  store i64 %call210, i64* %k1208, align 8, !tbaa !21
  %147 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr211 = getelementptr inbounds i8, i8* %147, i64 8
  store i8* %add.ptr211, i8** %ptr.addr, align 8, !tbaa !3
  %148 = load i64, i64* %k1208, align 8, !tbaa !21
  %149 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor212 = xor i64 %149, %148
  store i64 %xor212, i64* %h64.addr, align 8, !tbaa !21
  %150 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl213 = shl i64 %150, 27
  %151 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr214 = lshr i64 %151, 37
  %or215 = or i64 %shl213, %shr214
  %mul216 = mul i64 %or215, -7046029288634856825
  %add217 = add i64 %mul216, -8796714831421723037
  store i64 %add217, i64* %h64.addr, align 8, !tbaa !21
  %152 = bitcast i64* %k1208 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %152) #10
  br label %do.end218

do.end218:                                        ; preds = %do.body207
  br label %sw.bb219

sw.bb219:                                         ; preds = %entry, %do.end218
  br label %do.body220

do.body220:                                       ; preds = %sw.bb219
  %153 = bitcast i64* %k1221 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %153) #10
  %154 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %155 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call222 = call i64 @XXH_readLE64_align(i8* %154, i32 %155)
  %call223 = call i64 @XXH64_round(i64 0, i64 %call222)
  store i64 %call223, i64* %k1221, align 8, !tbaa !21
  %156 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr224 = getelementptr inbounds i8, i8* %156, i64 8
  store i8* %add.ptr224, i8** %ptr.addr, align 8, !tbaa !3
  %157 = load i64, i64* %k1221, align 8, !tbaa !21
  %158 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor225 = xor i64 %158, %157
  store i64 %xor225, i64* %h64.addr, align 8, !tbaa !21
  %159 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl226 = shl i64 %159, 27
  %160 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr227 = lshr i64 %160, 37
  %or228 = or i64 %shl226, %shr227
  %mul229 = mul i64 %or228, -7046029288634856825
  %add230 = add i64 %mul229, -8796714831421723037
  store i64 %add230, i64* %h64.addr, align 8, !tbaa !21
  %161 = bitcast i64* %k1221 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %161) #10
  br label %do.end231

do.end231:                                        ; preds = %do.body220
  br label %do.body232

do.body232:                                       ; preds = %do.end231
  %162 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr233 = getelementptr inbounds i8, i8* %162, i32 1
  store i8* %incdec.ptr233, i8** %ptr.addr, align 8, !tbaa !3
  %163 = load i8, i8* %162, align 1, !tbaa !11
  %conv234 = zext i8 %163 to i64
  %mul235 = mul i64 %conv234, 2870177450012600261
  %164 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor236 = xor i64 %164, %mul235
  store i64 %xor236, i64* %h64.addr, align 8, !tbaa !21
  %165 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl237 = shl i64 %165, 11
  %166 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr238 = lshr i64 %166, 53
  %or239 = or i64 %shl237, %shr238
  %mul240 = mul i64 %or239, -7046029288634856825
  store i64 %mul240, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end241

do.end241:                                        ; preds = %do.body232
  br label %do.body242

do.body242:                                       ; preds = %do.end241
  %167 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr243 = getelementptr inbounds i8, i8* %167, i32 1
  store i8* %incdec.ptr243, i8** %ptr.addr, align 8, !tbaa !3
  %168 = load i8, i8* %167, align 1, !tbaa !11
  %conv244 = zext i8 %168 to i64
  %mul245 = mul i64 %conv244, 2870177450012600261
  %169 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor246 = xor i64 %169, %mul245
  store i64 %xor246, i64* %h64.addr, align 8, !tbaa !21
  %170 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl247 = shl i64 %170, 11
  %171 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr248 = lshr i64 %171, 53
  %or249 = or i64 %shl247, %shr248
  %mul250 = mul i64 %or249, -7046029288634856825
  store i64 %mul250, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end251

do.end251:                                        ; preds = %do.body242
  %172 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call252 = call i64 @XXH64_avalanche(i64 %172)
  store i64 %call252, i64* %retval, align 8
  br label %return

sw.bb253:                                         ; preds = %entry
  br label %do.body254

do.body254:                                       ; preds = %sw.bb253
  %173 = bitcast i64* %k1255 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %173) #10
  %174 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %175 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call256 = call i64 @XXH_readLE64_align(i8* %174, i32 %175)
  %call257 = call i64 @XXH64_round(i64 0, i64 %call256)
  store i64 %call257, i64* %k1255, align 8, !tbaa !21
  %176 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr258 = getelementptr inbounds i8, i8* %176, i64 8
  store i8* %add.ptr258, i8** %ptr.addr, align 8, !tbaa !3
  %177 = load i64, i64* %k1255, align 8, !tbaa !21
  %178 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor259 = xor i64 %178, %177
  store i64 %xor259, i64* %h64.addr, align 8, !tbaa !21
  %179 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl260 = shl i64 %179, 27
  %180 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr261 = lshr i64 %180, 37
  %or262 = or i64 %shl260, %shr261
  %mul263 = mul i64 %or262, -7046029288634856825
  %add264 = add i64 %mul263, -8796714831421723037
  store i64 %add264, i64* %h64.addr, align 8, !tbaa !21
  %181 = bitcast i64* %k1255 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %181) #10
  br label %do.end265

do.end265:                                        ; preds = %do.body254
  br label %sw.bb266

sw.bb266:                                         ; preds = %entry, %do.end265
  br label %do.body267

do.body267:                                       ; preds = %sw.bb266
  %182 = bitcast i64* %k1268 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %182) #10
  %183 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %184 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call269 = call i64 @XXH_readLE64_align(i8* %183, i32 %184)
  %call270 = call i64 @XXH64_round(i64 0, i64 %call269)
  store i64 %call270, i64* %k1268, align 8, !tbaa !21
  %185 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr271 = getelementptr inbounds i8, i8* %185, i64 8
  store i8* %add.ptr271, i8** %ptr.addr, align 8, !tbaa !3
  %186 = load i64, i64* %k1268, align 8, !tbaa !21
  %187 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor272 = xor i64 %187, %186
  store i64 %xor272, i64* %h64.addr, align 8, !tbaa !21
  %188 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl273 = shl i64 %188, 27
  %189 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr274 = lshr i64 %189, 37
  %or275 = or i64 %shl273, %shr274
  %mul276 = mul i64 %or275, -7046029288634856825
  %add277 = add i64 %mul276, -8796714831421723037
  store i64 %add277, i64* %h64.addr, align 8, !tbaa !21
  %190 = bitcast i64* %k1268 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %190) #10
  br label %do.end278

do.end278:                                        ; preds = %do.body267
  br label %sw.bb279

sw.bb279:                                         ; preds = %entry, %do.end278
  br label %do.body280

do.body280:                                       ; preds = %sw.bb279
  %191 = bitcast i64* %k1281 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %191) #10
  %192 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %193 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call282 = call i64 @XXH_readLE64_align(i8* %192, i32 %193)
  %call283 = call i64 @XXH64_round(i64 0, i64 %call282)
  store i64 %call283, i64* %k1281, align 8, !tbaa !21
  %194 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr284 = getelementptr inbounds i8, i8* %194, i64 8
  store i8* %add.ptr284, i8** %ptr.addr, align 8, !tbaa !3
  %195 = load i64, i64* %k1281, align 8, !tbaa !21
  %196 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor285 = xor i64 %196, %195
  store i64 %xor285, i64* %h64.addr, align 8, !tbaa !21
  %197 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl286 = shl i64 %197, 27
  %198 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr287 = lshr i64 %198, 37
  %or288 = or i64 %shl286, %shr287
  %mul289 = mul i64 %or288, -7046029288634856825
  %add290 = add i64 %mul289, -8796714831421723037
  store i64 %add290, i64* %h64.addr, align 8, !tbaa !21
  %199 = bitcast i64* %k1281 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %199) #10
  br label %do.end291

do.end291:                                        ; preds = %do.body280
  br label %sw.bb292

sw.bb292:                                         ; preds = %entry, %do.end291
  br label %do.body293

do.body293:                                       ; preds = %sw.bb292
  %200 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %201 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call294 = call i32 @XXH_readLE32_align(i8* %200, i32 %201)
  %conv295 = zext i32 %call294 to i64
  %mul296 = mul i64 %conv295, -7046029288634856825
  %202 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor297 = xor i64 %202, %mul296
  store i64 %xor297, i64* %h64.addr, align 8, !tbaa !21
  %203 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr298 = getelementptr inbounds i8, i8* %203, i64 4
  store i8* %add.ptr298, i8** %ptr.addr, align 8, !tbaa !3
  %204 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl299 = shl i64 %204, 23
  %205 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr300 = lshr i64 %205, 41
  %or301 = or i64 %shl299, %shr300
  %mul302 = mul i64 %or301, -4417276706812531889
  %add303 = add i64 %mul302, 1609587929392839161
  store i64 %add303, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end304

do.end304:                                        ; preds = %do.body293
  br label %do.body305

do.body305:                                       ; preds = %do.end304
  %206 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr306 = getelementptr inbounds i8, i8* %206, i32 1
  store i8* %incdec.ptr306, i8** %ptr.addr, align 8, !tbaa !3
  %207 = load i8, i8* %206, align 1, !tbaa !11
  %conv307 = zext i8 %207 to i64
  %mul308 = mul i64 %conv307, 2870177450012600261
  %208 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor309 = xor i64 %208, %mul308
  store i64 %xor309, i64* %h64.addr, align 8, !tbaa !21
  %209 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl310 = shl i64 %209, 11
  %210 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr311 = lshr i64 %210, 53
  %or312 = or i64 %shl310, %shr311
  %mul313 = mul i64 %or312, -7046029288634856825
  store i64 %mul313, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end314

do.end314:                                        ; preds = %do.body305
  br label %do.body315

do.body315:                                       ; preds = %do.end314
  %211 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr316 = getelementptr inbounds i8, i8* %211, i32 1
  store i8* %incdec.ptr316, i8** %ptr.addr, align 8, !tbaa !3
  %212 = load i8, i8* %211, align 1, !tbaa !11
  %conv317 = zext i8 %212 to i64
  %mul318 = mul i64 %conv317, 2870177450012600261
  %213 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor319 = xor i64 %213, %mul318
  store i64 %xor319, i64* %h64.addr, align 8, !tbaa !21
  %214 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl320 = shl i64 %214, 11
  %215 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr321 = lshr i64 %215, 53
  %or322 = or i64 %shl320, %shr321
  %mul323 = mul i64 %or322, -7046029288634856825
  store i64 %mul323, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end324

do.end324:                                        ; preds = %do.body315
  %216 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call325 = call i64 @XXH64_avalanche(i64 %216)
  store i64 %call325, i64* %retval, align 8
  br label %return

sw.bb326:                                         ; preds = %entry
  br label %do.body327

do.body327:                                       ; preds = %sw.bb326
  %217 = bitcast i64* %k1328 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %217) #10
  %218 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %219 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call329 = call i64 @XXH_readLE64_align(i8* %218, i32 %219)
  %call330 = call i64 @XXH64_round(i64 0, i64 %call329)
  store i64 %call330, i64* %k1328, align 8, !tbaa !21
  %220 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr331 = getelementptr inbounds i8, i8* %220, i64 8
  store i8* %add.ptr331, i8** %ptr.addr, align 8, !tbaa !3
  %221 = load i64, i64* %k1328, align 8, !tbaa !21
  %222 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor332 = xor i64 %222, %221
  store i64 %xor332, i64* %h64.addr, align 8, !tbaa !21
  %223 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl333 = shl i64 %223, 27
  %224 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr334 = lshr i64 %224, 37
  %or335 = or i64 %shl333, %shr334
  %mul336 = mul i64 %or335, -7046029288634856825
  %add337 = add i64 %mul336, -8796714831421723037
  store i64 %add337, i64* %h64.addr, align 8, !tbaa !21
  %225 = bitcast i64* %k1328 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %225) #10
  br label %do.end338

do.end338:                                        ; preds = %do.body327
  br label %sw.bb339

sw.bb339:                                         ; preds = %entry, %do.end338
  br label %do.body340

do.body340:                                       ; preds = %sw.bb339
  %226 = bitcast i64* %k1341 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %226) #10
  %227 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %228 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call342 = call i64 @XXH_readLE64_align(i8* %227, i32 %228)
  %call343 = call i64 @XXH64_round(i64 0, i64 %call342)
  store i64 %call343, i64* %k1341, align 8, !tbaa !21
  %229 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr344 = getelementptr inbounds i8, i8* %229, i64 8
  store i8* %add.ptr344, i8** %ptr.addr, align 8, !tbaa !3
  %230 = load i64, i64* %k1341, align 8, !tbaa !21
  %231 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor345 = xor i64 %231, %230
  store i64 %xor345, i64* %h64.addr, align 8, !tbaa !21
  %232 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl346 = shl i64 %232, 27
  %233 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr347 = lshr i64 %233, 37
  %or348 = or i64 %shl346, %shr347
  %mul349 = mul i64 %or348, -7046029288634856825
  %add350 = add i64 %mul349, -8796714831421723037
  store i64 %add350, i64* %h64.addr, align 8, !tbaa !21
  %234 = bitcast i64* %k1341 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %234) #10
  br label %do.end351

do.end351:                                        ; preds = %do.body340
  br label %sw.bb352

sw.bb352:                                         ; preds = %entry, %do.end351
  br label %do.body353

do.body353:                                       ; preds = %sw.bb352
  %235 = bitcast i64* %k1354 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %235) #10
  %236 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %237 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call355 = call i64 @XXH_readLE64_align(i8* %236, i32 %237)
  %call356 = call i64 @XXH64_round(i64 0, i64 %call355)
  store i64 %call356, i64* %k1354, align 8, !tbaa !21
  %238 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr357 = getelementptr inbounds i8, i8* %238, i64 8
  store i8* %add.ptr357, i8** %ptr.addr, align 8, !tbaa !3
  %239 = load i64, i64* %k1354, align 8, !tbaa !21
  %240 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor358 = xor i64 %240, %239
  store i64 %xor358, i64* %h64.addr, align 8, !tbaa !21
  %241 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl359 = shl i64 %241, 27
  %242 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr360 = lshr i64 %242, 37
  %or361 = or i64 %shl359, %shr360
  %mul362 = mul i64 %or361, -7046029288634856825
  %add363 = add i64 %mul362, -8796714831421723037
  store i64 %add363, i64* %h64.addr, align 8, !tbaa !21
  %243 = bitcast i64* %k1354 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %243) #10
  br label %do.end364

do.end364:                                        ; preds = %do.body353
  br label %do.body365

do.body365:                                       ; preds = %do.end364
  %244 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr366 = getelementptr inbounds i8, i8* %244, i32 1
  store i8* %incdec.ptr366, i8** %ptr.addr, align 8, !tbaa !3
  %245 = load i8, i8* %244, align 1, !tbaa !11
  %conv367 = zext i8 %245 to i64
  %mul368 = mul i64 %conv367, 2870177450012600261
  %246 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor369 = xor i64 %246, %mul368
  store i64 %xor369, i64* %h64.addr, align 8, !tbaa !21
  %247 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl370 = shl i64 %247, 11
  %248 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr371 = lshr i64 %248, 53
  %or372 = or i64 %shl370, %shr371
  %mul373 = mul i64 %or372, -7046029288634856825
  store i64 %mul373, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end374

do.end374:                                        ; preds = %do.body365
  br label %do.body375

do.body375:                                       ; preds = %do.end374
  %249 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr376 = getelementptr inbounds i8, i8* %249, i32 1
  store i8* %incdec.ptr376, i8** %ptr.addr, align 8, !tbaa !3
  %250 = load i8, i8* %249, align 1, !tbaa !11
  %conv377 = zext i8 %250 to i64
  %mul378 = mul i64 %conv377, 2870177450012600261
  %251 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor379 = xor i64 %251, %mul378
  store i64 %xor379, i64* %h64.addr, align 8, !tbaa !21
  %252 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl380 = shl i64 %252, 11
  %253 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr381 = lshr i64 %253, 53
  %or382 = or i64 %shl380, %shr381
  %mul383 = mul i64 %or382, -7046029288634856825
  store i64 %mul383, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end384

do.end384:                                        ; preds = %do.body375
  br label %do.body385

do.body385:                                       ; preds = %do.end384
  %254 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr386 = getelementptr inbounds i8, i8* %254, i32 1
  store i8* %incdec.ptr386, i8** %ptr.addr, align 8, !tbaa !3
  %255 = load i8, i8* %254, align 1, !tbaa !11
  %conv387 = zext i8 %255 to i64
  %mul388 = mul i64 %conv387, 2870177450012600261
  %256 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor389 = xor i64 %256, %mul388
  store i64 %xor389, i64* %h64.addr, align 8, !tbaa !21
  %257 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl390 = shl i64 %257, 11
  %258 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr391 = lshr i64 %258, 53
  %or392 = or i64 %shl390, %shr391
  %mul393 = mul i64 %or392, -7046029288634856825
  store i64 %mul393, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end394

do.end394:                                        ; preds = %do.body385
  %259 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call395 = call i64 @XXH64_avalanche(i64 %259)
  store i64 %call395, i64* %retval, align 8
  br label %return

sw.bb396:                                         ; preds = %entry
  br label %do.body397

do.body397:                                       ; preds = %sw.bb396
  %260 = bitcast i64* %k1398 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %260) #10
  %261 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %262 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call399 = call i64 @XXH_readLE64_align(i8* %261, i32 %262)
  %call400 = call i64 @XXH64_round(i64 0, i64 %call399)
  store i64 %call400, i64* %k1398, align 8, !tbaa !21
  %263 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr401 = getelementptr inbounds i8, i8* %263, i64 8
  store i8* %add.ptr401, i8** %ptr.addr, align 8, !tbaa !3
  %264 = load i64, i64* %k1398, align 8, !tbaa !21
  %265 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor402 = xor i64 %265, %264
  store i64 %xor402, i64* %h64.addr, align 8, !tbaa !21
  %266 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl403 = shl i64 %266, 27
  %267 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr404 = lshr i64 %267, 37
  %or405 = or i64 %shl403, %shr404
  %mul406 = mul i64 %or405, -7046029288634856825
  %add407 = add i64 %mul406, -8796714831421723037
  store i64 %add407, i64* %h64.addr, align 8, !tbaa !21
  %268 = bitcast i64* %k1398 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %268) #10
  br label %do.end408

do.end408:                                        ; preds = %do.body397
  br label %sw.bb409

sw.bb409:                                         ; preds = %entry, %do.end408
  br label %do.body410

do.body410:                                       ; preds = %sw.bb409
  %269 = bitcast i64* %k1411 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %269) #10
  %270 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %271 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call412 = call i64 @XXH_readLE64_align(i8* %270, i32 %271)
  %call413 = call i64 @XXH64_round(i64 0, i64 %call412)
  store i64 %call413, i64* %k1411, align 8, !tbaa !21
  %272 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr414 = getelementptr inbounds i8, i8* %272, i64 8
  store i8* %add.ptr414, i8** %ptr.addr, align 8, !tbaa !3
  %273 = load i64, i64* %k1411, align 8, !tbaa !21
  %274 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor415 = xor i64 %274, %273
  store i64 %xor415, i64* %h64.addr, align 8, !tbaa !21
  %275 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl416 = shl i64 %275, 27
  %276 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr417 = lshr i64 %276, 37
  %or418 = or i64 %shl416, %shr417
  %mul419 = mul i64 %or418, -7046029288634856825
  %add420 = add i64 %mul419, -8796714831421723037
  store i64 %add420, i64* %h64.addr, align 8, !tbaa !21
  %277 = bitcast i64* %k1411 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %277) #10
  br label %do.end421

do.end421:                                        ; preds = %do.body410
  br label %sw.bb422

sw.bb422:                                         ; preds = %entry, %do.end421
  br label %do.body423

do.body423:                                       ; preds = %sw.bb422
  %278 = bitcast i64* %k1424 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %278) #10
  %279 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %280 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call425 = call i64 @XXH_readLE64_align(i8* %279, i32 %280)
  %call426 = call i64 @XXH64_round(i64 0, i64 %call425)
  store i64 %call426, i64* %k1424, align 8, !tbaa !21
  %281 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr427 = getelementptr inbounds i8, i8* %281, i64 8
  store i8* %add.ptr427, i8** %ptr.addr, align 8, !tbaa !3
  %282 = load i64, i64* %k1424, align 8, !tbaa !21
  %283 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor428 = xor i64 %283, %282
  store i64 %xor428, i64* %h64.addr, align 8, !tbaa !21
  %284 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl429 = shl i64 %284, 27
  %285 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr430 = lshr i64 %285, 37
  %or431 = or i64 %shl429, %shr430
  %mul432 = mul i64 %or431, -7046029288634856825
  %add433 = add i64 %mul432, -8796714831421723037
  store i64 %add433, i64* %h64.addr, align 8, !tbaa !21
  %286 = bitcast i64* %k1424 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %286) #10
  br label %do.end434

do.end434:                                        ; preds = %do.body423
  br label %sw.bb435

sw.bb435:                                         ; preds = %entry, %do.end434
  br label %do.body436

do.body436:                                       ; preds = %sw.bb435
  %287 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %288 = load i32, i32* %align.addr, align 4, !tbaa !11
  %call437 = call i32 @XXH_readLE32_align(i8* %287, i32 %288)
  %conv438 = zext i32 %call437 to i64
  %mul439 = mul i64 %conv438, -7046029288634856825
  %289 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor440 = xor i64 %289, %mul439
  store i64 %xor440, i64* %h64.addr, align 8, !tbaa !21
  %290 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %add.ptr441 = getelementptr inbounds i8, i8* %290, i64 4
  store i8* %add.ptr441, i8** %ptr.addr, align 8, !tbaa !3
  %291 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl442 = shl i64 %291, 23
  %292 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr443 = lshr i64 %292, 41
  %or444 = or i64 %shl442, %shr443
  %mul445 = mul i64 %or444, -4417276706812531889
  %add446 = add i64 %mul445, 1609587929392839161
  store i64 %add446, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end447

do.end447:                                        ; preds = %do.body436
  br label %sw.bb448

sw.bb448:                                         ; preds = %entry, %do.end447
  br label %do.body449

do.body449:                                       ; preds = %sw.bb448
  %293 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr450 = getelementptr inbounds i8, i8* %293, i32 1
  store i8* %incdec.ptr450, i8** %ptr.addr, align 8, !tbaa !3
  %294 = load i8, i8* %293, align 1, !tbaa !11
  %conv451 = zext i8 %294 to i64
  %mul452 = mul i64 %conv451, 2870177450012600261
  %295 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor453 = xor i64 %295, %mul452
  store i64 %xor453, i64* %h64.addr, align 8, !tbaa !21
  %296 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl454 = shl i64 %296, 11
  %297 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr455 = lshr i64 %297, 53
  %or456 = or i64 %shl454, %shr455
  %mul457 = mul i64 %or456, -7046029288634856825
  store i64 %mul457, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end458

do.end458:                                        ; preds = %do.body449
  br label %sw.bb459

sw.bb459:                                         ; preds = %entry, %do.end458
  br label %do.body460

do.body460:                                       ; preds = %sw.bb459
  %298 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr461 = getelementptr inbounds i8, i8* %298, i32 1
  store i8* %incdec.ptr461, i8** %ptr.addr, align 8, !tbaa !3
  %299 = load i8, i8* %298, align 1, !tbaa !11
  %conv462 = zext i8 %299 to i64
  %mul463 = mul i64 %conv462, 2870177450012600261
  %300 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor464 = xor i64 %300, %mul463
  store i64 %xor464, i64* %h64.addr, align 8, !tbaa !21
  %301 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl465 = shl i64 %301, 11
  %302 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr466 = lshr i64 %302, 53
  %or467 = or i64 %shl465, %shr466
  %mul468 = mul i64 %or467, -7046029288634856825
  store i64 %mul468, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end469

do.end469:                                        ; preds = %do.body460
  br label %sw.bb470

sw.bb470:                                         ; preds = %entry, %do.end469
  br label %do.body471

do.body471:                                       ; preds = %sw.bb470
  %303 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %incdec.ptr472 = getelementptr inbounds i8, i8* %303, i32 1
  store i8* %incdec.ptr472, i8** %ptr.addr, align 8, !tbaa !3
  %304 = load i8, i8* %303, align 1, !tbaa !11
  %conv473 = zext i8 %304 to i64
  %mul474 = mul i64 %conv473, 2870177450012600261
  %305 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor475 = xor i64 %305, %mul474
  store i64 %xor475, i64* %h64.addr, align 8, !tbaa !21
  %306 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shl476 = shl i64 %306, 11
  %307 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr477 = lshr i64 %307, 53
  %or478 = or i64 %shl476, %shr477
  %mul479 = mul i64 %or478, -7046029288634856825
  store i64 %mul479, i64* %h64.addr, align 8, !tbaa !21
  br label %do.end480

do.end480:                                        ; preds = %do.body471
  br label %sw.bb481

sw.bb481:                                         ; preds = %entry, %do.end480
  %308 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call482 = call i64 @XXH64_avalanche(i64 %308)
  store i64 %call482, i64* %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, i64* %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb481, %do.end394, %do.end324, %do.end251, %do.end191, %do.end128, %do.end79, %do.end27
  %309 = load i64, i64* %retval, align 8
  ret i64 %309
}

; Function Attrs: nounwind ssp uwtable
define void @XXH64_canonicalFromHash(%struct.XXH64_canonical_t* %dst, i64 %hash) #0 {
entry:
  %dst.addr = alloca %struct.XXH64_canonical_t*, align 8
  %hash.addr = alloca i64, align 8
  store %struct.XXH64_canonical_t* %dst, %struct.XXH64_canonical_t** %dst.addr, align 8, !tbaa !3
  store i64 %hash, i64* %hash.addr, align 8, !tbaa !21
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i64, i64* %hash.addr, align 8, !tbaa !21
  %call = call i64 @XXH_swap64(i64 %0)
  store i64 %call, i64* %hash.addr, align 8, !tbaa !21
  %1 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8, !tbaa !3
  %2 = bitcast %struct.XXH64_canonical_t* %1 to i8*
  %3 = bitcast i64* %hash.addr to i8*
  %4 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %dst.addr, align 8, !tbaa !3
  %5 = bitcast %struct.XXH64_canonical_t* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call1 = call i8* @__memcpy_chk(i8* %2, i8* %3, i64 8, i64 %6) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH_swap64(i64 %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8, !tbaa !21
  %0 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shl = shl i64 %0, 56
  %and = and i64 %shl, -72057594037927936
  %1 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shl1 = shl i64 %1, 40
  %and2 = and i64 %shl1, 71776119061217280
  %or = or i64 %and, %and2
  %2 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shl3 = shl i64 %2, 24
  %and4 = and i64 %shl3, 280375465082880
  %or5 = or i64 %or, %and4
  %3 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shl6 = shl i64 %3, 8
  %and7 = and i64 %shl6, 1095216660480
  %or8 = or i64 %or5, %and7
  %4 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shr = lshr i64 %4, 8
  %and9 = and i64 %shr, 4278190080
  %or10 = or i64 %or8, %and9
  %5 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shr11 = lshr i64 %5, 24
  %and12 = and i64 %shr11, 16711680
  %or13 = or i64 %or10, %and12
  %6 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shr14 = lshr i64 %6, 40
  %and15 = and i64 %shr14, 65280
  %or16 = or i64 %or13, %and15
  %7 = load i64, i64* %x.addr, align 8, !tbaa !21
  %shr17 = lshr i64 %7, 56
  %and18 = and i64 %shr17, 255
  %or19 = or i64 %or16, %and18
  ret i64 %or19
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH64_hashFromCanonical(%struct.XXH64_canonical_t* %src) #0 {
entry:
  %src.addr = alloca %struct.XXH64_canonical_t*, align 8
  store %struct.XXH64_canonical_t* %src, %struct.XXH64_canonical_t** %src.addr, align 8, !tbaa !3
  %0 = load %struct.XXH64_canonical_t*, %struct.XXH64_canonical_t** %src.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH64_canonical_t* %0 to i8*
  %call = call i64 @XXH_readBE64(i8* %1)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH_readBE64(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %call = call i64 @XXH_read64(i8* %0)
  %call1 = call i64 @XXH_swap64(i64 %call)
  ret i64 %call1
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits(i8* %input, i64 %len) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_64bits_internal(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, i64 (i8*, i64, i64, i8*, i64)* %f_hashLong) #1 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hashLong.addr = alloca i64 (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  store i64 (i8*, i64, i64, i8*, i64)* %f_hashLong, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8, !tbaa !3
  %0 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %4 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_len_0to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp1 = icmp ule i64 %5, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %7 = load i64, i64* %len.addr, align 8, !tbaa !7
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %9 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %10 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call3 = call i64 @XXH3_len_17to128_64b(i8* %6, i64 %7, i8* %8, i64 %9, i64 %10)
  store i64 %call3, i64* %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp5 = icmp ule i64 %11, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %12 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %13 = load i64, i64* %len.addr, align 8, !tbaa !7
  %14 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %15 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %16 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call7 = call i64 @XXH3_len_129to240_64b(i8* %12, i64 %13, i8* %14, i64 %15, i64 %16)
  store i64 %call7, i64* %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %17 = load i64 (i8*, i64, i64, i8*, i64)*, i64 (i8*, i64, i64, i8*, i64)** %f_hashLong.addr, align 8, !tbaa !3
  %18 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %19 = load i64, i64* %len.addr, align 8, !tbaa !7
  %20 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %22 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %call9 = call i64 %17(i8* %18, i64 %19, i64 %20, i8* %21, i64 %22)
  store i64 %call9, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %23 = load i64, i64* %retval, align 8
  ret i64 %23
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %4 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSecret)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_64bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_64b_withSeed)
  ret i64 %call
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed(i8* %input, i64 %len, i64 %seed, i8* %secret, i64 %secretLen) #5 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %1 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_hashLong_64b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  ret i64 %call
}

; Function Attrs: nounwind ssp uwtable
define %struct.XXH3_state_s* @XXH3_createState() #0 {
entry:
  %call = call i8* @XXH_alignedMalloc(i64 576, i64 64)
  %0 = bitcast i8* %call to %struct.XXH3_state_s*
  ret %struct.XXH3_state_s* %0
}

; Function Attrs: nounwind ssp uwtable
define internal i8* @XXH_alignedMalloc(i64 %s, i64 %align) #0 {
entry:
  %retval = alloca i8*, align 8
  %s.addr = alloca i64, align 8
  %align.addr = alloca i64, align 8
  %base = alloca i8*, align 8
  %offset = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  store i64 %s, i64* %s.addr, align 8, !tbaa !7
  store i64 %align, i64* %align.addr, align 8, !tbaa !7
  %0 = bitcast i8** %base to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i64, i64* %s.addr, align 8, !tbaa !7
  %2 = load i64, i64* %align.addr, align 8, !tbaa !7
  %add = add i64 %1, %2
  %call = call i8* @XXH_malloc(i64 %add)
  store i8* %call, i8** %base, align 8, !tbaa !3
  %3 = load i8*, i8** %base, align 8, !tbaa !3
  %cmp = icmp ne i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  %5 = load i64, i64* %align.addr, align 8, !tbaa !7
  %6 = load i8*, i8** %base, align 8, !tbaa !3
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %align.addr, align 8, !tbaa !7
  %sub = sub i64 %8, 1
  %and = and i64 %7, %sub
  %sub1 = sub i64 %5, %and
  store i64 %sub1, i64* %offset, align 8, !tbaa !7
  %9 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #10
  %10 = load i8*, i8** %base, align 8, !tbaa !3
  %11 = load i64, i64* %offset, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 %11
  store i8* %add.ptr, i8** %ptr, align 8, !tbaa !3
  %12 = load i64, i64* %offset, align 8, !tbaa !7
  %conv = trunc i64 %12 to i8
  %13 = load i8*, i8** %ptr, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8, i8* %13, i64 -1
  store i8 %conv, i8* %arrayidx, align 1, !tbaa !11
  %14 = load i8*, i8** %ptr, align 8, !tbaa !3
  store i8* %14, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  %15 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #10
  %16 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #10
  br label %cleanup

if.end:                                           ; preds = %entry
  store i8* null, i8** %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %17 = bitcast i8** %base to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #10
  %18 = load i8*, i8** %retval, align 8
  ret i8* %18
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_freeState(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  call void @XXH_alignedFree(i8* %1)
  ret i32 0
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH_alignedFree(i8* %p) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %ptr = alloca i8*, align 8
  %offset = alloca i8, align 1
  %base = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %p.addr, align 8, !tbaa !3
  %cmp = icmp ne i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i8*, i8** %p.addr, align 8, !tbaa !3
  store i8* %2, i8** %ptr, align 8, !tbaa !3
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %offset) #10
  %3 = load i8*, i8** %ptr, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 -1
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !11
  store i8 %4, i8* %offset, align 1, !tbaa !11
  %5 = bitcast i8** %base to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #10
  %6 = load i8*, i8** %ptr, align 8, !tbaa !3
  %7 = load i8, i8* %offset, align 1, !tbaa !11
  %conv = zext i8 %7 to i32
  %idx.ext = sext i32 %conv to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %idx.neg
  store i8* %add.ptr, i8** %base, align 8, !tbaa !3
  %8 = load i8*, i8** %base, align 8, !tbaa !3
  call void @XXH_free(i8* %8)
  %9 = bitcast i8** %base to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %offset) #10
  %10 = bitcast i8** %ptr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @XXH3_copyState(%struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s* %src_state) #0 {
entry:
  %dst_state.addr = alloca %struct.XXH3_state_s*, align 8
  %src_state.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %dst_state, %struct.XXH3_state_s** %dst_state.addr, align 8, !tbaa !3
  store %struct.XXH3_state_s* %src_state, %struct.XXH3_state_s** %src_state.addr, align 8, !tbaa !3
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %src_state.addr, align 8, !tbaa !3
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %dst_state.addr, align 8, !tbaa !3
  %5 = bitcast %struct.XXH3_state_s* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 576, i64 %6) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %1 = bitcast %struct.XXH3_state_s* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %3 = bitcast %struct.XXH3_state_s* %2 to i8*
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true)
  %call = call i8* @__memset_chk(i8* %1, i32 0, i64 576, i64 %4) #10
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 0
  %arrayidx = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i64 0, i64 0
  store i64 3266489917, i64* %arrayidx, align 16, !tbaa !21
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i64 0, i64 1
  store i64 -7046029288634856825, i64* %arrayidx2, align 8, !tbaa !21
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc3, i64 0, i64 2
  store i64 -4417276706812531889, i64* %arrayidx4, align 16, !tbaa !21
  %8 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %8, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc5, i64 0, i64 3
  store i64 1609587929392839161, i64* %arrayidx6, align 8, !tbaa !21
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %9, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [8 x i64], [8 x i64]* %acc7, i64 0, i64 4
  store i64 -8796714831421723037, i64* %arrayidx8, align 16, !tbaa !21
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [8 x i64], [8 x i64]* %acc9, i64 0, i64 5
  store i64 2246822519, i64* %arrayidx10, align 8, !tbaa !21
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [8 x i64], [8 x i64]* %acc11, i64 0, i64 6
  store i64 2870177450012600261, i64* %arrayidx12, align 16, !tbaa !21
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %acc13 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [8 x i64], [8 x i64]* %acc13, i64 0, i64 7
  store i64 2654435761, i64* %arrayidx14, align 8, !tbaa !21
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %14 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %seed15 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %14, i32 0, i32 9
  store i64 %13, i64* %seed15, align 8, !tbaa !30
  %15 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 11
  store i8* %15, i8** %extSecret, align 8, !tbaa !32
  %17 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %sub = sub i64 %17, 64
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 7
  store i64 %sub, i64* %secretLimit, align 8, !tbaa !33
  %19 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %secretLimit16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %19, i32 0, i32 7
  %20 = load i64, i64* %secretLimit16, align 8, !tbaa !33
  %div = udiv i64 %20, 8
  %21 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %21, i32 0, i32 5
  store i64 %div, i64* %nbStripesPerBlock, align 8, !tbaa !34
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !21
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8, !tbaa !32
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_initCustomSecret_sse2(i8* noalias %customSecret, i64 %seed64) #1 {
entry:
  %customSecret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %seed = alloca <2 x i64>, align 16
  %i = alloca i32, align 4
  %src = alloca float*, align 64
  %dest = alloca <2 x i64>*, align 16
  store i8* %customSecret, i8** %customSecret.addr, align 8, !tbaa !3
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #10
  store i32 12, i32* %nbRounds, align 4, !tbaa !9
  %1 = bitcast <2 x i64>* %seed to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #10
  %2 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %sub = sub nsw i64 0, %2
  %3 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call = call <2 x i64> @_mm_set_epi64x(i64 %sub, i64 %3)
  store <2 x i64> %call, <2 x i64>* %seed, align 16, !tbaa !11
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #10
  %5 = bitcast float** %src to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #10
  store float* bitcast ([192 x i8]* @XXH3_kSecret to float*), float** %src, align 64, !tbaa !3
  %6 = bitcast <2 x i64>** %dest to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #10
  %7 = load i8*, i8** %customSecret.addr, align 8, !tbaa !3
  %8 = bitcast i8* %7 to <2 x i64>*
  store <2 x i64>* %8, <2 x i64>** %dest, align 16, !tbaa !3
  %9 = load <2 x i64>*, <2 x i64>** %dest, align 16, !tbaa !3
  %10 = call <2 x i64>* asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(<2 x i64>* %9) #8, !srcloc !35
  store <2 x i64>* %10, <2 x i64>** %dest, align 16, !tbaa !3
  store i32 0, i32* %i, align 4, !tbaa !9
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %11 = load i32, i32* %i, align 4, !tbaa !9
  %cmp = icmp slt i32 %11, 12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, i32* %i, align 4, !tbaa !9
  %mul = mul nsw i32 %12, 4
  %idx.ext = sext i32 %mul to i64
  %add.ptr = getelementptr inbounds float, float* bitcast ([192 x i8]* @XXH3_kSecret to float*), i64 %idx.ext
  %call1 = call <4 x float> @_mm_load_ps(float* %add.ptr)
  %call2 = call <2 x i64> @_mm_castps_si128(<4 x float> %call1)
  %13 = load <2 x i64>, <2 x i64>* %seed, align 16, !tbaa !11
  %call3 = call <2 x i64> @_mm_add_epi64(<2 x i64> %call2, <2 x i64> %13)
  %14 = load <2 x i64>*, <2 x i64>** %dest, align 16, !tbaa !3
  %15 = load i32, i32* %i, align 4, !tbaa !9
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %14, i64 %idxprom
  store <2 x i64> %call3, <2 x i64>* %arrayidx, align 16, !tbaa !11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4, !tbaa !9
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4, !tbaa !9
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = bitcast <2 x i64>** %dest to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #10
  %18 = bitcast float** %src to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #10
  %19 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %19) #10
  %20 = bitcast <2 x i64>* %seed to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %20) #10
  %21 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %21) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_64bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 0, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH3_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %bEnd = alloca i8*, align 8
  %secret = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  %loadSize = alloca i64, align 8
  %limit = alloca i8*, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !11
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %3
  store i8* %add.ptr, i8** %bEnd, align 8, !tbaa !3
  %4 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  %6 = load i8*, i8** %extSecret, align 8, !tbaa !32
  %cmp1 = icmp eq i8* %6, null
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %8 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %extSecret2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %8, i32 0, i32 11
  %9 = load i8*, i8** %extSecret2, align 8, !tbaa !32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %9, %cond.false ]
  store i8* %cond, i8** %secret, align 8, !tbaa !3
  %10 = load i64, i64* %len.addr, align 8, !tbaa !7
  %11 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %11, i32 0, i32 8
  %12 = load i64, i64* %totalLen, align 16, !tbaa !36
  %add = add i64 %12, %10
  store i64 %add, i64* %totalLen, align 16, !tbaa !36
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 3
  %14 = load i32, i32* %bufferedSize, align 16, !tbaa !37
  %conv = zext i32 %14 to i64
  %15 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add3 = add i64 %conv, %15
  %cmp4 = icmp ule i64 %add3, 256
  br i1 %cmp4, label %if.then6, label %if.end13

if.then6:                                         ; preds = %cond.end
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 3
  %18 = load i32, i32* %bufferedSize8, align 16, !tbaa !37
  %idx.ext = zext i32 %18 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %arraydecay7, i64 %idx.ext
  %19 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %20 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call i8* @XXH_memcpy(i8* %add.ptr9, i8* %19, i64 %20)
  %21 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv10 = trunc i64 %21 to i32
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 3
  %23 = load i32, i32* %bufferedSize11, align 16, !tbaa !37
  %add12 = add i32 %23, %conv10
  store i32 %add12, i32* %bufferedSize11, align 16, !tbaa !37
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end13:                                         ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.end13
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 3
  %25 = load i32, i32* %bufferedSize14, align 16, !tbaa !37
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.then15, label %if.end29

if.then15:                                        ; preds = %do.end
  %26 = bitcast i64* %loadSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %26) #10
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 3
  %28 = load i32, i32* %bufferedSize16, align 16, !tbaa !37
  %sub = sub i32 256, %28
  %conv17 = zext i32 %sub to i64
  store i64 %conv17, i64* %loadSize, align 8, !tbaa !7
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer18 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer18, i32 0, i32 0
  %30 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %30, i32 0, i32 3
  %31 = load i32, i32* %bufferedSize20, align 16, !tbaa !37
  %idx.ext21 = zext i32 %31 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay19, i64 %idx.ext21
  %32 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %33 = load i64, i64* %loadSize, align 8, !tbaa !7
  %call23 = call i8* @XXH_memcpy(i8* %add.ptr22, i8* %32, i64 %33)
  %34 = load i64, i64* %loadSize, align 8, !tbaa !7
  %35 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr24 = getelementptr inbounds i8, i8* %35, i64 %34
  store i8* %add.ptr24, i8** %input.addr, align 8, !tbaa !3
  %36 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %acc = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %36, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %nbStripesSoFar = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 6
  %38 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %38, i32 0, i32 5
  %39 = load i64, i64* %nbStripesPerBlock, align 8, !tbaa !34
  %40 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer26 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %40, i32 0, i32 2
  %arraydecay27 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer26, i32 0, i32 0
  %41 = load i8*, i8** %secret, align 8, !tbaa !3
  %42 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %42, i32 0, i32 7
  %43 = load i64, i64* %secretLimit, align 8, !tbaa !33
  %44 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %45 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %46 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  call void @XXH3_consumeStripes(i64* %arraydecay25, i64* %nbStripesSoFar, i64 %39, i8* %arraydecay27, i64 4, i8* %41, i64 %43, i32 %44, void (i8*, i8*, i8*, i32)* %45, void (i8*, i8*)* %46)
  %47 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize28 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %47, i32 0, i32 3
  store i32 0, i32* %bufferedSize28, align 16, !tbaa !37
  %48 = bitcast i64* %loadSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #10
  br label %if.end29

if.end29:                                         ; preds = %if.then15, %do.end
  %49 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr30 = getelementptr inbounds i8, i8* %49, i64 256
  %50 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %cmp31 = icmp ule i8* %add.ptr30, %50
  br i1 %cmp31, label %if.then33, label %if.end56

if.then33:                                        ; preds = %if.end29
  %51 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %51) #10
  %52 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %add.ptr34 = getelementptr inbounds i8, i8* %52, i64 -256
  store i8* %add.ptr34, i8** %limit, align 8, !tbaa !3
  br label %do.body35

do.body35:                                        ; preds = %do.cond42, %if.then33
  %53 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %acc36 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %53, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [8 x i64], [8 x i64]* %acc36, i32 0, i32 0
  %54 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %nbStripesSoFar38 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %54, i32 0, i32 6
  %55 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %nbStripesPerBlock39 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %55, i32 0, i32 5
  %56 = load i64, i64* %nbStripesPerBlock39, align 8, !tbaa !34
  %57 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %58 = load i8*, i8** %secret, align 8, !tbaa !3
  %59 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit40 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %59, i32 0, i32 7
  %60 = load i64, i64* %secretLimit40, align 8, !tbaa !33
  %61 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %62 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %63 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  call void @XXH3_consumeStripes(i64* %arraydecay37, i64* %nbStripesSoFar38, i64 %56, i8* %57, i64 4, i8* %58, i64 %60, i32 %61, void (i8*, i8*, i8*, i32)* %62, void (i8*, i8*)* %63)
  %64 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr41 = getelementptr inbounds i8, i8* %64, i64 256
  store i8* %add.ptr41, i8** %input.addr, align 8, !tbaa !3
  br label %do.cond42

do.cond42:                                        ; preds = %do.body35
  %65 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %66 = load i8*, i8** %limit, align 8, !tbaa !3
  %cmp43 = icmp ule i8* %65, %66
  br i1 %cmp43, label %do.body35, label %do.end45

do.end45:                                         ; preds = %do.cond42
  %67 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer46 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %67, i32 0, i32 2
  %arraydecay47 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer46, i32 0, i32 0
  %add.ptr48 = getelementptr inbounds i8, i8* %arraydecay47, i64 256
  %add.ptr49 = getelementptr inbounds i8, i8* %add.ptr48, i64 -64
  %68 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr50 = getelementptr inbounds i8, i8* %68, i64 -64
  %69 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer51 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %69, i32 0, i32 2
  %arraydecay52 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer51, i32 0, i32 0
  %add.ptr53 = getelementptr inbounds i8, i8* %arraydecay52, i64 256
  %add.ptr54 = getelementptr inbounds i8, i8* %add.ptr53, i64 -64
  %70 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr54, i1 false, i1 true)
  %call55 = call i8* @__memcpy_chk(i8* %add.ptr49, i8* %add.ptr50, i64 64, i64 %70) #10
  %71 = bitcast i8** %limit to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #10
  br label %if.end56

if.end56:                                         ; preds = %do.end45, %if.end29
  %72 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %73 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %cmp57 = icmp ult i8* %72, %73
  br i1 %cmp57, label %if.then59, label %if.end68

if.then59:                                        ; preds = %if.end56
  %74 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer60 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %74, i32 0, i32 2
  %arraydecay61 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer60, i32 0, i32 0
  %75 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %76 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %77 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %sub.ptr.lhs.cast = ptrtoint i8* %76 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %77 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call62 = call i8* @XXH_memcpy(i8* %arraydecay61, i8* %75, i64 %sub.ptr.sub)
  %78 = load i8*, i8** %bEnd, align 8, !tbaa !3
  %79 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %sub.ptr.lhs.cast63 = ptrtoint i8* %78 to i64
  %sub.ptr.rhs.cast64 = ptrtoint i8* %79 to i64
  %sub.ptr.sub65 = sub i64 %sub.ptr.lhs.cast63, %sub.ptr.rhs.cast64
  %conv66 = trunc i64 %sub.ptr.sub65 to i32
  %80 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize67 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %80, i32 0, i32 3
  store i32 %conv66, i32* %bufferedSize67, align 16, !tbaa !37
  br label %if.end68

if.end68:                                         ; preds = %if.then59, %if.end56
  store i32 0, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end68, %if.then6
  %81 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %81) #10
  %82 = bitcast i8** %bEnd to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %82) #10
  %cleanup.dest = load i32, i32* %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cleanup.cont, %cleanup, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_accumulate_512_sse2(i8* noalias %acc, i8* noalias %input, i8* noalias %secret, i32 %accWidth) #1 {
entry:
  %acc.addr = alloca i8*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %xacc = alloca <2 x i64>*, align 16
  %xinput = alloca <2 x i64>*, align 8
  %xsecret = alloca <2 x i64>*, align 8
  %i = alloca i64, align 8
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_lo = alloca <2 x i64>, align 16
  %tmp = alloca <2 x i64>, align 16
  %product = alloca <2 x i64>, align 16
  %data_swap = alloca <2 x i64>, align 16
  %tmp7 = alloca <2 x i64>, align 16
  %sum = alloca <2 x i64>, align 16
  %sum13 = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !11
  %0 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %acc.addr, align 8, !tbaa !3
  %2 = bitcast i8* %1 to <2 x i64>*
  store <2 x i64>* %2, <2 x i64>** %xacc, align 16, !tbaa !3
  %3 = bitcast <2 x i64>** %xinput to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64>* %5, <2 x i64>** %xinput, align 8, !tbaa !3
  %6 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #10
  %7 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %8 = bitcast i8* %7 to <2 x i64>*
  store <2 x i64>* %8, <2 x i64>** %xsecret, align 8, !tbaa !3
  %9 = bitcast i64* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #10
  store i64 0, i64* %i, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i64, i64* %i, align 8, !tbaa !7
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %11) #10
  %12 = load <2 x i64>*, <2 x i64>** %xinput, align 8, !tbaa !3
  %13 = load i64, i64* %i, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %12, i64 %13
  %call = call <2 x i64> @_mm_loadu_si128(<2 x i64>* %add.ptr)
  store <2 x i64> %call, <2 x i64>* %data_vec, align 16, !tbaa !11
  %14 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %14) #10
  %15 = load <2 x i64>*, <2 x i64>** %xsecret, align 8, !tbaa !3
  %16 = load i64, i64* %i, align 8, !tbaa !7
  %add.ptr1 = getelementptr inbounds <2 x i64>, <2 x i64>* %15, i64 %16
  %call2 = call <2 x i64> @_mm_loadu_si128(<2 x i64>* %add.ptr1)
  store <2 x i64> %call2, <2 x i64>* %key_vec, align 16, !tbaa !11
  %17 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %17) #10
  %18 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !11
  %19 = load <2 x i64>, <2 x i64>* %key_vec, align 16, !tbaa !11
  %call3 = call <2 x i64> @_mm_xor_si128(<2 x i64> %18, <2 x i64> %19)
  store <2 x i64> %call3, <2 x i64>* %data_key, align 16, !tbaa !11
  %20 = bitcast <2 x i64>* %data_key_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %20) #10
  %21 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !11
  %22 = bitcast <2 x i64> %21 to <4 x i32>
  %call4 = call <2 x i64> @_mm_undefined_si128()
  %23 = bitcast <2 x i64> %call4 to <4 x i32>
  %shuffle = shufflevector <4 x i32> %22, <4 x i32> %23, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %24 = bitcast <4 x i32> %shuffle to <2 x i64>
  store <2 x i64> %24, <2 x i64>* %tmp, align 16, !tbaa !11
  %25 = load <2 x i64>, <2 x i64>* %tmp, align 16, !tbaa !11
  store <2 x i64> %25, <2 x i64>* %data_key_lo, align 16, !tbaa !11
  %26 = bitcast <2 x i64>* %product to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %26) #10
  %27 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !11
  %28 = load <2 x i64>, <2 x i64>* %data_key_lo, align 16, !tbaa !11
  %call5 = call <2 x i64> @_mm_mul_epu32(<2 x i64> %27, <2 x i64> %28)
  store <2 x i64> %call5, <2 x i64>* %product, align 16, !tbaa !11
  %29 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %cmp6 = icmp eq i32 %29, 1
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %30 = bitcast <2 x i64>* %data_swap to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %30) #10
  %31 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !11
  %32 = bitcast <2 x i64> %31 to <4 x i32>
  %call8 = call <2 x i64> @_mm_undefined_si128()
  %33 = bitcast <2 x i64> %call8 to <4 x i32>
  %shuffle9 = shufflevector <4 x i32> %32, <4 x i32> %33, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %34 = bitcast <4 x i32> %shuffle9 to <2 x i64>
  store <2 x i64> %34, <2 x i64>* %tmp7, align 16, !tbaa !11
  %35 = load <2 x i64>, <2 x i64>* %tmp7, align 16, !tbaa !11
  store <2 x i64> %35, <2 x i64>* %data_swap, align 16, !tbaa !11
  %36 = bitcast <2 x i64>* %sum to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %36) #10
  %37 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !3
  %38 = load i64, i64* %i, align 8, !tbaa !7
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %37, i64 %38
  %39 = load <2 x i64>, <2 x i64>* %arrayidx, align 16, !tbaa !11
  %40 = load <2 x i64>, <2 x i64>* %data_swap, align 16, !tbaa !11
  %call10 = call <2 x i64> @_mm_add_epi64(<2 x i64> %39, <2 x i64> %40)
  store <2 x i64> %call10, <2 x i64>* %sum, align 16, !tbaa !11
  %41 = load <2 x i64>, <2 x i64>* %product, align 16, !tbaa !11
  %42 = load <2 x i64>, <2 x i64>* %sum, align 16, !tbaa !11
  %call11 = call <2 x i64> @_mm_add_epi64(<2 x i64> %41, <2 x i64> %42)
  %43 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !3
  %44 = load i64, i64* %i, align 8, !tbaa !7
  %arrayidx12 = getelementptr inbounds <2 x i64>, <2 x i64>* %43, i64 %44
  store <2 x i64> %call11, <2 x i64>* %arrayidx12, align 16, !tbaa !11
  %45 = bitcast <2 x i64>* %sum to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %45) #10
  %46 = bitcast <2 x i64>* %data_swap to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %46) #10
  br label %if.end

if.else:                                          ; preds = %for.body
  %47 = bitcast <2 x i64>* %sum13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %47) #10
  %48 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !3
  %49 = load i64, i64* %i, align 8, !tbaa !7
  %arrayidx14 = getelementptr inbounds <2 x i64>, <2 x i64>* %48, i64 %49
  %50 = load <2 x i64>, <2 x i64>* %arrayidx14, align 16, !tbaa !11
  %51 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !11
  %call15 = call <2 x i64> @_mm_add_epi64(<2 x i64> %50, <2 x i64> %51)
  store <2 x i64> %call15, <2 x i64>* %sum13, align 16, !tbaa !11
  %52 = load <2 x i64>, <2 x i64>* %product, align 16, !tbaa !11
  %53 = load <2 x i64>, <2 x i64>* %sum13, align 16, !tbaa !11
  %call16 = call <2 x i64> @_mm_add_epi64(<2 x i64> %52, <2 x i64> %53)
  %54 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !3
  %55 = load i64, i64* %i, align 8, !tbaa !7
  %arrayidx17 = getelementptr inbounds <2 x i64>, <2 x i64>* %54, i64 %55
  store <2 x i64> %call16, <2 x i64>* %arrayidx17, align 16, !tbaa !11
  %56 = bitcast <2 x i64>* %sum13 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %56) #10
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %57 = bitcast <2 x i64>* %product to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %57) #10
  %58 = bitcast <2 x i64>* %data_key_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %58) #10
  %59 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %59) #10
  %60 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %60) #10
  %61 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %61) #10
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %62 = load i64, i64* %i, align 8, !tbaa !7
  %inc = add i64 %62, 1
  store i64 %inc, i64* %i, align 8, !tbaa !7
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %63 = bitcast i64* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %63) #10
  %64 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %64) #10
  %65 = bitcast <2 x i64>** %xinput to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %65) #10
  %66 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %66) #10
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_scrambleAcc_sse2(i8* noalias %acc, i8* noalias %secret) #1 {
entry:
  %acc.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %xacc = alloca <2 x i64>*, align 16
  %xsecret = alloca <2 x i64>*, align 8
  %prime32 = alloca <2 x i64>, align 16
  %i = alloca i64, align 8
  %acc_vec = alloca <2 x i64>, align 16
  %shifted = alloca <2 x i64>, align 16
  %data_vec = alloca <2 x i64>, align 16
  %key_vec = alloca <2 x i64>, align 16
  %data_key = alloca <2 x i64>, align 16
  %data_key_hi = alloca <2 x i64>, align 16
  %tmp = alloca <2 x i64>, align 16
  %prod_lo = alloca <2 x i64>, align 16
  %prod_hi = alloca <2 x i64>, align 16
  store i8* %acc, i8** %acc.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  %0 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %acc.addr, align 8, !tbaa !3
  %2 = bitcast i8* %1 to <2 x i64>*
  store <2 x i64>* %2, <2 x i64>** %xacc, align 16, !tbaa !3
  %3 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64>* %5, <2 x i64>** %xsecret, align 8, !tbaa !3
  %6 = bitcast <2 x i64>* %prime32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %6) #10
  %call = call <2 x i64> @_mm_set1_epi32(i32 -1640531535)
  store <2 x i64> %call, <2 x i64>* %prime32, align 16, !tbaa !11
  %7 = bitcast i64* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #10
  store i64 0, i64* %i, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i64, i64* %i, align 8, !tbaa !7
  %cmp = icmp ult i64 %8, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = bitcast <2 x i64>* %acc_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %9) #10
  %10 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !3
  %11 = load i64, i64* %i, align 8, !tbaa !7
  %arrayidx = getelementptr inbounds <2 x i64>, <2 x i64>* %10, i64 %11
  %12 = load <2 x i64>, <2 x i64>* %arrayidx, align 16, !tbaa !11
  store <2 x i64> %12, <2 x i64>* %acc_vec, align 16, !tbaa !11
  %13 = bitcast <2 x i64>* %shifted to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %13) #10
  %14 = load <2 x i64>, <2 x i64>* %acc_vec, align 16, !tbaa !11
  %call1 = call <2 x i64> @_mm_srli_epi64(<2 x i64> %14, i32 47)
  store <2 x i64> %call1, <2 x i64>* %shifted, align 16, !tbaa !11
  %15 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %15) #10
  %16 = load <2 x i64>, <2 x i64>* %acc_vec, align 16, !tbaa !11
  %17 = load <2 x i64>, <2 x i64>* %shifted, align 16, !tbaa !11
  %call2 = call <2 x i64> @_mm_xor_si128(<2 x i64> %16, <2 x i64> %17)
  store <2 x i64> %call2, <2 x i64>* %data_vec, align 16, !tbaa !11
  %18 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %18) #10
  %19 = load <2 x i64>*, <2 x i64>** %xsecret, align 8, !tbaa !3
  %20 = load i64, i64* %i, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds <2 x i64>, <2 x i64>* %19, i64 %20
  %call3 = call <2 x i64> @_mm_loadu_si128(<2 x i64>* %add.ptr)
  store <2 x i64> %call3, <2 x i64>* %key_vec, align 16, !tbaa !11
  %21 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %21) #10
  %22 = load <2 x i64>, <2 x i64>* %data_vec, align 16, !tbaa !11
  %23 = load <2 x i64>, <2 x i64>* %key_vec, align 16, !tbaa !11
  %call4 = call <2 x i64> @_mm_xor_si128(<2 x i64> %22, <2 x i64> %23)
  store <2 x i64> %call4, <2 x i64>* %data_key, align 16, !tbaa !11
  %24 = bitcast <2 x i64>* %data_key_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %24) #10
  %25 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !11
  %26 = bitcast <2 x i64> %25 to <4 x i32>
  %call5 = call <2 x i64> @_mm_undefined_si128()
  %27 = bitcast <2 x i64> %call5 to <4 x i32>
  %shuffle = shufflevector <4 x i32> %26, <4 x i32> %27, <4 x i32> <i32 1, i32 0, i32 3, i32 0>
  %28 = bitcast <4 x i32> %shuffle to <2 x i64>
  store <2 x i64> %28, <2 x i64>* %tmp, align 16, !tbaa !11
  %29 = load <2 x i64>, <2 x i64>* %tmp, align 16, !tbaa !11
  store <2 x i64> %29, <2 x i64>* %data_key_hi, align 16, !tbaa !11
  %30 = bitcast <2 x i64>* %prod_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %30) #10
  %31 = load <2 x i64>, <2 x i64>* %data_key, align 16, !tbaa !11
  %32 = load <2 x i64>, <2 x i64>* %prime32, align 16, !tbaa !11
  %call6 = call <2 x i64> @_mm_mul_epu32(<2 x i64> %31, <2 x i64> %32)
  store <2 x i64> %call6, <2 x i64>* %prod_lo, align 16, !tbaa !11
  %33 = bitcast <2 x i64>* %prod_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %33) #10
  %34 = load <2 x i64>, <2 x i64>* %data_key_hi, align 16, !tbaa !11
  %35 = load <2 x i64>, <2 x i64>* %prime32, align 16, !tbaa !11
  %call7 = call <2 x i64> @_mm_mul_epu32(<2 x i64> %34, <2 x i64> %35)
  store <2 x i64> %call7, <2 x i64>* %prod_hi, align 16, !tbaa !11
  %36 = load <2 x i64>, <2 x i64>* %prod_lo, align 16, !tbaa !11
  %37 = load <2 x i64>, <2 x i64>* %prod_hi, align 16, !tbaa !11
  %call8 = call <2 x i64> @_mm_slli_epi64(<2 x i64> %37, i32 32)
  %call9 = call <2 x i64> @_mm_add_epi64(<2 x i64> %36, <2 x i64> %call8)
  %38 = load <2 x i64>*, <2 x i64>** %xacc, align 16, !tbaa !3
  %39 = load i64, i64* %i, align 8, !tbaa !7
  %arrayidx10 = getelementptr inbounds <2 x i64>, <2 x i64>* %38, i64 %39
  store <2 x i64> %call9, <2 x i64>* %arrayidx10, align 16, !tbaa !11
  %40 = bitcast <2 x i64>* %prod_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %40) #10
  %41 = bitcast <2 x i64>* %prod_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %41) #10
  %42 = bitcast <2 x i64>* %data_key_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %42) #10
  %43 = bitcast <2 x i64>* %data_key to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %43) #10
  %44 = bitcast <2 x i64>* %key_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %44) #10
  %45 = bitcast <2 x i64>* %data_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %45) #10
  %46 = bitcast <2 x i64>* %shifted to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %46) #10
  %47 = bitcast <2 x i64>* %acc_vec to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %47) #10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %48 = load i64, i64* %i, align 8, !tbaa !7
  %inc = add i64 %48, 1
  store i64 %inc, i64* %i, align 8, !tbaa !7
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %49 = bitcast i64* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #10
  %50 = bitcast <2 x i64>* %prime32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %50) #10
  %51 = bitcast <2 x i64>** %xsecret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %51) #10
  %52 = bitcast <2 x i64>** %xacc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %52) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 @XXH3_64bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca i64, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  %cleanup.dest.slot = alloca i32
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %0 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %1, i32 0, i32 11
  %2 = load i8*, i8** %extSecret, align 8, !tbaa !32
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %4, i32 0, i32 11
  %5 = load i8*, i8** %extSecret1, align 8, !tbaa !32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %5, %cond.false ]
  store i8* %cond, i8** %secret, align 8, !tbaa !3
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 8
  %7 = load i64, i64* %totalLen, align 16, !tbaa !36
  %cmp2 = icmp ugt i64 %7, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %8 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %8) #10
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %10 = load i8*, i8** %secret, align 8, !tbaa !3
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %9, i8* %10, i32 0)
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %11 = load i8*, i8** %secret, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 11
  %12 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %12, i32 0, i32 8
  %13 = load i64, i64* %totalLen5, align 16, !tbaa !36
  %mul = mul i64 %13, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  store i64 %call, i64* %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  %14 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %14) #10
  br label %cleanup

if.end:                                           ; preds = %cond.end
  %15 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %15, i32 0, i32 9
  %16 = load i64, i64* %seed, align 8, !tbaa !30
  %tobool = icmp ne i64 %16, 0
  br i1 %tobool, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %17 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %17, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen8 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 8
  %19 = load i64, i64* %totalLen8, align 16, !tbaa !36
  %20 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %seed9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %20, i32 0, i32 9
  %21 = load i64, i64* %seed9, align 8, !tbaa !30
  %call10 = call i64 @XXH3_64bits_withSeed(i8* %arraydecay7, i64 %19, i64 %21)
  store i64 %call10, i64* %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end11:                                         ; preds = %if.end
  %22 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer12 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %22, i32 0, i32 2
  %arraydecay13 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer12, i32 0, i32 0
  %23 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %23, i32 0, i32 8
  %24 = load i64, i64* %totalLen14, align 16, !tbaa !36
  %25 = load i8*, i8** %secret, align 8, !tbaa !3
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 7
  %27 = load i64, i64* %secretLimit, align 8, !tbaa !33
  %add = add i64 %27, 64
  %call15 = call i64 @XXH3_64bits_withSecret(i8* %arraydecay13, i64 %24, i8* %25, i64 %add)
  store i64 %call15, i64* %retval, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.then6, %if.then
  %28 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #10
  %29 = load i64, i64* %retval, align 8
  ret i64 %29
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_digest_long(i64* %acc, %struct.XXH3_state_s* %state, i8* %secret, i32 %accWidth) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %accWidth.addr = alloca i32, align 4
  %nbStripes = alloca i64, align 8
  %nbStripesSoFar = alloca i64, align 8
  %lastStripe = alloca [64 x i8], align 16
  %catchupSize = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !3
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !11
  %0 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %1 = bitcast i64* %0 to i8*
  %2 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %acc1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc1, i32 0, i32 0
  %3 = bitcast i64* %arraydecay to i8*
  %4 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %5 = bitcast i64* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* %3, i64 64, i64 %6) #10
  %7 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %7, i32 0, i32 3
  %8 = load i32, i32* %bufferedSize, align 16, !tbaa !37
  %cmp = icmp uge i32 %8, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #10
  %10 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize2 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %10, i32 0, i32 3
  %11 = load i32, i32* %bufferedSize2, align 16, !tbaa !37
  %div = udiv i32 %11, 64
  %conv = zext i32 %div to i64
  store i64 %conv, i64* %nbStripes, align 8, !tbaa !7
  %12 = bitcast i64* %nbStripesSoFar to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #10
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %nbStripesSoFar3 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 6
  %14 = load i64, i64* %nbStripesSoFar3, align 16, !tbaa !38
  store i64 %14, i64* %nbStripesSoFar, align 8, !tbaa !7
  %15 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %nbStripesPerBlock = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 5
  %17 = load i64, i64* %nbStripesPerBlock, align 8, !tbaa !34
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %19 = load i64, i64* %nbStripes, align 8, !tbaa !7
  %20 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %21 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %21, i32 0, i32 7
  %22 = load i64, i64* %secretLimit, align 8, !tbaa !33
  %23 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  call void @XXH3_consumeStripes(i64* %15, i64* %nbStripesSoFar, i64 %17, i8* %arraydecay4, i64 %19, i8* %20, i64 %22, i32 %23, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 3
  %25 = load i32, i32* %bufferedSize5, align 16, !tbaa !37
  %rem = urem i32 %25, 64
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %26 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %27 = bitcast i64* %26 to i8*
  %28 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer7 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %28, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer7, i32 0, i32 0
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize9 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 3
  %30 = load i32, i32* %bufferedSize9, align 16, !tbaa !37
  %idx.ext = zext i32 %30 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay8, i64 %idx.ext
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr, i64 -64
  %31 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %32 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %32, i32 0, i32 7
  %33 = load i64, i64* %secretLimit11, align 8, !tbaa !33
  %add.ptr12 = getelementptr inbounds i8, i8* %31, i64 %33
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -7
  %34 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  call void @XXH3_accumulate_512_sse2(i8* %27, i8* %add.ptr10, i8* %add.ptr13, i32 %34)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %35 = bitcast i64* %nbStripesSoFar to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %35) #10
  %36 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %36) #10
  br label %if.end39

if.else:                                          ; preds = %entry
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize14 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 3
  %38 = load i32, i32* %bufferedSize14, align 16, !tbaa !37
  %tobool15 = icmp ne i32 %38, 0
  br i1 %tobool15, label %if.then16, label %if.end38

if.then16:                                        ; preds = %if.else
  %39 = bitcast [64 x i8]* %lastStripe to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %39) #10
  %40 = bitcast i64* %catchupSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %40) #10
  %41 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %41, i32 0, i32 3
  %42 = load i32, i32* %bufferedSize17, align 16, !tbaa !37
  %sub = sub i32 64, %42
  %conv18 = zext i32 %sub to i64
  store i64 %conv18, i64* %catchupSize, align 8, !tbaa !7
  %arraydecay19 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %43 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %43, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay21, i64 256
  %44 = load i64, i64* %catchupSize, align 8, !tbaa !7
  %idx.neg = sub i64 0, %44
  %add.ptr23 = getelementptr inbounds i8, i8* %add.ptr22, i64 %idx.neg
  %45 = load i64, i64* %catchupSize, align 8, !tbaa !7
  %call24 = call i8* @__memcpy_chk(i8* %arraydecay19, i8* %add.ptr23, i64 %45, i64 64) #10
  %arraydecay25 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %46 = load i64, i64* %catchupSize, align 8, !tbaa !7
  %add.ptr26 = getelementptr inbounds i8, i8* %arraydecay25, i64 %46
  %47 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer27 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %47, i32 0, i32 2
  %arraydecay28 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer27, i32 0, i32 0
  %48 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %bufferedSize29 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %48, i32 0, i32 3
  %49 = load i32, i32* %bufferedSize29, align 16, !tbaa !37
  %conv30 = zext i32 %49 to i64
  %arraydecay31 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %50 = load i64, i64* %catchupSize, align 8, !tbaa !7
  %add.ptr32 = getelementptr inbounds i8, i8* %arraydecay31, i64 %50
  %51 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr32, i1 false, i1 true)
  %call33 = call i8* @__memcpy_chk(i8* %add.ptr26, i8* %arraydecay28, i64 %conv30, i64 %51) #10
  %52 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %53 = bitcast i64* %52 to i8*
  %arraydecay34 = getelementptr inbounds [64 x i8], [64 x i8]* %lastStripe, i32 0, i32 0
  %54 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %55 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit35 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %55, i32 0, i32 7
  %56 = load i64, i64* %secretLimit35, align 8, !tbaa !33
  %add.ptr36 = getelementptr inbounds i8, i8* %54, i64 %56
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr36, i64 -7
  %57 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  call void @XXH3_accumulate_512_sse2(i8* %53, i8* %arraydecay34, i8* %add.ptr37, i32 %57)
  %58 = bitcast i64* %catchupSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %58) #10
  %59 = bitcast [64 x i8]* %lastStripe to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %59) #10
  br label %if.end38

if.end38:                                         ; preds = %if.then16, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH3_mergeAccs(i64* noalias %acc, i8* noalias %secret, i64 %start) #0 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  %start.addr = alloca i64, align 8
  %result64 = alloca i64, align 8
  %i = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %start, i64* %start.addr, align 8, !tbaa !21
  %0 = bitcast i64* %result64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i64, i64* %start.addr, align 8, !tbaa !21
  store i64 %1, i64* %result64, align 8, !tbaa !21
  %2 = bitcast i64* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #10
  store i64 0, i64* %i, align 8, !tbaa !7
  store i64 0, i64* %i, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64, i64* %i, align 8, !tbaa !7
  %cmp = icmp ult i64 %3, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %5 = load i64, i64* %i, align 8, !tbaa !7
  %mul = mul i64 2, %5
  %add.ptr = getelementptr inbounds i64, i64* %4, i64 %mul
  %6 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %7 = load i64, i64* %i, align 8, !tbaa !7
  %mul1 = mul i64 16, %7
  %add.ptr2 = getelementptr inbounds i8, i8* %6, i64 %mul1
  %call = call i64 @XXH3_mix2Accs(i64* %add.ptr, i8* %add.ptr2)
  %8 = load i64, i64* %result64, align 8, !tbaa !21
  %add = add i64 %8, %call
  store i64 %add, i64* %result64, align 8, !tbaa !21
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, i64* %i, align 8, !tbaa !7
  %inc = add i64 %9, 1
  store i64 %inc, i64* %i, align 8, !tbaa !7
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load i64, i64* %result64, align 8, !tbaa !21
  %call3 = call i64 @XXH3_avalanche(i64 %10)
  %11 = bitcast i64* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #10
  %12 = bitcast i64* %result64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #10
  ret i64 %call3
}

; Function Attrs: nounwind ssp uwtable
define void @XXH3_generateSecret(i8* %secretBuffer, i8* %customSeed, i64 %customSeedSize) #0 {
entry:
  %secretBuffer.addr = alloca i8*, align 8
  %customSeed.addr = alloca i8*, align 8
  %customSeedSize.addr = alloca i64, align 8
  %segmentSize = alloca i64, align 8
  %nbSegments = alloca i64, align 8
  %scrambler = alloca %struct.XXH128_canonical_t, align 1
  %seeds = alloca [12 x i64], align 16
  %segnb = alloca i64, align 8
  %agg.tmp = alloca %struct.XXH128_hash_t, align 8
  %toFill = alloca i64, align 8
  %filled = alloca i64, align 8
  %segmentStart = alloca i64, align 8
  %segment = alloca %struct.XXH128_canonical_t, align 1
  %agg.tmp18 = alloca %struct.XXH128_hash_t, align 8
  store i8* %secretBuffer, i8** %secretBuffer.addr, align 8, !tbaa !3
  store i8* %customSeed, i8** %customSeed.addr, align 8, !tbaa !3
  store i64 %customSeedSize, i64* %customSeedSize.addr, align 8, !tbaa !7
  %0 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !7
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !3
  %2 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !3
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %1, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, i64 %3) #10
  br label %return

if.end:                                           ; preds = %entry
  %4 = bitcast i64* %segmentSize to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  store i64 16, i64* %segmentSize, align 8, !tbaa !7
  %5 = bitcast i64* %nbSegments to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #10
  store i64 12, i64* %nbSegments, align 8, !tbaa !7
  %6 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %6) #10
  %7 = bitcast [12 x i64]* %seeds to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* %7) #10
  %8 = bitcast i64* %segnb to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #10
  %9 = load i8*, i8** %customSeed.addr, align 8, !tbaa !3
  %10 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !7
  %call1 = call { i64, i64 } @XXH128(i8* %9, i64 %10, i64 0)
  %11 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = extractvalue { i64, i64 } %call1, 0
  store i64 %13, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = extractvalue { i64, i64 } %call1, 1
  store i64 %15, i64* %14, align 8
  %16 = bitcast %struct.XXH128_hash_t* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %scrambler, i64 %18, i64 %20)
  %21 = bitcast i64* %toFill to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) #10
  %22 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !7
  %cmp2 = icmp ugt i64 %22, 96
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %23 = load i64, i64* %customSeedSize.addr, align 8, !tbaa !7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 96, %cond.true ], [ %23, %cond.false ]
  store i64 %cond, i64* %toFill, align 8, !tbaa !7
  %24 = bitcast i64* %filled to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #10
  %25 = load i64, i64* %toFill, align 8, !tbaa !7
  store i64 %25, i64* %filled, align 8, !tbaa !7
  %arraydecay = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %26 = bitcast i64* %arraydecay to i8*
  %27 = load i8*, i8** %customSeed.addr, align 8, !tbaa !3
  %28 = load i64, i64* %toFill, align 8, !tbaa !7
  %call3 = call i8* @__memcpy_chk(i8* %26, i8* %27, i64 %28, i64 96) #10
  br label %while.cond

while.cond:                                       ; preds = %cond.end9, %cond.end
  %29 = load i64, i64* %filled, align 8, !tbaa !7
  %cmp4 = icmp ult i64 %29, 96
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %30 = load i64, i64* %filled, align 8, !tbaa !7
  %31 = load i64, i64* %filled, align 8, !tbaa !7
  %sub = sub i64 96, %31
  %cmp5 = icmp ugt i64 %30, %sub
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %while.body
  %32 = load i64, i64* %filled, align 8, !tbaa !7
  %sub7 = sub i64 96, %32
  br label %cond.end9

cond.false8:                                      ; preds = %while.body
  %33 = load i64, i64* %filled, align 8, !tbaa !7
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true6
  %cond10 = phi i64 [ %sub7, %cond.true6 ], [ %33, %cond.false8 ]
  store i64 %cond10, i64* %toFill, align 8, !tbaa !7
  %arraydecay11 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %34 = bitcast i64* %arraydecay11 to i8*
  %35 = load i64, i64* %filled, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %34, i64 %35
  %arraydecay12 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %36 = bitcast i64* %arraydecay12 to i8*
  %37 = load i64, i64* %toFill, align 8, !tbaa !7
  %arraydecay13 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %38 = bitcast i64* %arraydecay13 to i8*
  %39 = load i64, i64* %filled, align 8, !tbaa !7
  %add.ptr14 = getelementptr inbounds i8, i8* %38, i64 %39
  %40 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr14, i1 false, i1 true)
  %call15 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %36, i64 %37, i64 %40) #10
  %41 = load i64, i64* %toFill, align 8, !tbaa !7
  %42 = load i64, i64* %filled, align 8, !tbaa !7
  %add = add i64 %42, %41
  store i64 %add, i64* %filled, align 8, !tbaa !7
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %43 = bitcast i64* %filled to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #10
  %44 = bitcast i64* %toFill to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %44) #10
  %45 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !3
  %46 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %47 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !3
  %48 = call i64 @llvm.objectsize.i64.p0i8(i8* %47, i1 false, i1 true)
  %call16 = call i8* @__memcpy_chk(i8* %45, i8* %46, i64 16, i64 %48) #10
  store i64 1, i64* %segnb, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %49 = load i64, i64* %segnb, align 8, !tbaa !7
  %cmp17 = icmp ult i64 %49, 12
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %50 = bitcast i64* %segmentStart to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %50) #10
  %51 = load i64, i64* %segnb, align 8, !tbaa !7
  %mul = mul i64 %51, 16
  store i64 %mul, i64* %segmentStart, align 8, !tbaa !7
  %52 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %52) #10
  %53 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  %arraydecay19 = getelementptr inbounds [12 x i64], [12 x i64]* %seeds, i32 0, i32 0
  %54 = load i64, i64* %segnb, align 8, !tbaa !7
  %add.ptr20 = getelementptr inbounds i64, i64* %arraydecay19, i64 %54
  %55 = bitcast i64* %add.ptr20 to i8*
  %call21 = call i64 @XXH_readLE64(i8* %55)
  %56 = load i64, i64* %segnb, align 8, !tbaa !7
  %add22 = add i64 %call21, %56
  %call23 = call { i64, i64 } @XXH128(i8* %53, i64 16, i64 %add22)
  %57 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call23, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call23, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.XXH128_hash_t* %agg.tmp18 to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  call void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %segment, i64 %64, i64 %66)
  %67 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !3
  %68 = load i64, i64* %segmentStart, align 8, !tbaa !7
  %add.ptr24 = getelementptr inbounds i8, i8* %67, i64 %68
  %69 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  %70 = load i8*, i8** %secretBuffer.addr, align 8, !tbaa !3
  %71 = load i64, i64* %segmentStart, align 8, !tbaa !7
  %add.ptr25 = getelementptr inbounds i8, i8* %70, i64 %71
  %72 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr25, i1 false, i1 true)
  %call26 = call i8* @__memcpy_chk(i8* %add.ptr24, i8* %69, i64 16, i64 %72) #10
  %73 = bitcast %struct.XXH128_canonical_t* %segment to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %73) #10
  %74 = bitcast i64* %segmentStart to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %74) #10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %75 = load i64, i64* %segnb, align 8, !tbaa !7
  %inc = add i64 %75, 1
  store i64 %inc, i64* %segnb, align 8, !tbaa !7
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %76 = bitcast i64* %segnb to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %76) #10
  %77 = bitcast [12 x i64]* %seeds to i8*
  call void @llvm.lifetime.end.p0i8(i64 96, i8* %77) #10
  %78 = bitcast %struct.XXH128_canonical_t* %scrambler to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %78) #10
  %79 = bitcast i64* %nbSegments to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %79) #10
  %80 = bitcast i64* %segmentSize to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %80) #10
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @XXH128_canonicalFromHash(%struct.XXH128_canonical_t* %dst, i64 %hash.coerce0, i64 %hash.coerce1) #0 {
entry:
  %hash = alloca %struct.XXH128_hash_t, align 8
  %dst.addr = alloca %struct.XXH128_canonical_t*, align 8
  %0 = bitcast %struct.XXH128_hash_t* %hash to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %hash.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %hash.coerce1, i64* %2, align 8
  store %struct.XXH128_canonical_t* %dst, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !3
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %3 = load i64, i64* %high64, align 8, !tbaa !39
  %call = call i64 @XXH_swap64(i64 %3)
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  store i64 %call, i64* %high641, align 8, !tbaa !39
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %4 = load i64, i64* %low64, align 8, !tbaa !41
  %call2 = call i64 @XXH_swap64(i64 %4)
  %low643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  store i64 %call2, i64* %low643, align 8, !tbaa !41
  %5 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !3
  %6 = bitcast %struct.XXH128_canonical_t* %5 to i8*
  %high644 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 1
  %7 = bitcast i64* %high644 to i8*
  %8 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !3
  %9 = bitcast %struct.XXH128_canonical_t* %8 to i8*
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true)
  %call5 = call i8* @__memcpy_chk(i8* %6, i8* %7, i64 8, i64 %10) #10
  %11 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !3
  %12 = bitcast %struct.XXH128_canonical_t* %11 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 8
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %hash, i32 0, i32 0
  %13 = bitcast i64* %low646 to i8*
  %14 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %dst.addr, align 8, !tbaa !3
  %15 = bitcast %struct.XXH128_canonical_t* %14 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %15, i64 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr7, i1 false, i1 true)
  %call8 = call i8* @__memcpy_chk(i8* %add.ptr, i8* %13, i64 8, i64 %16) #10
  ret void
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH128(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call { i64, i64 } @XXH3_128bits_withSeed(i8* %0, i64 %1, i64 %2)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits(i8* %input, i64 %len) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSecret)
  %2 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_128bits_internal(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen, { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  %f_hl128.addr = alloca { i64, i64 } (i8*, i64, i64, i8*, i64)*, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  store { i64, i64 } (i8*, i64, i64, i8*, i64)* %f_hl128, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8, !tbaa !3
  %0 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %4 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call = call { i64, i64 } @XXH3_len_0to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp1 = icmp ule i64 %10, 128
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %12 = load i64, i64* %len.addr, align 8, !tbaa !7
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %14 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %15 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call3 = call { i64, i64 } @XXH3_len_17to128_128b(i8* %11, i64 %12, i8* %13, i64 %14, i64 %15)
  %16 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call3, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call3, 1
  store i64 %20, i64* %19, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %21 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp5 = icmp ule i64 %21, 240
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %22 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %23 = load i64, i64* %len.addr, align 8, !tbaa !7
  %24 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %25 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %26 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call7 = call { i64, i64 } @XXH3_len_129to240_128b(i8* %22, i64 %23, i8* %24, i64 %25, i64 %26)
  %27 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call7, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call7, 1
  store i64 %31, i64* %30, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %32 = load { i64, i64 } (i8*, i64, i64, i8*, i64)*, { i64, i64 } (i8*, i64, i64, i8*, i64)** %f_hl128.addr, align 8, !tbaa !3
  %33 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %34 = load i64, i64* %len.addr, align 8, !tbaa !7
  %35 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %36 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %37 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %call9 = call { i64, i64 } %32(i8* %33, i64 %34, i64 %35, i8* %36, i64 %37)
  %38 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = extractvalue { i64, i64 } %call9, 0
  store i64 %40, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = extractvalue { i64, i64 } %call9, 1
  store i64 %42, i64* %41, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then2, %if.then
  %43 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %44 = load { i64, i64 }, { i64, i64 }* %43, align 8
  ret { i64, i64 } %44
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %4 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits_withSecret(i8* %input, i64 %len, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 0, i8* %2, i64 %3, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_defaultSecret)
  %4 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = extractvalue { i64, i64 } %call, 0
  store i64 %6, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = extractvalue { i64, i64 } %call, 1
  store i64 %8, i64* %7, align 8
  %9 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_defaultSecret(i8* noalias %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %1 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %2 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %4 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %3, i64 %4, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits_withSeed(i8* %input, i64 %len, i64 %seed) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %1 = load i64, i64* %len.addr, align 8, !tbaa !7
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call { i64, i64 } @XXH3_128bits_internal(i8* %0, i64 %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, { i64, i64 } (i8*, i64, i64, i8*, i64)* @XXH3_hashLong_128b_withSeed)
  %3 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %9 = load { i64, i64 }, { i64, i64 }* %8, align 8
  ret { i64, i64 } %9
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed(i8* %input, i64 %len, i64 %seed64, i8* noalias %secret, i64 %secretLen) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLen.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLen, i64* %secretLen.addr, align 8, !tbaa !7
  %0 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %1 = load i64, i64* %secretLen.addr, align 8, !tbaa !7
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %4 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %call = call { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* %2, i64 %3, i64 %4, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2, void (i8*, i64)* @XXH3_initCustomSecret_sse2)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_reset(%struct.XXH3_state_s* %statePtr) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind ssp uwtable
define internal void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %statePtr, i64 %seed, i8* %secret, i64 %secretSize) #0 {
entry:
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %1 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  call void @XXH3_64bits_reset_internal(%struct.XXH3_state_s* %0, i64 %1, i8* %2, i64 %3)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_reset_withSecret(%struct.XXH3_state_s* %statePtr, i8* %secret, i64 %secretSize) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %3 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 0, i8* %2, i64 %3)
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %cmp1 = icmp eq i8* %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %cmp4 = icmp ult i64 %5, 136
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then2, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_reset_withSeed(%struct.XXH3_state_s* %statePtr, i64 %seed) #0 {
entry:
  %retval = alloca i32, align 4
  %statePtr.addr = alloca %struct.XXH3_state_s*, align 8
  %seed.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %statePtr, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %cmp = icmp eq %struct.XXH3_state_s* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %2 = load i64, i64* %seed.addr, align 8, !tbaa !21
  call void @XXH3_128bits_reset_internal(%struct.XXH3_state_s* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192)
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !21
  call void @XXH3_initCustomSecret_sse2(i8* %arraydecay, i64 %4)
  %5 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %statePtr.addr, align 8, !tbaa !3
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %5, i32 0, i32 11
  store i8* null, i8** %extSecret, align 8, !tbaa !32
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind ssp uwtable
define i32 @XXH3_128bits_update(%struct.XXH3_state_s* %state, i8* %input, i64 %len) #0 {
entry:
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  %0 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %call = call i32 @XXH3_update(%struct.XXH3_state_s* %0, i8* %1, i64 %2, i32 1, void (i8*, i8*, i8*, i32)* @XXH3_accumulate_512_sse2, void (i8*, i8*)* @XXH3_scrambleAcc_sse2)
  ret i32 %call
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH3_128bits_digest(%struct.XXH3_state_s* %state) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %state.addr = alloca %struct.XXH3_state_s*, align 8
  %secret = alloca i8*, align 8
  %acc = alloca [8 x i64], align 16
  %h128 = alloca %struct.XXH128_hash_t, align 8
  %cleanup.dest.slot = alloca i32
  store %struct.XXH3_state_s* %state, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %0 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %extSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %1, i32 0, i32 11
  %2 = load i8*, i8** %extSecret, align 8, !tbaa !32
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %customSecret = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %customSecret, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %extSecret1 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %4, i32 0, i32 11
  %5 = load i8*, i8** %extSecret1, align 8, !tbaa !32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %arraydecay, %cond.true ], [ %5, %cond.false ]
  store i8* %cond, i8** %secret, align 8, !tbaa !3
  %6 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %6, i32 0, i32 8
  %7 = load i64, i64* %totalLen, align 16, !tbaa !36
  %cmp2 = icmp ugt i64 %7, 240
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %8 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %8) #10
  %arraydecay3 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %10 = load i8*, i8** %secret, align 8, !tbaa !3
  call void @XXH3_digest_long(i64* %arraydecay3, %struct.XXH3_state_s* %9, i8* %10, i32 1)
  %11 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %11) #10
  %arraydecay4 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %12 = load i8*, i8** %secret, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 11
  %13 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen5 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %13, i32 0, i32 8
  %14 = load i64, i64* %totalLen5, align 16, !tbaa !36
  %mul = mul i64 %14, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay4, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call, i64* %low64, align 8, !tbaa !41
  %arraydecay6 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %15 = load i8*, i8** %secret, align 8, !tbaa !3
  %16 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %16, i32 0, i32 7
  %17 = load i64, i64* %secretLimit, align 8, !tbaa !33
  %add.ptr7 = getelementptr inbounds i8, i8* %15, i64 %17
  %add.ptr8 = getelementptr inbounds i8, i8* %add.ptr7, i64 64
  %add.ptr9 = getelementptr inbounds i8, i8* %add.ptr8, i64 -64
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -11
  %18 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen11 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %18, i32 0, i32 8
  %19 = load i64, i64* %totalLen11, align 16, !tbaa !36
  %mul12 = mul i64 %19, -4417276706812531889
  %neg = xor i64 %mul12, -1
  %call13 = call i64 @XXH3_mergeAccs(i64* %arraydecay6, i8* %add.ptr10, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %call13, i64* %high64, align 8, !tbaa !39
  %20 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %21 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 16, i32 8, i1 false), !tbaa.struct !42
  store i32 1, i32* %cleanup.dest.slot, align 4
  %22 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %22) #10
  %23 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %23) #10
  br label %cleanup

if.end:                                           ; preds = %cond.end
  %24 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %seed = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %24, i32 0, i32 9
  %25 = load i64, i64* %seed, align 8, !tbaa !30
  %tobool = icmp ne i64 %25, 0
  br i1 %tobool, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.end
  %26 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %26, i32 0, i32 2
  %arraydecay15 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer, i32 0, i32 0
  %27 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen16 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %27, i32 0, i32 8
  %28 = load i64, i64* %totalLen16, align 16, !tbaa !36
  %29 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %seed17 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %29, i32 0, i32 9
  %30 = load i64, i64* %seed17, align 8, !tbaa !30
  %call18 = call { i64, i64 } @XXH3_128bits_withSeed(i8* %arraydecay15, i64 %28, i64 %30)
  %31 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call18, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call18, 1
  store i64 %35, i64* %34, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end19:                                         ; preds = %if.end
  %36 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %buffer20 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %36, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [256 x i8], [256 x i8]* %buffer20, i32 0, i32 0
  %37 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %totalLen22 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %37, i32 0, i32 8
  %38 = load i64, i64* %totalLen22, align 16, !tbaa !36
  %39 = load i8*, i8** %secret, align 8, !tbaa !3
  %40 = load %struct.XXH3_state_s*, %struct.XXH3_state_s** %state.addr, align 8, !tbaa !3
  %secretLimit23 = getelementptr inbounds %struct.XXH3_state_s, %struct.XXH3_state_s* %40, i32 0, i32 7
  %41 = load i64, i64* %secretLimit23, align 8, !tbaa !33
  %add = add i64 %41, 64
  %call24 = call { i64, i64 } @XXH3_128bits_withSecret(i8* %arraydecay21, i64 %38, i8* %39, i64 %add)
  %42 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %call24, 0
  store i64 %44, i64* %43, align 8
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %call24, 1
  store i64 %46, i64* %45, align 8
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then14, %if.then
  %47 = bitcast i8** %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #10
  %48 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %49 = load { i64, i64 }, { i64, i64 }* %48, align 8
  ret { i64, i64 } %49
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: nounwind ssp uwtable
define i32 @XXH128_isEqual(i64 %h1.coerce0, i64 %h1.coerce1, i64 %h2.coerce0, i64 %h2.coerce1) #0 {
entry:
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %0 = bitcast %struct.XXH128_hash_t* %h1 to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %h1.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %h1.coerce1, i64* %2, align 8
  %3 = bitcast %struct.XXH128_hash_t* %h2 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %h2.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %h2.coerce1, i64* %5, align 8
  %6 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %7 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %call = call i32 @memcmp(i8* %6, i8* %7, i64 16)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i32 @memcmp(i8*, i8*, i64) #6

; Function Attrs: nounwind ssp uwtable
define i32 @XXH128_cmp(i8* %h128_1, i8* %h128_2) #0 {
entry:
  %retval = alloca i32, align 4
  %h128_1.addr = alloca i8*, align 8
  %h128_2.addr = alloca i8*, align 8
  %h1 = alloca %struct.XXH128_hash_t, align 8
  %h2 = alloca %struct.XXH128_hash_t, align 8
  %hcmp = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store i8* %h128_1, i8** %h128_1.addr, align 8, !tbaa !3
  store i8* %h128_2, i8** %h128_2.addr, align 8, !tbaa !3
  %0 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #10
  %1 = load i8*, i8** %h128_1.addr, align 8, !tbaa !3
  %2 = bitcast i8* %1 to %struct.XXH128_hash_t*
  %3 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  %4 = bitcast %struct.XXH128_hash_t* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 16, i32 8, i1 false), !tbaa.struct !42
  %5 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %5) #10
  %6 = load i8*, i8** %h128_2.addr, align 8, !tbaa !3
  %7 = bitcast i8* %6 to %struct.XXH128_hash_t*
  %8 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  %9 = bitcast %struct.XXH128_hash_t* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 16, i32 8, i1 false), !tbaa.struct !42
  %10 = bitcast i32* %hcmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %10) #10
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %11 = load i64, i64* %high64, align 8, !tbaa !39
  %high641 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %12 = load i64, i64* %high641, align 8, !tbaa !39
  %cmp = icmp ugt i64 %11, %12
  %conv = zext i1 %cmp to i32
  %high642 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 1
  %13 = load i64, i64* %high642, align 8, !tbaa !39
  %high643 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 1
  %14 = load i64, i64* %high643, align 8, !tbaa !39
  %cmp4 = icmp ugt i64 %13, %14
  %conv5 = zext i1 %cmp4 to i32
  %sub = sub nsw i32 %conv, %conv5
  store i32 %sub, i32* %hcmp, align 4, !tbaa !9
  %15 = load i32, i32* %hcmp, align 4, !tbaa !9
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load i32, i32* %hcmp, align 4, !tbaa !9
  store i32 %16, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %17 = load i64, i64* %low64, align 8, !tbaa !41
  %low646 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %18 = load i64, i64* %low646, align 8, !tbaa !41
  %cmp7 = icmp ugt i64 %17, %18
  %conv8 = zext i1 %cmp7 to i32
  %low649 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h2, i32 0, i32 0
  %19 = load i64, i64* %low649, align 8, !tbaa !41
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h1, i32 0, i32 0
  %20 = load i64, i64* %low6410, align 8, !tbaa !41
  %cmp11 = icmp ugt i64 %19, %20
  %conv12 = zext i1 %cmp11 to i32
  %sub13 = sub nsw i32 %conv8, %conv12
  store i32 %sub13, i32* %retval, align 4
  store i32 1, i32* %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %21 = bitcast i32* %hcmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %21) #10
  %22 = bitcast %struct.XXH128_hash_t* %h2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %22) #10
  %23 = bitcast %struct.XXH128_hash_t* %h1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %23) #10
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind ssp uwtable
define { i64, i64 } @XXH128_hashFromCanonical(%struct.XXH128_canonical_t* %src) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %src.addr = alloca %struct.XXH128_canonical_t*, align 8
  %h = alloca %struct.XXH128_hash_t, align 8
  store %struct.XXH128_canonical_t* %src, %struct.XXH128_canonical_t** %src.addr, align 8, !tbaa !3
  %0 = bitcast %struct.XXH128_hash_t* %h to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #10
  %1 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8, !tbaa !3
  %2 = bitcast %struct.XXH128_canonical_t* %1 to i8*
  %call = call i64 @XXH_readBE64(i8* %2)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h, i32 0, i32 1
  store i64 %call, i64* %high64, align 8, !tbaa !39
  %3 = load %struct.XXH128_canonical_t*, %struct.XXH128_canonical_t** %src.addr, align 8, !tbaa !3
  %digest = getelementptr inbounds %struct.XXH128_canonical_t, %struct.XXH128_canonical_t* %3, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %digest, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 8
  %call1 = call i64 @XXH_readBE64(i8* %add.ptr)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h, i32 0, i32 0
  store i64 %call1, i64* %low64, align 8, !tbaa !41
  %4 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %5 = bitcast %struct.XXH128_hash_t* %h to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 16, i32 8, i1 false), !tbaa.struct !42
  %6 = bitcast %struct.XXH128_hash_t* %h to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %6) #10
  %7 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i32 @XXH_readLE32_align(i8* %ptr, i32 %align) #1 {
entry:
  %retval = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  store i32 %align, i32* %align.addr, align 4, !tbaa !11
  %0 = load i32, i32* %align.addr, align 4, !tbaa !11
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %call = call i32 @XXH_readLE32(i8* %1)
  store i32 %call, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3, align 4, !tbaa !9
  store i32 %4, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

; Function Attrs: allocsize(0)
declare i8* @malloc(i64) #7

declare void @free(i8*) #6

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH_read32(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i32, align 4
  store i8* %memPtr, i8** %memPtr.addr, align 8, !tbaa !3
  %0 = bitcast i32* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #10
  %1 = bitcast i32* %val to i8*
  %2 = load i8*, i8** %memPtr.addr, align 8, !tbaa !3
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 4, i32 1, i1 false)
  %3 = load i32, i32* %val, align 4, !tbaa !9
  %4 = bitcast i32* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #10
  ret i32 %3
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @XXH32_avalanche(i32 %h32) #0 {
entry:
  %h32.addr = alloca i32, align 4
  store i32 %h32, i32* %h32.addr, align 4, !tbaa !9
  %0 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr = lshr i32 %0, 15
  %1 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %xor = xor i32 %1, %shr
  store i32 %xor, i32* %h32.addr, align 4, !tbaa !9
  %2 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %mul = mul i32 %2, -2048144777
  store i32 %mul, i32* %h32.addr, align 4, !tbaa !9
  %3 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr1 = lshr i32 %3, 13
  %4 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %xor2 = xor i32 %4, %shr1
  store i32 %xor2, i32* %h32.addr, align 4, !tbaa !9
  %5 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %mul3 = mul i32 %5, -1028477379
  store i32 %mul3, i32* %h32.addr, align 4, !tbaa !9
  %6 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %shr4 = lshr i32 %6, 16
  %7 = load i32, i32* %h32.addr, align 4, !tbaa !9
  %xor5 = xor i32 %7, %shr4
  store i32 %xor5, i32* %h32.addr, align 4, !tbaa !9
  %8 = load i32, i32* %h32.addr, align 4, !tbaa !9
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH_readLE64_align(i8* %ptr, i32 %align) #1 {
entry:
  %retval = alloca i64, align 8
  %ptr.addr = alloca i8*, align 8
  %align.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8, !tbaa !3
  store i32 %align, i32* %align.addr, align 4, !tbaa !11
  %0 = load i32, i32* %align.addr, align 4, !tbaa !11
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %call = call i64 @XXH_readLE64(i8* %1)
  store i64 %call, i64* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i8*, i8** %ptr.addr, align 8, !tbaa !3
  %3 = bitcast i8* %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !21
  store i64 %4, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i64, i64* %retval, align 8
  ret i64 %5
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH_read64(i8* %memPtr) #0 {
entry:
  %memPtr.addr = alloca i8*, align 8
  %val = alloca i64, align 8
  store i8* %memPtr, i8** %memPtr.addr, align 8, !tbaa !3
  %0 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = bitcast i64* %val to i8*
  %2 = load i8*, i8** %memPtr.addr, align 8, !tbaa !3
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 1, i1 false)
  %3 = load i64, i64* %val, align 8, !tbaa !21
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #10
  ret i64 %3
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH64_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8, !tbaa !21
  %0 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr = lshr i64 %0, 33
  %1 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor = xor i64 %1, %shr
  store i64 %xor, i64* %h64.addr, align 8, !tbaa !21
  %2 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %mul = mul i64 %2, -4417276706812531889
  store i64 %mul, i64* %h64.addr, align 8, !tbaa !21
  %3 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr1 = lshr i64 %3, 29
  %4 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor2 = xor i64 %4, %shr1
  store i64 %xor2, i64* %h64.addr, align 8, !tbaa !21
  %5 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %mul3 = mul i64 %5, 1609587929392839161
  store i64 %mul3, i64* %h64.addr, align 8, !tbaa !21
  %6 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %shr4 = lshr i64 %6, 32
  %7 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %xor5 = xor i64 %7, %shr4
  store i64 %xor5, i64* %h64.addr, align 8, !tbaa !21
  %8 = load i64, i64* %h64.addr, align 8, !tbaa !21
  ret i64 %8
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_0to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp ugt i64 %0, 8
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_len_9to16_64b(i8* %1, i64 %2, i8* %3, i64 %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp2 = icmp uge i64 %5, 4
  %conv3 = zext i1 %cmp2 to i32
  %conv4 = sext i32 %conv3 to i64
  %expval5 = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool6 = icmp ne i64 %expval5, 0
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %7 = load i64, i64* %len.addr, align 8, !tbaa !7
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %9 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call8 = call i64 @XXH3_len_4to8_64b(i8* %6, i64 %7, i8* %8, i64 %9)
  store i64 %call8, i64* %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  %10 = load i64, i64* %len.addr, align 8, !tbaa !7
  %tobool10 = icmp ne i64 %10, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end9
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %12 = load i64, i64* %len.addr, align 8, !tbaa !7
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call12 = call i64 @XXH3_len_1to3_64b(i8* %11, i64 %12, i8* %13, i64 %14)
  store i64 %call12, i64* %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end9
  %15 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 -7046029288634856825, %15
  %16 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 56
  %call14 = call i64 @XXH_readLE64(i8* %add.ptr)
  %17 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr15 = getelementptr inbounds i8, i8* %17, i64 64
  %call16 = call i64 @XXH_readLE64(i8* %add.ptr15)
  %xor = xor i64 %call14, %call16
  %xor17 = xor i64 %add, %xor
  %call18 = call i64 @XXH3_avalanche(i64 %xor17)
  store i64 %call18, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.then11, %if.then7, %if.then
  %18 = load i64, i64* %retval, align 8
  ret i64 %18
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_17to128_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %1 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul = mul i64 %2, -7046029288634856825
  store i64 %mul, i64* %acc, align 8, !tbaa !21
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp ugt i64 %3, 32
  br i1 %cmp, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp1 = icmp ugt i64 %4, 64
  br i1 %cmp1, label %if.then2, label %if.end20

if.then2:                                         ; preds = %if.then
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp3 = icmp ugt i64 %5, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 48
  %7 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr5 = getelementptr inbounds i8, i8* %7, i64 96
  %8 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %8)
  %9 = load i64, i64* %acc, align 8, !tbaa !21
  %add = add i64 %9, %call
  store i64 %add, i64* %acc, align 8, !tbaa !21
  %10 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %11 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr6 = getelementptr inbounds i8, i8* %10, i64 %11
  %add.ptr7 = getelementptr inbounds i8, i8* %add.ptr6, i64 -64
  %12 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr8 = getelementptr inbounds i8, i8* %12, i64 112
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call9 = call i64 @XXH3_mix16B(i8* %add.ptr7, i8* %add.ptr8, i64 %13)
  %14 = load i64, i64* %acc, align 8, !tbaa !21
  %add10 = add i64 %14, %call9
  store i64 %add10, i64* %acc, align 8, !tbaa !21
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %15 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr11 = getelementptr inbounds i8, i8* %15, i64 32
  %16 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr12 = getelementptr inbounds i8, i8* %16, i64 64
  %17 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call13 = call i64 @XXH3_mix16B(i8* %add.ptr11, i8* %add.ptr12, i64 %17)
  %18 = load i64, i64* %acc, align 8, !tbaa !21
  %add14 = add i64 %18, %call13
  store i64 %add14, i64* %acc, align 8, !tbaa !21
  %19 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %20 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr15 = getelementptr inbounds i8, i8* %19, i64 %20
  %add.ptr16 = getelementptr inbounds i8, i8* %add.ptr15, i64 -48
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr17 = getelementptr inbounds i8, i8* %21, i64 80
  %22 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr16, i8* %add.ptr17, i64 %22)
  %23 = load i64, i64* %acc, align 8, !tbaa !21
  %add19 = add i64 %23, %call18
  store i64 %add19, i64* %acc, align 8, !tbaa !21
  br label %if.end20

if.end20:                                         ; preds = %if.end, %if.then
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr21 = getelementptr inbounds i8, i8* %24, i64 16
  %25 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr22 = getelementptr inbounds i8, i8* %25, i64 32
  %26 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call23 = call i64 @XXH3_mix16B(i8* %add.ptr21, i8* %add.ptr22, i64 %26)
  %27 = load i64, i64* %acc, align 8, !tbaa !21
  %add24 = add i64 %27, %call23
  store i64 %add24, i64* %acc, align 8, !tbaa !21
  %28 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %29 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr25 = getelementptr inbounds i8, i8* %28, i64 %29
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -32
  %30 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr27 = getelementptr inbounds i8, i8* %30, i64 48
  %31 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call28 = call i64 @XXH3_mix16B(i8* %add.ptr26, i8* %add.ptr27, i64 %31)
  %32 = load i64, i64* %acc, align 8, !tbaa !21
  %add29 = add i64 %32, %call28
  store i64 %add29, i64* %acc, align 8, !tbaa !21
  br label %if.end30

if.end30:                                         ; preds = %if.end20, %entry
  %33 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr31 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr32 = getelementptr inbounds i8, i8* %34, i64 0
  %35 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call33 = call i64 @XXH3_mix16B(i8* %add.ptr31, i8* %add.ptr32, i64 %35)
  %36 = load i64, i64* %acc, align 8, !tbaa !21
  %add34 = add i64 %36, %call33
  store i64 %add34, i64* %acc, align 8, !tbaa !21
  %37 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %38 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr35 = getelementptr inbounds i8, i8* %37, i64 %38
  %add.ptr36 = getelementptr inbounds i8, i8* %add.ptr35, i64 -16
  %39 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr37 = getelementptr inbounds i8, i8* %39, i64 16
  %40 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call38 = call i64 @XXH3_mix16B(i8* %add.ptr36, i8* %add.ptr37, i64 %40)
  %41 = load i64, i64* %acc, align 8, !tbaa !21
  %add39 = add i64 %41, %call38
  store i64 %add39, i64* %acc, align 8, !tbaa !21
  %42 = load i64, i64* %acc, align 8, !tbaa !21
  %call40 = call i64 @XXH3_avalanche(i64 %42)
  %43 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #10
  ret i64 %call40
}

; Function Attrs: noinline nounwind ssp uwtable
define internal i64 @XXH3_len_129to240_64b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #5 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca i64, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %1 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #10
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul = mul i64 %2, -7046029288634856825
  store i64 %mul, i64* %acc, align 8, !tbaa !21
  %3 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #10
  %4 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv = trunc i64 %4 to i32
  %div = sdiv i32 %conv, 16
  store i32 %div, i32* %nbRounds, align 4, !tbaa !9
  %5 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #10
  store i32 0, i32* %i, align 4, !tbaa !9
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4, !tbaa !9
  %cmp = icmp slt i32 %6, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %8 = load i32, i32* %i, align 4, !tbaa !9
  %mul2 = mul nsw i32 16, %8
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %idx.ext
  %9 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %10 = load i32, i32* %i, align 4, !tbaa !9
  %mul3 = mul nsw i32 16, %10
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %9, i64 %idx.ext4
  %11 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_mix16B(i8* %add.ptr, i8* %add.ptr5, i64 %11)
  %12 = load i64, i64* %acc, align 8, !tbaa !21
  %add = add i64 %12, %call
  store i64 %add, i64* %acc, align 8, !tbaa !21
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, i32* %i, align 4, !tbaa !9
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4, !tbaa !9
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i64, i64* %acc, align 8, !tbaa !21
  %call6 = call i64 @XXH3_avalanche(i64 %14)
  store i64 %call6, i64* %acc, align 8, !tbaa !21
  store i32 8, i32* %i, align 4, !tbaa !9
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc20, %for.end
  %15 = load i32, i32* %i, align 4, !tbaa !9
  %16 = load i32, i32* %nbRounds, align 4, !tbaa !9
  %cmp8 = icmp slt i32 %15, %16
  br i1 %cmp8, label %for.body10, label %for.end22

for.body10:                                       ; preds = %for.cond7
  %17 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %18 = load i32, i32* %i, align 4, !tbaa !9
  %mul11 = mul nsw i32 16, %18
  %idx.ext12 = sext i32 %mul11 to i64
  %add.ptr13 = getelementptr inbounds i8, i8* %17, i64 %idx.ext12
  %19 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %20 = load i32, i32* %i, align 4, !tbaa !9
  %sub = sub nsw i32 %20, 8
  %mul14 = mul nsw i32 16, %sub
  %idx.ext15 = sext i32 %mul14 to i64
  %add.ptr16 = getelementptr inbounds i8, i8* %19, i64 %idx.ext15
  %add.ptr17 = getelementptr inbounds i8, i8* %add.ptr16, i64 3
  %21 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call18 = call i64 @XXH3_mix16B(i8* %add.ptr13, i8* %add.ptr17, i64 %21)
  %22 = load i64, i64* %acc, align 8, !tbaa !21
  %add19 = add i64 %22, %call18
  store i64 %add19, i64* %acc, align 8, !tbaa !21
  br label %for.inc20

for.inc20:                                        ; preds = %for.body10
  %23 = load i32, i32* %i, align 4, !tbaa !9
  %inc21 = add nsw i32 %23, 1
  store i32 %inc21, i32* %i, align 4, !tbaa !9
  br label %for.cond7

for.end22:                                        ; preds = %for.cond7
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %25 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr23 = getelementptr inbounds i8, i8* %24, i64 %25
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr23, i64 -16
  %26 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr25 = getelementptr inbounds i8, i8* %26, i64 136
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 -17
  %27 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call27 = call i64 @XXH3_mix16B(i8* %add.ptr24, i8* %add.ptr26, i64 %27)
  %28 = load i64, i64* %acc, align 8, !tbaa !21
  %add28 = add i64 %28, %call27
  store i64 %add28, i64* %acc, align 8, !tbaa !21
  %29 = load i64, i64* %acc, align 8, !tbaa !21
  %call29 = call i64 @XXH3_avalanche(i64 %29)
  %30 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #10
  %31 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #10
  %32 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #10
  ret i64 %call29
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #8

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_9to16_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflip1 = alloca i64, align 8
  %bitflip2 = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %acc = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = bitcast i64* %bitflip1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 24
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 32
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %3 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 %xor, %3
  store i64 %add, i64* %bitflip1, align 8, !tbaa !21
  %4 = bitcast i64* %bitflip2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr3 = getelementptr inbounds i8, i8* %5, i64 40
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %6 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 48
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %7 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 %xor7, %7
  store i64 %sub, i64* %bitflip2, align 8, !tbaa !21
  %8 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #10
  %9 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %call8 = call i64 @XXH_readLE64(i8* %9)
  %10 = load i64, i64* %bitflip1, align 8, !tbaa !21
  %xor9 = xor i64 %call8, %10
  store i64 %xor9, i64* %input_lo, align 8, !tbaa !21
  %11 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #10
  %12 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %13 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr10 = getelementptr inbounds i8, i8* %12, i64 %13
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -8
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %14 = load i64, i64* %bitflip2, align 8, !tbaa !21
  %xor13 = xor i64 %call12, %14
  store i64 %xor13, i64* %input_hi, align 8, !tbaa !21
  %15 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %15) #10
  %16 = load i64, i64* %len.addr, align 8, !tbaa !7
  %17 = load i64, i64* %input_lo, align 8, !tbaa !21
  %call14 = call i64 @XXH_swap64(i64 %17)
  %add15 = add i64 %16, %call14
  %18 = load i64, i64* %input_hi, align 8, !tbaa !21
  %add16 = add i64 %add15, %18
  %19 = load i64, i64* %input_lo, align 8, !tbaa !21
  %20 = load i64, i64* %input_hi, align 8, !tbaa !21
  %call17 = call i64 @XXH3_mul128_fold64(i64 %19, i64 %20)
  %add18 = add i64 %add16, %call17
  store i64 %add18, i64* %acc, align 8, !tbaa !21
  %21 = load i64, i64* %acc, align 8, !tbaa !21
  %call19 = call i64 @XXH3_avalanche(i64 %21)
  %22 = bitcast i64* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #10
  %23 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #10
  %24 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #10
  %25 = bitcast i64* %bitflip2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %25) #10
  %26 = bitcast i64* %bitflip1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %26) #10
  ret i64 %call19
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_4to8_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input1 = alloca i32, align 4
  %input2 = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %input64 = alloca i64, align 8
  %x = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8, !tbaa !21
  %2 = bitcast i32* %input1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #10
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %call2 = call i32 @XXH_readLE32(i8* %3)
  store i32 %call2, i32* %input1, align 4, !tbaa !9
  %4 = bitcast i32* %input2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #10
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %6 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 %6
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input2, align 4, !tbaa !9
  %7 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #10
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr5 = getelementptr inbounds i8, i8* %8, i64 8
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %9 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr7 = getelementptr inbounds i8, i8* %9, i64 16
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr7)
  %xor9 = xor i64 %call6, %call8
  %10 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 %xor9, %10
  store i64 %sub, i64* %bitflip, align 8, !tbaa !21
  %11 = bitcast i64* %input64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #10
  %12 = load i32, i32* %input2, align 4, !tbaa !9
  %conv10 = zext i32 %12 to i64
  %13 = load i32, i32* %input1, align 4, !tbaa !9
  %conv11 = zext i32 %13 to i64
  %shl12 = shl i64 %conv11, 32
  %add = add i64 %conv10, %shl12
  store i64 %add, i64* %input64, align 8, !tbaa !21
  %14 = bitcast i64* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #10
  %15 = load i64, i64* %input64, align 8, !tbaa !21
  %16 = load i64, i64* %bitflip, align 8, !tbaa !21
  %xor13 = xor i64 %15, %16
  store i64 %xor13, i64* %x, align 8, !tbaa !21
  %17 = load i64, i64* %x, align 8, !tbaa !21
  %shl14 = shl i64 %17, 49
  %18 = load i64, i64* %x, align 8, !tbaa !21
  %shr = lshr i64 %18, 15
  %or = or i64 %shl14, %shr
  %19 = load i64, i64* %x, align 8, !tbaa !21
  %shl15 = shl i64 %19, 24
  %20 = load i64, i64* %x, align 8, !tbaa !21
  %shr16 = lshr i64 %20, 40
  %or17 = or i64 %shl15, %shr16
  %xor18 = xor i64 %or, %or17
  %21 = load i64, i64* %x, align 8, !tbaa !21
  %xor19 = xor i64 %21, %xor18
  store i64 %xor19, i64* %x, align 8, !tbaa !21
  %22 = load i64, i64* %x, align 8, !tbaa !21
  %mul = mul i64 %22, -6939452855193903323
  store i64 %mul, i64* %x, align 8, !tbaa !21
  %23 = load i64, i64* %x, align 8, !tbaa !21
  %shr20 = lshr i64 %23, 35
  %24 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add21 = add i64 %shr20, %24
  %25 = load i64, i64* %x, align 8, !tbaa !21
  %xor22 = xor i64 %25, %add21
  store i64 %xor22, i64* %x, align 8, !tbaa !21
  %26 = load i64, i64* %x, align 8, !tbaa !21
  %mul23 = mul i64 %26, -6939452855193903323
  store i64 %mul23, i64* %x, align 8, !tbaa !21
  %27 = load i64, i64* %x, align 8, !tbaa !21
  %call24 = call i64 @XXH_xorshift64(i64 %27, i32 28)
  %28 = bitcast i64* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #10
  %29 = bitcast i64* %input64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %29) #10
  %30 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) #10
  %31 = bitcast i32* %input2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #10
  %32 = bitcast i32* %input1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #10
  ret i64 %call24
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_len_1to3_64b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combined = alloca i32, align 4
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  %mixed = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c1) #10
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !11
  store i8 %1, i8* %c1, align 1, !tbaa !11
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c2) #10
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1, !tbaa !11
  store i8 %4, i8* %c2, align 1, !tbaa !11
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c3) #10
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %6 = load i64, i64* %len.addr, align 8, !tbaa !7
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1, !tbaa !11
  store i8 %7, i8* %c3, align 1, !tbaa !11
  %8 = bitcast i32* %combined to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #10
  %9 = load i8, i8* %c1, align 1, !tbaa !11
  %conv = zext i8 %9 to i32
  %shl = shl i32 %conv, 16
  %10 = load i8, i8* %c2, align 1, !tbaa !11
  %conv3 = zext i8 %10 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %11 = load i8, i8* %c3, align 1, !tbaa !11
  %conv5 = zext i8 %11 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %12 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv8 = trunc i64 %12 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combined, align 4, !tbaa !9
  %13 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #10
  %14 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %call = call i32 @XXH_readLE32(i8* %14)
  %15 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 4
  %call11 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call, %call11
  %conv12 = zext i32 %xor to i64
  %16 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 %conv12, %16
  store i64 %add, i64* %bitflip, align 8, !tbaa !21
  %17 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #10
  %18 = load i32, i32* %combined, align 4, !tbaa !9
  %conv13 = zext i32 %18 to i64
  %19 = load i64, i64* %bitflip, align 8, !tbaa !21
  %xor14 = xor i64 %conv13, %19
  store i64 %xor14, i64* %keyed, align 8, !tbaa !21
  %20 = bitcast i64* %mixed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #10
  %21 = load i64, i64* %keyed, align 8, !tbaa !21
  %mul = mul i64 %21, -7046029288634856825
  store i64 %mul, i64* %mixed, align 8, !tbaa !21
  %22 = load i64, i64* %mixed, align 8, !tbaa !21
  %call15 = call i64 @XXH3_avalanche(i64 %22)
  %23 = bitcast i64* %mixed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #10
  %24 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #10
  %25 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %25) #10
  %26 = bitcast i32* %combined to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c3) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c2) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c1) #10
  ret i64 %call15
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH3_avalanche(i64 %h64) #0 {
entry:
  %h64.addr = alloca i64, align 8
  store i64 %h64, i64* %h64.addr, align 8, !tbaa !21
  %0 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call = call i64 @XXH_xorshift64(i64 %0, i32 37)
  store i64 %call, i64* %h64.addr, align 8, !tbaa !21
  %1 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %mul = mul i64 %1, 1609587791953885689
  store i64 %mul, i64* %h64.addr, align 8, !tbaa !21
  %2 = load i64, i64* %h64.addr, align 8, !tbaa !21
  %call1 = call i64 @XXH_xorshift64(i64 %2, i32 32)
  store i64 %call1, i64* %h64.addr, align 8, !tbaa !21
  %3 = load i64, i64* %h64.addr, align 8, !tbaa !21
  ret i64 %3
}

; Function Attrs: nounwind ssp uwtable
define internal i64 @XXH3_mul128_fold64(i64 %lhs, i64 %rhs) #0 {
entry:
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca %struct.XXH128_hash_t, align 8
  store i64 %lhs, i64* %lhs.addr, align 8, !tbaa !21
  store i64 %rhs, i64* %rhs.addr, align 8, !tbaa !21
  %0 = bitcast %struct.XXH128_hash_t* %product to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #10
  %1 = load i64, i64* %lhs.addr, align 8, !tbaa !21
  %2 = load i64, i64* %rhs.addr, align 8, !tbaa !21
  %call = call { i64, i64 } @XXH_mult64to128(i64 %1, i64 %2)
  %3 = bitcast %struct.XXH128_hash_t* %product to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 0
  %8 = load i64, i64* %low64, align 8, !tbaa !41
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %product, i32 0, i32 1
  %9 = load i64, i64* %high64, align 8, !tbaa !39
  %xor = xor i64 %8, %9
  %10 = bitcast %struct.XXH128_hash_t* %product to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #10
  ret i64 %xor
}

; Function Attrs: nounwind ssp uwtable
define internal { i64, i64 } @XXH_mult64to128(i64 %lhs, i64 %rhs) #0 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %lhs.addr = alloca i64, align 8
  %rhs.addr = alloca i64, align 8
  %product = alloca i128, align 16
  %r128 = alloca %struct.XXH128_hash_t, align 8
  store i64 %lhs, i64* %lhs.addr, align 8, !tbaa !21
  store i64 %rhs, i64* %rhs.addr, align 8, !tbaa !21
  %0 = bitcast i128* %product to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #10
  %1 = load i64, i64* %lhs.addr, align 8, !tbaa !21
  %conv = zext i64 %1 to i128
  %2 = load i64, i64* %rhs.addr, align 8, !tbaa !21
  %conv1 = zext i64 %2 to i128
  %mul = mul i128 %conv, %conv1
  store i128 %mul, i128* %product, align 16, !tbaa !43
  %3 = bitcast %struct.XXH128_hash_t* %r128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %3) #10
  %4 = load i128, i128* %product, align 16, !tbaa !43
  %conv2 = trunc i128 %4 to i64
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %r128, i32 0, i32 0
  store i64 %conv2, i64* %low64, align 8, !tbaa !41
  %5 = load i128, i128* %product, align 16, !tbaa !43
  %shr = lshr i128 %5, 64
  %conv3 = trunc i128 %shr to i64
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %r128, i32 0, i32 1
  store i64 %conv3, i64* %high64, align 8, !tbaa !39
  %6 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %7 = bitcast %struct.XXH128_hash_t* %r128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 16, i32 8, i1 false), !tbaa.struct !42
  %8 = bitcast %struct.XXH128_hash_t* %r128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %8) #10
  %9 = bitcast i128* %product to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %9) #10
  %10 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %11 = load { i64, i64 }, { i64, i64 }* %10, align 8
  ret { i64, i64 } %11
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH_xorshift64(i64 %v64, i32 %shift) #1 {
entry:
  %v64.addr = alloca i64, align 8
  %shift.addr = alloca i32, align 4
  store i64 %v64, i64* %v64.addr, align 8, !tbaa !21
  store i32 %shift, i32* %shift.addr, align 4, !tbaa !9
  %0 = load i64, i64* %v64.addr, align 8, !tbaa !21
  %1 = load i64, i64* %v64.addr, align 8, !tbaa !21
  %2 = load i32, i32* %shift.addr, align 4, !tbaa !9
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %1, %sh_prom
  %xor = xor i64 %0, %shr
  ret i64 %xor
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_mix16B(i8* noalias %input, i8* noalias %secret, i64 %seed64) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed64.addr = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  %0 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %call = call i64 @XXH_readLE64(i8* %1)
  store i64 %call, i64* %input_lo, align 8, !tbaa !21
  %2 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #10
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 8
  %call1 = call i64 @XXH_readLE64(i8* %add.ptr)
  store i64 %call1, i64* %input_hi, align 8, !tbaa !21
  %4 = load i64, i64* %input_lo, align 8, !tbaa !21
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %call2 = call i64 @XXH_readLE64(i8* %5)
  %6 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %add = add i64 %call2, %6
  %xor = xor i64 %4, %add
  %7 = load i64, i64* %input_hi, align 8, !tbaa !21
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr3 = getelementptr inbounds i8, i8* %8, i64 8
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %9 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %sub = sub i64 %call4, %9
  %xor5 = xor i64 %7, %sub
  %call6 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor5)
  %10 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #10
  %11 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #10
  ret i64 %call6
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #10
  %1 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ([8 x i64]* @XXH3_hashLong_64b_internal.acc to i8*), i64 64, i32 16, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %6 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %7 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %2, i64 %3, i8* %4, i64 %5, i32 0, void (i8*, i8*, i8*, i32)* %6, void (i8*, i8*)* %7)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %8 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 11
  %9 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul = mul i64 %9, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  %10 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %10) #10
  ret i64 %call
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_hashLong_internal_loop(i64* noalias %acc, i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nb_rounds = alloca i64, align 8
  %block_len = alloca i64, align 8
  %nb_blocks = alloca i64, align 8
  %n = alloca i64, align 8
  %nbStripes = alloca i64, align 8
  %p = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !11
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %0 = bitcast i64* %nb_rounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %sub = sub i64 %1, 64
  %div = udiv i64 %sub, 8
  store i64 %div, i64* %nb_rounds, align 8, !tbaa !7
  %2 = bitcast i64* %block_len to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #10
  %3 = load i64, i64* %nb_rounds, align 8, !tbaa !7
  %mul = mul i64 64, %3
  store i64 %mul, i64* %block_len, align 8, !tbaa !7
  %4 = bitcast i64* %nb_blocks to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %6 = load i64, i64* %block_len, align 8, !tbaa !7
  %div1 = udiv i64 %5, %6
  store i64 %div1, i64* %nb_blocks, align 8, !tbaa !7
  %7 = bitcast i64* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #10
  store i64 0, i64* %n, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i64, i64* %n, align 8, !tbaa !7
  %9 = load i64, i64* %nb_blocks, align 8, !tbaa !7
  %cmp = icmp ult i64 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %12 = load i64, i64* %n, align 8, !tbaa !7
  %13 = load i64, i64* %block_len, align 8, !tbaa !7
  %mul2 = mul i64 %12, %13
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 %mul2
  %14 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %15 = load i64, i64* %nb_rounds, align 8, !tbaa !7
  %16 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %17 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  call void @XXH3_accumulate(i64* %10, i8* %add.ptr, i8* %14, i64 %15, i32 %16, void (i8*, i8*, i8*, i32)* %17)
  %18 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %19 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %20 = bitcast i64* %19 to i8*
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %22 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %add.ptr3 = getelementptr inbounds i8, i8* %21, i64 %22
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  call void %18(i8* %20, i8* %add.ptr4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i64, i64* %n, align 8, !tbaa !7
  %inc = add i64 %23, 1
  store i64 %inc, i64* %n, align 8, !tbaa !7
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %24 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #10
  %25 = load i64, i64* %len.addr, align 8, !tbaa !7
  %26 = load i64, i64* %block_len, align 8, !tbaa !7
  %27 = load i64, i64* %nb_blocks, align 8, !tbaa !7
  %mul5 = mul i64 %26, %27
  %sub6 = sub i64 %25, %mul5
  %div7 = udiv i64 %sub6, 64
  store i64 %div7, i64* %nbStripes, align 8, !tbaa !7
  %28 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %29 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %30 = load i64, i64* %nb_blocks, align 8, !tbaa !7
  %31 = load i64, i64* %block_len, align 8, !tbaa !7
  %mul8 = mul i64 %30, %31
  %add.ptr9 = getelementptr inbounds i8, i8* %29, i64 %mul8
  %32 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %33 = load i64, i64* %nbStripes, align 8, !tbaa !7
  %34 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %35 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  call void @XXH3_accumulate(i64* %28, i8* %add.ptr9, i8* %32, i64 %33, i32 %34, void (i8*, i8*, i8*, i32)* %35)
  %36 = load i64, i64* %len.addr, align 8, !tbaa !7
  %and = and i64 %36, 63
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %37 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %37) #10
  %38 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %39 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr10 = getelementptr inbounds i8, i8* %38, i64 %39
  %add.ptr11 = getelementptr inbounds i8, i8* %add.ptr10, i64 -64
  store i8* %add.ptr11, i8** %p, align 8, !tbaa !3
  %40 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %41 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %42 = bitcast i64* %41 to i8*
  %43 = load i8*, i8** %p, align 8, !tbaa !3
  %44 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %45 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %add.ptr12 = getelementptr inbounds i8, i8* %44, i64 %45
  %add.ptr13 = getelementptr inbounds i8, i8* %add.ptr12, i64 -64
  %add.ptr14 = getelementptr inbounds i8, i8* %add.ptr13, i64 -7
  %46 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  call void %40(i8* %42, i8* %43, i8* %add.ptr14, i32 %46)
  %47 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %48 = bitcast i64* %nbStripes to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #10
  %49 = bitcast i64* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #10
  %50 = bitcast i64* %nb_blocks to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %50) #10
  %51 = bitcast i64* %block_len to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %51) #10
  %52 = bitcast i64* %nb_rounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %52) #10
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_accumulate(i64* noalias %acc, i8* noalias %input, i8* noalias %secret, i64 %nbStripes, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %input.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %n = alloca i64, align 8
  %in = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !3
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %nbStripes, i64* %nbStripes.addr, align 8, !tbaa !7
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !11
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %0 = bitcast i64* %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  store i64 0, i64* %n, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %n, align 8, !tbaa !7
  %2 = load i64, i64* %nbStripes.addr, align 8, !tbaa !7
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = bitcast i8** %in to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #10
  %4 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %5 = load i64, i64* %n, align 8, !tbaa !7
  %mul = mul i64 %5, 64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %mul
  store i8* %add.ptr, i8** %in, align 8, !tbaa !3
  %6 = load i8*, i8** %in, align 8, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, i8* %6, i64 320
  call void @llvm.prefetch(i8* %add.ptr1, i32 0, i32 3, i32 1)
  %7 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %8 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %9 = bitcast i64* %8 to i8*
  %10 = load i8*, i8** %in, align 8, !tbaa !3
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %12 = load i64, i64* %n, align 8, !tbaa !7
  %mul2 = mul i64 %12, 8
  %add.ptr3 = getelementptr inbounds i8, i8* %11, i64 %mul2
  %13 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  call void %7(i8* %9, i8* %10, i8* %add.ptr3, i32 %13)
  %14 = bitcast i8** %in to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i64, i64* %n, align 8, !tbaa !7
  %inc = add i64 %15, 1
  store i64 %inc, i64* %n, align 8, !tbaa !7
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = bitcast i64* %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #10
  ret void
}

; Function Attrs: inaccessiblemem_or_argmemonly nounwind
declare void @llvm.prefetch(i8* nocapture readonly, i32, i32, i32) #9

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_hashLong_64b_withSeed_internal(i8* %input, i64 %len, i64 %seed, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #1 {
entry:
  %retval = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !3
  %0 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %call = call i64 @XXH3_hashLong_64b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  store i64 %call, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 192, i8* %5) #10
  %6 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !3
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %7 = load i64, i64* %seed.addr, align 8, !tbaa !21
  call void %6(i8* %arraydecay, i64 %7)
  %8 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %9 = load i64, i64* %len.addr, align 8, !tbaa !7
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %10 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %11 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %call2 = call i64 @XXH3_hashLong_64b_internal(i8* %8, i64 %9, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %10, void (i8*, i8*)* %11)
  store i64 %call2, i64* %retval, align 8
  %12 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 192, i8* %12) #10
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i64, i64* %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind
declare i8* @__memset_chk(i8*, i32, i64, i64) #2

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH_writeLE64(i8* %dst, i64 %v64) #1 {
entry:
  %dst.addr = alloca i8*, align 8
  %v64.addr = alloca i64, align 8
  store i8* %dst, i8** %dst.addr, align 8, !tbaa !3
  store i64 %v64, i64* %v64.addr, align 8, !tbaa !21
  %0 = load i8*, i8** %dst.addr, align 8, !tbaa !3
  %1 = bitcast i64* %v64.addr to i8*
  %2 = load i8*, i8** %dst.addr, align 8, !tbaa !3
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 8, i64 %3) #10
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_set_epi64x(i64 %__q1, i64 %__q0) #1 {
entry:
  %__q1.addr = alloca i64, align 8
  %__q0.addr = alloca i64, align 8
  %.compoundliteral = alloca <2 x i64>, align 16
  store i64 %__q1, i64* %__q1.addr, align 8, !tbaa !21
  store i64 %__q0, i64* %__q0.addr, align 8, !tbaa !21
  %0 = load i64, i64* %__q0.addr, align 8, !tbaa !21
  %vecinit = insertelement <2 x i64> undef, i64 %0, i32 0
  %1 = load i64, i64* %__q1.addr, align 8, !tbaa !21
  %vecinit1 = insertelement <2 x i64> %vecinit, i64 %1, i32 1
  store <2 x i64> %vecinit1, <2 x i64>* %.compoundliteral, align 16, !tbaa !11
  %2 = load <2 x i64>, <2 x i64>* %.compoundliteral, align 16, !tbaa !11
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_add_epi64(<2 x i64> %__a, <2 x i64> %__b) #1 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !11
  store <2 x i64> %__b, <2 x i64>* %__b.addr, align 16, !tbaa !11
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !11
  %1 = load <2 x i64>, <2 x i64>* %__b.addr, align 16, !tbaa !11
  %add = add <2 x i64> %0, %1
  ret <2 x i64> %add
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_castps_si128(<4 x float> %__a) #1 {
entry:
  %__a.addr = alloca <4 x float>, align 16
  store <4 x float> %__a, <4 x float>* %__a.addr, align 16, !tbaa !11
  %0 = load <4 x float>, <4 x float>* %__a.addr, align 16, !tbaa !11
  %1 = bitcast <4 x float> %0 to <2 x i64>
  ret <2 x i64> %1
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <4 x float> @_mm_load_ps(float* %__p) #1 {
entry:
  %__p.addr = alloca float*, align 8
  store float* %__p, float** %__p.addr, align 8, !tbaa !3
  %0 = load float*, float** %__p.addr, align 8, !tbaa !3
  %1 = bitcast float* %0 to <4 x float>*
  %2 = load <4 x float>, <4 x float>* %1, align 16, !tbaa !11
  ret <4 x float> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal void @XXH3_consumeStripes(i64* noalias %acc, i64* noalias %nbStripesSoFarPtr, i64 %nbStripesPerBlock, i8* noalias %input, i64 %nbStripes, i8* noalias %secret, i64 %secretLimit, i32 %accWidth, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %nbStripesSoFarPtr.addr = alloca i64*, align 8
  %nbStripesPerBlock.addr = alloca i64, align 8
  %input.addr = alloca i8*, align 8
  %nbStripes.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretLimit.addr = alloca i64, align 8
  %accWidth.addr = alloca i32, align 4
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %nbStripesToEndofBlock = alloca i64, align 8
  %nbStripesAfterBlock = alloca i64, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !3
  store i64* %nbStripesSoFarPtr, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  store i64 %nbStripesPerBlock, i64* %nbStripesPerBlock.addr, align 8, !tbaa !7
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %nbStripes, i64* %nbStripes.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretLimit, i64* %secretLimit.addr, align 8, !tbaa !7
  store i32 %accWidth, i32* %accWidth.addr, align 4, !tbaa !11
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %0 = load i64, i64* %nbStripesPerBlock.addr, align 8, !tbaa !7
  %1 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  %2 = load i64, i64* %1, align 8, !tbaa !7
  %sub = sub i64 %0, %2
  %3 = load i64, i64* %nbStripes.addr, align 8, !tbaa !7
  %cmp = icmp ule i64 %sub, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = bitcast i64* %nbStripesToEndofBlock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  %5 = load i64, i64* %nbStripesPerBlock.addr, align 8, !tbaa !7
  %6 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  %7 = load i64, i64* %6, align 8, !tbaa !7
  %sub1 = sub i64 %5, %7
  store i64 %sub1, i64* %nbStripesToEndofBlock, align 8, !tbaa !7
  %8 = bitcast i64* %nbStripesAfterBlock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #10
  %9 = load i64, i64* %nbStripes.addr, align 8, !tbaa !7
  %10 = load i64, i64* %nbStripesToEndofBlock, align 8, !tbaa !7
  %sub2 = sub i64 %9, %10
  store i64 %sub2, i64* %nbStripesAfterBlock, align 8, !tbaa !7
  %11 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %12 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %14 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i64, i64* %14, i64 0
  %15 = load i64, i64* %arrayidx, align 8, !tbaa !7
  %mul = mul i64 %15, 8
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 %mul
  %16 = load i64, i64* %nbStripesToEndofBlock, align 8, !tbaa !7
  %17 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %18 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  call void @XXH3_accumulate(i64* %11, i8* %12, i8* %add.ptr, i64 %16, i32 %17, void (i8*, i8*, i8*, i32)* %18)
  %19 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %20 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %21 = bitcast i64* %20 to i8*
  %22 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %23 = load i64, i64* %secretLimit.addr, align 8, !tbaa !7
  %add.ptr3 = getelementptr inbounds i8, i8* %22, i64 %23
  call void %19(i8* %21, i8* %add.ptr3)
  %24 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %25 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %26 = load i64, i64* %nbStripesToEndofBlock, align 8, !tbaa !7
  %mul4 = mul i64 %26, 64
  %add.ptr5 = getelementptr inbounds i8, i8* %25, i64 %mul4
  %27 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %28 = load i64, i64* %nbStripesAfterBlock, align 8, !tbaa !7
  %29 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %30 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  call void @XXH3_accumulate(i64* %24, i8* %add.ptr5, i8* %27, i64 %28, i32 %29, void (i8*, i8*, i8*, i32)* %30)
  %31 = load i64, i64* %nbStripesAfterBlock, align 8, !tbaa !7
  %32 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  store i64 %31, i64* %32, align 8, !tbaa !7
  %33 = bitcast i64* %nbStripesAfterBlock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %33) #10
  %34 = bitcast i64* %nbStripesToEndofBlock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %34) #10
  br label %if.end

if.else:                                          ; preds = %entry
  %35 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %36 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %37 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %38 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  %arrayidx6 = getelementptr inbounds i64, i64* %38, i64 0
  %39 = load i64, i64* %arrayidx6, align 8, !tbaa !7
  %mul7 = mul i64 %39, 8
  %add.ptr8 = getelementptr inbounds i8, i8* %37, i64 %mul7
  %40 = load i64, i64* %nbStripes.addr, align 8, !tbaa !7
  %41 = load i32, i32* %accWidth.addr, align 4, !tbaa !11
  %42 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  call void @XXH3_accumulate(i64* %35, i8* %36, i8* %add.ptr8, i64 %40, i32 %41, void (i8*, i8*, i8*, i32)* %42)
  %43 = load i64, i64* %nbStripes.addr, align 8, !tbaa !7
  %44 = load i64*, i64** %nbStripesSoFarPtr.addr, align 8, !tbaa !3
  %45 = load i64, i64* %44, align 8, !tbaa !7
  %add = add i64 %45, %43
  store i64 %add, i64* %44, align 8, !tbaa !7
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_loadu_si128(<2 x i64>* %__p) #1 {
entry:
  %__p.addr = alloca <2 x i64>*, align 8
  store <2 x i64>* %__p, <2 x i64>** %__p.addr, align 8, !tbaa !3
  %0 = load <2 x i64>*, <2 x i64>** %__p.addr, align 8, !tbaa !3
  %1 = bitcast <2 x i64>* %0 to %struct.__loadu_si128*
  %__v = getelementptr inbounds %struct.__loadu_si128, %struct.__loadu_si128* %1, i32 0, i32 0
  %2 = load <2 x i64>, <2 x i64>* %__v, align 1, !tbaa !11
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_xor_si128(<2 x i64> %__a, <2 x i64> %__b) #1 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !11
  store <2 x i64> %__b, <2 x i64>* %__b.addr, align 16, !tbaa !11
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !11
  %1 = load <2 x i64>, <2 x i64>* %__b.addr, align 16, !tbaa !11
  %xor = xor <2 x i64> %0, %1
  ret <2 x i64> %xor
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_undefined_si128() #1 {
entry:
  ret <2 x i64> zeroinitializer
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_mul_epu32(<2 x i64> %__a, <2 x i64> %__b) #1 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !11
  store <2 x i64> %__b, <2 x i64>* %__b.addr, align 16, !tbaa !11
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !11
  %1 = bitcast <2 x i64> %0 to <4 x i32>
  %2 = load <2 x i64>, <2 x i64>* %__b.addr, align 16, !tbaa !11
  %3 = bitcast <2 x i64> %2 to <4 x i32>
  %4 = call <2 x i64> @llvm.x86.sse2.pmulu.dq(<4 x i32> %1, <4 x i32> %3)
  ret <2 x i64> %4
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.pmulu.dq(<4 x i32>, <4 x i32>) #8

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_set1_epi32(i32 %__i) #1 {
entry:
  %__i.addr = alloca i32, align 4
  %.compoundliteral = alloca <4 x i32>, align 16
  store i32 %__i, i32* %__i.addr, align 4, !tbaa !9
  %0 = load i32, i32* %__i.addr, align 4, !tbaa !9
  %vecinit = insertelement <4 x i32> undef, i32 %0, i32 0
  %1 = load i32, i32* %__i.addr, align 4, !tbaa !9
  %vecinit1 = insertelement <4 x i32> %vecinit, i32 %1, i32 1
  %2 = load i32, i32* %__i.addr, align 4, !tbaa !9
  %vecinit2 = insertelement <4 x i32> %vecinit1, i32 %2, i32 2
  %3 = load i32, i32* %__i.addr, align 4, !tbaa !9
  %vecinit3 = insertelement <4 x i32> %vecinit2, i32 %3, i32 3
  store <4 x i32> %vecinit3, <4 x i32>* %.compoundliteral, align 16, !tbaa !11
  %4 = load <4 x i32>, <4 x i32>* %.compoundliteral, align 16, !tbaa !11
  %5 = bitcast <4 x i32> %4 to <2 x i64>
  ret <2 x i64> %5
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_srli_epi64(<2 x i64> %__a, i32 %__count) #1 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__count.addr = alloca i32, align 4
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !11
  store i32 %__count, i32* %__count.addr, align 4, !tbaa !9
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !11
  %1 = load i32, i32* %__count.addr, align 4, !tbaa !9
  %2 = call <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64> %0, i32 %1)
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal <2 x i64> @_mm_slli_epi64(<2 x i64> %__a, i32 %__count) #1 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__count.addr = alloca i32, align 4
  store <2 x i64> %__a, <2 x i64>* %__a.addr, align 16, !tbaa !11
  store i32 %__count, i32* %__count.addr, align 4, !tbaa !9
  %0 = load <2 x i64>, <2 x i64>* %__a.addr, align 16, !tbaa !11
  %1 = load i32, i32* %__count.addr, align 4, !tbaa !9
  %2 = call <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64> %0, i32 %1)
  ret <2 x i64> %2
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64>, i32) #8

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64>, i32) #8

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal i64 @XXH3_mix2Accs(i64* noalias %acc, i8* noalias %secret) #1 {
entry:
  %acc.addr = alloca i64*, align 8
  %secret.addr = alloca i8*, align 8
  store i64* %acc, i64** %acc.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  %0 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !21
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %call = call i64 @XXH_readLE64(i8* %2)
  %xor = xor i64 %1, %call
  %3 = load i64*, i64** %acc.addr, align 8, !tbaa !3
  %arrayidx1 = getelementptr inbounds i64, i64* %3, i64 1
  %4 = load i64, i64* %arrayidx1, align 8, !tbaa !21
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 8
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr)
  %xor3 = xor i64 %4, %call2
  %call4 = call i64 @XXH3_mul128_fold64(i64 %xor, i64 %xor3)
  ret i64 %call4
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_0to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %h128 = alloca %struct.XXH128_hash_t, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp ugt i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %4 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call { i64, i64 } @XXH3_len_9to16_128b(i8* %1, i64 %2, i8* %3, i64 %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp1 = icmp uge i64 %10, 4
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %12 = load i64, i64* %len.addr, align 8, !tbaa !7
  %13 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %14 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call3 = call { i64, i64 } @XXH3_len_4to8_128b(i8* %11, i64 %12, i8* %13, i64 %14)
  %15 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call3, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call3, 1
  store i64 %19, i64* %18, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %20 = load i64, i64* %len.addr, align 8, !tbaa !7
  %tobool = icmp ne i64 %20, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end4
  %21 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %22 = load i64, i64* %len.addr, align 8, !tbaa !7
  %23 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %24 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call6 = call { i64, i64 } @XXH3_len_1to3_128b(i8* %21, i64 %22, i8* %23, i64 %24)
  %25 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call6, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call6, 1
  store i64 %29, i64* %28, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %30 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %30) #10
  %31 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %31) #10
  %32 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %32, i64 64
  %call8 = call i64 @XXH_readLE64(i8* %add.ptr)
  %33 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr9 = getelementptr inbounds i8, i8* %33, i64 72
  %call10 = call i64 @XXH_readLE64(i8* %add.ptr9)
  %xor = xor i64 %call8, %call10
  store i64 %xor, i64* %bitflipl, align 8, !tbaa !21
  %34 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %34) #10
  %35 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr11 = getelementptr inbounds i8, i8* %35, i64 80
  %call12 = call i64 @XXH_readLE64(i8* %add.ptr11)
  %36 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr13 = getelementptr inbounds i8, i8* %36, i64 88
  %call14 = call i64 @XXH_readLE64(i8* %add.ptr13)
  %xor15 = xor i64 %call12, %call14
  store i64 %xor15, i64* %bitfliph, align 8, !tbaa !21
  %37 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 -7046029288634856825, %37
  %38 = load i64, i64* %bitflipl, align 8, !tbaa !21
  %xor16 = xor i64 %add, %38
  %call17 = call i64 @XXH3_avalanche(i64 %xor16)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call17, i64* %low64, align 8, !tbaa !41
  %39 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 -4417276706812531889, %39
  %40 = load i64, i64* %bitfliph, align 8, !tbaa !21
  %xor18 = xor i64 %sub, %40
  %call19 = call i64 @XXH3_avalanche(i64 %xor18)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %call19, i64* %high64, align 8, !tbaa !39
  %41 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %42 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 16, i32 8, i1 false), !tbaa.struct !42
  %43 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #10
  %44 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %44) #10
  %45 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %45) #10
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then2, %if.then
  %46 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %47 = load { i64, i64 }, { i64, i64 }* %46, align 8
  ret { i64, i64 } %47
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_17to128_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %coerce = alloca %struct.XXH128_hash_t, align 8
  %coerce13 = alloca %struct.XXH128_hash_t, align 8
  %coerce20 = alloca %struct.XXH128_hash_t, align 8
  %coerce25 = alloca %struct.XXH128_hash_t, align 8
  %h128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %1 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #10
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul = mul i64 %2, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8, !tbaa !41
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8, !tbaa !39
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp = icmp ugt i64 %3, 32
  br i1 %cmp, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp1 = icmp ugt i64 %4, 64
  br i1 %cmp1, label %if.then2, label %if.end14

if.then2:                                         ; preds = %if.then
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %cmp3 = icmp ugt i64 %5, 96
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %6 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 48
  %7 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %8 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr5 = getelementptr inbounds i8, i8* %7, i64 %8
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 -64
  %9 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr7 = getelementptr inbounds i8, i8* %9, i64 96
  %10 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %11 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %13, i64 %15, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr7, i64 %10)
  %16 = bitcast %struct.XXH128_hash_t* %coerce to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %22 = bitcast %struct.XXH128_hash_t* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 16, i32 8, i1 false), !tbaa.struct !42
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  %23 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr8 = getelementptr inbounds i8, i8* %23, i64 32
  %24 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %25 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr9 = getelementptr inbounds i8, i8* %24, i64 %25
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -48
  %26 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr11 = getelementptr inbounds i8, i8* %26, i64 64
  %27 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %28 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 0
  %30 = load i64, i64* %29, align 8
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 1
  %32 = load i64, i64* %31, align 8
  %call12 = call { i64, i64 } @XXH128_mix32B(i64 %30, i64 %32, i8* %add.ptr8, i8* %add.ptr10, i8* %add.ptr11, i64 %27)
  %33 = bitcast %struct.XXH128_hash_t* %coerce13 to { i64, i64 }*
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 0
  %35 = extractvalue { i64, i64 } %call12, 0
  store i64 %35, i64* %34, align 8
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 1
  %37 = extractvalue { i64, i64 } %call12, 1
  store i64 %37, i64* %36, align 8
  %38 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %39 = bitcast %struct.XXH128_hash_t* %coerce13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %38, i8* %39, i64 16, i32 8, i1 false), !tbaa.struct !42
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %40 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %add.ptr15 = getelementptr inbounds i8, i8* %40, i64 16
  %41 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %42 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr16 = getelementptr inbounds i8, i8* %41, i64 %42
  %add.ptr17 = getelementptr inbounds i8, i8* %add.ptr16, i64 -32
  %43 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr18 = getelementptr inbounds i8, i8* %43, i64 32
  %44 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %45 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 0
  %47 = load i64, i64* %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %call19 = call { i64, i64 } @XXH128_mix32B(i64 %47, i64 %49, i8* %add.ptr15, i8* %add.ptr17, i8* %add.ptr18, i64 %44)
  %50 = bitcast %struct.XXH128_hash_t* %coerce20 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = extractvalue { i64, i64 } %call19, 0
  store i64 %52, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = extractvalue { i64, i64 } %call19, 1
  store i64 %54, i64* %53, align 8
  %55 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %56 = bitcast %struct.XXH128_hash_t* %coerce20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %55, i8* %56, i64 16, i32 8, i1 false), !tbaa.struct !42
  br label %if.end21

if.end21:                                         ; preds = %if.end14, %entry
  %57 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %58 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %59 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr22 = getelementptr inbounds i8, i8* %58, i64 %59
  %add.ptr23 = getelementptr inbounds i8, i8* %add.ptr22, i64 -16
  %60 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %61 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %62 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call24 = call { i64, i64 } @XXH128_mix32B(i64 %64, i64 %66, i8* %57, i8* %add.ptr23, i8* %60, i64 %61)
  %67 = bitcast %struct.XXH128_hash_t* %coerce25 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = extractvalue { i64, i64 } %call24, 0
  store i64 %69, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = extractvalue { i64, i64 } %call24, 1
  store i64 %71, i64* %70, align 8
  %72 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %73 = bitcast %struct.XXH128_hash_t* %coerce25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %72, i8* %73, i64 16, i32 8, i1 false), !tbaa.struct !42
  %74 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %74) #10
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %75 = load i64, i64* %low6426, align 8, !tbaa !41
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %76 = load i64, i64* %high6427, align 8, !tbaa !39
  %add = add i64 %75, %76
  %low6428 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %add, i64* %low6428, align 8, !tbaa !41
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %77 = load i64, i64* %low6429, align 8, !tbaa !41
  %mul30 = mul i64 %77, -7046029288634856825
  %high6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %78 = load i64, i64* %high6431, align 8, !tbaa !39
  %mul32 = mul i64 %78, -8796714831421723037
  %add33 = add i64 %mul30, %mul32
  %79 = load i64, i64* %len.addr, align 8, !tbaa !7
  %80 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 %79, %80
  %mul34 = mul i64 %sub, -4417276706812531889
  %add35 = add i64 %add33, %mul34
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %add35, i64* %high6436, align 8, !tbaa !39
  %low6437 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  %81 = load i64, i64* %low6437, align 8, !tbaa !41
  %call38 = call i64 @XXH3_avalanche(i64 %81)
  %low6439 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call38, i64* %low6439, align 8, !tbaa !41
  %high6440 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  %82 = load i64, i64* %high6440, align 8, !tbaa !39
  %call41 = call i64 @XXH3_avalanche(i64 %82)
  %sub42 = sub i64 0, %call41
  %high6443 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %sub42, i64* %high6443, align 8, !tbaa !39
  %83 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %84 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %83, i8* %84, i64 16, i32 8, i1 false), !tbaa.struct !42
  %85 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %85) #10
  %86 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %86) #10
  %87 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %88 = load { i64, i64 }, { i64, i64 }* %87, align 8
  ret { i64, i64 } %88
}

; Function Attrs: noinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_129to240_128b(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, i64 %seed) #5 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %nbRounds = alloca i32, align 4
  %i = alloca i32, align 4
  %coerce = alloca %struct.XXH128_hash_t, align 8
  %coerce32 = alloca %struct.XXH128_hash_t, align 8
  %coerce45 = alloca %struct.XXH128_hash_t, align 8
  %h128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %1 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #10
  %2 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #10
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv = trunc i64 %3 to i32
  %div = sdiv i32 %conv, 32
  store i32 %div, i32* %nbRounds, align 4, !tbaa !9
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #10
  %5 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul = mul i64 %5, -7046029288634856825
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %mul, i64* %low64, align 8, !tbaa !41
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 0, i64* %high64, align 8, !tbaa !39
  store i32 0, i32* %i, align 4, !tbaa !9
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4, !tbaa !9
  %cmp = icmp slt i32 %6, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %8 = load i32, i32* %i, align 4, !tbaa !9
  %mul2 = mul nsw i32 32, %8
  %idx.ext = sext i32 %mul2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %idx.ext
  %9 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %10 = load i32, i32* %i, align 4, !tbaa !9
  %mul3 = mul nsw i32 32, %10
  %idx.ext4 = sext i32 %mul3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %9, i64 %idx.ext4
  %add.ptr6 = getelementptr inbounds i8, i8* %add.ptr5, i64 16
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %12 = load i32, i32* %i, align 4, !tbaa !9
  %mul7 = mul nsw i32 32, %12
  %idx.ext8 = sext i32 %mul7 to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %11, i64 %idx.ext8
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %14 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = load i64, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = load i64, i64* %17, align 8
  %call = call { i64, i64 } @XXH128_mix32B(i64 %16, i64 %18, i8* %add.ptr, i8* %add.ptr6, i8* %add.ptr9, i64 %13)
  %19 = bitcast %struct.XXH128_hash_t* %coerce to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = extractvalue { i64, i64 } %call, 0
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = extractvalue { i64, i64 } %call, 1
  store i64 %23, i64* %22, align 8
  %24 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %25 = bitcast %struct.XXH128_hash_t* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %25, i64 16, i32 8, i1 false), !tbaa.struct !42
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %26 = load i32, i32* %i, align 4, !tbaa !9
  %inc = add nsw i32 %26, 1
  store i32 %inc, i32* %i, align 4, !tbaa !9
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %low6410 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %27 = load i64, i64* %low6410, align 8, !tbaa !41
  %call11 = call i64 @XXH3_avalanche(i64 %27)
  %low6412 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  store i64 %call11, i64* %low6412, align 8, !tbaa !41
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %28 = load i64, i64* %high6413, align 8, !tbaa !39
  %call14 = call i64 @XXH3_avalanche(i64 %28)
  %high6415 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  store i64 %call14, i64* %high6415, align 8, !tbaa !39
  store i32 4, i32* %i, align 4, !tbaa !9
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc33, %for.end
  %29 = load i32, i32* %i, align 4, !tbaa !9
  %30 = load i32, i32* %nbRounds, align 4, !tbaa !9
  %cmp17 = icmp slt i32 %29, %30
  br i1 %cmp17, label %for.body19, label %for.end35

for.body19:                                       ; preds = %for.cond16
  %31 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %32 = load i32, i32* %i, align 4, !tbaa !9
  %mul20 = mul nsw i32 32, %32
  %idx.ext21 = sext i32 %mul20 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %31, i64 %idx.ext21
  %33 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %34 = load i32, i32* %i, align 4, !tbaa !9
  %mul23 = mul nsw i32 32, %34
  %idx.ext24 = sext i32 %mul23 to i64
  %add.ptr25 = getelementptr inbounds i8, i8* %33, i64 %idx.ext24
  %add.ptr26 = getelementptr inbounds i8, i8* %add.ptr25, i64 16
  %35 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr27 = getelementptr inbounds i8, i8* %35, i64 3
  %36 = load i32, i32* %i, align 4, !tbaa !9
  %sub = sub nsw i32 %36, 4
  %mul28 = mul nsw i32 32, %sub
  %idx.ext29 = sext i32 %mul28 to i64
  %add.ptr30 = getelementptr inbounds i8, i8* %add.ptr27, i64 %idx.ext29
  %37 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %38 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = load i64, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = load i64, i64* %41, align 8
  %call31 = call { i64, i64 } @XXH128_mix32B(i64 %40, i64 %42, i8* %add.ptr22, i8* %add.ptr26, i8* %add.ptr30, i64 %37)
  %43 = bitcast %struct.XXH128_hash_t* %coerce32 to { i64, i64 }*
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %43, i32 0, i32 0
  %45 = extractvalue { i64, i64 } %call31, 0
  store i64 %45, i64* %44, align 8
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %43, i32 0, i32 1
  %47 = extractvalue { i64, i64 } %call31, 1
  store i64 %47, i64* %46, align 8
  %48 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %49 = bitcast %struct.XXH128_hash_t* %coerce32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %48, i8* %49, i64 16, i32 8, i1 false), !tbaa.struct !42
  br label %for.inc33

for.inc33:                                        ; preds = %for.body19
  %50 = load i32, i32* %i, align 4, !tbaa !9
  %inc34 = add nsw i32 %50, 1
  store i32 %inc34, i32* %i, align 4, !tbaa !9
  br label %for.cond16

for.end35:                                        ; preds = %for.cond16
  %51 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %52 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr36 = getelementptr inbounds i8, i8* %51, i64 %52
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr36, i64 -16
  %53 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %54 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr38 = getelementptr inbounds i8, i8* %53, i64 %54
  %add.ptr39 = getelementptr inbounds i8, i8* %add.ptr38, i64 -32
  %55 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr40 = getelementptr inbounds i8, i8* %55, i64 136
  %add.ptr41 = getelementptr inbounds i8, i8* %add.ptr40, i64 -17
  %add.ptr42 = getelementptr inbounds i8, i8* %add.ptr41, i64 -16
  %56 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub43 = sub i64 0, %56
  %57 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = load i64, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = load i64, i64* %60, align 8
  %call44 = call { i64, i64 } @XXH128_mix32B(i64 %59, i64 %61, i8* %add.ptr37, i8* %add.ptr39, i8* %add.ptr42, i64 %sub43)
  %62 = bitcast %struct.XXH128_hash_t* %coerce45 to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = extractvalue { i64, i64 } %call44, 0
  store i64 %64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = extractvalue { i64, i64 } %call44, 1
  store i64 %66, i64* %65, align 8
  %67 = bitcast %struct.XXH128_hash_t* %acc to i8*
  %68 = bitcast %struct.XXH128_hash_t* %coerce45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %67, i8* %68, i64 16, i32 8, i1 false), !tbaa.struct !42
  %69 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %69) #10
  %low6446 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %70 = load i64, i64* %low6446, align 8, !tbaa !41
  %high6447 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %71 = load i64, i64* %high6447, align 8, !tbaa !39
  %add = add i64 %70, %71
  %low6448 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %add, i64* %low6448, align 8, !tbaa !41
  %low6449 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %72 = load i64, i64* %low6449, align 8, !tbaa !41
  %mul50 = mul i64 %72, -7046029288634856825
  %high6451 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %73 = load i64, i64* %high6451, align 8, !tbaa !39
  %mul52 = mul i64 %73, -8796714831421723037
  %add53 = add i64 %mul50, %mul52
  %74 = load i64, i64* %len.addr, align 8, !tbaa !7
  %75 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub54 = sub i64 %74, %75
  %mul55 = mul i64 %sub54, -4417276706812531889
  %add56 = add i64 %add53, %mul55
  %high6457 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %add56, i64* %high6457, align 8, !tbaa !39
  %low6458 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  %76 = load i64, i64* %low6458, align 8, !tbaa !41
  %call59 = call i64 @XXH3_avalanche(i64 %76)
  %low6460 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call59, i64* %low6460, align 8, !tbaa !41
  %high6461 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  %77 = load i64, i64* %high6461, align 8, !tbaa !39
  %call62 = call i64 @XXH3_avalanche(i64 %77)
  %sub63 = sub i64 0, %call62
  %high6464 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %sub63, i64* %high6464, align 8, !tbaa !39
  %78 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %79 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %78, i8* %79, i64 16, i32 8, i1 false), !tbaa.struct !42
  %80 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %80) #10
  %81 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %81) #10
  %82 = bitcast i32* %nbRounds to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %82) #10
  %83 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %83) #10
  %84 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %85 = load { i64, i64 }, { i64, i64 }* %84, align 8
  ret { i64, i64 } %85
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_9to16_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %input_lo = alloca i64, align 8
  %input_hi = alloca i64, align 8
  %m128 = alloca %struct.XXH128_hash_t, align 8
  %h128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #10
  %1 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 32
  %call = call i64 @XXH_readLE64(i8* %add.ptr)
  %2 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 40
  %call2 = call i64 @XXH_readLE64(i8* %add.ptr1)
  %xor = xor i64 %call, %call2
  %3 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub = sub i64 %xor, %3
  store i64 %sub, i64* %bitflipl, align 8, !tbaa !21
  %4 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #10
  %5 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr3 = getelementptr inbounds i8, i8* %5, i64 48
  %call4 = call i64 @XXH_readLE64(i8* %add.ptr3)
  %6 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 56
  %call6 = call i64 @XXH_readLE64(i8* %add.ptr5)
  %xor7 = xor i64 %call4, %call6
  %7 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 %xor7, %7
  store i64 %add, i64* %bitfliph, align 8, !tbaa !21
  %8 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #10
  %9 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %call8 = call i64 @XXH_readLE64(i8* %9)
  store i64 %call8, i64* %input_lo, align 8, !tbaa !21
  %10 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #10
  %11 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %12 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr9 = getelementptr inbounds i8, i8* %11, i64 %12
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr9, i64 -8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  store i64 %call11, i64* %input_hi, align 8, !tbaa !21
  %13 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %13) #10
  %14 = load i64, i64* %input_lo, align 8, !tbaa !21
  %15 = load i64, i64* %input_hi, align 8, !tbaa !21
  %xor12 = xor i64 %14, %15
  %16 = load i64, i64* %bitflipl, align 8, !tbaa !21
  %xor13 = xor i64 %xor12, %16
  %call14 = call { i64, i64 } @XXH_mult64to128(i64 %xor13, i64 -7046029288634856825)
  %17 = bitcast %struct.XXH128_hash_t* %m128 to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call14, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call14, 1
  store i64 %21, i64* %20, align 8
  %22 = load i64, i64* %len.addr, align 8, !tbaa !7
  %sub15 = sub i64 %22, 1
  %shl = shl i64 %sub15, 54
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %23 = load i64, i64* %low64, align 8, !tbaa !41
  %add16 = add i64 %23, %shl
  store i64 %add16, i64* %low64, align 8, !tbaa !41
  %24 = load i64, i64* %bitfliph, align 8, !tbaa !21
  %25 = load i64, i64* %input_hi, align 8, !tbaa !21
  %xor17 = xor i64 %25, %24
  store i64 %xor17, i64* %input_hi, align 8, !tbaa !21
  %26 = load i64, i64* %input_hi, align 8, !tbaa !21
  %27 = load i64, i64* %input_hi, align 8, !tbaa !21
  %conv = trunc i64 %27 to i32
  %conv18 = zext i32 %conv to i64
  %mul = mul i64 %conv18, 2246822518
  %add19 = add i64 %26, %mul
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %28 = load i64, i64* %high64, align 8, !tbaa !39
  %add20 = add i64 %28, %add19
  store i64 %add20, i64* %high64, align 8, !tbaa !39
  %high6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %29 = load i64, i64* %high6421, align 8, !tbaa !39
  %call22 = call i64 @XXH_swap64(i64 %29)
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %30 = load i64, i64* %low6423, align 8, !tbaa !41
  %xor24 = xor i64 %30, %call22
  store i64 %xor24, i64* %low6423, align 8, !tbaa !41
  %31 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %31) #10
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %32 = load i64, i64* %low6425, align 8, !tbaa !41
  %call26 = call { i64, i64 } @XXH_mult64to128(i64 %32, i64 -4417276706812531889)
  %33 = bitcast %struct.XXH128_hash_t* %h128 to { i64, i64 }*
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 0
  %35 = extractvalue { i64, i64 } %call26, 0
  store i64 %35, i64* %34, align 8
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 1
  %37 = extractvalue { i64, i64 } %call26, 1
  store i64 %37, i64* %36, align 8
  %high6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %38 = load i64, i64* %high6427, align 8, !tbaa !39
  %mul28 = mul i64 %38, -4417276706812531889
  %high6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  %39 = load i64, i64* %high6429, align 8, !tbaa !39
  %add30 = add i64 %39, %mul28
  store i64 %add30, i64* %high6429, align 8, !tbaa !39
  %low6431 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  %40 = load i64, i64* %low6431, align 8, !tbaa !41
  %call32 = call i64 @XXH3_avalanche(i64 %40)
  %low6433 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call32, i64* %low6433, align 8, !tbaa !41
  %high6434 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  %41 = load i64, i64* %high6434, align 8, !tbaa !39
  %call35 = call i64 @XXH3_avalanche(i64 %41)
  %high6436 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %call35, i64* %high6436, align 8, !tbaa !39
  %42 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %43 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %42, i8* %43, i64 16, i32 8, i1 false), !tbaa.struct !42
  %44 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %44) #10
  %45 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %45) #10
  %46 = bitcast i64* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #10
  %47 = bitcast i64* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %47) #10
  %48 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #10
  %49 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %49) #10
  %50 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %51 = load { i64, i64 }, { i64, i64 }* %50, align 8
  ret { i64, i64 } %51
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_4to8_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %input_lo = alloca i32, align 4
  %input_hi = alloca i32, align 4
  %input_64 = alloca i64, align 8
  %bitflip = alloca i64, align 8
  %keyed = alloca i64, align 8
  %m128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %0 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %conv = trunc i64 %0 to i32
  %call = call i32 @XXH_swap32(i32 %conv)
  %conv1 = zext i32 %call to i64
  %shl = shl i64 %conv1, 32
  %1 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %xor = xor i64 %1, %shl
  store i64 %xor, i64* %seed.addr, align 8, !tbaa !21
  %2 = bitcast i32* %input_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #10
  %3 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %call2 = call i32 @XXH_readLE32(i8* %3)
  store i32 %call2, i32* %input_lo, align 4, !tbaa !9
  %4 = bitcast i32* %input_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #10
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %6 = load i64, i64* %len.addr, align 8, !tbaa !7
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 %6
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 -4
  %call4 = call i32 @XXH_readLE32(i8* %add.ptr3)
  store i32 %call4, i32* %input_hi, align 4, !tbaa !9
  %7 = bitcast i64* %input_64 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #10
  %8 = load i32, i32* %input_lo, align 4, !tbaa !9
  %conv5 = zext i32 %8 to i64
  %9 = load i32, i32* %input_hi, align 4, !tbaa !9
  %conv6 = zext i32 %9 to i64
  %shl7 = shl i64 %conv6, 32
  %add = add i64 %conv5, %shl7
  store i64 %add, i64* %input_64, align 8, !tbaa !21
  %10 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #10
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr8 = getelementptr inbounds i8, i8* %11, i64 16
  %call9 = call i64 @XXH_readLE64(i8* %add.ptr8)
  %12 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr10 = getelementptr inbounds i8, i8* %12, i64 24
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %xor12 = xor i64 %call9, %call11
  %13 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add13 = add i64 %xor12, %13
  store i64 %add13, i64* %bitflip, align 8, !tbaa !21
  %14 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #10
  %15 = load i64, i64* %input_64, align 8, !tbaa !21
  %16 = load i64, i64* %bitflip, align 8, !tbaa !21
  %xor14 = xor i64 %15, %16
  store i64 %xor14, i64* %keyed, align 8, !tbaa !21
  %17 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %17) #10
  %18 = load i64, i64* %keyed, align 8, !tbaa !21
  %19 = load i64, i64* %len.addr, align 8, !tbaa !7
  %shl15 = shl i64 %19, 2
  %add16 = add i64 -7046029288634856825, %shl15
  %call17 = call { i64, i64 } @XXH_mult64to128(i64 %18, i64 %add16)
  %20 = bitcast %struct.XXH128_hash_t* %m128 to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call17, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call17, 1
  store i64 %24, i64* %23, align 8
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %25 = load i64, i64* %low64, align 8, !tbaa !41
  %shl18 = shl i64 %25, 1
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %26 = load i64, i64* %high64, align 8, !tbaa !39
  %add19 = add i64 %26, %shl18
  store i64 %add19, i64* %high64, align 8, !tbaa !39
  %high6420 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %27 = load i64, i64* %high6420, align 8, !tbaa !39
  %shr = lshr i64 %27, 3
  %low6421 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %28 = load i64, i64* %low6421, align 8, !tbaa !41
  %xor22 = xor i64 %28, %shr
  store i64 %xor22, i64* %low6421, align 8, !tbaa !41
  %low6423 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %29 = load i64, i64* %low6423, align 8, !tbaa !41
  %call24 = call i64 @XXH_xorshift64(i64 %29, i32 35)
  %low6425 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  store i64 %call24, i64* %low6425, align 8, !tbaa !41
  %low6426 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %30 = load i64, i64* %low6426, align 8, !tbaa !41
  %mul = mul i64 %30, -6939452855193903323
  store i64 %mul, i64* %low6426, align 8, !tbaa !41
  %low6427 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  %31 = load i64, i64* %low6427, align 8, !tbaa !41
  %call28 = call i64 @XXH_xorshift64(i64 %31, i32 28)
  %low6429 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 0
  store i64 %call28, i64* %low6429, align 8, !tbaa !41
  %high6430 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  %32 = load i64, i64* %high6430, align 8, !tbaa !39
  %call31 = call i64 @XXH3_avalanche(i64 %32)
  %high6432 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %m128, i32 0, i32 1
  store i64 %call31, i64* %high6432, align 8, !tbaa !39
  %33 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %34 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %33, i8* %34, i64 16, i32 8, i1 false), !tbaa.struct !42
  %35 = bitcast %struct.XXH128_hash_t* %m128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %35) #10
  %36 = bitcast i64* %keyed to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %36) #10
  %37 = bitcast i64* %bitflip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %37) #10
  %38 = bitcast i64* %input_64 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %38) #10
  %39 = bitcast i32* %input_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %39) #10
  %40 = bitcast i32* %input_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %40) #10
  %41 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %42 = load { i64, i64 }, { i64, i64 }* %41, align 8
  ret { i64, i64 } %42
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_len_1to3_128b(i8* %input, i64 %len, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %c1 = alloca i8, align 1
  %c2 = alloca i8, align 1
  %c3 = alloca i8, align 1
  %combinedl = alloca i32, align 4
  %combinedh = alloca i32, align 4
  %bitflipl = alloca i64, align 8
  %bitfliph = alloca i64, align 8
  %keyed_lo = alloca i64, align 8
  %keyed_hi = alloca i64, align 8
  %mixedl = alloca i64, align 8
  %mixedh = alloca i64, align 8
  %h128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c1) #10
  %0 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !11
  store i8 %1, i8* %c1, align 1, !tbaa !11
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c2) #10
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i64 %shr
  %4 = load i8, i8* %arrayidx1, align 1, !tbaa !11
  store i8 %4, i8* %c2, align 1, !tbaa !11
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c3) #10
  %5 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %6 = load i64, i64* %len.addr, align 8, !tbaa !7
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i64 %sub
  %7 = load i8, i8* %arrayidx2, align 1, !tbaa !11
  store i8 %7, i8* %c3, align 1, !tbaa !11
  %8 = bitcast i32* %combinedl to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #10
  %9 = load i8, i8* %c1, align 1, !tbaa !11
  %conv = zext i8 %9 to i32
  %shl = shl i32 %conv, 16
  %10 = load i8, i8* %c2, align 1, !tbaa !11
  %conv3 = zext i8 %10 to i32
  %shl4 = shl i32 %conv3, 24
  %or = or i32 %shl, %shl4
  %11 = load i8, i8* %c3, align 1, !tbaa !11
  %conv5 = zext i8 %11 to i32
  %shl6 = shl i32 %conv5, 0
  %or7 = or i32 %or, %shl6
  %12 = load i64, i64* %len.addr, align 8, !tbaa !7
  %conv8 = trunc i64 %12 to i32
  %shl9 = shl i32 %conv8, 8
  %or10 = or i32 %or7, %shl9
  store i32 %or10, i32* %combinedl, align 4, !tbaa !9
  %13 = bitcast i32* %combinedh to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %13) #10
  %14 = load i32, i32* %combinedl, align 4, !tbaa !9
  %call = call i32 @XXH_swap32(i32 %14)
  %shl11 = shl i32 %call, 13
  %15 = load i32, i32* %combinedl, align 4, !tbaa !9
  %call12 = call i32 @XXH_swap32(i32 %15)
  %shr13 = lshr i32 %call12, 19
  %or14 = or i32 %shl11, %shr13
  store i32 %or14, i32* %combinedh, align 4, !tbaa !9
  %16 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #10
  %17 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %call15 = call i32 @XXH_readLE32(i8* %17)
  %18 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %18, i64 4
  %call16 = call i32 @XXH_readLE32(i8* %add.ptr)
  %xor = xor i32 %call15, %call16
  %conv17 = zext i32 %xor to i64
  %19 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %add = add i64 %conv17, %19
  store i64 %add, i64* %bitflipl, align 8, !tbaa !21
  %20 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #10
  %21 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr18 = getelementptr inbounds i8, i8* %21, i64 8
  %call19 = call i32 @XXH_readLE32(i8* %add.ptr18)
  %22 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr20 = getelementptr inbounds i8, i8* %22, i64 12
  %call21 = call i32 @XXH_readLE32(i8* %add.ptr20)
  %xor22 = xor i32 %call19, %call21
  %conv23 = zext i32 %xor22 to i64
  %23 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %sub24 = sub i64 %conv23, %23
  store i64 %sub24, i64* %bitfliph, align 8, !tbaa !21
  %24 = bitcast i64* %keyed_lo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %24) #10
  %25 = load i32, i32* %combinedl, align 4, !tbaa !9
  %conv25 = zext i32 %25 to i64
  %26 = load i64, i64* %bitflipl, align 8, !tbaa !21
  %xor26 = xor i64 %conv25, %26
  store i64 %xor26, i64* %keyed_lo, align 8, !tbaa !21
  %27 = bitcast i64* %keyed_hi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %27) #10
  %28 = load i32, i32* %combinedh, align 4, !tbaa !9
  %conv27 = zext i32 %28 to i64
  %29 = load i64, i64* %bitfliph, align 8, !tbaa !21
  %xor28 = xor i64 %conv27, %29
  store i64 %xor28, i64* %keyed_hi, align 8, !tbaa !21
  %30 = bitcast i64* %mixedl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %30) #10
  %31 = load i64, i64* %keyed_lo, align 8, !tbaa !21
  %mul = mul i64 %31, -7046029288634856825
  store i64 %mul, i64* %mixedl, align 8, !tbaa !21
  %32 = bitcast i64* %mixedh to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %32) #10
  %33 = load i64, i64* %keyed_hi, align 8, !tbaa !21
  %mul29 = mul i64 %33, 2870177450012600261
  store i64 %mul29, i64* %mixedh, align 8, !tbaa !21
  %34 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %34) #10
  %35 = load i64, i64* %mixedl, align 8, !tbaa !21
  %call30 = call i64 @XXH3_avalanche(i64 %35)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call30, i64* %low64, align 8, !tbaa !41
  %36 = load i64, i64* %mixedh, align 8, !tbaa !21
  %call31 = call i64 @XXH3_avalanche(i64 %36)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %call31, i64* %high64, align 8, !tbaa !39
  %37 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %38 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %37, i8* %38, i64 16, i32 8, i1 false), !tbaa.struct !42
  %39 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %39) #10
  %40 = bitcast i64* %mixedh to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %40) #10
  %41 = bitcast i64* %mixedl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %41) #10
  %42 = bitcast i64* %keyed_hi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %42) #10
  %43 = bitcast i64* %keyed_lo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %43) #10
  %44 = bitcast i64* %bitfliph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %44) #10
  %45 = bitcast i64* %bitflipl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #10
  %46 = bitcast i32* %combinedh to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %46) #10
  %47 = bitcast i32* %combinedl to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %47) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c3) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c2) #10
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c1) #10
  %48 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %49 = load { i64, i64 }, { i64, i64 }* %48, align 8
  ret { i64, i64 } %49
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH128_mix32B(i64 %acc.coerce0, i64 %acc.coerce1, i8* %input_1, i8* %input_2, i8* %secret, i64 %seed) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %acc = alloca %struct.XXH128_hash_t, align 8
  %input_1.addr = alloca i8*, align 8
  %input_2.addr = alloca i8*, align 8
  %secret.addr = alloca i8*, align 8
  %seed.addr = alloca i64, align 8
  %0 = bitcast %struct.XXH128_hash_t* %acc to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %acc.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %acc.coerce1, i64* %2, align 8
  store i8* %input_1, i8** %input_1.addr, align 8, !tbaa !3
  store i8* %input_2, i8** %input_2.addr, align 8, !tbaa !3
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %seed, i64* %seed.addr, align 8, !tbaa !21
  %3 = load i8*, i8** %input_1.addr, align 8, !tbaa !3
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call = call i64 @XXH3_mix16B(i8* %3, i8* %add.ptr, i64 %5)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %6 = load i64, i64* %low64, align 8, !tbaa !41
  %add = add i64 %6, %call
  store i64 %add, i64* %low64, align 8, !tbaa !41
  %7 = load i8*, i8** %input_2.addr, align 8, !tbaa !3
  %call1 = call i64 @XXH_readLE64(i8* %7)
  %8 = load i8*, i8** %input_2.addr, align 8, !tbaa !3
  %add.ptr2 = getelementptr inbounds i8, i8* %8, i64 8
  %call3 = call i64 @XXH_readLE64(i8* %add.ptr2)
  %add4 = add i64 %call1, %call3
  %low645 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 0
  %9 = load i64, i64* %low645, align 8, !tbaa !41
  %xor = xor i64 %9, %add4
  store i64 %xor, i64* %low645, align 8, !tbaa !41
  %10 = load i8*, i8** %input_2.addr, align 8, !tbaa !3
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr6 = getelementptr inbounds i8, i8* %11, i64 16
  %12 = load i64, i64* %seed.addr, align 8, !tbaa !21
  %call7 = call i64 @XXH3_mix16B(i8* %10, i8* %add.ptr6, i64 %12)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %13 = load i64, i64* %high64, align 8, !tbaa !39
  %add8 = add i64 %13, %call7
  store i64 %add8, i64* %high64, align 8, !tbaa !39
  %14 = load i8*, i8** %input_1.addr, align 8, !tbaa !3
  %call9 = call i64 @XXH_readLE64(i8* %14)
  %15 = load i8*, i8** %input_1.addr, align 8, !tbaa !3
  %add.ptr10 = getelementptr inbounds i8, i8* %15, i64 8
  %call11 = call i64 @XXH_readLE64(i8* %add.ptr10)
  %add12 = add i64 %call9, %call11
  %high6413 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %acc, i32 0, i32 1
  %16 = load i64, i64* %high6413, align 8, !tbaa !39
  %xor14 = xor i64 %16, %add12
  store i64 %xor14, i64* %high6413, align 8, !tbaa !39
  %17 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %18 = bitcast %struct.XXH128_hash_t* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 16, i32 8, i1 false), !tbaa.struct !42
  %19 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %20 = load { i64, i64 }, { i64, i64 }* %19, align 8
  ret { i64, i64 } %20
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_internal(i8* noalias %input, i64 %len, i8* noalias %secret, i64 %secretSize, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %secret.addr = alloca i8*, align 8
  %secretSize.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %acc = alloca [8 x i64], align 16
  %h128 = alloca %struct.XXH128_hash_t, align 8
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i8* %secret, i8** %secret.addr, align 8, !tbaa !3
  store i64 %secretSize, i64* %secretSize.addr, align 8, !tbaa !7
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %0 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #10
  %1 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ([8 x i64]* @XXH3_hashLong_128b_internal.acc to i8*), i64 64, i32 16, i1 false)
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %2 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %3 = load i64, i64* %len.addr, align 8, !tbaa !7
  %4 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %5 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %6 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %7 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  call void @XXH3_hashLong_internal_loop(i64* %arraydecay, i8* %2, i64 %3, i8* %4, i64 %5, i32 1, void (i8*, i8*, i8*, i32)* %6, void (i8*, i8*)* %7)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %8 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %8) #10
  %arraydecay1 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %9 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 11
  %10 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul = mul i64 %10, -7046029288634856825
  %call = call i64 @XXH3_mergeAccs(i64* %arraydecay1, i8* %add.ptr, i64 %mul)
  %low64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 0
  store i64 %call, i64* %low64, align 8, !tbaa !41
  %arraydecay2 = getelementptr inbounds [8 x i64], [8 x i64]* %acc, i32 0, i32 0
  %11 = load i8*, i8** %secret.addr, align 8, !tbaa !3
  %12 = load i64, i64* %secretSize.addr, align 8, !tbaa !7
  %add.ptr3 = getelementptr inbounds i8, i8* %11, i64 %12
  %add.ptr4 = getelementptr inbounds i8, i8* %add.ptr3, i64 -64
  %add.ptr5 = getelementptr inbounds i8, i8* %add.ptr4, i64 -11
  %13 = load i64, i64* %len.addr, align 8, !tbaa !7
  %mul6 = mul i64 %13, -4417276706812531889
  %neg = xor i64 %mul6, -1
  %call7 = call i64 @XXH3_mergeAccs(i64* %arraydecay2, i8* %add.ptr5, i64 %neg)
  %high64 = getelementptr inbounds %struct.XXH128_hash_t, %struct.XXH128_hash_t* %h128, i32 0, i32 1
  store i64 %call7, i64* %high64, align 8, !tbaa !39
  %14 = bitcast %struct.XXH128_hash_t* %retval to i8*
  %15 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 16, i32 8, i1 false), !tbaa.struct !42
  %16 = bitcast %struct.XXH128_hash_t* %h128 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %16) #10
  %17 = bitcast [8 x i64]* %acc to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %17) #10
  %18 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %19 = load { i64, i64 }, { i64, i64 }* %18, align 8
  ret { i64, i64 } %19
}

; Function Attrs: alwaysinline nounwind ssp uwtable
define internal { i64, i64 } @XXH3_hashLong_128b_withSeed_internal(i8* noalias %input, i64 %len, i64 %seed64, void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*)* %f_scramble, void (i8*, i64)* %f_initSec) #1 {
entry:
  %retval = alloca %struct.XXH128_hash_t, align 8
  %input.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %seed64.addr = alloca i64, align 8
  %f_acc512.addr = alloca void (i8*, i8*, i8*, i32)*, align 8
  %f_scramble.addr = alloca void (i8*, i8*)*, align 8
  %f_initSec.addr = alloca void (i8*, i64)*, align 8
  %secret = alloca [192 x i8], align 16
  store i8* %input, i8** %input.addr, align 8, !tbaa !3
  store i64 %len, i64* %len.addr, align 8, !tbaa !7
  store i64 %seed64, i64* %seed64.addr, align 8, !tbaa !21
  store void (i8*, i8*, i8*, i32)* %f_acc512, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  store void (i8*, i8*)* %f_scramble, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  store void (i8*, i64)* %f_initSec, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !3
  %0 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %2 = load i64, i64* %len.addr, align 8, !tbaa !7
  %3 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %4 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %call = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %1, i64 %2, i8* getelementptr inbounds ([192 x i8], [192 x i8]* @XXH3_kSecret, i32 0, i32 0), i64 192, void (i8*, i8*, i8*, i32)* %3, void (i8*, i8*)* %4)
  %5 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.start.p0i8(i64 192, i8* %10) #10
  %11 = load void (i8*, i64)*, void (i8*, i64)** %f_initSec.addr, align 8, !tbaa !3
  %arraydecay = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %12 = load i64, i64* %seed64.addr, align 8, !tbaa !21
  call void %11(i8* %arraydecay, i64 %12)
  %13 = load i8*, i8** %input.addr, align 8, !tbaa !3
  %14 = load i64, i64* %len.addr, align 8, !tbaa !7
  %arraydecay1 = getelementptr inbounds [192 x i8], [192 x i8]* %secret, i32 0, i32 0
  %15 = load void (i8*, i8*, i8*, i32)*, void (i8*, i8*, i8*, i32)** %f_acc512.addr, align 8, !tbaa !3
  %16 = load void (i8*, i8*)*, void (i8*, i8*)** %f_scramble.addr, align 8, !tbaa !3
  %call2 = call { i64, i64 } @XXH3_hashLong_128b_internal(i8* %13, i64 %14, i8* %arraydecay1, i64 192, void (i8*, i8*, i8*, i32)* %15, void (i8*, i8*)* %16)
  %17 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call2, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call2, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast [192 x i8]* %secret to i8*
  call void @llvm.lifetime.end.p0i8(i64 192, i8* %22) #10
  br label %return

return:                                           ; preds = %if.end, %if.then
  %23 = bitcast %struct.XXH128_hash_t* %retval to { i64, i64 }*
  %24 = load { i64, i64 }, { i64, i64 }* %23, align 8
  ret { i64, i64 } %24
}

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { alwaysinline nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone speculatable }
attributes #4 = { argmemonly nounwind }
attributes #5 = { noinline nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readnone }
attributes #9 = { inaccessiblemem_or_argmemonly nounwind }
attributes #10 = { nounwind }
attributes #11 = { allocsize(0) }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 5.0.2 (https://github.com/llvm-mirror/clang.git 26cac19a0d622afc91cd52a002921074bccc6a27) (https://github.com/llvm-mirror/llvm.git da4a2839d80ac52958be0129b871beedfe90136e)"}
!3 = !{!4, !4, i64 0}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!8, !8, i64 0}
!8 = !{!"long", !5, i64 0}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !5, i64 0}
!11 = !{!5, !5, i64 0}
!12 = !{!13, !10, i64 8}
!13 = !{!"XXH32_state_s", !10, i64 0, !10, i64 4, !10, i64 8, !10, i64 12, !10, i64 16, !10, i64 20, !5, i64 24, !10, i64 40, !10, i64 44}
!14 = !{!13, !10, i64 12}
!15 = !{!13, !10, i64 16}
!16 = !{!13, !10, i64 20}
!17 = !{!13, !10, i64 0}
!18 = !{!13, !10, i64 4}
!19 = !{!13, !10, i64 40}
!20 = !{i32 60904}
!21 = !{!22, !22, i64 0}
!22 = !{!"long long", !5, i64 0}
!23 = !{!24, !22, i64 8}
!24 = !{!"XXH64_state_s", !22, i64 0, !22, i64 8, !22, i64 16, !22, i64 24, !22, i64 32, !5, i64 40, !10, i64 72, !10, i64 76, !22, i64 80}
!25 = !{!24, !22, i64 16}
!26 = !{!24, !22, i64 24}
!27 = !{!24, !22, i64 32}
!28 = !{!24, !22, i64 0}
!29 = !{!24, !10, i64 72}
!30 = !{!31, !22, i64 552}
!31 = !{!"XXH3_state_s", !5, i64 0, !5, i64 64, !5, i64 256, !10, i64 512, !10, i64 516, !8, i64 520, !8, i64 528, !8, i64 536, !22, i64 544, !22, i64 552, !22, i64 560, !4, i64 568}
!32 = !{!31, !4, i64 568}
!33 = !{!31, !8, i64 536}
!34 = !{!31, !8, i64 520}
!35 = !{i32 1011204}
!36 = !{!31, !22, i64 544}
!37 = !{!31, !10, i64 512}
!38 = !{!31, !8, i64 528}
!39 = !{!40, !22, i64 8}
!40 = !{!"", !22, i64 0, !22, i64 8}
!41 = !{!40, !22, i64 0}
!42 = !{i64 0, i64 8, !21, i64 8, i64 8, !21}
!43 = !{!44, !44, i64 0}
!44 = !{!"__int128", !5, i64 0}
